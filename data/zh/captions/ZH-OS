[{"name": "", "block_id": "8350e3e38c7b4b53bdad05a52cad478c", "text": ["接下来我们再看一下", "I/O设备的一个接口分析", "首先我们看一下", "I/O设备接口的一个大致位置", "它在我们整个文件系统的", "靠底下这一部分", "它呢首先向上和我们VFS有一个接口", "使得它也能够被我们VFS统一管理", "同时呢 它也和我们", "具体文件系统有一个接口", "使得具体文件系统向它", "可以发出读 写 控制等请求", "向下呢它还进一步", "和我们的驱动有一个接口", "使得和不同的外设", "比如我们的硬盘 我们的串口", "我们的屏幕等等进行对接", "完成最底层的数据的访问", "这是I/O接口这一块大致的一个功能", "这里面很关键一个结构", "就是device这么一个结构", "可以看出来它和我们前面", "inode的定义相似之处", "它也是一系列函数指针", "和一些成员变量组成", "特别是open close  I/O", "还有I/O control", "那么open close和我们前面讲的", "Inode 的open close是一个意思", "就是打开设备 关闭设备", "I/O呢它用一个这个来表示读或者写", "I/O control是用来表示什么", "表示一些 通常读写", "不太方便表示的一些操作", "比如说我要完成对某个设备的控制", "它不是读也不是写", "那么就需要有一个 特殊的一个", "函数的指针来完成", "它怎么和我们VFS进行对接呢", "在这里面它还有一个成员变量", "是对接着这里面的FS 可以看出来", "一个device是属于一个特殊的", "device VFS这么一个结构", "而device VFS呢 会挂到一个", "VFS一个总体框架之下", "从而完成了在VFS这个层面", "对device的一个有效的管理", "那我们可以再结合", "整个device的初始化过程", "来了解怎么来实现", "对device的一个访问", "当然这个访问是通过VFS来实现的", "这里面并没有拿我们SFS", "所直接对接的disk来做一个介绍", "而是以另外两个设备", "就是stdin或者stdout", "stdout是往串口和显示器", "输出这么一个设备", "而stdin呢是接收键盘输入一个设备", "那么我们希望大家通过", "对这两个设备的了解", "来进一步自己去分析", "对于disk这么一个device", "怎么进行初始化的", "可以看出来 这是我们最早的那个", "uCore开始启动的时候", "做初始化的总控函数", "在这里面会增加一部分", "这一部分是fs_init", "这是lab8的一个增加的一部分内容", "在fs_init里面呢", "会进一步调device的init", "OK 这里面又会进一步", "调好几个不同类型的", "device的一个初始化", "先拿stdout来举例", "stdout呢会创建一个inode", "这个inode是专门针对device的inode", "这就把我们的device和inode", "建立了一个联系", "同时还有一个stdout_device_init", "那么这个呢 是完成了", "对它的函数的一个对接", "还有一个vfs_add_dev", "从而使这个device可以加入到", "这个VFS整个的管理之中来", "进一步可以看看这个", "device_init做什么事情", "它把刚才device所针对那些函数指针呢", "跟我们具体函数进行了对接", "包括了open close还有I/O", "这个I/O就是读 写的什么操作", "大家想一想", "这是stdout 那是一个写操作", "还有是一个control", "表明一些特殊操作 用control来表示", "这就是stdout一个device的初始化过程", "在这个初始化过程中我们可以看到", "它创建了inode 和VFS进行了对接", "把自己的一些特定的函数", "以device里面的虚函数指针进行了对接", "那么完成这些工作之后", "我们在VFS层面呢", "就可以有效地访问这个device了", "同理我们看一下stdin 这是输入", "相对是read操作", "那么跟前面不同在哪呢", "就在一个地方dev_init_stdin", "同时也一样有一个stdin一个device_init", "它和前面操作是类似的", "它也建立它自己一套函数体系", "和device函数指针进行对接", "其它两部分是一样的", "创建一个inode 和绑定VFS", "但这个对接有点不太一样", "它的I/O这个操作是对应stdin的I/O", "那这个是什么呢 是一个读操作", "因为它是需要从键盘读入数据", "还有一个不同在哪 在这儿", "它增加了一个等待队列的设置", "为什么会增加这么一个设置 大家想一想", "其实有可能 当它想去发出读请求之后", "不能马上得到回应", "在这个时候 由于资源得不到满足", "它需要去睡眠", "从而可以把CPU让出来", "这是我们前面讲同步互斥的时候", "涉及到的一些概念", "可以看出来在file system里面", "整个大的框架里面呢", "会涉及到进程 同步互斥", "内存管理等多方面内容", "是对我们前面一系列实验的", "进一步补充完善和使用"]}, {"name": "", "block_id": "795ec66e734a4f3abdc65d22300f1b28", "text": ["好 那我们接下来", "讲一下这个copy-on-write机制", "这个呢和我们的这个", "进程管理和内存管理紧密相连", "也是我们的challenge练习", "所以说呢这部分", "可以理解为是一个扩展内容", "大家了解一下OK", "如果感兴趣同学", "我们鼓励大家做一下尝试", "copy-on-write机制呢", "在应用方面也讲到是说", "同一种机制使得我们", "在创建子进程的时候能够", "共享父进程的内存空间", "从而可以节省内存的占用", "那我们举个例子看process", "一开始process A这是一个父进程", "它有一个vma和一个", "它的page table都是可读可写的", "内存空间可读可写", "好 通过do_fork呢我们创建了进程B", "那么进程B呢", "它可以重用", "重用这个进程A的地址空间", "跟我们前面讲的不太一样", "我们前面是说我们要复制一份", "把整个内存空间要做一次拷贝", "而且这里面呢它不做拷贝", "他们是共用一块内存空间", "从而可以使得", "空间的占用量大大减少", "那这样情况会不会出现问题呢", "如果是只读的话那没问题", "你可以看到", "它们因为共用是一块区域", "那么它都做读操作", "不在内存做改变的话", "没任何问题", "如果它是写操作就有问题了", "为什么呢", "因为一个进程", "写了一个内存地址之后呢", "另一个进程也许不希望", "这个内存地址被做修改", "也意味着在这种情况下", "我们对写要做个特殊的操作", "我们这里面做了什么特殊的处理呢", "会对这个pgdir我们页表呢", "把相应的那个内存空间设成只读", "这带来什么问题", "一旦某一个进程", "无论是进程B还是进程A", "就无论父子进程哪一个", "做了写操作", "由于你的页表里面对应的内容", "设置那个属性", "就页表下面设置属性是只读", "所以一旦做写操作会产生什么", "大家想一想", "对 我们可以看到它会产生一个page fault", "因为对只读页做了一个写操作", "违背了这个内存的管理的原则", "所以说会产生page fault", "但这个page fault正是我们需要利用的", "你可以看着 在一般情况下", "我们的vma是表明了这个进程", "它的一个合法地址空间", "是具有可读可写的属性的", "特别是对于数据段来说", "但是我们的页表是不是只读", "这其实有一个矛盾", "这个矛盾就会导致产生一个page fault", "而我们copy-on-write机制呢", "正是利用这个矛盾", "来建立了有效的这个", "省空间这么一个操作过程", "一旦出现page fault", "也意味着在这一点上这两个进程", "需要有各自独立的空间了", "如果是B  process B", "对这个空间做了修改", "那我们希望是什么呢", "在这一块空间", "这个以页为单位", "这个空间", "它的空间呢它有它自己的页表项", "而同理", "这个process A保持原有的页表项不变", "这里面是被修改过的内容", "而这里面是没有被修改的内容", "可以看到这里面就完成了一个分割", "但是对于只读的那些", "内存页没有任何变化", "所以说仅仅是需要有写的时候", "内存会增加一小部分内容", "但是对那些只读的", "依然没有增加", "所以空间copy-on-write就在哪呢", "当做一个write操作的时候呢", "会完成页表内容一个复制和更新", "这从而使得我们整个进程创建的开销", "因为我们前面", "没有拷贝整个内存空间的开销", "大大减少", "且有效的节省空间", "还保证了这个整个进程", "进程A和进程B能够正确执行", "但是光做到这一步", "就是完成一次复制", "是否就够了呢", "对于简单的情况", "这样确实OK", "我们有各自的内存页", "它的出发点是在于", "你做了一次写操作", "那么它可以把这个页表项改了", "对应页表的那个物理地址空间", "做了两份不同的内容", "OK 没问题", "但如果你在深入考虑一下", "可能会出现一种新的一种现象", "就是当引入copy-on-write机制之后呢", "会出现哪种现象呢", "就是一个物理的页", "它会有多个虚拟页指向它", "因为有不同的进程", "不同的进程指向同一个物理页", "但它的虚拟地址空间是不一样", "分属于不同的进程", "那这里面我们对页的管理", "特别是物理页的管理", "就需要有新的一种机制", "因为它的reference", "就是引用这个物理页", "这个个数是不一样的", "有多少个进程引用", "也意味着它这个", "引用计数应该是多少", "那这个个数很重要", "我们会看到为什么呢", "因为在进程的运行过程中", "我们在讲lab3的时候", "给大家提到过可能会出现", "swapin swapout这个换入换出", "那当把一个页换出出去之后呢", "也许这个页和另一个进程", "所对应的虚拟页", "共享了同一个物理页", "那怎么去有效的换入换出", "且能保证放在这里面", "这个页的内容和被其它进程", "所用到的那个页的内容是一致的", "因为这里面出现一种新的状态", "有可能那个页既在这里面", "也在内存中", "那其实会导致一个问题的复杂", "当然我们在这里面呢", "可以不考虑这些情况", "我们只考虑最简单的", "没有换入换出的情况下", "那么他只需要有一个reference counter", "对于每一个物理页", "有一个reference counter就OK了", "但一旦要再进一步考虑到", "有这个我们说的swap in  swap out", "这种虚存管理机制之后呢", "使得这个页共享这种特点", "那么还有一些", "更新的一些应对的一些手段", "才能保证整个这个数据是一致的", "否则会出现一系列的问题", "为此呢我们可以考虑简单一点", "如果把这个swap fs", "这一块", "关于虚存管理这一块", "稍微靠后的话我们不考虑的话", "那我们还需要去考虑什么呢", "就是引用计数", "那你会在实现copy_range  do_pgfault", "还有dup_mmap", "copy_range干什么复制", "do_pgfault完成虚存管理", "dup_mmap呢", "是完成这个对内存管理的一个复制", "那这些功能里面都要有所考虑", "关于页的共享这么一个属性", "这是大家在做练习的时候", "可能需要去注意的一点", "还有呢你们在写的时候", "要另外需要注意的有足够的test case", "就是要有一些bench mark", "来测试你的代码是正确的", "这里面关于这个", "内存的页的这个属性状态", "就随着运行在不同阶段", "它的状态是有一定的变化", "就类似于我们进程管理的时候", "进程运行过程中它有状态变化", "当由于你引入这个copy-on-write机制之后", "还有虚存管理机制之后", "它这个内存的这个页的状态", "也是一个动态变化的", "那这些能否形成一个", "类似于我们进程管理", "一个生命周期一个图", "这里面有一个状态转换图", "这是我们在做这个challenge实验的时候", "需要考虑内容", "你怎么证明图的转换关系是对的", "很有挑战", "那我们鼓励同学去尝试一下", "我们这里面呢", "给大家做一个简单介绍而已", "大家需要通过实践", "才能够得到一个", "相对合理和正确一个解答", "好 那我就给大家讲完了", "就是关于lab5的情况", "这里面重点是说", "你要去理解怎么去构造出", "一个用户态的进程", "怎么去完成", "父进程到子进程一个fork 复制", "怎么去完成这个", "进程的系统调用的服务", "这部分是去阅读代码就可以", "我们这边不需要大家去coding", "还有就是challenge", "copy-on-write机制", "给大家做了介绍", "这就是我们整个lab5的一个讲解", "好 谢谢大家"]}, {"name": "", "block_id": "c1cffea66a8e4e0a94995a0ccf367814", "text": ["下面我们来讨论死锁的处理方法", "死锁的处理方法呢", "我们通常情况下可以理解为", "跟我们的消防的方法是很类似的", "这里头呢 我们基本上可以按照", "消防的那些处理方法来进行类比", "首先第一个 就是死锁预防", "确保系统永远不会进入死锁状态", "比如说我们在消防里头", "为了避免火灾", "我在一些敏感的区域里头", "我就会限定 在这个区域里头", "不允许用任何的火", "好 那这样一来的话", "在这个区域里出现火灾的", "可能性也就没有了", "那对于死锁来说呢", "我们也是一样的", "我们在那里呢", "死锁可能出现的时候", "有四个必要条件", "那我们把那四个必要条件里的", "任何一个去掉", "它就不会进入死锁了", "但是这时候呢", "实际上它的问题是说", "你不让它使用这些资源", "不让那四个条件得到满足", "那这时候呢 实际上可能的问题是", "系统的资源利用效率比较低", "那这就是第二种做法", "就是死锁避免", "这可以理解为", "我们采用严格的监管措施", "到底是否是允许用火", "有一个严格的审批流程", "比如说在某些区域里头", "你不可以完全禁止用火", "那这时候呢 我就会说", "什么样的人 有什么样的资质的人", "能够处理这个问题的人 你可以用", "比如说在林区的防火", "只有相应的 有资质的人", "你可以在这里头去使用", "这是我们这里的第二种做法", "在使用之前进行判断", "只允许不会出现死锁的进程请求资源", "这就是我们在这里头 死锁避免", "再有一种做法呢", "是我在管理不过来的时候", "那我就会允许第三种做法", "死锁检测和恢复", "是否会出现死锁", "这个事我管不过来", "那我也就不管了", "比如说像在居民用火", "你不允许他不用火是不可能的", "你进行严格的监管呢也做不到", "那这怎么办呢", "我们就预备一个消防队", "出了问题之后我派消防队去", "那么这也是一样的", "我检测到系统进入死锁状态后", "那我就进行恢复", "而在我们这几种做法里头呢", "在我们实际的操作系统里呢", "通常情况下我们把这件事情", "指派给应用进程来处理", "通常操作系统是忽略死锁的存在", "这是我们目前", "大多数操作系统的做法", "那有了这样一个非常粗的介绍之后", "我们下边就来具体看一下", "这三种做法里的情况", "第一个 死锁预防", "也就是说", "我们限制进程申请资源的方式", "那怎么来限制呢", "就是限制的结果是", "不满足死锁的必要条件", "怎么能做到不满足死锁的必要条件呢", "我们有四个条件", "任何一个不满足就可以了", "比如说第一个互斥", "我们把需要互斥访问的资源", "封装成可以同时访问的", "那这件事情就没了", "一个实际的例子是说我们的打印机", "在早期的时候 打印机每个进程", "可以往打印机上送打印作业", "那这时候 在送的过程当中呢", "是必须互斥的", "如果说两个进程同时往一台打印机上", "送打印作业", "那这时候打出来的结果", "是谁也不能用了", "而现在呢 我们在使用打印机的时候", "你基本上感觉不到这一条", "原因在于 我们在打印机里加了缓冲", "只有当前一个送完了之后", "它才会去接收另一个的打印请求", "那这就是我们现在的", "网络打印机的做法", "好 那这样一来的话", "它就可以大家一起使用", "只是说在打印机内部", "它给你协调谁先谁后", "这是第一个 把互斥条件去掉", "第二个是说 我把持有并等待", "这个条件给去掉", "那在这个条件里头呢", "实际上是我申请到的一部分资源", "我再去申请另一部分资源", "那我怎么可以把它去掉呢", "一种做法是说你在请求资源的时候", "你不能占用任何资源", "这指什么意思呢", "这指是说你要想申请资源的话", "你就必须一次", "把所有的资源全部申请到", "如果说你已经申请了一部分", "然后再去申请的话", "那就会出现死锁的可能性", "这个呢 有一个形象的比喻是说", "我们在贷款的时候", "你希望去做一个项目", "好 这时候呢", "需要银行给你贷款", "那你可以说 我一次把所有", "我需要的钱全部贷出来", "这样就避免一种情况是说", "我做到一半 我钱不够用了", "这种情况", "但是这时候呢 它的问题是", "它的资源效率会是利用比较低的", "这种做法更细化下去的一种", "可以操作的做法就是", "我进程在开始的时候", "申请所有需要的资源", "如果说我不满足", "我这个申请的要求的话", "那就不允许它开始", "那这样一来每一个开始进程", "它就确信它一定能执行到结束", "这样的话我这个问题也解决掉了", "这是它最主要的问题", "资源利用效率太低", "你比如说像我们修一个水电站", "持续几年 十几年的时间", "那你最开始的时候", "一口气把它需要的资金全部到位", "那这时候实际上", "它的利用效率是非常低的", "那第三个做法呢 是非抢占", "我们在前边说有一个条件", "你分配资源之后", "进程不主动放弃的话", "我是没有办法回收的", "这样的话 我才能构成", "循环无限期等待", "如果说在这里头加一个条件", "一旦你申请的资源不能立即分配", "你就释放你已经占用的所有资源", "如果说我们有这一条的话", "那这件事情也没有了", "这个对于我们刚才说的", "单向通行桥梁的情况", "就是一旦两辆车撞上了", "那这时候两辆车都会往回倒", "那再来申请的时候", "这个单向通行的桥梁呢", "也就能通行了", "只有在这里头 进程能够获取到", "它所有需要的资源", "它才给它分配", "这样的话实际上某种角度上", "跟我们前面说的", "去掉持有并等待这个条件的做法", "有类似的地方", "也相当于在那里头呢", "我是要申请一次全部申请", "在这地方呢 我申请", "在我再申请的时候", "我必须需要的资源都有", "我才能够往下申请", "最后一个 循环等待", "我们怎么把它去掉呢", "实际上就是对资源排序", "按照我们固定的顺序来申请资源", "这时候我就不存在循环等待了", "这时候它会有啥问题呢", "和我们前边的做法有类似的地方", "按照顺序来申请", "可能你先申请的某一项资源", "实际上我是后用到", "这时候也会有效率下降的问题", "这是我们说到的死锁预防", "通过这一类办法呢", "我们可以避免死锁出现的四个条件", "任何一个不成立 那这事就没了", "第二类做法呢 是死锁避免", "这是针对第一类做法", "如果说我想完全禁止掉", "它出现死锁的话", "那这时候呢 我的资源利用效率低", "那提高资源利用效率的办法呢", "就是给我自己分配资源的时候", "把这个手续变得更复杂", "那这里做法就是", "我利用额外的先验信息", "在分配资源的时候", "我来判断是否会出现死锁", "如果说有可能出现死锁", "那我就不分配给你", "那只是没有可能出现死锁的情况", "我才分配给你", "这就是我们这里说的死锁避免", "这就有点像在银行里 你去借款", "它依据你的信用情况", "来判断我借给你之后", "你是否会如期归还", "如果说我判断完的结果", "你是有可能不如期归还", "当然我判断完之后", "你有可能不如期归还", "你也有可能是能归还的", "好 我判断完了之后", "只是信用比较好的", "我才分配给它资源", "当然这种情况它也是有风险的", "那在计算机系统里头呢", "就是你对先验知识的准确性了", "具体做法是这样的", "要求进程事先声明你的需求量", "也就是说你最大的需求资源数是多少", "银行里头可以满足这个资源数", "那我就把这资源分配给你", "那这时候呢 实际上相当于", "我限定提供和分配资源的时候", "我必须能确保满足进程的最大需求", "如果不能满足的话", "我就是会有麻烦的 会出现死锁", "那我就不分配给你", "那这时候说 我们怎么知道", "它是否会有麻烦呢", "那这时候就是 我们动态进行检查", "那这时候就是我们前面说到的", "资源分配图 在这就能用得上了", "我判断分配给你这个资源之后", "不会出现死锁", "我就把它分配给你", "这是第二种做法", "那在这第二种做法里头呢", "就有一个比较麻烦的事", "银行或者说系统必须来动态地判断", "我是否分配给你资源之后", "不会出现死锁", "那这就是我们这里说到的", "系统资源分配安全状态", "你在请求的时候系统判断是否安全", "安全了我才分配给你", "那怎么算是安全呢", "实际上就是针对", "所有进程已占用的资源", "我来找出一个进程的执行序列", "这个序列执行", "保证我已有的资源能够满足", "这个序列执行到结束", "如果能行的话", "我这系统的状态就是安全的", "好 你要求分配的资源", "我就是可以分配给你了", "稍微具体一点是这样的", "我当前所有占用资源的进程", "P1到Pn", "我在这里给它做一个排序", "这个排序有这样一个要求", "Pi要求的资源", "它小于我当前可用的空闲资源", "和Pj已经占用的资源", "这个Pj是在这个序列当中", "小于i的所有之间", "也就是说在它之前的", "这些进程已经占用的资源", "加上现在可用的这些空闲的资源", "它俩搁在一起", "是否能满足进程PI的要求", "如果能满足", "对于所有这些都能满足的话", "那这就是安全的", "这就相当于是什么样的做法呢", "就是第一个进程Pi", "它没有再往前的进程了", "所以这时候呢", "当前可用的资源", "必须能够满足P1的需求", "那这时候它就是安全的", "如果说后续的某一个Pi", "它请求的时候", "当前可用的不够", "前边还有一些被其他进程占用了", "那这时候它就等待", "等待你前边的这些进程执行结束", "那你的占用资源不就回来了吗", "由于有上边的一条回来的资源", "就能够满足我的要求了", "搁在一起我就可以执行完毕了", "执行完之后", "我这事就行了", "等到整个序列当中的", "任何一个进程都执行结束", "最后一个也就能满足它的需求", "到这我们整个系统里的", "占有资源的进程都能正常的完成", "那我的系统就是安全的", "有了这个描述之后", "我们的安全和死锁之间的关系呢", "就可以用这个图来表示", "说我们在这个系统里头", "处于安全状态的", "它一定不会出现死锁", "那是不是说我不安全的", "就一定会死锁呢", "也不是这样的", "就好比说银行", "我把这个款贷出去", "有可能对方还不了我", "但是他也有可能能还我", "如果他能还的话", "这件事情也是可做的", "这就看你的风险有多大了", "实际上我们在这画了一个更大的圈", "用不安全其中包括死锁状态", "我只是对于安全情况我来分配资源", "这样的话", "从而保证我系统不会出现死锁", "如果说不安全", "是有可能出现死锁的", "我们避免出现死锁", "我就在这画的这条线上", "来保证我系统是处于安全的状态", "到这我们说清楚了", "死锁的处理的三类办法", "基本上是按照我们消防的", "那三类办法来做处理"]}, {"name": "", "block_id": "2406ca65b10c4e58a0bba40841a40655", "text": ["下面我们来讨论进程挂起", "在前面我们讨论", "进程状态模型的时候呢", "它主要讨论的是", "跟CPU相关的这些状态", "但实际上我们在", "进程当中的状态里头呢", "还有一类是在跟存储相关", "也就是说进程一部分存储是", "放到外存里头的", "和虚拟存储相关联起来", "这是呢就是我们这里的", "挂起进程模型", "它是指什么意思呢", "它是指处于挂起状态的进程是", "放在磁盘上的", "放到磁盘上的目的呢", "是为了减少内存的占用量", "那减少它的内存占用量", "就可以提供更多的内存", "给其它的进程来使用", "有了进程挂起之后", "我们的进程状态模型图呢", "也会因此而发生变化", "这就是我们这里的挂起进程模型", "和我们前面讲的三状态进程模型", "相比呢在这里多了两种状态", "就绪挂起和等待挂起", "这两种新加的状态呢", "实际上就是为了描述", "在外存当中的进程的状态", "那其它的状态它是不会在外存里的", "第一个呢是等待挂起", "那这时候描述的是说进程在", "外存并且等待事件的出现", "那就相当于在等待的基础上", "加了一个关于进程的位置的信息", "而接下来一个呢是就绪挂起", "那就绪挂起呢实际上就相当于", "它处于就绪的状态", "但这时候呢进程在外存当中", "那它只要进入到内存里头呢", "它就可以运行了", "那这时候它进不到内存里的原因呢", "是内存的空间不够", "或者说它的优先级不够高", "好 有了这两个状态之后", "我们就会在状态之间呢", "多加了一组变迁", "这组变迁呢", "我们可以把它分成这样几类", "一类是挂起", "也就是说把进程从内存转到外存", "那具体说起来呢", "有三个与此相关的变迁", "第一个是从等待到等待挂起", "那出现这种变化的原因呢", "是没有进程处于就绪状态", "或者说就绪进程", "需要更多的内存空间", "然后第二个呢是说", "就绪到就绪挂起", "那在这里头呢", "有高优先级的进程等待", "而这时候呢低优先级的进程呢", "在内存当中处于就绪状态", "那为了让这个高优先级等待进程", "进来之后有足够的空间", "那这时候它把它", "把这个低优先级的就绪进程呢", "对换到外存当中", "从而呢成为挂起就绪", "好 还有一个变迁呢是", "直接从运行状态到了挂起就绪", "那在这里头呢", "实际上就是对于分时系统", "如果有抢先的话", "在极特殊的一些情况下", "会出现这种情况", "比如说有高优先级等待的进程", "因事件的出现而进入就绪", "而这时候呢没有足够的内存空间", "它就会把当前", "正在运行的这个进程呢", "抢先并且把它变成挂起就绪的状态", "好 这是三个从内存到外存的变迁", "分别涉及到就绪运行和等待", "也就相当于三状态进程模型里", "在内存里三个状态呢", "都会有可能会 放到外存里头去", "从而产生相应的挂起", "然后在外存当中", "可能出现的状态呢就是", "我们在这里内存当中的等待到就绪", "这地方有挂起", "等待挂起到就绪挂起", "好 那这个地方呢", "是等待的事件出现", "并且相关的进程呢处于等待挂起上", "那这时候它就变成是就绪挂起", "好 反过身来这几个", "在外存当中的进程呢", "它可能会被倒回到内存当中来", "这时候的变迁呢称之为叫激活", "那具体说起来的激活有两种情况", "一种是从就绪挂起到就绪", "那这种情况是说", "我在内存当中没有就绪进程", "或者说挂起就绪这个进程呢", "它的优先级比较高", "这个时候它会把它倒回来", "还有一种呢就是从等待挂起到等待", "这种状态呢通常情况下是", "前面的进程释放了大量的空间", "而且这个等待挂起的", "这个进程呢优先级比较高", "好 这是呢我们在这里说到的", "挂起进程模型里头", "它所涉及到进程模型的变化", "那我们看到由于状态的不同", "我们会涉及到很多的队列", "把进程控制块连成一体", "好 从这个角度来讲呢", "我们甚至可以用状态队列", "来对进程的状态呢", "有某种形式的描述", "也就是说我们通常情况下", "在代码当中去考察进程状态时候", "就是它的标志性操作", "就是把这个PCB", "挂到哪个队列当中", "好 我们在这里呢", "维护了一组队列", "表示进程的当前状态", "然后每一个不同的队列呢", "它表示不同的状态", "你比如说各种各样的等待", "就绪队列", "好 这些队列的状态的变化呢", "导致了相应的进程在", "不同队列之间的切换", "或者说移动", "那这时候呢", "我们可以把这种状态的变化呢", "以一种队列的形式来体现出来", "我们这儿有就绪队列若干个", "然后这个地方有等待队列若干个", "这是处理机", "实际上这时候的状态变迁呢", "变成是队列之间的进程的搬迁", "好 到这儿呢", "我们就把进程的状态呢说明白了"]}, {"name": "", "block_id": "0eb1dfbe23ec408783b3c4c8b32729ff", "text": ["下面我们来讨论死锁检测算法", "死锁检测和前边的银行家算法", "不一样的地方在于", "我不管分配的时候状态", "我只是在系统运行不下去", "我要去检测", "看看系统里的资源分配状态", "看是否已经出现死锁", "所以死锁检测呢", "是首先它允许系统进入死锁状态", "然后系统维护资源分配图", "当前哪些已经分配出去", "哪些正在请求", "具有这样一张图", "然后周期性的调用死锁检测算法", "来看这里是否存在死锁", "如果有 那我就会", "调用死锁恢复机制来进行恢复", "那我们首先关心的是如何来检测", "刚才我们在银行家算法里头", "这个分配是否安全", "那我是假装分配出去", "然后去看它是否安全", "而死锁检测呢实际上你已经分配完了", "只是去看它是否安全了", "那这时候说", "这个检测和前边的银行家算法里的", "安全检测有什么区别", "那实际上在这里呢", "最主要的一个区别就是", "它没有最大私人请求量的判断", "其它的它们俩是很相似的", "首先它有一个向量", "我现在系统里还有哪些可用资源", "这是个M 维的向量", "然后再有一个M乘N的矩阵", "是说我每一个进程", "已经分配了每一类资源各是多少", "这是它的基本数据结构", "然后说我们怎么检测呢", "我首先是对两个变量进行初始化", "一个是work", "指的是我现在系统里的空闲资源", "也就是它的可用资源", "然后是每一个线程的状态", "它是否还占用资源", "如果说它还占用资源", "那它就是false", "这就是我们要考虑的", "如果它已经不占用资源", "那么这个要么是结束的", "要么不是我们这里关心的", "资源所需要讨论的", "然后我们就需要来检查", "是否是我现在剩余的这些资源", "够某一个线程执行到结束", "那所谓的执行到结束它有一个请求", "这个请求和当前的", "可用资源之间是个啥关系", "如果是能找到", "我满足某一个线程的当前请求", "那这时候说 就算是找着了", "如果说找了一圈之后没有办法满足", "那这时候系统就有可能进入死锁状态了", "找到之后我就把它以分配的", "相当于我当前这个请求的资源", "用剩余的资源是可以满足的分配给它", "它完成运行它已经分配资源", "又可以回收回来到这个work里头", "那这样的话我这个线程就变成完成状态", "然后我再回来找", "如果说我经过若干轮", "我把所有的线程的状态", "都变成是完成状态的话", "那么这时候呢", "我的系统就算是安全的", "如果说这里头有一个它是false", "还处在等待状态的话", "那么这时候它就是产生了死锁", "我们看到在这里呢", "银行家算法和死锁检测算法", "它俩非常相似", "但是有一些小的区别", "然后它的计算量呢", "我在这是对每一个线程要循环一圈", "然后我要检查最多会到N的平方轮", "然后我每一个资源会进行一次操作", "那这时候呢 会是M乘N的平方", "所以在这里头", "如果说你的进程数目", "和资源量很大的话", "那这个死锁检测的开销是很大的", "还有一个就是我多长时间检测一次", "把这些开销算到里头去", "实际上开销是很大的", "那我们在前边说操作系统内部呢", "通常情况下不管死锁的事", "也就是由于这个原因", "下边我们通过一个实际的例子", "来看死锁检测", "在这个例子当中呢", "我有五个线程 三种资源", "它的资源总数的情况在这", "分别是7、2、6", "然后这个是它当前已经分配出去的状态", "和当前各个进程请求的状态", "在这我们实际上就可以看到一种情况", "我这里有两个请求是0", "实际上我们通常情况下", "只是在没有可用资源的时候", "我才会来做这种检查", "这两个没有请求的这个线程", "它肯定是可以执行结束的", "我们让它执行结束", "这时候看到我的可用资源是变成3 1 3", "这时我看", "我这个资源是否可以满足剩余的", "还需要资源的这些线程的资源需求量", "我们从这可以看到 它都满足", "所以这时候这个状态呢", "它是能够正常结束", "里头是没有死锁的", "这是我们找到了一个安全序列", "所以在这示例里头呢", "看这个检查还是比较容易的", "我们换一个角度", "我实际上在这里呢", "就把这两个的量给换了一下", "这时候第一个仍然是可以结束", "然后第三个原来是可以结束", "现在变成是还要申请", "但这时我们就看到", "实际上这时候你没有办法", "找到一个可以结束的状态", "因为第一个可以回收是B这个资源", "而B这个资源呢 只有它需要", "剩下的都A和C", "A和C都没有了 那这样的话", "我们就都没有办法顺利的完成", "所以这时候呢", "系统里就出现死锁了", "那出现死锁之后我们就会想到", "这死锁怎么来处理", "那在这之前呢", "我们还会再有一个问题", "说死锁检测算法我怎么来用", "刚才我们说是没有资源了", "我会来做这死锁检测", "然后我多长时间检测一次", "那这时候呢", "你不能等它系统里已经是完全搞不动了", "你才会来做这种检测", "那这时候呢", "你往回滚的量也是会很大的", "这是你在选择时间和周期的时候", "需要考虑的问题", "然后再有一个呢", "就是如果说里头出现了", "多个造成死锁的循环", "那这时候你很难分辨出", "哪一个是里头的关键", "因为我们找出关键的原因是", "为了减少我终止的进程的数目", "如果你找不着的话", "那这时候你就会终止很多进程", "这时候呢 它的开销也会是很大的", "假定说我能找着是否有死锁", "然后这时候我要进行进程的中终止", "我需要把产生死锁的进程终止掉", "我一次只终止一个", "因为你一块终止很多个的话", "有可能也是没必要的 我终止一个", "然后看它是否还会再有死锁", "那这时候说我到底终止哪一个呢", "这是我们在这里", "关于终止进程的顺序的考虑", "首先第一个我们按优先级", "那优先级最低的", "然后再一个就是", "我看它已经执行了多长时间", "和未来它可能需要执行多长时间", "有可能未来执行多长时间", "你干脆就不知道", "已经运行了多长时间", "运行时间越长的我们越希望留下它", "原因在于它已经占用系统资源", "算了很长时间了", "还有一种考虑是", "它已经占用的资源的情况", "实际上我们时间也是一种资源", "它已经占用的资源和未来需要的资源", "这都是我们在这里", "选择终止进程的时候所需要考虑的", "还有两种可能的考虑是我在终止的时候", "我会终止多少个进程", "这个数目越小越好", "然后会说我终止了进程是什么样的", "是前台的交互进程和后台的P处理", "我们通常情况下是愿意", "让用户交互的进程能够继续执行下去", "这是终止进程的选择", "然后我选择了要终止之后", "那我怎么来终止呢", "由抢夺资源", "抢占进程所占用的资源", "这是我选择成本最小的", "然后我可以回退", "回退到以前的某个状态", "然后继续启动进程的执行", "在这里头呢 可能会出现饥饿", "我一个进程终止之后 我再继续执行", "可能还会是同样的进程被终止", "这时候呢", "就会出现我们这里说的饥饿情况", "这是我们关于死锁检测的讨论"]}, {"name": "", "block_id": "985d4373a7db4e4fa36fcc8163446278", "text": ["那我们前面对这个", "uCore文件系统结构", "有一个大致的了解", "接下来我们再进一步深入一下", "看看一个具体文件系统", "是怎么能够表示出它所需要那些文件", "和给用户访问的一些操作的", "就是simple file system一个分析", "在simple file system里面呢", "我们重点关注是一个一般的文件", "就是我们说通常的打开 读 写 关闭", "这么一个操作用到的文件和目录", "它的一个类型所需要涉及到", "一些数据结构和操作", "这里面需要考虑一系列问题", "第一个就是说硬盘上", "怎么有效去组织一个文件系统", "怎么能够通过文件系统组织", "来表示出更具体的文件", "硬盘的布局是什么", "硬盘上它是以磁盘块为单位", "来进行读或者写操作", "那怎么去和我们文件的", "数据块进行对应", "如何去管理这些空闲的磁盘块", "怎么去表示一个文件或者目录", "到底文件里面包含什么东西", "目录包含什么东西", "还有这个数据怎么去定位", "这些问题就是要", "设计一个文件系统里面", "需要去考虑的内容", "好 我们这里面采取的方法是什么呢", "自下而上 从硬盘到内存", "观察这个数据结构", "它们之间依赖关系", "谁包含谁 这么一个方法", "来分析我们simple file system", "它大致是怎么来组成的", "那我们可以看看这幅图", "首先我们可以定位一下", "simple file system呢", "在整个文件系统的这部分", "中间这部分", "它的主要的内容是", "存在我们硬盘上的", "就是这一块", "整个我们提供虚拟硬盘", "这个硬盘呢 它保存了", "simple file system整体的一个结构", "这里面包含了super block", "根目录的inode", "freemap 就是表明当前", "哪些磁盘块是空闲的", "还有一些跟数据相关的", "数据块的一些信息", "那simple file system当它在内存中", "被uCore操作系统进行操作和管理的时候", "它会涉及到file 目录", "inode和I/O buffer", "那么文件和目录呢", "它和我们inode有一个交互", "我们需要通过inode来表示", "这个文件和目录的关系", "以及这个文件和目录", "它所在的位置和内容", "这个I/O buffer主要是用于说", "我们需要把文件数据读到内存中来", "放到一个buffer里面去", "或者把内存中的buffer数据呢", "写到我们硬盘中去", "这里面就有一个buffer这么一个管理", "这是我们说simple file system", "它大致涉及的内容", "那我们再从硬盘的角度来看一下", "这个Simple file system它的组成部分", "第一个叫super block", "根据这个名字可以看出来超级块", "它是对我们整个simple file system", "一个总体的一个描述", "包含了它一个标识 magic number", "然后它整体一个块数", "当前还有空闲多少块", "还有它的一个字符串信息", "这是super block内部的一个内容", "我们需要把它读到我们内存中去", "通过什么呢 sfs_do_mount", "那么这个do_mount要把文件系统", "加载到我们uCore kernel里去", "使得我们应用可以去访问", "那这一步呢 是在开始做", "文件系统初始化的时候", "需要去完成的工作", "紧接着呢 我们会在内存中", "建立好一个", "simple file system的整体框架", "这个框架什么呢 sfs_fs", "这个看名字有点怪", "就是simple file system的", "一个file system", "在这个结构里面呢", "你可以看到 刚才那个", "super block信息已经放到这儿", "第二部分呢 是这个文件系统所在的device", "也就说它有一个", "针对具体一个设备的表述", "这一块我们放后面会进一步讲解", "第三部分是freemap", "就是当前这个文件系统中", "还有哪些空闲的数据块 可以去使用", "那么通过freemap可以表示出来", "这是用一个bit来表示一个data的block", "还有就是sfs_buffer 用于缓冲用的", "还有呢 inode_list", "就是所有这里面的inode", "它会通过一个哈希或者是链表的方式", "保存在我们内存中", "便于我们来检索", "属于SFS这个文件系统一些inode情况", "那这就是形成一个整体的架构", "我们再逐步往下进一步细看", "第一个很关键的", "在这个硬盘块上面", "除了super block之外", "就是一个叫root-dir的inode", "什么叫root-dir inode", "就是根目录的inode的结构", "那么根目录表明了", "我们一开始访问这个文件系统", "可以看到的目录信息", "那这个根目录信息里面", "包含了直接索引块和间接索引块", "它大致的位置在什么地方", "就是在这里面", "用这个数据结构来表示出来的", "同时我们还可以看到对于目录而言", "它的数据它是什么呢", "包含了这部分内容", "就是一个是索引节点", "所占数据块的索引", "还有就是文件名", "这实际上表明一个目录项", "就是我们前面在讲", "文件系统抽象时候提到的", "目录是由一系列目录项组成", "在这里面我们是用一个数组方式来表示", "通过查找一个目录所在的inode", "所对应的它的data", "可以找着属于这个目录里", "所有的目录项", "而每一个目录项呢", "包含了关键的文件名", "和文件名所对应的inode的那个索引值", "OK这就是说我们目录项里面的内容", "第二部分呢 是我们文件的数据", "那么文件数据放在什么地方呢", "就是用这个来表示的", "也是一样 是由我们这个inode里面", "它的间接索引块和直接索引块", "来表明我们的data block在什么地方", "对于file而言", "这个data block就是它的data", "就是我们说文件的具体内容", "那我们如果要读写文件", "最终这个文件的数据放什么地方呢", "就放在这些地方里面", "通过inode里面index可以查找", "这些data block在所在的位置", "然后进一步通过我们硬盘的读写呢", "就可以把这个数据", "进行相应的读或者写操作", "这里面很关键就是inode了", "我们可以看看simple file system的inode", "包含什么样的信息", "它其实包含两个层面的内容", "第一个层面是在内存中", "它有一个sfs_inode", "第二层面是我们硬盘上 也有一个inode", "它称之为sfs_disk_inode", "可以看出来它们关系是什么", "disk_inode呢 是sfs_inode一个成员变量", "那我们需要通过这个sfs_disk_inode", "来完成进一步针对文件的读写操作", "那么这里面会涉及到打开 关闭文件", "读 写文件", "还有读写inode所对应数据块的", "一系列操作", "那这些操作是什么 我们可以看看", "那么如果说我们知道一个inode", "我们希望访问这个inode的数据", "那么这里面存在两种情况", "一种是这个inode表明是一个目录", "或者这个inode表明是个文件", "这两者是不一样的", "这个函数就是sfs_bmap的一系列操作呢", "是关于文件这种情况的数据块读写", "而下面这几个函数 (direntry)", "就是目录entry呢", "它其实涉及到针对目录的 数据的读写", "可以看出来它们是不一样的", "但是呢 我们有一系列的", "高层的 针对file的一些操作", "这个操作 其实是和我们后续会讲到的", "虚拟文件系统相关", "它会把底层的一些函数的细节给屏蔽掉", "向上提供一个统一的接口比如open close", "这个接口是一样的", "但是它具体对应到", "simple file system的实现", "它这个open file或者close", "这些操作是不一样的", "通过这些函数呢来完成", "对一个文件的打开 关闭 读写操作", "紧接着还会通过不太一样的一些操作", "比如说opendir", "或者getdirectory entry来完成", "针对目录读打开 关闭操作", "这里面也写一个写", "大家仔细考虑一下这里面有写吗", "这是留给大家的一个问题", "大家可以再考虑一下", "这里面只是介绍了", "基于index这种方式的", "文件系统具体实现", "还有其它一些文件系统", "大家通过做实验", "还可以进一步掌握和了解"]}, {"name": "", "block_id": "0c59617cb7574e0bb46f8cb3ae644bca", "text": ["接下来我们讨论碎片整理", "碎片整理是想说", "我们已经把内存分区分配给了进程", "它们也已经站定了某一个位置", "但是这个时候", "我正在执行的应用进程", "或者说新创建的进程需要内存空间", "这个时候没有了", "或者说这些都已经剩下小的碎片了", "那我想要内存空间", "这个时候怎么办", "我们可以通过碎片整理", "来获取更大的可用内存空间", "以便于满足进程的应用空间需求", "我们看碎片整理", "碎片整理是指我们通过调整", "已分配给进程的内存分区它的位置", "来减少碎片的一种做法", "这种做法有一个图示", "说这里头这几个闪烁的地方", "就在我们这里头是空闲的空间", "但是假定说这里头最大是剩三块", "但是现在我要分配一个连续四块", "那就没有了", "这个时候怎么办呢", "我们希望通过碎片整理", "我们把它压缩到一起", "然后剩的这块就可以满足要求了", "但是我要把正在内存当中的", "这些进程的位置挪动", "这个事是不可以随便弄的", "原因在于我里头", "可能有各种各样的地址引用", "这种引用用的是绝对地址的话", "那这个时候你挪了之后", "它是没办法正确运行的", "所以在这里头要进行碎片紧凑", "它是需要一些条件", "也就是说我所有这些进程", "都是可以动态重定位的", "只有做到这点之后", "我这里程序才可以去搬它", "当然这种搬也是有开销的", "你不可以正在处于运行的状态去搬", "通常情况下我们会在什么情况去搬", "正常情况下 处于等待状态进程", "我会对它进行搬动", "然后再有一个", "并不是说为了一小块区域", "我要把整个内存当中的", "很多进程都把它挪一遍", "这个开销也是大的", "我在这里头在什么情况下", "我需要考虑到开销", "然后进行这种紧凑", "关于具体的做法", "在大家需要相应的技术的时候", "再仔细去看", "我们在这就介绍到这种程度", "第二种做法是分区对换", "刚才我把内存里的这些分区", "不管怎么挪", "最后的结果它都是在内存里头", "如果说这个时候仍然不能用", "你还是没办法", "所以在这里 内存分区对换", "是指我把这种处于等待状态进程", "它占用地址空间给它抢占了", "然后把这个等待进程占用的数据", "我总得找个地方存", "我把它存到外存里头去", "在这里就是对换到对换区", "这时候我内存里的空间也就变大了", "在这 我们也通过一个图示来看", "在这个图示里", "底下是内存和外存的状态", "中间这个图实际上说的是", "我们在系统里头", "进程在执行过程当中", "我们维护进程的状态信息", "这个我们在后面讨论还会再说到", "我们看每创建一个进程", "创建的时候它在内存里要占一块区域", "创建好之后 它数据结构都弄好", "操作系统维护的数据建好", "然后这个时候它可以投入到运行状态", "它在运行的过程当中", "可能会有另外一个进程要创建", "它也需要在这里分配相应的存储区域", "然后进到就绪状态", "第一个还在继续运行", "在这个过程当中我们继续可以进行下去", "由于某种原因我P1处于等待状态", "这个时候P2 P3又进内存里", "来运行状态", "那么在这种状态下", "如果说我再有一个P4进来", "它要的空间就不够了", "这个时候怎么办呢", "我们会把处于等待状这个搬到外存里头去", "这样空出一块区域来", "我把这个P4放在这里", "这是我们就可以让它更多进程在系统里交替运行", "使得我的可用空间能变大", "在这里大家可以注意到", "我们这有一个对换的名字", "实际上大家如果注意的话", "在你的Linux或者Unix系统里", "它有一个分区 叫换区", "实际上这个对换区在早期的时候", "它就是一种充分利用内存的做法", "那么在这张图里头我们可以看到", "在早的时候 甚至在操作系统里头", "只有一个应用进程可以在内存的状态下", "它都可以用对换来实现多进程交替运行", "在这是这样的", "任何一个时候只有一个进程在内存当中运行", "而处于暂停的 是把它放到外存里头", "如果说当前进程主动让出处理机使用权限", "这个时候做法 把它对换到外存当中", "在把外存当中这个搬回去", "这个时候我就可以继续运行下去了", "用这种办法实际上在我们比较早的时候", "内存很紧张的情况下", "我们在系统里就可以实现", "多进程的交替运行", "当然在这里这个交替", "它的开销是非常大的", "原因在于内存和外存之间的速度差的很远", "即使是这样 由于我们前面的系统", "计算机系统它的成本非常高", "所以这样做的开销 也是可以接受的", "当然在这里头我在对换的时候", "到底把谁对换出来", "这个时候开销有多大", "这个时候在系统里", "你就得经过仔细的权衡", "所以在前面做的时候", "它花很大的精力会去解决", "我到底是对换哪一个进程", "这是我们在早期的时候", "计算机系统里的多进程", "通过对换区的方式来做的一种实现"]}, {"name": "", "block_id": "f8cd8da99b204c0ba1eec77d48ee4269", "text": ["第三部分是关于GCC内联汇编", "GCC内联汇编比较特殊", "它是说我们怎么在C语言的开发环境中来使用汇编代码", "来写汇编代码", "使得C和混编来混在一起来使用", "称之为内联汇编", "这个实际上是GCC和有特点的地方", "有了内联汇编之后", "可以直接很简洁的在C里面插入汇编代码", "来完成相应的功能", "那为什么要在C里面插汇编代码呢", "大家想一想 其实是由于我们的C语言", "不足以完成所有的CPU的指令", "特别是有一些特权指令", "它没有对应的C语言的对照", "比如说我们刚才说的加载全局描述符表 LGDT", "这么一条机器指令 你没法用C语言表述", "你只能用汇编来表述", "在这种情况下 内联汇编会发生很大的作用", "它可以很简单的在C语言里面写出一句话", "来把这个功能给完成", "这使得我们写的代码更加清楚 更加便于理解", "好 我们接下来就来看看它是如何工作的", "这也是我们需要去了解的", "因为我们在uCore中有这种代码存在", "所以说我们希望大家能够通过对这部分的了解", "能够读懂这个代码", "从而可以更好的理解uCore的整个执行过程", "这是一个例子", "这是汇编代码 这是内联汇编", "你可以看出来其实它们很像", "这是汇编代码 把这个值赋给EAX的寄存器", "那么对于我们来说 内联汇编怎么写呢", "加了一个asm代表内联汇编的关键字", "然后把刚才这段汇编括起来", "括起来之后用引号表示字符串", "还需要注意它这个标示里面", "一个百分号变成两个百分号", "这是一些语法上的一些表示而已", "那其实还是很直接的对应", "这是一种简单的对应方式 好理解", "我们再看看 它的一个完整的格式是这样的", "asm关键字 然后用一个括号", "这里面这一段就是刚才说的字符串", "还有三个约束表示", "对于输出操作数 输入操作数", "还有一个clobber", "一个我们暂时可以忽略的一个表述", "这三个表述都是可选的", "你可以像刚才那样什么都不加", "但是你如果要建立一定约束", "比如说我希望把某一个变量用某一个寄存器来表示", "那么可以在里面加一定的约束", "使得它完成现在的功能", "我们会以例子来展示它大致的一个过程", "好 这是一段代码片段 大家可以看看", "这是取于我们uCore的代码", "比如这是一个CR0的内存变量", "我们希望把刚才说的CR0寄存器的某一个bit给置位", "怎么来做呢 CR0寄存器没法用C语言来表示", "不得不用内联汇编来表示它", "这里面写了两句话", "比如说在这里面", "首先把CR0的内容读到这个%0寄存器里面去", "然后这个寄存器的内容最终会赋给CR0这个变量", "这个=r 是大致这个含义", "既然你把CR0寄存器的内容读给了CR0这个变量", "那我们可以对变量进行操作", "把某一个位置成1", "或了一下 或等于 置成1", "之后我们再把内存里的内容写回到CR0寄存器里面去", "就靠这条指令来完成", "可以看到 正好倒过来了", "是要把CR0给一个寄存器", "它会把这个寄存器的值赋给CR0寄存器", "那我们生成汇编", "如果我们把这段代码生成汇编", "可以看到是不是我们刚才想达到的意思", "CR0寄存器赋给ebx", "ebx给到一个 这实际上是代表一个局部变量", "然后这一步就是一个或操作", "来完成了对某一个bit的置1", "再把这个局部变量里面的值赋给EAX寄存器", "最后把EAX赋给CR0", "那就完成了这两个内联汇编的功能", "可以看出来 这段代码比这段代码要复杂", "因为这里面加了相应的约束之后", "用我们的GCC编译器自动的帮我们把关系给建立好", "基于你刚才所谓的约束的规则", "所以可以看出来", "有了这么一个表示之后", "我们可以更简洁的来完成一些汇编才能完成的功能", "前面已经讲到了 这里面一些关键字", "volatile 是不需要做进一步的优化 调整顺序", "那这个%0 代表的是第一个用到的寄存器", "这个r代表是任意寄存器的意思", "这里面都有相应的含义", "来建立相应的约束", "也意味着我们说用EBX或者EAX来完成对CR0的传递", "都是可以的 因为它这个值是r", "这是一个约束的表示", "那我们其实可以看一个更复杂的例子", "这里有一系列的局部变量", "然后会执行一个int 80的指令", "这个int 80也是一个特殊的指令", "产生我们说的软中断", "这个过程需要把这些arg1赋给bx", "arg2赋给cx  arg3赋给dx", "arg4赋给什么呢 ESI", "不同的字符代表什么意思", "这边有一个约束的约定", "所以这条内联汇编其实等同于这么一条指令", "它最终是会把相应的这些局部变量赋给相应的寄存器", "然后调用int 80这么一个指令", "产生一个软中断 最后这个软中断返回的值", "会再赋给EBP", "最后是把它赋给了这个地方", "我们基本上就简单的给大家介绍了一下内联汇编", "如果大家需要去进一步了解内联汇编的话", "也可以看一些相关的文档", "这方面网上文档也比较多 大家可以去了解一下", "这里面最主要的目标是", "希望大家能够通过对这个的一个初步了解", "能够知道uCore中出现的内联汇编大致是什么含义", "这是我们说去了解的一个最主要的目标"]}, {"name": "", "block_id": "bfdc1b0bd5c84769a17ed5df66c1f9c8", "text": ["这一讲我们来介绍信号量和管程", "信号量和管程", "都是操作系统当中", "提供的两种同步方法", "那最开始我们说", "因为我们在系统里呢", "为了提高系统的并发性", "所以我们引入了多进程和多线程", "多线程的引入导致了", "资源的共享使用和竞争", "我们就会需要去", "寻找解决的办法", "这就是我们这里要同步", "同步呢是为了协调多个进程", "对共享数据的访问", "我们把这个问题抽象出来", "就变成是在任何一个时刻", "那我们只能有一个线程", "在执行临界区的代码", "解决的办法呢", "我们前面有这样几种说", "我们可以基于底层的硬件实现", "也可以在上面呢", "有高层的抽象编程方法", "那我们今天讲的信号量和管程", "都是属于编程方法的两种", "这是我们要最终解决的问题", "我们需要协调各个线程", "对临界资源的访问", "然后我们的做法呢有这样几种", "首先呢我们在最底层", "希望来解决这个问题", "你比如说禁止中断", "那我也有 做原子操作", "把读和修改这两个", "变成一个原子操作", "比如说我们TS指令", "然后我们也有呢", "完全基于最基本的读写操作", "来构造出来的软件同步办法", "这几类办法呢", "我们把它都抽象成一个接口", "说 就是我们这里前面说的锁", "那用锁来申请临界区的进入", "和在临界区完成之后那退出释放", "好 这个机制能比较好地抽象", "而它的实现呢", "是依靠这底下这三种办法", "这三种办法呢各有各的适用场合", "然后有一个统一的锁机制之后", "我们在上面能实现临界区的访问", "今天我们要说的信号量呢", "实际上就是跟锁机制", "在同一个层次上的一种编程方法", "它的做法是在操作系统的控制下", "来做这件事情", "信号量是操作系统提供的一种", "协调共享资源访问的方法", "那这种方法呢", "它和我们前面讲到的", "软件同步方法有什么区别呢", "软件同步方法呢", "实际上我们讨论的是平等的", "线程之间的一种协调机制", "那也就是说我如果用线程", "通过软件方法来协调", "谁进入临界区的时候", "这些线程之间的位置是完全平等的", "但是我们这里讲到的信号量呢", "实际上它是由操作系统来负责管理的", "操作系统作为管理者", "它高于我们的进程", "这做一个类比", "就相当于是说我们在球场上踢球", "一种是说两个球队一块踢", "没有裁判", "好 那这时候", "我们有一套共同的规则", "好 那这时候大家一起来踢", "在这个过程当中呢", "如果说有问题 我们照规则来", "但实际上这时候呢", "大家对规则理解", "总是会有各种各样偏差", "于是我们引入一个裁判", "那裁判就是说", "只要我们俩有分歧的时候", "找到一个仲裁", "由裁判说了算", "那我们在这儿呢", "实际上就是由操作系统", "来做这个裁判", "也就说两个进程协调", "谁能使用临界区资源", "由操作系统说了算", "有了一个仲裁者", "或者一个管理者之后呢", "这种协调会变得比原来容易", "好 在这种情况下", "我们用一个信号量", "来表示一类资源", "信号量的取值呢", "就是它的资源的数目", "这种做法呢是最早", "由一个荷兰科学家", "叫Dijkstra 他提出的", "那这个名字呢", "我们在前面的数据结构里头", "计算机科学里头", "有很多他做出的贡献", "这种办法呢在早期的操作系统当中", "是最主要的同步机制", "那目前呢在我们实际系统当中", "这种用的相对来说比较少", "但是它的重要性呢仍然是非常高的", "它具体怎么做呢", "信号量是一种抽象的数据类型", "这个数据类型里头有三个内容", "一个是一个整形变量", "这个变量的取值呢", "你可以理解为", "你要共享的资源的数目", "然后由两个原子操作", "那这两个原子操作呢一个叫P操作", "它是申请资源的时候要用的", "我申请使用一个资源", "那我把这个计数呢减一", "也就相当于可用的资源数变少了", "好 那这时候呢", "就可能有一种情况是说", "我来申请资源的时候", "已经没有资源了", "那这时候我就减成一个负数了", "减成负数之后呢", "我就需要等待另外的线程", "用完这个资源之后", "它释放了我才能用", "好 那这时候呢它就进入等待状态", "如果说不是这样 它是大于0的", "也就相当于我拿到了相应资源", "那我就可以使用了", "好 这个P的出处呢是荷兰语", "那最早这个科学家他做出来的", "我们后续就延续这个提法了", "然后反过来呢", "我用完资源之后", "我释放的时候一个V操作", "V操作就是把计数加一", "如果说你占用的是", "由1变成0的那个资源", "后面的线程再来的时候", "那它就已经是负数了 它在等待", "好 那这时候你加一之后", "如果说它仍然是小于等于0的", "那么这时候就说明", "有另外一个线程", "在等这个资源来使用", "它目前处于等待状态", "好 那这时候呢", "我就唤醒相应的等待线程", "好 这个V呢", "也是跟P一样的", "它来自于荷兰语", "好 有了这两个之后", "我们看这个它怎么来用的", "我们做这样一个类比", "也就说我假定有一个车站", "车站有两个站台", "一个站台呢可以停一列火车", "进行上下乘客 或者说货物的装卸", "好 我们在这儿呢把它抽象成", "一个有两个资源的信号量", "它做法什么样子呢", "在这儿我们看到", "这是车站的两个站台", "好 没有任何站台被使用的时候", "这时候任何一个火车", "都是可以进来的", "好 那这时候呢有一列火车", "直接进到一个站台", "然后这时候仍然有资源呢", "这时候我这儿还是绿灯", "好 等我把这资源占满了", "我们通常情况下理解", "这时候就有红灯", "后面再来火车的话", "它就停到这儿了", "好 那这时候呢说再来火车", "那实际上这时候呢 我就相当于", "这地方的P操作减1再减1", "这时候由2就减成0了", "好 那这时候呢", "再来第三辆的时候", "它就出去等着了", "等第一辆火车装卸完毕 它离开", "好 那这时候加1", "加1之后发现那", "我这里头后面还有一个等着的", "那这时候呢它就可以进来了", "好 然后这时候呢两个都占用了", "那我们在信号灯上看着就是红灯了", "那我们实际上信号量的作用呢", "就是类似于这个车站的控制流程", "好 那我们说信号量它是", "由一个整形变量加两个操作", "那么这个整形变量呢", "加上前面这个操作呢是", "P操作和V操作对它进行保护", "好这种保护之后呢", "实际上我们就能做到", "你对信号量中的整形变量的修改", "你只能通过PV操作来完成", "操作系统呢来保证", "这个PV操作的原子性", "那实际上这是我们前面说到的", "操作系统在执行它的代码的时候", "它的优先级高于我们", "进程的用户代码", "所以在这时候呢", "它能保证它在执行过程当中", "不受应用进程的代码执行的干扰", "好 那这样就能保证它的原子性了", "好 那这时候在执行过程当中呢", "P操作有可能由于没有资源", "而进入等待状态", "V操作呢只会释放资源", "处于等待状态的进程呢", "变成是就绪状态", "好 那这时候说", "我们用信号量实现的同步", "那这时候它能够做到公平吗", "在我们实际用的时候呢", "通常情况下假设它是公平的", "在实际的系统当中呢", "这个公平呢也会有些偏差的", "那我们在这里说到的公平是指", "我线程不会无限期的等待下去", "它一定会结束", "这是由于操作系统", "在这里起的作用", "那实际上我们在实际系统用的时候", "这个P操作呢它也会说", "在后面有一个等的最长时限的参数", "那超时之后它直接错误返回", "好 然后在这儿信号量的等待队列呢", "我们是按先进先出排队", "这一条呢实际上", "在我们前面说到的锁机制里", "自旋锁它实际上是做不到的", "为什么呢 原因在于", "我们自旋锁是需要占用CPU", "随时随地去查", "有可能临界区的使用者", "退出的时候它刚改完", "下一个进入者是谁去查", "那它就能进去", "如果说你运气不好", "正好是这个资源变成有效", "你去查的时候在你之前", "就有一个人已经查过了", "好 那么这时候呢", "你就没有办法按照你", "等待的这个顺序来做这一条", "好 那我们看信号量的实现", "我们把它定义成一个数据类型", "好那这里头呢有一个变量 sem(semaphore)", "然后有一个等待队列q", "那这些呢都是在操作系统内核里头的", "然后它定义两个操作", "P操作和V操作", "那在这里干些啥呢", "进来之后它是信号量的变量减1", "然后 如果你减完之后的值是小于0", "那么这时候呢就说明我没有资源了", "减到零是可以的", "好 那它把这个线程呢", "放到等待队列里头", "并且呢阻塞", "好 那这时候呢切换", "好 等到我申请到了", "那我就没有进入这个堵塞", "我就直接进到临界区里去执行", "那执行的过程当中呢", "用完了退出的时候作为啥呢", "信号量当中的变量加1", "好 如果说加一之后还小于0", "那就说实际上前面有人在等着", "好 那这时候呢", "我就从对应的等待队列里头", "把相应的线程放到就绪队列里头", "这和我们前面讲的", "进程的状态的变迁", "这样就结合起来了", "然后它结束 它就干别的去了", "那另一个 就可以进到临界区里头", "好 这是我们说到信号量的实现", "从这儿来讲好像这个东西很简单", "和我们前面区别在哪", "就是在于这一段代码", "执行的原子性", "它是由操作系统来保护的", "为啥我们前面做不到这样一点呢", "我这里头 减一和判断", "那我们在前面", "讨论软件方法的时候", "最大的问题就在于", "我减完一之后和这个判断这俩", "中间可能会中断", "好 由于这个中断", "我们就有无数的麻烦", "好 那这个时候现在有", "操作系统在里头做保护了", "好 我这两个代码", "它的执行不会被打断", "我们就会发现", "这个地方 我变成一个原子之后", "我的日子就好过多了", "好 那这是我们说", "信号量的基本原理", "下面我们会去", "用实际的例子", "来说明它的使用方法"]}, {"name": "", "block_id": "732ab93c088543aab5efdaedfed6dddb", "text": ["接下来 我们看一下在实际代码当中", "一个系统调用的引用到最后的实现", "在这我们可以看到在我们ucore里头", "我这里演示的ucore", "实际上我们用的是ucore+代码", "和我们现在同学们做实验ucore会有一些区别", "为了有所区别 所以我在这演示的时候", "用的是ucore+", "以便同学在里头做的时候需自己去找一遍", "在你那个系统里头他的函数的实现情况", "在这里一个例子 在这个例子就有一句去读文件", "在这里后面有参数 这是一个应用态的一个测试应例", "他在里面去访问的 我们看一下这read个函数", "他调用其他调用其他函数情况", "这有很多例子会调用read", "然后他会调sys read然后是sys call", "这两个函数在往下就没有了", "这个转过来到这sys read实际上就是转变成sys call", "然后这个时候你的函数功能变成这里一个参数", "后面内容都变 这是sys call函数", "然后sys call函数实现在哪", "实现在这 我们看到这是sys call实现", "前面有一些相应的参数获取", "然后对于我们来说", "我们需要关心代码是这段", "这是在X86情况下他的系统调用", "这是num是我们刚在PPT里看到的", "是他的系统调用的编号", "这是系统调用的中段号 这是系统调用", "到这我们从用户态的情况", "在往下就已经跟踪不到了", "我们转过身来在内核态", "内核态我们刚才在PPT里说", "他是从all trap到trap然后在我们这里我们先看trap", "这里头实际上就是从中段进来之后", "他填了一个数据结构叫trap free", "在这个数据结构当中", "是获取到了相应中段产生的一些信息", "他里面有我们说的中段号和相应寄存器的值", "到这就转到trap dispatch 这我们可以看到其中有一个sys call", "他会判断trap num是多少", "根据不同情况我们关心的是在这里的sys call", "如果说你是其他 比如说时钟终断", "那在这里他的时间代码在这", "我们关心到这 他到sys call这个函数", "这个函数我们看一下这是他函数调用图", "我们trap dispatch到这是sys call然后这个sys call实际下去之后", "在里面有很多内容 我们看直接代码", "这是sys call 到这来之后 他会转到sys read", "到这会去读取你的参数", "这实际上就是从系统调用进来之后", "获取他一二三 这三个参数", "然后这个时候转过之后变成sys write", "我们看到这来的时候 这是sys read到sys write", "然后再往下就是相应的实现了", "我们看在这sys write到这里最后下去之后", "我们带这里根据不同情况完成相应文件的读取工作", "在这里实际我在介绍中间还缺了一段", "就是从trap在往前那段", "和sys dispatch到sys read这段我在这没做展示", "希望大家下去之后能够把", "相应的整个从用户态到内核态", "然后到函数的实现 一直到返回", "把整个这条路分析明白", "那这样你就知道一个系统调用是如何实现的", "好今天的课就上到这里 下课"]}, {"name": "", "block_id": "7a2e54a3797a4afca4a4af747360788c", "text": ["各位同学好 那么接下来我们介绍一下", "有关lab1的具体的实验的一些细节", "那前面我们已经给大家在讲解了一下", "有关lab1的一些基本的一些知识", "包括我们说这里面看到CPU的分段机制", "CPU 特别是X86这个架构", "以及X86中断处理机制", "然后在lab1里面其实这些方面都可以涉及到", "那我们lab1主要干什么呢", "我们看看 它的实验目的", "那lab1的实验目的是希望", "能够把这个OS给加载到内存中去执行", "那么能够加载OS呢 我们也知道", "我们还需要一个Bootloader", "所以说在这里面包含了怎么去设计", "Bootloader以及把这个OS加载进去之后呢", "它能够去管理中断还有就是", "有基本的一个外设的一个处理", "那在这里面我们学到什么呢", "希望通过这个lab1", "我们知道在计算机原理这一块呢", "可以看到它涉及到是", "CPU的编址与寻址这一点很重要", "因为我们的Bootloader", "我们的uCore OS都会加载到内存中去运行", "在CPU里面如何寻址", "如何对内存进行编址这一点很重要", "没有这个相应的一个处理的话", "那么我们后续就很难对内存进行有效的管理", "这里面可以看到基于分段机制内存管理", "这是我们X86里面一个很有特色的一个地方", "当然这里面我们用很简单的分段机制", "第二是CPU的中断处理这", "是我们需要去了解的", "第三个 我们可以看到它可以有外设", "它可以通过相应的一些控制机制", "能够跟外设打交道来完成最基本的一些处理", "比如说在lab1里面会涉及到什么呢", "串口 并口 CGA 就是我们的显示器", "以及时钟 就是产生时钟中断", "有时钟 还有硬盘的读取 这些操作呢", "其实都是计算机原理中会涉及到内容", "在我们的lab1里面就一下子都反映到了", "虽然看的很多 但其实还是很简单的", "为了能够充分的利用这些外设", "我们有两个软件 这里面其实包含了两个软件", "一个是Bootloader 一个是uCore", "在Bootloader里面呢", "我们会学到如何去编译 运行 调试", "Bootloader这个软件", "第二个也会学到 uCore其实也是一样", "也需要有编译 运行 调试", "这是一些通用一些技术", "把这个掌握之后呢", "其实对大家后续学习其他的lab", "完成其他的lab实验呢", "会打下一个比较好的基础", "第二个呢我们会看到在Bootloader里面", "它会涉及到对文件的读取", "那么ELF去执行文件 它怎么去读取的", "第三是外设 怎么去访问", "它至少能够把硬盘中的数据读到内存中来", "第一个 第二个能够显示字符串", "这是Bootloader能够完成的", "一个很重要的事情", "其实它还有个很重要的工作", "就是能够把这个CPU", "让CPU进入保护模式", "这是Bootloader干的很重要的一个事情", "在uCoreOS里面呢", "Bootloader首先会把uCoreOS加载进来", "然后把控制权交给uCoreOS去运行", "所以我们还会知道uCore OS它怎么启动的", "第二个呢 我们怎么能够去分析", "在uCoreOS中的这个函数的调用关系", "还有 在uCoreOS里面需要考虑中断", "因为它要为接下来这个实验做好一个准备", "有了中断这个管理机制之后呢", "当外设发出请求之后呢", "我们的CPU可以通过中断机制得到响应", "第二个呢 当你产生异常", "或者发出系统调用的时候 我们的软件", "我们的软件由于你某种不恰当的操作", "产生某种异常或者系统调用", "或者是一些错误的时候呢", "那通过这个中断管理机制呢", "能够感知到这种现象的存在", "并进行相应的处理", "所以中断这个机制很重要", "第三 在uCore里面还能看到", "有了中断管理机制之后我们就可以控制外设", "让外设定期地产生时钟中断", "比如这个时钟就是一种外设", "OK 那这是我们lab1会涉及到内容", "相对而言我们可以看到它", "和我们原理课对应在什么地方呢", "原理课我们的前几节课其实会讲到中断", "会讲到系统调用 会讲到异常 这一块呢", "在这里面有一个中断管理好像是直接对应的", "第二个讲到连续物理空间的分配", "而连续物理空间的分配呢", "是和我们这边说到这个CPU的编址", "寻址基于分段机制的内存管理是有紧密联系的", "因为我们这里面把这个分段机制", "就可以看成是一种简单的", "这种连续物理内存一种管理机制", "在这种机制下我们怎么有效去完成后续的", "我们在lab2中会碰到物理内存管理", "首先得要有这个基础 这个基础要打好", "所以我们可以看到 这里面做lab1", "它和我们原理课的关系", "这里可以看出 有两个很重要的关系", "一个是连续内存的管理", "第二个是中断的处理", "其他部分呢 都是说为了能够", "让一个OS能够正常的运转起来", "所不得不涉及各方面一些知识", "这个知识了解之后", "我想对大家后续完成各种实验", "会打一个很好的一个基础", "那接下来我们可以看看", "我们到底要完成哪些练习", "为了能够实现lab1这个目标呢", "我们大致提供了6个基本练习和一个扩展练习", "比较多 确实这个lab1的相对来说", "它容量比较大 但是我相信大家通过仔细的阅读", "相应的实验指导书以及仔细的阅读代码", "了解自己的所不知道的一些知识之后呢", "能够很快的完成这些实验 我们看一下lab1", "lab1什么意思呢", "lab1其实主要是让大家熟悉这个实验的过程", "它要能够理解如何通过Make", "来生成执行文件的过程", "这里面其实我们可以看看", "我们这里给大家做一个demo", "这是我们这个lab1这个答案的这个目录", "在这儿 就是lab result", "首先我们make clean一下", "可以把这个刚才编译这些都给它删除掉", "然后呢 make V=", "这实际上就是设置一个标记", "使得我们Make它的执行过程能够展现出来", "详细的这个编译执行过程会展现出来", "那可以看到它调了GCC", "GCC来把一些C的源代码", "编译成了所谓的.O文件是目标文件", "然后通过ld，ld会把这些目标文件呢", "会转换成一个执行程序", "比如说在这里面会转换成这个bootblock.out", "这个实际上是可以理解为", "是一个Bootloader一个执行程序", "还有一些程序比如说用dd呢", "最后可以把这个Bootloader", "把Bootloader放到一个虚拟的硬盘里面去", "我们这儿生成一个虚拟硬盘叫uCore.img count", "我们硬件模拟器呢", "就会基于这个虚拟硬盘中的数据", "来执行相应的这个代码", "当然后面还看到这里面其实生成了两个软件", "第一个是Bootloader 第二叫kernel", "kernel实际上是uCore的组成部分", "所以说可以通过刚才这条命令", "能够知道Bootloader", "以及uCore是如何一步步生成的", "当然它取决于我们一个文件 Makefile", "这个文件相对来说比较复杂", "大家一开始的时候其实不用太去管这个文件", "你只要管 你到底要去用到了哪些.C程序", "来最后生成了Bootloader和uCore就OK了", "如果大家感兴趣的话可以再做进一步的了解", "我们说刚才已经看到uCore.img如何生成的", "给大家做了简单介绍", "第二个问题 一个被系统认为是符合规范的", "硬件主引导扇区的特征是什么", "这个呢其实也是一个小的一个细节", "就是我们怎么知道", "特别是我们说BIOS", "在引导这个主引导扇区的时候", "它怎么知道主引导扇区是符合规范的", "那它有一定的特征", "这个特征呢其实大家需要看一下", "提示一下 需要看一下一个文件", "在哪呢 在这个tools里面", "它最后有一个 有这么一个文件", "sign.c 在这个文件里面", "它完成了特征的标记", "需要大家去读一读", "看看到底哪个是这个特征的标记", "好 那练习一呢 就给大家简单介绍到这儿"]}, {"name": "", "block_id": "50c6b12ee20a4e19b304b86ef6845902", "text": ["接下来", "我们对页表进行进一步的介绍", "那么在页表里头呢 我们刚才说", "页表是负责从逻辑页号", "到物理页号之间的转换", "那这个转换", "它到底在里头是如何进行的", "在前面我们讲到过有一个页表", "页表负责完成这个转换", "那这里我们想说的是", "每一个逻辑页面", "对应着在页表里头呢", "有一个页表项", "这个页表项完成这个逻辑页号", "到物理帧号之间的转换", "那在这个转换过程当中呢", "我们还有一条需要说明的就是", "页表里的内容", "会随着程序的运行而发生变化", "这种变化呢 就使得我们有可能", "动态的去调整我分配给一个进程的", "内存空间的大小", "好 再有一个呢就是", "这个表放在哪儿呢", "这个表它在一个寄存器里", "页表基址寄存器", "在这个寄存器里 告诉你", "这个页表它的起始位置在哪", "好 有了你的逻辑页号之后", "那我就可以找到相应的表项", "那这个表项里头", "还有一些啥内容", "我们在前面的讨论里头呢是说", "里头有页帧号", "它的页帧在哪", "但是这个页表项里呢不止这些", "我们刚才说了 这里有一条动态", "我们可以在程序运行的过程当中", "来给它分配新的物理帧", "放到这个 它的进程地址空间里头", "那这时候呢 这种新加入的状态的改变", "就是靠这里的这些标志", "这里的状态来修改的", "那这里头呢是我们常用到的", "几个标志位 存在位 修改位 和引用位", "存在位是指我们有一个逻辑页号", "是否有一个物理页面", "物理帧和它相对应", "如果有 这个存在位就是1", "好 这一条是表示我们这个页", "对应的分配的动态性", "然后修改位和引用位", "是在我们后续的课程内容当中会用到的", "修改位是说我对应的这个页面", "里面内容是否修改了", "然后引用位 是指这个页面", "在过去一段时间里", "是否有过对它的引用", "是否访问过这个页面里的", "某一个存储单元", "刚才我们在页表中加了几个标志位", "那下面呢 我们就来通过", "一个实际的过程", "来看这几个标志位当中的", "存在位在里头作用", "好 这是一个实际的系统当中的示例", "这是逻辑地址空间 物理地址空间", "分页之后 每一页上页的结束页号", "页内偏移最后单位", "这地方呢是它的假设前提", "每页有2的10次方", "1024个字节", "总共是一个16位的系统", "这是每一K算一页 每一K算一页", "这是一个示意", "好 我们再看在这个", "我们前面讲的里头", "是我有一个逻辑地址", "CPU在执行指令的时候", "它转换成一个物理地址", "这是32K的", "那在这儿呢", "16位地址是从0到15", "那0到9是页内偏移", "10到15是页号", "那页表呢 在这里完成这个转换", "这个转换 如果说在我们", "没有标志位的情况下呢", "我是每一个逻辑页号都对应过来", "有一个帧号组合起来", "找到实际的位置", "那现在有了存在位之后呢", "我们就可能有些没有", "那这个存在位在哪呢", "就在这里 那你找过来的时候", "有可能某一页找不到", "那实际上就说这一页对应过来", "没有对应的物理帧号", "那这时候 相当于", "并没有给它分配相应的存储", "这使得我们可以在这里呢", "可以有动态的变化", "页式存储管理可以让我们", "不连续地分配内存空间", "但是它也会带来很多的问题", "那这儿列的第一个问题", "是它的访问性能的问题", "我们在没有页表的时候", "我要访问一个存储单元", "那我给你的是物理地址", "物理地址呢 直接去访问", "就能拿到你要的东西", "但现在因为我们为了实现", "非连续内存分配", "好 那这时候呢", "我们就会加了一个页表在中间", "那我每访问一个存储单元的时候呢", "我都需要先知道", "它逻辑页号对应的物理页帧号是多少", "那这个转换都要求我去访问页表", "那这样一来的话", "我的访问就变成是两次了", "先读页表项", "看看那个对应的物理页帧号是多少", "然后再依据这个页帧号", "和页内的偏移合到一起得到物理地址", "再去访问实际的内容", "这样的话它的读写性能就会大幅度下降", "读写量也会大幅度增加", "第二个问题是说我们有了一个页表", "如果说这时候我的内存地址空间很大", "这个页表的存储容量也是不能忽视的", "它可能会很大", "像我们刚才说那个示例系统里头", "32K的物理内存", "那 1K占一项 那我就32项", "如果每一项占4字节的话", "那就是128字节", "这个量呢相对来说很小", "而我们现在实际系统已经达到了64位", "也就是说 我的地址总线", "可能会是64位地址总线", "如果这时候 你仍然使用", "1K作为它的页面的大小", "那这个时候你会有多少个页面", "2的64次方", "页的大小是2的10次方", "那就是2的54次方个页面", "2的54次方个页面", "如果每一个页表项占64位的地址", "光地址的话那就是8 8 64", "那就要占8个字节", "那这样的话你的一个页表项", "至少是8个字节", "好 实际上如果再加上标志位", "它仍然是不够的", "假定它就是8个", "那这时候2的54次方", "每一个占8字节 那", "就是2的57次方", "那2的57次方的存储区域来存你的页表", "这个空间也是足够大的", "好 那针对这种页表引入的好处之外", "它又带来的麻烦", "这些麻烦我们怎么处理呢", "那这是给出的两种做法", "第一种呢是缓存", "那由于我们在程序执行的时候", "访问的数据 访问的代码", "它都具有一定的相邻性", "我访问执行一条指令", "我接下来执行的是它的下一条指令", "我访问数组的第一个元素", "我接下来可能访问是它第二个元素", "这时候它们可能都会在一页里头", "这种可能性比较大", "好 这样一来的话", "把你得到的页表项缓存下来", "我下一次的时候利用这缓存", "极大的可能性", "我是可以直接访问到物理内存的", "这样的话 就可以把你的", "这个访问次数减下来", "第二个是说我的页表很大", "一个很长的表 那很麻烦", "那我们对付这种长的问题", "的做法是什么呢", "我把它切段 好 间接访问", "先找它是在哪个子表里头", "然后在子表里再去找", "好 这就是我们说的间接访问", "这种间接访问", "对应过来呢就是多级页表", "那我们下面呢", "会深入再讨论快表和多级页表"]}, {"name": "", "block_id": "169d50a5219549cb8d582c74f8de7689", "text": ["下面我们讨论虚拟文件系统", "虚拟文件系统的提出", "是为了面对 我们有多种", "不同的文件系统", "而在操作系统当中", "它又希望对上提供一个统一的接口", "这种问题所提出的", "这就涉及到我们这里说到的", "文件系统的实现", "它在这里采用一种分层的结构", "这中间为了把上边抹平 弄成一致的", "在这加了一个虚拟文件系统", "它使得文件系统对上层应用", "提供统一的文件访问", "和文件系统控制的系统调用接口", "然后中间呢 维护各种文件系统所共同的", "一些数据结构和常用的操作算法", "然后下边呢 来对各种不同的", "实际的文件系统", "提供相应的访问接口", "这就是我们这里说到的", "虚拟文件系统", "那么在虚拟文件系统里头", "它的目标是 要针对所有的", "不同的文件系统给出一个抽象", "在这里头 具体要提供的", "功能有这样几个", "一个是 对上提供相同的文件", "和文件系统的访问接口", "然后在它内部 维护所有文件", "和文件系统相关的数据结构", "这是各种文件系统统一的", "然后 在这里有一组高效的", "查询例程来完成对文件系统的遍历", "再往下呢 是对特定的文件系统模块", "提供相应的交互接口", "这是对下的", "有了这些之后 我们就希望能够", "把各种各样的文件系统统一到一起", "然后对上层用户提供统一的接口", "具体说起来 在文件系统里", "都有哪样一些基本的树状结构呢", "在这里我们说有三个", "一个是文件卷控制块", "就是我们通常所说的超级块", "它里头是每个文件系统", "对应着有一个文件卷控制块", "里头描述了这个文件系统的详细信息", "比如说它的数据块有多大", "有多少数据块已经分配出去了", "还有多少是空闲的", "相应的共享等等这些引用的计数", "第二个是文件控制块", "通常也是我们所说的索引节点", "或者叫inode 说的都是它", "每一个文件有一个文件控制块", "在里头描述了这个文件的详细信息", "比如说这个文件的访问权限 拥有者", "大小 和数据块所在的位置", "等等这样一些信息", "再有一个是目录项", "目录里头是由目录项组成的", "每个目录项对应着一个子目录", "或者说一个文件", "然后所有这些目录项的数据结构", "和树状的分层结构", "形成了文件系统的数据结构", "然后在这里主要维护的是", "每一个目录项所对应的文件控制块在哪", "它的父目录 子目录分别在哪", "这样的话就形成了我们这里的", "树状的数据结构了", "有了这些基本的数据结构之后呢", "我们就可以看到这样一张", "文件系统的组织结构", "文件卷控制块 到每一个目录项", "这些目录项呢", "组织成一个树状结构", "树状结构里的再往下一层呢", "是每一个文件", "它的文件控制块", "文件控制块知道它实际的", "文件里头的数据块", "这是构成了", "我们这个文件系统里的组织视图", "在这种视图的情况下", "我们就要去来讨论它的存储", "先说 我们这里有的东西是", "卷控制块 是每个文件系统一个", "然后文件控制块 是每个文件一个", "目录项或者叫目录节点", "是每个文件或者目录对应着有一个", "这些东西 都是要存到你的", "磁盘上的数据块当中", "有了这一条之后", "当你需要加载的时候", "我们把相应的内容加载在内存里头", "它分别在什么时候加载的呢", "卷控制块 它的内容是在", "文件系统挂载的时候", "把它加载到内存", "而文件控制块", "是在访问相应文件的时候", "加载到内存", "因为你需要访问文件 就必须知道", "它都在哪些位置", "那这时候就把这些内容加载到内存", "而目录项呢", "它没有一个统一的时间", "你在遍历要找某一个文件的时候", "它会遍历 从根目录到相应文件的路径", "那这个遍历的时候", "遇着的 就把这些目录项", "都加载到内存当中", "有了这样一个过程之后", "我们就可以看到文件系统的存储结构", "首先我们看到 这是我们的磁盘", "上边都是 一个一个的基本的数据块单位", "这是我们上边刚才画的组织视图", "卷控制块 在这里头", "卷控制块的位置是固定的", "卷控制块指向下边", "是每一个目录的目录项", "这构成中间这一段", "目录项里头对应的可能是下一级目录", "或者说是文件", "对应到文件的话", "那么这就是文件控制块", "那就是这一段", "文件控制块里说明了", "每一个文件所在的位置", "那这就是 再往下的一层", "这是我整个磁盘的存储视图", "有了这个视图之后呢", "我们就能知道 我们在虚拟文件系统里头", "需要保存的各个文件系统", "公共的一些信息都是些什么", "从而也就通过虚拟文件系统", "把各种实际的文件系统", "和应用之间的间距给弥补上了", "从而我们可以通过一个统一的接口", "访问各种各样的实际的文件系统"]}, {"name": "", "block_id": "5c646027462c4df6a2965861e7e0abb9", "text": ["我们前面讲了", "这个页异常要干的事情", "我们再看看 我们重点考虑说", "我们要实现页替换算法了", "因为在do_pgfault里面", "还是把这个整个机制给实现完毕", "但是你要完成这个页替换算法", "那你还需要考虑一些问题", "对于我们原理课讲的时候", "比较简单一点是说", "我们根据某种策略来选择某一个页", "把它换出去 到这儿ok了", "那落到我们具体的", "操作系统里面呢", "你会去考虑以下一些问题", "第一个问题应该换出哪个页", "那么这个应该换出", "这是一个策略问题 那实际上", "是和我们页替换算法是紧密相连的", "但是在做这一步的时候", "你还需要考虑很多问题", "比如说你怎么来建立虚拟页", "和磁盘扇区的对应关系", "我前面说到了", "知道一个页出错了", "那么怎么知道它在硬盘什么地方", "你要把这个对应关系给建立起来", "你还需要什么呢", "还需要知道何时进行换入换出", "是主动地要把一些页换出去", "还是说是被动地", "产生了内存不够之后", "才开始换入换出的这个操作", "这是换入换出操作的一个实际问题", "以及你要设计什么样的数据结构", "来支持页替换算法", "这一点很重要的", "就是我们希望大家在做实验的时候", "就可以设计不同的页替换算法", "但是呢对我们上层OS", "其它部分的实现呢没有影响", "这里面就用到了", "我们在lab0里面讲到的", "要设计一套函数指针的一个链表", "只要把这些函数实现完之后", "它接口没变", "虽然它的实现可以有千变万化的", "一些不同的算法实现", "但是它接口不变", "从而可以灵活地通过ucore", "来实现不同的页替换算法", "所以要设计一个比较通用的", "抽象度比较高的一个数据结构", "来支持我们不同类型的页替换算法", "这一块已经做好了", "大家可以在这基础之上", "来完成我们说的", "我们的实验需要FIFO这个页替换算法", "最后怎么来进行页面的换入换出", "其实就是说你要去完成这个读写", "对disk读写 这是说你要能够实现", "让这个页替换算法", "能够在这个ucore里面正常工作", "需要考虑的一系列问题", "我们可以逐一去解决", "第一个问题就是", "你要考虑你那个页替换的算法", "这个页替换算法它的一个框架", "实现在swap.c里面", "你看swap.c和swap.h", "那么这里面定义了一个数据结构", "一个函数指针的列表", "这里面是相当于", "把页替换框架给实现了", "那内核其它部分呢", "只需要用框架里面的函数就OK了", "那具体的页替换的算法的", "具体的实现呢", "可以放在另外一个地方", "比如说对我们这个实验来说", "可以写一个文件叫", "swap_fifo.c和swap_fifo.h", "在这里面填写你的算法", "这些算法的名字是和我们swap.c里面", "swap_manager定义的函数指针", "是一致就OK了", "这是说你要在哪实现这些问题", "然后假设实现好之后呢", "我们会有一套检测机制check_swap", "来看你这个实现是否对", "就是说你那个语义", "FIFO那个语义就是我们页替换算法", "那个语义能否正确的完成", "我们这儿有一个check", "好 另一方面呢", "我们也提到你怎么去建立虚拟页", "和磁盘扇区的对应关系", "我怎么知道一个页和一个disk", "到底什么样的关系", "这个关系怎么建立 大家想一想", "放在哪建立比较合适", "其实我们这里呢用到了什么呢", "用到了swap_entry_t", "来代表这么一个对应关系的一个建立", "比如说这里面它有一个24个bit", "这个offset来代表磁盘扇区的一个编号", "那磁盘扇区的编号可以用这个来表示", "那虚拟页的编号在哪表示呢", "其实很简单 它和我们的页表是一样的", "靠那个页表里面的index 来表示虚拟页号", "那既然用页表里面的index", "来表示虚拟页号 那也意味着我们可以", "把这个磁盘扇区这个offset", "其实可以写到页表项里面去", "那页表项其实多了一个功能", "我们以前说页表项完成了什么呢", "完成的是虚拟页和物理页帧的", "一个对应关系", "是放在我们这个页表项里面的", "那一旦说我们把这个页表项", "换了一个功能", "它是虚拟页和我们磁盘扇区的", "一个对应关系也可以放这里面", "那怎么能够保证一个页表项", "同时具有两个功能呢", "其实同时是不可能的", "只能是在不同情况下它有不同的含义", "什么情况呢", "如果它那个present位这就需要知道", "我们页表项里面有一系列的bit", "这个bit有特定的含义", "比如它有个P位叫present位", "这个位如果是0", "代表这个映射关系没有", "也意味着不存在一个虚拟页", "和一个物理页帧的对应关系", "因为它的present位是0", "既然在这种情况下", "我们不需要去用这个页表项来表示", "表示这个虚拟页", "和物理页帧的对应关系", "那我们可以用这个表项来表示什么呢", "虚拟页和我们的硬盘扇区的对应关系", "其实这是 正好是根据这个bit的", "0和1来区分它到底表示什么含义的", "那同时我们节省了空间", "这种方式就可以有效地来完成", "虚拟页和磁盘扇区对应关系的一个建立", "那我们知道swap_entry_t它的一个结构之后", "我们可以进一步了解到", "这个每一个swap_entry_t是表明了", "一个虚拟页和一个所谓的这个", "我们的磁盘的扇区的一个映射关系", "那这地方是放在哪呢 是放在PTE里面的", "那我们要用好这个宏 swap_offset之后", "就可以有效地从一个PTE里面", "PTE是什么呢 Page Table Entry", "就是页表项", "从页表项里面把对应的那个", "swap_entry_t取出来", "从而可以知道我们这个硬盘扇区", "的位置在什么地方", "它的一个索引值就知道了", "从而可以正确完成", "对这个硬盘数据的读或者写操作", "那我们其实可以进一步扩展开来", "我们页替换算法其实还有很多种", "我们讲原理课的时候除了FIFO之外", "还讲了clock算法enhanced clock算法等等", "那其实基于我们刚才讲的这个呢", "也可以在此基础上", "来实现clock和enhanced clock这个算法", "大家可以去尝试一下", "作为我们的challenge练习", "可以去尝试一下", "需要注意的是你要用这种算法呢", "你可能还需要考虑很重要的", "一些时间相关的一些因素", "怎么能够在ucore里面进行记录", "这一点需要大家去在课后", "再去仔细想一想", "好 假定我们设计好这个页替换算法", "那其实页替换算法", "大家想一想页替换算法", "只是考虑了什么 只是考虑了", "我要把哪一页换出去是吧", "那么这是页替换算法要考虑的问题", "什么时候触发这个事情呢", "我们要考虑换出 触发的事情", "那其实大家想一想 我们的ucore", "在执行什么操作的时候会出现这种", "会触发页替换算法", "去执行把某一页换出去呢", "其实就和我们前面讲到的", "动态分配内存相关", "如果要去分配一个虚拟页 这时候呢", "我们的页替换算法发现说页不够了", "那我们就需要把某一页换出去", "这时候会触发页替换算法", "所以说这是一种", "被动的页替换算法策略", "它属于产生某一个", "内存分配一个请求之后", "发现内存不够了", "我们才去被动地去完成这个", "把某一个不采用的页给换出去", "这么一个操作 这是换出", "但是页替换算法", "还没有解决的问题是换入 是吧", "那换入在哪出现呢", "换入其实应该是在我们刚才说的", "page fault的时候会出现", "就是当我访问某一个页", "这个页是合法的页", "但是它又不在内存中的时候", "这个时候就会触发换入操作", "这一块呢是跟我们换入操作相关", "那么我们的换入换出结合在一起", "才形成一个完整的虚存管理系统", "那我们知道这个页替换算法", "其实需要用到一些", "我们ucore里面的一些支持", "包含数据结构 有两个重要结构", "大家需要注意在做的时候", "第一结构是什么 page", "这个结构其实在我们lab2里面", "管理物理内存页的时候", "其实已经用到了 在这里面一开始", "就用来管理物理内存页的", "我们放在lab3里面", "其实它还有很重要的作用", "就是把这个空闲页给管理起来", "从而可以知道", "当前剩下多少空闲物理页", "是否当前空闲页已经没有了 还是有", "那么专门有一个这个page_link你需要注意", "它这里面会用来链接这个空闲页", "如果说我们需要换入的时候", "从这里面去找出来一个页去换入", "如果说空闲页没了", "那我们就要把某一个页给换出去", "那把某一个页换出去", "其实是它这个页替换算法的一个实现", "我们这里面是放在", "swap fifo里面来实现的", "这里面刚才已经提到了", "这里面为了更好的理解这里面各个函数", "到底要完成什么样的功能", "建议大家读一读这里面的注释", "以及对这个结构", "特别是说到的swap_manager这几个结构", "这个结构里每一个函数指针", "到底要干什么事情 有更清楚的理解", "我们这里面说要把某一页换出去", "最终是通过这儿来完成一个", "策略的选择 到底要换哪个页", "对于FIFO来说", "它就是最早进入那个页就要被换出去", "OK 什么是最早 就是靠我们", "刚才我们说page里面那个list", "来找到最早这个页", "最早放进去那个list里面的那个node", "那一项那就是我们要换出去的", "所以说这个呢我们这个函数的实现", "swap_out_victim这一块就是要找到那个页", "就要从哪找呢就刚才我说的page", "形成一个list里面找出来", "当大家如果完成了这个实验之后呢", "如果是一个正确的实现可以看到", "这么一个类似这样的一个输出", "我把这个输出给大家简单解释一下", "刚才说有一个vma的一个check", "这里面就是如果", "vma和mm结构设置好之后呢", "这个check是可以成功的", "如果你这个do_pgfault", "能基本完成工作的话", "那么当有一次缺页异常产生之后呢", "那我们这个do_pgfault会分配一个页", "从而可以使得do_pgfault", "这个功能能够完成", "把合法的虚拟地址和一个物理地址", "建立对应的映射关系", "从而可以让这一块check_pgfault能够成功", "然后再接下来会完成什么", "就是说的关于页替换算法这一块", "那么它会建立好一个FIFO的", "一个页替换算法", "这里面是需要大家去实现相应的一个", "我们说swap_fifo.c和swap_fifo.h里面", "完成相应的工作", "然后会建立一个环境 建立好环境之后", "它会进行一系列的测试", "这些输出是在do_pgfault里面实现的", "就是说你可以知道", "当产生一个异常之后 到底是什么原因", "这是什么原因", "在什么地址出现这种页访问异常", "那从而可以知道出了这个问题", "你要去做相应的一些什么样的操作", "如果说是你实现正确的FIFO", "这个check的话 那么你这个顺序", "我们说我们把刚才说的具体数字呢", "用一种我们说字母来表示ABCDE", "这么一个顺序", "跟我们这个做原理课里面提到的序列", "页的序列是一样的", "这个序列如果产生之后应该是", "有一个在哪一时刻产生缺页", "以及缺页的次数是确定的", "接下来是做一系列的探测", "看是否是这么一回事", "从而如果这些所有探测都过了之后", "那我们说你这个check_swap是成功的", "这就是对结果的一个简单的描述", "大家可以去仔细看一下这几个函数", "check_swap  check_pgfault  check_vmm", "这几个函数具体的测了什么东西", "从而可以指导你们", "来完成各自的实现的细节", "好 那我们把lab3这一块呢", "给大家做了一个简要的介绍", "希望大家能够结合视频", "结合我们的实验指导书", "来完成lab3的实验", "祝大家实验顺利 好 谢谢"]}, {"name": "", "block_id": "3107fe6968994d9e9380ada2817fef19", "text": ["各位同学大家好", "今天我们来开始介绍置换算法", "那在置换算法这一部分里头呢", "我们分成这样三部分来讨论", "首先是置换算法的概念", "也就是说置换算法", "到底是干什么的", "然后接下来两个部分是", "两种类型的置换算法", "局部置换算法是说我", "假定分配给一个物理页面数", "已经定了之后", "然后我去选择到底哪个被置换", "而全局置换算法", "是不区分置换的这个页面", "到底属于哪个进程 这样的话", "隐含着后边有每个进程", "分配的物理页面数", "也会做调整的这样一种情况", "好 那我们接下来一个一个的说", "置换算法是干什么的呢", "置换算法是说我们在", "虚拟存储系统当中", "出现缺页的时候", "我需要把一个新的页面", "换到内存当中来 换入", "但这时候内存当中的页面", "已经全部都用完了", "那这时候我必须选择一个页面", "把它放到外存当中去", "那我新要用的页面才能放进来", "置换算法的功能就是", "选择被置换的物理页面", "你到底选择哪一个", "那你说我选择的时候", "我怎么来选择呢", "那选择有它的依据", "那这时候就是我们在这里头", "你的依据到底是啥", "这就是置换算法的设计目标", "那在这里头呢", "我们想要来设计一种置换算法", "它的目标呢 是说我希望尽可能的", "减少页面的调入和调出的次数", "那要想让你这个调入调出的次数", "实际上这个时候", "跟你实际运行的那个程序", "对存储访问的特征", "是有密切关系的", "好 那这时候我希望能够了解", "程序在执行的过程当中", "它的内存的访问特征", "然后我来设计这个置换算法", "那这样一来", "你得是针对", "每一个应用程序来设计吗", "那不是这样的", "我在操作系统没办法这么做", "我只能是设计一个置换算法", "然后考虑到它可能运行环境的", "这一系列的进程的访问特征", "然后从里头找出", "适用面比较广的这种情况", "那具体说起来呢 我们希望是这样的", "把未来不再访问", "或者说近期不再访问的", "这些页面调出去", "那这一条实际上很大的麻烦", "是在于我如何能知道这一点", "我如何能对未来的情况做一个估计", "而这是我们在设计置换算法的时候", "考虑最多的一些因素", "好 在具体讨论我如何来做这种选择", "如何来设计置换算法之前呢", "还有一个小问题需要在这先说一下", "就是页面锁定", "这个是虚拟存储当中的一个概念", "说我在进行置换的时候", "有一些页面", "你是不可以把它换到外存里头的", "那这种情况呢 通常情况下是说", "我有一些必须在内存里头的", "重要的这些逻辑页面", "这时候你比如说", "操作系统里头的关键代码", "然后还有一些呢", "它并不一定是操作系统里的关键代码", "但是它要求响应速度比较快", "你要是说访问的那页在外存里头", "那这个性能下降是它接受不了的", "好 这些代码我也放在这里头", "好 我们怎么来做到这一点呢", "实际上在虚拟页式里头", "它就在页表里的页表项", "相应的页面上加一个锁定标志", "有了这个标志之后", "置换算法在运行的过程当中就", "不会把这个页面放在外存里面去", "那在具体讨论之前呢", "我们还有一个问题需要大家讨论", "那就是我设计了一种置换算法", "你设计一种 到底我们俩谁算好", "那这种好 实际上在这", "是通过统计测试用例", "的形式来给出来的", "那在这我们为了后续讨论方便", "我们需要给出一些约定", "也就是说我怎么知道", "一个进程的访问内存的序列呢", "我就是记录它访问", "所有存储单元的这个轨迹", "然后那你比如说这里头", "我们通常情况下", "访问页面的时候是页号 页内偏移", "那在我们这里头呢", "我们关心的是访问的是哪一页", "实际上一页内部", "到底是哪一个存储单元", "这时候是我们不太关心的", "好 我们在这页号 页内偏移", "我得到这个序列", "然后我把页内偏移都去掉", "做简化就变成了底下这个序列了", "好 为了我们在后边说置换算法的时候", "说起来方便", "我们在这里头又给它换了一种表示", "用字母来表示", "这样避免和我们的顺序的1 2 3 4搞混了", "好 有了这个之后", "那这时候哪种算法比较好呢", "那我们的评价标准是", "模拟置换算法的行为 然后记录", "在这个置换的过程当中", "各个算法到底有多少次缺页", "少的就是好的 那有了这两条之后", "我们大概就可以开始", "来讨论置换算法了", "那在讨论之前呢", "我们还是首先把置换算法做一个分类", "因为你要界定你在讨论", "置换算法的时候能够借用的外界条件", "那在这里头呢", "按照借用的外界条件的不同", "我们分成两类", "一类叫做局部置换算法", "那在局部置换算法里头呢", "分配给一个进程的物理页面数", "是已经确定了", "那我们在置换的时候", "选择的范围仅限于当前进程", "有了这一条之后", "那也就相当于我在置换的过程当中", "每个进程分配的", "页面的总数是不会变化的", "那这里头呢", "我们有一系列的算法 最优算法", "也就是说如果我能预测未来的话", "我依据未来来决定我换哪个页面", "这个是理论上的最好状态", "没有算法比它更好", "但是它的问题是", "这个算法你在实际用的时候", "你没办法知道", "它所依赖的那个前提条件", "就是未来什么时候会用到这个页面", "第二个呢 是先进先出", "这个算法是说用最简单的办法", "我不知道它未来是啥情况", "我就按照进来的时候的先后顺序", "但是这个进来的先后顺序呢", "并不一定反映了", "实际的存储的访问特征", "好 那这样的话", "这个算法的性能不好", "再有一个就是", "最近最久未使用算法", "那它实际上是在这里头呢", "这个算法先进先出太差", "最优算法没法实现", "因为你是预测未来没法实现", "好 那在这最近最久未使用算法", "就是我把预测未来", "变成是我统计过去", "在过去一段时间的特征", "我们通常情况下认为你过去的特征", "对你未来是一种预测", "好 我们基于这样一种假设前提呢", "来讨论最近最久未使用算法", "但是这种算法呢 它可能实现", "但是仍然它的复杂度比较高", "好 那这时候呢", "就由它的这两种近似算法", "我们这会说到", "时钟算法和最不常用算法", "那这都是对最近最久", "未使用算法的一种近似", "那具体的近似的做法呢", "我们在后边再详细去说", "这是一类 也就是相当于", "我在当前进程暂用的页面里", "来讨论我换谁", "还有一类算法呢", "叫全局置换算法", "它不关心你当前换的这个页面", "属于哪个进程", "它讨论的范围是说置换的范围", "是在所有可能换出的物理页面", "它不管是哪个进程的", "这隐含着 如果说我在置换的时候", "是进程A的一个需要访问的页面", "被置换出去那是进程B的", "实际上这时候就隐含了", "这两个进程之间分配的", "物理页面数的一个变化", "好 这时候呢 它也有两种算法", "我们在这会说到", "工作集算法和缺页率算法", "好 有了这样一个大致分类之后", "我们就先按照局部置换算法和", "全局置换算法的顺序", "来一个一个的进行讨论"]}, {"name": "", "block_id": "f586885e2699414b9bc047ca94cea56b", "text": ["最后我们讲一下关于ucore编程里面", "常用的一些编程的方法", "让大家能够熟悉ucore编程的技巧", "这里面主要强调一些", "关于面向对象编程和通用数据结构的设计", "那么ucore虽然是基于C语言开发的", "但是它确实也产生了一些", "面向对象一些编程手段 比如说在这里面", "我们建立一个所谓物理内存的管理器", "那叫pmm_manager", "这个管理器它有很多一些函数的实现", "它的表示是用函数指针的方式来实现", "实际上对外暴露给需要访问物理内存管理器这些", "调动者一个统一的接口 这个接口不会改变", "但是你如果有不同的物理内存管理方法", "比如说有不同连续内存的分配方法", "那我们可以保持同样接口 但是它实现不一样", "这个带来所谓统一的interface", "但是它Details的实现不一样", "面向对象设计的原则", "我们来看看一般应用程序", "怎么来用双向循环链表的", "比如这么一个数据结构", "这个数据结构需要通过双向链表形式", "把它链接在一起 它有一个元素data", "同时它也有一个prev前一个指针和next下一个指针", "那么就形成了这么一个双向循环的链表", "当然这种方式确实在应用程序开发里面常见", "我们需要针对每一种特定的数据结构", "都要建立类似的数据结构", "这使得建立起来的数据结构不具有通用性", "我们有没有更好的办法", "我们以ucore双向链表结构来展示一下", "我们定义一个通用的双向链表比如叫list_entry", "这个也一样 你看到刚刚才类似Prev和next", "但是这个Prev和next并不是特定结构的指针", "它是一个通用结构指针 都是list_entry", "假设我们想建立这么一个双向链表结构", "它包含了free_area和page两种不同类型的strust", "那我怎么来用这种方式来建立呢", "我们先看free_area结构 free_area里面包含了两块", "一块是free_list这free_list就是一个list_entry", "第二个它中间的元素叫nr_free", "这是一个特定一个它的元素", "那么free_list就是这么一个数据结构", "就是list_entry_t这么一个结构", "你可以看到这里面就包含了两个指针", "那么怎么跟page连接在一起呢 我们来看看", "我们把page这个结构也是这么定义的", "它自己一些比如reference", "其它一些自己特定域在里面 成员变量在里面", "但是它最后一个page_link", "page_link也是一样也是list_entry数据结构", "有了这两个之后 这个page_link", "和free_list可以建立相应的链接关系", "就通过prev和next来建立双向链接关系", "这里面即满足了不同类型数据结构的", "它们特定一些成员变量一些表示", "而且在设计链接关系的时候", "用的是一种通用的一种结构来表示", "这是通用的双向链表的表示方式", "应该说在我们ucore里面大量存在", "这种方式大量存在", "有了这种方式之后我们可以更灵活", "更简洁来表示不同的资源", "以及资源之间的关系", "有了这个链表数据结构之后", "我们还有相应对它进行操作的函数", "这个函数的操作和我们通常链表操作差不多", "有初始化 有增加删除等等", "这都是不同函数的表示", "其实还需要很重要一点", "就是在于你怎么能够根据free_list的", "或者说根据刚才说的page_link", "它的结构能够找到它对应", "整个数据结构起始位置", "这个实际上有一定技巧", "在这里面我们可以看看一个例子", "怎么去访问链表的结点所在处的宿主数据结构", "那这里面也有一样有free_area刚才说的变量", "我们希望能够去以这个为头节点来查找", "所有的free_area管理的page这么一个数据结构", "那么它列出它一个方式", "在这里面看起来和通常的轮巡方式是差不多", "有一点不一样 需要注意在哪", "它用到一个特殊的宏叫le2page这么一个结构", "通过le2page来找到某一个page结构", "变量的头指针在什么地方", "这是它一个有特点的地方", "那么le2page怎么实现的", "这实际上是我们关心的", "le2page它里面包含了两块", "一个是指针 一个是member", "这个指针是链表节点所在数据结构的指针", "Member是它的名字 比如说在这里面", "page这个结构里面它是叫做pagerank这两块", "然后它是由另一个宏来执行的", "就是to_struct 里面包含了三个内容", "一个是le 一个是page 一个是member", "这个page怎么体现 就是这个里面le2page", "可以看出来它对一个特定的数据结构", "那么它需要一个特定的结构在这里体现", "那么这个结构到底怎么用 我们可以看到", "那么to_struct又是这三块进一步的展开", "这里面是等于这个链表节点的地址", "减去一个offset这个offset是什么呢", "就是减去它之前以page为例 它处于这个位置", "前面的一个偏移值 它减去之后呢", "实际上得到了 宿主数据结构头指针的一个信息", "这就是offsetof 包含了一个type一个member", "Type就是page member就是pagerank", "这offsetof又是什么呢 这个表达式比较特殊", "可以看出来 type*0 这个0代表什么意思呢", "它不代表具体的一个地址", "而是和在一起代表这种类型的", "一个成员变量一个member成员变量", "在这个类型中的一个偏移值", "整个代表这么一个含义", "那么有了这个含义之后", "我就可以把这个offset得到一个偏移值之后呢", "把ptr的地址减去那个偏移值", "一个指针操作就可以得到这个page", "数据结构的一个特定宿主变量它的地址在什么地方", "那这个le2page这个宏呢", "用到了三部分的内容 第一部分", "是宿主数据结构的链表节点的指针就是le", "第二个呢这个数据结构本身这个page这是第二块", "第三块是这个链表所对应的这个成员变量的", "名字叫member 有了这三个信息之后呢", "最后通过关键的一种表达式 这么一种表达式", "得出这个member 在这个数据结构中的offset", "然后把这个节点的这个地址减去offset", "就得到了这个宿主数据结构", "所对应变量的头指针的地址", "这就是它的大致结构", "知道了这个之后呢后面就可以", "用这种le2page等等 来完成", "对特定数据结构的头指针一个寻址的的过程", "这实际上是我们说 这个实验环境", "重点需要大家去掌握的内容", "好这部分内容就到这为止 谢谢大家"]}, {"name": "", "block_id": "44c958f61da4407eb90c47c23466219e", "text": ["下面来我们来讨论", "空闲空间的管理", "有了前面的文件分区", "空闲空间的管理呢", "相对来说就变得更容易了", "原因在于 这地方我们", "不需要记录它的顺序", "只需要记录和跟踪文件卷当中", "未分配的数据块的分布情况", "当然在这里头呢它也会有", "跟前面的文件分配不一样的地方", "那就是这个里头内容呢", "随着文件的创建和删除", "它的状态是随时发生变化的", "我们在这里 有些什么样的", "办法来说这事呢", "我们需要考虑的问题是", "我用什么样的数据结构", "来表示空闲空间的这个列表", "我们首先看到第一种呢是位图", "每一个块占一位", "然后所有的块", "对应到所有位放到一起", "就构成一个空闲数据块的列表", "在这个列表里头呢", "零表示对应的数据块i", "比如说Di等于0", "表示数据块i是空闲的", "否则呢就表示这一块", "已经分配出去了", "用这种办法之后呢", "我们看到 如果说你的", "文件分区很大的话", "那么这时候呢", "这个向量表占的空间也是很大的", "这地方给出一个例子是说", "我有一个160GB的磁盘", "然后我4KB为一块", "那这样的话", "2的30次方乘以160", "然后我4K 2的12次方为一块", "那这样的话我有40兆数据块", "如果说我在这里头呢", "每一个8位能表示8个数据块", "那就是5M字节的位图", "所占用的存储空间", "这个空间你是需要频繁进行修改的话", "那这时候呢它的修改量也是很大的", "与此同时说我们要想去", "找到磁盘上一个空闲块", "那我需要去查这个表", "在查的范围是什么样子呢", "假定空闲块的分布呢是均匀的", "那这时候我在找所需要花的时间呢", "基本上是说磁盘块的总数", "和空闲块的数目之间一个比", "你占的比例越高它越容易找着", "这是位图表示空闲空间的方法", "那同时呢也还有其他一些办法", "比如说像我们前面说到链表法", "我仍然可以用这种方式来表示", "每一个空闲块里头呢", "有一个指针指向下一块", "那这样的话我在这里呢很方便", "也能找到我的空闲块组织起来", "当然这种办法呢它的开销会比较大", "我们也可以把它", "跟其他办法组合到一块", "那就是这里的链式索引", "我最底下一层是用索引", "上边用链表", "这样的话既可以节省相应的空间", "又找起来不是很费事", "这是我们用来表示", "空闲空间的几种方法", "在实际系统里呢", "也是这几种方法组合起来使用的", "下面我们来讨论磁盘阵列", "冗余磁盘阵列raid实际上是一种", "提高文件系统可靠性", "和读写性能的一组技术", "通常情况下我们在访问磁盘的时候", "由于磁盘上有磁头的移动", "这是一种机械运动", "所以它的性能呢相对来说是比较慢的", "通常情况下这里头呢", "我们会通过磁盘分区", "来限制这个寻道的时间", "从而提高它的性能", "分区是一组柱面的集合", "比如说在这里头", "我们把一个磁盘上", "分成了A B两个分区", "那在每一个分区呢", "我们都可以视为逻辑上独立的一个磁盘", "但实际上它是没办法完全独立的", "比如说我在这里头", "我要是只在A分区上进行文件读写", "那么它的性能是会提高的", "但如果说你把这一个磁盘", "分成了A和B两个分区", "但是你的操作系统", "同时在两个分区上进行操作", "那么这时候呢在A B分区上进行切换", "它的性能呢是很差的", "这是一个呢典型的", "文件系统分区的做法", "我们在这儿呢介绍一个", "典型的磁盘文件系统的组织", "首先我们说一下文件卷", "和磁盘分区的关系", "文件卷是指拥有一个完整的", "文件系统实例的外存空间", "通常情况下它对应到", "我们磁盘上一个分区", "比如说在这里头", "我们把一号磁盘分成A和B两个分区", "每一个分区呢有一套自己的", "完整的文件系统实例", "它有目录 文件", "通常前面还有文件卷控制块", "还有一种做法呢是说", "我们也可以把多个磁盘合在一起", "变成一个逻辑的分区", "这些呢 它是可以扩大", "你的磁盘分区的容量", "以便于你能在一个分区里存更多的数据", "这些呢 都没有办法", "提高我们的读写性能和可靠性", "多分区管理呢 实际上就想", "利用多个独立的磁盘", "同时使用来提高它的性能", "也就说通过并行提高它的吞吐量", "然后来提高它的可靠性", "相当于是说我通过冗余", "你比如说数据存多份", "来提高它的可靠性和可用性", "具体说起来呢冗余磁盘阵列", "实际上raid是一组磁盘管理的技术", "它通过条带化 映像", "和带校验的条带化", "来实现对磁盘可靠性性能的提升", "这组技术的实现方法呢有两种", "一种我们可以做到", "操作系统文件系统里头", "通过文件系统的卷管理", "来实现上面说到这些", "冗余磁盘阵列的技术", "也可以呢用硬件来实现", "用硬件的raid控制器", "用这种控制器 实际上在你的操作系统", "感觉不到它的存在", "就像是用一个分区一样的", "下面我们来看这几种冗余磁盘阵列技术", "它所能带来的好处和它的具体做法", "第一种呢raid0它是一种磁盘条带化技术", "它通过把数据块分成若干个子块", "然后把这些子块存在独立的磁盘上", "注意这地方一定是要独立", "我在一个硬盘上", "把它分成多个逻辑分区是不起作用的", "通过这些独立硬盘上的并行数据块访问", "来提高磁盘的带宽", "我们看一下具体做法", "假定我这儿有三个磁盘", "然后在操作系统层面上", "看到一个数据块是这样的", "那我在存储的时候呢", "我把它分成三个子块", "这里一行是一块", "这是一个示意", "然后我把它存到这三个磁盘上", "这样的话我如果说是写数据", "那么我是三个磁盘同时写", "应该它的速度呢会提高接近它的三倍", "如果是读呢我可以从三个一块来读", "那这时候它速度也会提升三倍", "但如果说你读取的数据量小", "这时候你读三个", "但是我只要第一个里的数据", "那这时候它的速度是没有提升的", "这是第一种做法 raid0", "通过条带化来提高读写的磁盘带宽", "从而呢提高它的性能", "第二种做法呢是raid1 磁盘镜像", "它通过同时向两个磁盘", "写入相同的数据", "来提高它的可靠性", "当然你读取的时候呢", "可以从任何一个来读", "如果你读的数据可以同时从两个里读的话", "那么它的读性能呢也会提高一倍", "那它具体做法是什么呢", "那这里呢可以提高它的可靠性", "可靠性是成倍增加的", "而读性能呢它是线性增加的", "具体怎么做呢", "这有两个物理的硬盘", "我们把它划成分区", "然后把我数据呢", "同时存在这两个上头", "这时候写的性能呢是跟原来一样的", "然后读的性能呢是会提高的", "如果你读很多数据的话", "这是磁盘镜像 它的主要特征", "是提高可靠性", "然后接下来一个呢", "是带校验的磁盘条带化", "这是我们这里的raid4", "它的做法是", "把数据块做条带化", "并且加了一个校验磁盘", "这个校验磁盘呢", "专门用来存校验和", "这时候你的存储容量", "是没有条带化那么高的", "但是它的可靠性呢是提高了", "也就说N个磁盘的话", "它其中有一个错误的时候", "它是可以恢复过来的", "它允许任意一个故障磁盘出问题的时候", "它可以从里头能把数据完整恢复出来", "那它具体怎么做呢", "假定我这儿有五个磁盘", "那我用来存数据采用条带化呢是前面四个", "最后一个来存它的校验和", "在存校验和的时候呢", "我需要依据前面四个数据", "来算这个校验和", "这是我存的里头", "如果我读数据的时候", "我需要把它们全部一块读出来", "然后去判断它是否正确", "任何一个有错", "我可以从这里把它恢复回来", "这样的话就提高了它的可靠性", "也提高了它的读写性能", "当然这里的可靠性是说", "没有我们刚才这个镜像", "可靠性提高那么高", "那我在这里头N个磁盘里", "N分之一可能性它坏掉", "那我是能恢复的", "如果更多那它就不行了", "再有一个呢", "是带分布式校验的磁盘条带化", "这种做法呢和raid4相比呢", "它就是把校验和的存放位置 做了一个分布", "不是把校验和固定的存在校验磁盘上", "这样的做法呢", "可以把校验磁盘的访问瓶颈呢分摊开", "从而提高它的性能", "那我们看具体怎么做", "我们把每一个数据块分散到这5个磁盘上", "第一个X  它的校验和呢", "假定我们说它是在5号磁盘上", "最后一个", "然后下一个时候的呢", "它的校验和就不存在这5上了", "而是存在1上 这是第二个", "第三个时候呢", "我再放到第2个磁盘", "第四个时候呢再放到第3个（磁盘上）", "那这样的话", "我们在每次读写的时候呢", "这个校验和的这种依赖", "也就变得分散开去了", "从而这样的话就可以减少", "它对校验和所在那个磁盘的读写压力", "这是我们说到的几种Raid技术", "用来提高它的读写性能和它的可靠性", "这些技术呢我们都是基于数据块的", "实际上它也可以基于字节", "或者基于比特位", "这种做法呢 实际上相当于", "我们这里raid0 4 5", "就我们刚才说都是基于数据块的", "raid3呢是基于位的", "那这种做法它实际上区别在什么地方呢", "假定我有三个磁盘", "它做校验怎么办", "这是基于每一块里的", "每一位组合到一起来使用的", "当然现在我们在实际系统里", "用最多的还是基于数据块的", "这是基于字节和位的磁盘冗余技术", "我们还可以再进一步扩展", "raid5可以恢复一个磁盘的错误", "那如果有多个呢", "实际上我们在这里呢有raid6", "它增加了两个冗余块", "那这样的话我可以允许呢", "有两个磁盘出错的时候", "它也是可以恢复的", "这样的话就进一步提高它的可靠性", "当然这种可靠性到底提了多少", "要跟你数据重要性和", "你对可靠性的要求的不同而不同", "与此同时我们这些技术呢", "也允许把它嵌套到一起来使用", "比如说我们raid0是提高它的性能", "而raid1可以提高它的可靠性", "那这时候我是不是可以", "在提高性能的同时", "提高它的可靠性呢", "那这时候就把这两个组合起来", "那是raid0+1", "首先是两个磁盘之间做条带化", "这时候呢你往里读写的时候", "它的性能会提高", "然后在这基础上我再做一个磁盘镜像", "这一组和这一组之间做镜像", "那么这时候可靠性提高了", "当然我们在这里头呢", "以用这种办法来提高性能和可靠性", "它的成本也是大幅度增加的", "所以这是这上头呢", "再把它搁在一起变成raid1", "组合到一起是raid嵌套", "这个嵌套也可以反过来", "底下是raid1我先做镜像", "然后在这里头呢在上面再套一层raid0", "我往两个里头呢同时写", "这样的话也是可以起到类似的效果", "通过这一系列的技术呢", "我们可以在文件系统基础上", "来不断提高它的性能和可靠性", "这是我们今天说到的文件系统", "今天的课就上到这里  下课"]}, {"name": "", "block_id": "f976975303324e2db16e692a1ebaadde", "text": ["下面我们来讨论如何用前面的", "信号量和管程的方法", "来解决几个经典的同步问题", "这就是我们这里说到的", "哲学家就餐问题和读者写者问题", "首先我们来看哲学家就餐问题", "这个问题的描述是这样的", "有五位哲学家围坐在一个圆桌旁", "这是这五位哲学家", "他们编号分别为0到4", "然后桌子上呢放了5把刀叉", "每个哲学家之间呢有一个", "那这地方纯粹是为了我们在这里", "来讨论同步互斥而设置一种场景", "在这里头呢", "每个哲学家会进行思考", "或者就餐两种操作", "那思考呢不需要周围的资源", "而就餐呢 他需要拿到两个叉子", "他才可以开始就餐", "所以这时候呢", "两个哲学家之间", "会需要共享一把叉子", "那我们可以在这儿认为呢", "这个叉子是我在这里头", "两个哲学家之间的共享资源", "在思考的时候", "哲学家会把两把叉子都放回原处", "在他旁边的哲学家就可以用", "这个叉子来进行就餐了", "好 我的问题是我如何让", "这五个哲学家能够有序的进行", "他们想进行的操作", "也就说他思考的时候", "这时候随时可以进行", "不就餐的话", "他就可以在这里进行思考", "那关键问题是", "他想就餐的时候会怎么样", "如果说相邻的两个哲学家都想就餐", "那这时候呢", "他们就需要有一个人等待", "原因在于 这时候他们俩之间", "只有一个叉子", "这个叉子只能保证一个人用", "好 这时候我们说", "用什么办法我们能解决这些问题呢", "说我在这里首先想到的", "是用信号量的办法", "那信号量的办法我如何来解决呢", "那我们在这里做法呢", "第一个方案是说我每把叉子", "算是一个资源对应着一个信号量", "那它的初值是1", "好 然后说先有一个程序的框架", "五个哲学家", "每个哲学家的ID呢这里的i", "它可能是0到4", "它可以进行两种操作 思考和就餐", "我们在这里需要考虑", "主要部分是他就餐这一部分", "就餐的时候他需要拿到", "左边的刀叉和右边的刀叉", "那这时候我们说两个P操作", "来获得他左边和右边的叉子", "如果他能获得到他就会就餐", "等他吃完之后", "他释放两边的刀叉", "整个又回来 他可以又进行思考", "那这时候的问题是", "这个算法行吗", "那在多数情况下它是没问题的", "你比如说在这里头", "我先申请左边的刀叉", "那如果申请不到", "那我再去申请右边的刀叉", "如果两边申请到我就就餐", "如果申请到一个", "旁边这个人呢已经先拿取", "我的右边的刀叉", "对于他来说是左边", "好 那也时候呢", "我就会等着他就餐完毕之后", "他放下刀叉然后进行思考的时候", "我再拿起右边刀叉", "这时候我也可以开始就餐了", "但是在一种极端的情况下", "大家可以想象", "如果五个哲学家", "他们都在同一时间", "进行相同的动作", "这时候会出现什么情况", "大家一起拿左边的刀叉", "先假定在前面所有的刀叉", "都是放在那儿的", "好 大家一起拿左边刀叉", "然后这时候都拿到左边之后", "这时候五个哲学家", "每个人拿到一个刀叉", "都是左边的对于他们来说", "好 这时候他开始拿去拿右边这个", "那这时候会出现啥情况", "每个哲学家右边都没有了", "好 那按照刚才我们约定说", "这时候等着下一个用完了我再来用", "但实际上这时候呢", "每一个人都拿到了左边的刀叉", "没有拿到右边了", "而这时候所有人呢都开始等待", "那这时候会等出结果来吗", "没有任何一个人可以开始就餐", "那这样一来的话", "所有的人都是无限期等待下去", "好 那所以这时候出现什么问题", "这个算法是不正确的", "有可能进入死锁", "也就是五个人同时", "拿左边刀叉的时候", "那它就会进入死锁状态", "好 那这个不行我怎么改呢", "那这就是我们想到的第二种做法", "极端的做法", "因为实际上在我们系统里头", "我们希望把资源得到充分的利用", "一旦我没有办法做充分利用的时候", "我就把所有资源打成一个整包", "然后说只有一个进程", "可以占用这一整包的资源", "不管它是不是都需要", "那在这种情况下", "我这个系统也能正常的运行下去", "只是效率低一些就是了", "好 那我们想到是这种做法", "我设置一个互斥变量", "我任何一个时刻", "只有一个哲学家可以就餐", "那这事呢也变得可以能解决出来", "那在这儿也是这样的", "这是思考就餐", "我需要保护就餐这一段", "我用这个 mutex", "来作为这个互斥信号量", "好 在这个地方呢", "P操作和V操作 任何一个哲学家", "他只要是申请到这个互斥信号量", "也就是我们这里说二进制信号量", "好 那这时候呢它就可以进行就餐", "因为它的初值是1", "所以任何一个时刻", "只有一个哲学家能够", "获取到这个信号量", "然后他再去依次", "拿起左边和右边的刀叉", "那这时候它会碰到障碍吗", "不会 因为这五个信号量", "你只有在申请到了", "二进制信号量之后", "你才有可能来申请到", "刀叉的信号量", "而任何一个时刻呢", "我只有一个进程", "申请到二进制信号量", "好 那这时候呢", "后面这两个申请不会碰到问题", "好 他会就餐", "吃完之后他放下刀叉", "然后释放互斥信号量", "他继续上面的思考", "那从这种做法里头呢", "我们看到 这是能够保证", "大家顺序吃饭的", "但是我这时候的情况", "是我有五把刀叉", "按道理来说", "我可以给两个人一起吃", "因为总会剩一把刀叉在那儿放着", "而我们现在这里头呢", "我只要他一个人吃", "好 那这样话它的效率就降低了", "但是它是正确的", "这种做法呢我们认为它可以接受", "但是性能不好", "我们有没有更好的办法", "好 那这时候我们说", "再给出第三种解决方案", "我仍然是用五把刀叉", "但是我不会设一个全局的锁", "把整个就餐这事", "变成一个临界区的操作", "那我怎么办呢", "针对我们刚才说到的", "五个哲学家一起拿起左边的刀叉", "之后所面临的死锁的情况", "我让他们每个人", "拿刀叉的时候有差异", "不至于是所有的人", "全部都一起拿起左边的", "那这样一来的话就", "不会出现构成环路的情况", "那总会有先有后", "好 最后保证大家都能拿到", "那在通常情况下呢", "我可以两个人一起就餐", "那在这儿怎么做呢", "好 我在这儿设一个分支结构", "如果说根据每个人的编号不同", "我采取不同的动作", "偶数编号的", "我先拿左边后拿右边", "奇数的先拿右边后拿左边", "那这样一来的话", "就不会出现五个都拿到", "一部分资源构成环路这种情况", "好 那等他就餐完了之后", "我把刀叉放回去", "那这时候我有必要再在这个地方", "再把它分成两种情况吗", "实际上这个操作它是不会堵塞的", "所以你不用把它分成两种情况", "好 那么这时候说", "在这种情况下我可以", "两个哲学家同时就餐吗", "你比如说0号和2号", "假定这时候没有其他人的话", "那他们俩是可以的", "因为中间隔了一个哲学家", "好 那这时候他们俩", "都可以拿到相应的叉子", "他不断是正确的", "不会出现死锁", "并且允许 有可能的话", "两个人同时就餐", "这是我们在这里呢", "用信号量能给出的", "一种比较理想的办法", "那这时候问", "这种做法是不是最优的呢", "我是不是可以", "还想得出更好的办法呢", "这个呢留给大家", "下去之后进行思考"]}, {"name": "", "block_id": "0de7f6e1acc04fd4ad99305722214431", "text": ["练习六呢 主要是能够去", "建立中断向量表", "那这个相对来说复杂一点", "它需要知道向量表的这个细节", "就是一个中断向量表的一项", "到底应该是包含哪些中断描述符", "中断描述符到底是由哪些信息组成的", "可以看出来 在这里面呢", "跟中断相关的集中在这个地方", "我们说", "要让X86的中断系统能够正常工作", "那需要做几件事情", "这个事情 首先在初始化阶段能够看到", "pic_init 这是完成中断控制器的初始化", "这是一个外设", "是一个特殊的设备", "8259的一个中断控制器", "这里面有一些相关的细节", "这些细节也是主要是", "完成对8259一个管理和配制", "那么我们大致可以理解为", "把8259配置好之后", "相应的外设就能够产生中断", "并被CPU所接收和处理", "为接受后续的时钟中断打开一个基础", "那有了这个跟外设相关的", "中断控制器初始化完毕之后呢", "我们还需要让CPU建立好一个", "中断描述符表", "也或者简称为中断向量表", "那么中断描述符表呢", "就是这里面 叫IDT", "它的一个初始化过程", "那么IDT 我们在前面介绍基础知识的时候", "已经跟大家讲过", "就是80386这个中断描述符表的", "每一项代表什么意思", "这里面就把这个项建立好", "这里面这个索引", "这个中断描述符表可以理解为", "是一个大的数组", "每一个索引 能代表一个中断号", "当一个中断产生之后", "它会有对应这个中断号", "比如说时钟中断 它会有对应的中断号", "这个中断号会用来作为index", "来查IDT描述符表", "这个表里面对应index一项呢", "记录了当产生中断之后", "所要去应对中断服务例程的地址", "这个地址有两部分信息", "一部分是所谓段描述符", "或者叫段选择子", "第二部分是这个偏移", "可以根据段选择子中的内容", "来查找我们前面介绍过的段描述符", "段描述符存在什么地方呢", "段描述符存在全局描述符表中", "它一样 因为有了选择子这个index", "就可以基于这个index", "来查找段描述符", "查找段描述符之后 我们就知道", "这个有关这个中断服务例程的基址", "再加上它的offset", "就形成了中断服务例程的这个提示地址", "这个整个查找过程是由硬件完成的", "但是IDT这个表", "就中断描述符表", "和我们刚才说的全局描述符表", "是由我们软件来建立的", "这里面都是由uCore来建立的", "怎么能够让我们CPU知道说你建好这个表呢", "那这条特殊的指令", "比如LIDT  就是load idt", "就完成了对中断描述符表的加载", "从而使CPU知道中断描述符表在什么地方", "它就知道了", "这是它的一个起始地址", "当建立完这个8259", "这个中断控制器的初始化", "以及IDT中断描述符表初始化之后", "最后还需要一步 就是Enable中断", "就是使能中断 这个是在这儿", "叫intr enable", "如果说你某一个外设", "要想让它能够产生中断的话", "那么你对特定的外设也做相应的初始化", "所以说如果我们这里面", "是需要处理时钟中断的话", "那么时钟一个初始化过程也需要完成", "这里面呢 也是有很多跟外设相关的", "跟时钟外设相关的", "8253这个芯片相关的一些设置", "我们不用太追究细节", "可以大致理解为它每一百个tick", "会产生一次中断", "这里就是大致的一个介绍", "当完成了这个时钟外设的初始化之后呢", "有了这三步", "PIC  IDT  Clock这三步初始化", "那么我们就会使能中断", "使能中断就是一个很特殊的指令", "STI 这也是一条机器指令", "那么这条指令在什么地方呢", "STI其实也是一个内嵌汇编", "就是我们说的内联汇编", "ASM就是STI一条指令", "这条指令就完成了使能中断这么一个控制", "那么CLI呢", "实际上是另外一条指令", "就是屏蔽中断", "那其实有一个小问题", "一开始Bootloader启动的时候", "是处于中断使能", "还是中断是屏蔽的呢", "你怎么知道的呢", "这个问题大家可以考虑一下", "好 完成了这个中断向量表的初始化之后", "其实包括各种外设的初始化之后", "就可以产生中断了", "产生中断之后", "我们的中断服务例程怎么来响应它", "这个是需要进一步去完成的内容", "做实验内容需要去完成的", "那我们在这里面呢", "其实是在trap.c里面会有一个函数", "这个trap函数来接管", "但是比较有意思的一个问题是", "这个trap是中断服务例程的入口地址吗", "其实不是", "中断服务例程的入口地址", "在这个文件里面 叫vector.S", "这个汇编文件里面", "在这里面定义了255个中断号的", "所对应的起始地址", "当然我们这里面用不了这么多", "我们大致可以看着在前面有相应的一些处理", "那么它处理的入口", "都是叫__alltraps这个地方", "当产生64号中断的时候", "我们建立中断描述符表", "会使得我们CPU指针", "执行指令这个指针", "跳到EIP指到这个地方来", "vector64 这个地址", "会进一步跳到__alltraps里面", "__alltraps在trap entry里面", "这是__alltraps", "__alltraps会保存一系列的寄存器", "这里面就讲到了", "我们讲80386这个中断处理机制", "会讲到硬件产生中断之后会保存", "保存被打断的地址和它的flag寄存器等等", "但是它保存并不完整 那么为了能够", "回到被打断的地方重新执行呢", "我们需要确保", "环境能够完全恢复到跟以前一样", "所以我们把后续", "在执行中断服务例程中", "用到的寄存器的内容呢", "都要先保存起来", "以避免破坏返回去的那个环境", "这里面看到叫push DS ES等等", "这都是完成保存", "那这些保存信息都", "放在这个内核的中断站里面", "最后这里看到", "它这里面会有一个call trap", "那么这个call trap 实际上调用了一个函数", "这个函数实际上在trap.c里面", "就在这儿", "那么trap.c呢会进一步调trap dispatch", "那trap dispatch呢", "就会查找这个相应中断号", "如果说它发现是时钟中断", "这里面有这么一个标记", "时钟中断号需要注意这个", "加起来值就是32", "如果发现32", "它认为时钟中断会把这个ticks", "这是全局的变量", "把ticks做一个加操作", "如果ticks满了一定次数", "这里面设置的次数是100次吧", "那就会print一个ticks", "就打印出一个信息出来", "那这个信息出在什么地方呢", "这里很重要的结构", "就是trapframe 这个数据结构", "在这个结构里面 我们可以看到", "实际上它保存了被打断那一刻的", "很重要的寄存器的信息", "比如说下面这一段", "这一段是我们说到的", "是在这个硬件一旦产生中断之后", "我们硬件CPU会自动保存一些信息", "而接下来这些信息呢", "是我们的软件来保存的", "那么这一条信息是什么呢", "这条信息是考虑的是", "将来有可能出现从用户态产生中断", "会切换到内核态", "那么就会多保存一些信息", "就是ESP SS", "那么这条信息呢", "实际上是我们说", "如果出现不同特权级的转换", "比如说用户态产生中断之后", "会切到内核态", "那么这就出现一个特权级的转换", "那么它需要保存更多的一些信息", "要把用户态栈的信息给保存下来", "就保存这个地方", "以便于能够正确的恢复", "从内核态恢复到用户态去进一步执行", "对于X86而言", "用户态一般我们设置在特权级3", "而内核态设置在特权级0在这里面", "这是练习六大致的一个介绍", "扩展练习呢 其实是给一些", "觉得前面六个练习", "还觉得不够挑战的同学准备的", "主要是能够实现不同特权级的一个切换", "怎么能够通过中断机制", "来实现不同特权级的切换", "这里面重点就是要设置好", "返回到某一个特权级", "它所保存的信息", "保存那些寄存器的信息应该怎么设置", "这里面有很多小的细节", "如果有同学感兴趣的话可以进一步去学习", "那么我们就把练习一到扩展练习", "都给大家做了一个简单的介绍", "希望大家能够基于刚才介绍更好的完成实验", "有同学也说 这个一开始看代码量其实挺大的", "我们也给大家说到了", "就是关于每一个lab", "其实有一系列小的Project组成的", "如果大家比较好奇说", "想看到这个lab是怎么一步一步建立起来", "那么我们还可以查找相应的Project的信息", "我们也会在网上公布", "大家可以去看一看", "到底是如何一步一步的", "一个一个小的Project", "构成了一个大的lab", "然后最终形成一共8个lab", "那么它其实有几十个小的Project组成", "这是我们这个lab1的一个介绍", "好 谢谢大家"]}, {"name": "", "block_id": "4188600a7857498da1ecadc48cee40e8", "text": ["各位同学我们这次课主要讲的是", "操作系统的第二个实验", "关于物理内存的管理", "那我们原理课里面", "其实对这个内存管理做了很深入的讲解", "主要是说物理内存它的相关的一些细节", "比如说怎么去建立映射关系", "物理内存相应的一些它的作用等等", "给大家做了一个讲解", "那我们这里面是想结合实验让大家对", "这个物理内存有一个更深入的理解", "看看操作系统怎么来", "对物理内存进行有效的管理", "这里面有两个比较困难的地方", "第一个是关于特权级", "因为我们说操作系统加上我们的CPU", "给我们不同的应用程序提供一个隔离的空间", "这点需要有一个保护机制 那这是一个", "第二个我们的应用程序不能够随随便便的去", "访问我们的操作系统的空间", "这一点也是通过保护机制来实现的", "这里面有一个特权级这么一个概念", "我们希望通过lab2让大家能够知道", "操作系统怎么利用CPU的硬件机制来建立", "所谓的保护机制", "这是第一个特权级这一块给大家做一个讲解", "第二部分是关于内存管理单元", "X86的内存管理单元", "那我们这里面讲的更多的是基于X86的", "MMU 这个内存管理单元", "来看我们操作系统怎么利用", "这个MMU的功能来实现内存的映射", "这实际上就是说可以把", "我们的虚拟的连续地址空间", "映射到分散的离散的物理空间里面去", "这两者之间是有差别的", "那么这个差别是通过我们的X86内存管理单元", "在操作系统的管理之下来实现的", "那这两点需要大家能够理解", "所以我们这一讲主要是给大家讲一下", "硬件到底做了什么事情", "我们操作系统怎么利用", "这个相应的一些机制来完成这些功能", "从而可以实现操作系统物理内存的管理", "首先我们看一下X86的特权级", "那首先我们要知道就是这个硬件", "我们CPU到底提供了几种特权级", "然后我们的程序在跑的时候", "我们的CPU到底当前处于哪样特权级", "就是说你应用程序到底处于什么特权级", "你怎么知道的 你的应用程序是在内核态跑的", "还是在用户态跑的", "第三个我们说我们的应用程序跑在用户态", "但可能过了一会儿又跑到内核态", "我们操作系统在运行 那么这个来回的切换", "涉及到一个所谓的特权级的切换", "那这个切换过程怎么实现的", "这是我们说这一节里面要讲的内容", "就是X86特权级的一个问题", "好 那我们接下来看一下 第一个是了解特权级", "我们看一下X86特权级", "X86特权级你可以看到它有0 1 2 3", "四个特权级 其中内核是处于0特权级", "因为就是我们特权级最高的地方就在Level 0", "那么我们的应用程序一般是放在Level 3", "就是Applications 这个应用程序放在Level 3", "那么也意味着应用程序", "无法去破坏内核里面的代码或者数据", "但是它可以得到内核态代码的服务", "它可以得到它的服务", "同时看到还有Level 1 Level 2", "那么当时intel设计CPU的时候考虑比较灵活", "说我们还有其它一些应用", "也许需要更多的层级来做区分", "但其实在我们现在的", "操作系统设计里面一般来说", "只需要两级", "就是一个操作系统Kernel有一个级别", "一个是我们应用程序有一个级别", "就够了 基本上就够了", "所以说对于我们lab2这个实验来说", "它只需用Level 0和Level 3就够了", "一个是用来给我们操作系统ucore来跑的", "来访问数据和运行", "执行一些特权指令等等", "那么另外一个是我们应用程序", "它跑到Level 3 这是我们说X86特权级里面", "我们的操作系统怎么去利用的", "那对于我们常见的操作系统", "比如说Linux Windows等等", "基本上也都是用了0和3这两个级别就够了", "这是我们说X86特权级的一个情况", "那我们说有一些指令它只能在ring 0里面执行", "而这些指令是X86的一些特权指令", "那这些指令一般也是我们操作系统来完成的", "那我们应用程序", "如果它一开始运行在用户态的时候", "如果它要去执行这些特权指令", "比如我们说的修改页表 响应中断", "访问内核区域的数据的时候", "比如我们说访问数据段 访问页表", "还有访问中断服务例程去执行的时候", "那就会产生异常 我们前面讲到", "有中断 有异常 这是说的产生异常", "产生异常之后就会阻止你继续执行", "这是一种典型的保护机制", "那么它是靠我们操作系统会做一个设置", "在我们CPU这个硬件的管理之下来确保", "我们的一般的应用程序处在", "我们刚才说的处于ring 3", "属于一般的特权级的情况下", "它无法去访问ring 0下面的一些", "所可以使用的一些特权指令", "和对应的那些数据等等", "那前面我们看到CPU在很多情况下", "会做特权级检查 具体它怎么来做的", "我们需要进一步去了解一下细节", "接下来我们会接下来给大家介绍一下", "包括选择子以及后面的描述符", "怎么结合在一起来完成", "这一条指令执行的特权级检查", "那么为什么要这么做的呢", "我们其实很重要的一点就是", "我们在完成lab1 lab2以及后续的lab的时候", "经常会出现各种各样的错误", "而这些错误有一大部分情况", "是跟特权级相关的", "你如果理解了为什么会产生", "这些异常或者错误", "那么你就可以知道到底哪些地方你写错了", "所以说我们这边需要了解内部CPU", "是怎么来完成这个特权级检查的", "我们首先介绍个概念", "第一个概念是什么呢 段选择子", "段选择子是位于我们的段寄存器里面的", "那么我们可以说一个段", "有代码段 有数据段", "也意味着你的程序在代码段里执行", "你的数据位于数据段空间中", "那么一条指令去执行 它就会去访问", "我们的代码段和数据段", "而这个RPL以及后续讲到的CPL", "它其实就是一个位于数据段", "一个位于代码段", "合在一起再和我们段描述符里面", "所对应的DPL进行比较", "有点复杂 没关系", "大家可以逐步来看一下是怎么一回事", "首先我们介绍的段选择子", "这个段选择子第二步我们可以看到", "它的DPL是位于什么呢", "段描述符里面的 段描述符是什么东西", "我们前面已经讲到过", "段描述符是用来表示一个段的特征的", "一个很重要的数据信息", "我们这里面关注的跟特级权相关的", "包括了一个DPL", "就是跟这个段所相关的一个特权级", "我们也看到了", "前面说我们一项指令要访问一个段", "那这个代表了这一个段", "这一个数据段或者代码段", "它特级权是什么样的", "也意味着它前面讲的RPL和", "这里面的DPL做一个比较", "看这个特权级是否符合", "很简单一个想法", "就是我要去访问某一个数据", "首先我的特权级要足够高", "我才能访问某一个数据", "那你的特权级在什么地方呢", "那么大家可以看到", "其实我们在前面lab1中已经提到过有中断", "我们讲过中断", "那中断 异常 陷入", "其实都还是需要通过一定的特权级检查", "所以在里面中断门", "中断门是我们说前面讲到的", "中断描述符表里面的重要组成部分", "中断门 陷入门里面 它都有对应的DPL", "这也是用来表明这个中断和", "对应的陷入大致特权级的展现", "我们前面已经讲到了", "有段描述符 有中断门 有陷入门", "那么这几个它们都有对应的DPL", "而我们在产生中断", "或者完成一次内存访问的时候", "都会有对应的CPL和RPL", "那么这个CPL  RPL和DPL之间", "有一个对应的特权级检查 从而可以确保", "当前这个操作是否会产生特权级的一个错误", "或者能够正常的通过特权级的检查", "能够继续完成相应的操作 这就是我们说", "这个特权级检查里面需要考虑的问题", "我们看看怎么来比较", "我们知道RPL DPL和CPL", "我们是讲三个概念 RPL是处于数据段", "比如说我们的DS ES FS和GS", "那么它这里面是存了一个RPL", "是当前你要访问的数据段对应的特权级", "就是RPL 第二个你执行这条指令", "指令有个所谓的代码段", "那么指令的代码段存在哪呢", "CS里面 CS里面对应了一个CPL", "就是当前的一个代码段的一个特权级", "这个就是CPL 那么也意味着我们一条指令", "要访问一个数据段的时候", "它有两个特权级的表示", "一个是当前的特权级CPL", "位于CS的最低两位", "第二个是对应的要访问的数据段的RPL", "也是处于对应的ES或者FS等等", "它那个低两位有个RPL", "这两个占了两个bit和前面说的X86里面的", "四级特权级是一一对应的", "那就是0到3 0代表最高的优先级", "数值越低特权级越高 数值越高特权级越低", "正好是倒过来的 那这是发出请求的一方", "另一方面我们说你要访问的那个段", "无论是通过中断访问代码段", "还是通过内存访问 访问数据段", "它都会有一个那个段的描述", "就是无论是门还是段", "它都有一个所谓的DPL", "这个DPL代表了", "你要访问的目标它的特权级", "这个在什么情况下", "RPL CPL 和DPL处于什么关系的时候", "这个访问是合法的", "哪些情况是访问的不合法的", "这是我们说CPU检查的时候", "需要重点考虑的内容", "其实这个检查是挺简单的", "大家可以看看 有两种情况", "一种是针对我们说的中断 陷入 异常", "这种情况称之为门情况", "访问门的时候 它需要做两个判断", "它当前的代码段CPL要小于门所处于的DPL", "也意味着这个门的特权级要比较低", "而我当前执行的代码段要比较高", "这样才允许通过门", "第二个CPL要大于等于DPL", "这什么意思呢 通过门之后目的是什么呢", "是要我们去访问特权级更高的段", "有了这个约束之后", "其实就可以实现我们的应用程序", "一般的特权级的应用程序", "就是我们说处于ring 3特权级的应用程序", "可以访问处于内核态的操作系统提供的服务", "这属于特权级ring 0的这个操作系统的服务", "就是从低优先级的可以访问高优先级的代码", "这是说通过我们说的中断门", "陷阱门或者陷入门可以完成这个功能", "那么在我们后续的lab5中", "有应用程序的时候就可以看到这一点", "我们用户态的进程可以通过这种方式", "通过系统调用的方式", "来获得我们操作系统的服务", "从用户态切换到内核态", "后续也会给大家进一步的讲解", "第二个是关于访问段的一个表述", "对于访问段而言也一样", "我们说我们当前的代码段", "和我们要访问的这个数据段", "我们发出的数据段特权级的请求", "一定要小于等于DPL这个段", "那么这意味着什么呢 这意味着说", "当前发出请求的这一方", "就是当前处于代码段执行这条指令", "它发出请求 我当前处于这种状态", "我要去访问某一个数据段", "那么我本身的特权级要高于对应的目标", "你作为使用方", "我的特权级要比较高一点我才能访问", "那么对应的数值的比较呢", "说就是小于等于", "就是CPL和RPL最大的一个值", "就是最低那个权限", "要高于它所对应的目标的那个段的特权级", "我们这里面数值上是小", "在实际特权级比较上是高", "这点正好是倒过来的 所以是小于等于", "那么有了这两个表示之后", "如果说它能够通过这个检查", "也就意味着它的特权级的检查是合格的", "那么我们这个指令可以正常去访问", "如果通不过就会产生所谓的保护错", "也是一种异常"]}, {"name": "", "block_id": "ceaaeebc712b4c14965b8df1e57ae42f", "text": ["下面我们来介绍第三类同步方法", "就是这里的更高级的抽象方法", "它实际上是基于硬件的同步原语", "来实现的同步方法", "我们在前面已经说过中断禁用", "可以实现进程之间的同步", "那还有一类呢是原子操作指令", "也就说把若干个我们在同步当中", "会用到的操作", "把它合成一个原子操作", "在硬件上保证它的原子性", "这样的话 操作系统", "就可以基于这个来实现", "更高级的编程抽象", "简化进程同步", "第一个呢是锁", "锁呢实际上是一个抽象的数据结构", "这个数据结构呢", "由一个二进制变量", "和两个操作原语组成", "二进制变量呢它表示两种状态", "一种是锁定一种是解锁", "而两个操作呢是这样的", "一个是锁的请求", "我要申请这个锁", "那这个操作呢 它是原子的", "在请求的过程当中", "一直到获取到这个锁之前", "它都一直处于等待状态", "那它返回的时候", "你就已经获得这个锁了", "第二个操作呢是释放", "释放锁呢 它是唤醒其它的", "等待这个锁的进程", "有了这两个操作之后", "我们用它来实现临界区的访问", "那就很方便了", "那这是临界区的访问", "进入区就是请求操作", "退出区呢就是释放操作", "那有了这个之后这件事情就行了", "那它内部呢我们是", "基于原子操作指令", "原子操作指令呢", "是CPU体系结构当中", "提供的一类特殊的指令", "这些指令呢把若干个操作", "合成一个原子操作", "保证它们之间中间", "不会出现部分执行的状态", "一个呢测试与置位指令", "通常我们说的TS指令", "它的功能呢", "是从内存单元中读取数据", "测试并且置位该存储单元", "测试呢就是判断这个值是不是1", "然后并且往这个单元里呢写1", "也就说如果里头是1", "那你读出来写进去的还是1", "内容没变", "但是我们知道里头是1了", "好 如果里头是0", "那这时候呢我读出来的0", "写进去的1", "好 那这是我对它进行修改了", "这条指令的准确含义呢", "可以用这个伪码来表示", "实际上这是从里头读出一个量来", "然后把另外一个量写进去", "并且把读出的量呢返回回来", "这是它的功能", "这三个基本的操作合到一起", "它是一个原子操作", "它们不会被中断", "好 基于这一条 我们来实现", "我们前面的同步就会很方便", "另一条呢是交换指令", "它的功能呢是交换内存中两个值", "实际上它的指令含义呢", "我们可以用这样一段", "伪码来表示", "用一个temp", "把第一个值读出来", "然后把第二个值复制过去之后", "再把你读出来的值呢", "复制到第二个值", "好 用这种办法呢", "我们可以把两个值呢做交换", "这也是一个原子操作", "也就说读出来和写进去之间", "不会产生部分执行的状态", "那如果说我们", "以前面的分配进程ID为例", "如果我们这里读出来和", "写进去这两个是一个整体的话", "那我ID加1就没问题了", "好 这是两个基本的原语", "基于这两个原子操作指令", "我们可以来实现锁", "那在这儿呢 我们先是", "用TS指令来实现自旋锁", "它的做法是这样的", "初始化", "你这个锁里这个初值为0", "然后我来构造它的请求操作原语", "实际上这里头呢", "就是用TS指令去把", "你这里的value这个值读出来", "并且往里写1", "那如果里头是1", "那这个操作呢就相当于是个检查", "如果里头是0", "那么就把里设置为1", "并且这个循环结束", "好 它就进到下面这个页区去了", "好 释放的时候呢", "就是把这个值改成0", "那我们看这个写入的过程呢", "我们把它展开之后", "变成这样两种", "一种呢原来里头是0", "那么这时候呢", "实际上相当于这个锁", "处于解锁的状态", "好 这时候我把里写成1", "也就相当于我占用这个锁", "并且使得其它的进程就处于", "后续来的就处于等待状态了", "而如果锁处于锁定的状态", "也就处于忙的状态", "那么这时候呢你读出来的是1", "写进去的是1", "好 那它的状态", "没有发生任何的改变", "好 那这是用TS指令", "实现的自旋锁", "那我们看看它有什么样的特点", "那在这里头呢是", "这个自旋锁里头的TS指令的执行", "它是要耗用CPU时间的", "所以它在等待状态的时候呢", "它是消耗CPU的", "好 那我们看基于这个", "我是不是可以把等待的时候", "占用CPU的这件事情呢有所缓解", "那我们就把这个", "变成一个无忙等待的锁", "那怎么做呢", "首先我在你那个锁的数据结构里呢", "加上一个等待队列", "这个等待队列呢", "就是我等待这个锁的", "相应的进程所排的队列", "然后我把这个锁的请求操作", "在里又增加一段内容", "先while 进行判断", "如果说在这里头呢", "查询一次之后 里头是1", "那么我就把我当前线程呢", "放到等待队列里头", "同时呢 执行调度程序", "那这时候其它进行可以继续执行", "好 一旦是切换回来", "轮着我再运行的时候", "就是有释放锁操作", "把我这个线程从等待状态", "变成就绪状态了", "好 回来的时候呢我再继续去查", "好 如果这时候", "它的状态是解锁的状态", "那请求就完成了", "好 这时候我就可以进入到临界区", "好 转过身来在释放的时候", "比我们刚才的忙等待多了点什么", "填0 表示释放锁", "这跟原来是一样的", "那加了一句就是", "我把这个线程呢", "从等待队列里头", "放到就绪队列里头去", "这是这一步做的", "好 有了这个的话", "那你在等待的过程当中呢", "我就处于放弃CPU使用权的状态", "这样的话我CPU就可以干别的了", "好 我们看到在这个过程当中呢", "我们就实现了让权等待", "这是基于TS指令的实现", "那我们说基于交换指令", "也是一样可以来做成这件事情的", "那基本上就是把这个", "TS指令的功能换成交换指令", "好 基于原子操作指令", "所构造的这种锁", "它有什么样的特征呢", "它是适应于单处理机", "也适应于共享内存的多处理机", "我们前面讲的中断禁用", "只能用于单处理机", "如果我有多个处理机的话", "你在一个处理机上", "禁止中断的响应 那不管用", "另一个处理机上如果说有中断响应", "或者说有其它的进程执行", "那它仍然可以修改", "你共享的那些变量", "好 再有一个呢", "它能适应任意数目的进程同步", "那在这里头它不像我们前面", "你两个进程同步是一种状态", "三个更多的时候", "这种状态就会更复杂", "那么在这儿呢都是一样", "相对来说它是简单", "并且容易验证它的正确性", "好 它支持多临界区", "如果你有若干个临界区", "每一个临界区对应着", "一个锁那就可以了", "当然它也有问题", "如果说你是忙等待锁", "那这时候呢它会占用CPU的时间", "另外呢它可能导致饥饿", "也就相当于我在这里呢", "并没有做到", "按先来后到的顺序来使用资源", "因为我在锁的请求操作当中呢", "我放到就绪队列里头来之后", "我会再去检查", "就像我们前面说的", "你在检查那个时刻", "如果说资源处于空闲状态", "那就申请到了", "那你回来的时候呢", "实际上各个线程它把就绪队列", "排定的顺序并不见得是", "我们申请锁的这个顺序", "同时它还可能出现死锁", "那这描述一种死锁的情况是", "有一个低优先级的进程", "它占用了临界区资源", "好 另一个请求", "访问临界区的高优先级进程", "由于它优先级高", "那么这时候呢", "它就可以占用CPU来执行", "而占用CPU来执行呢", "实际上它执行的那个代码是请求", "如果那个地方你用的是忙等待", "那么这时候呢它就一直等待", "这样的话两边就相互等了", "低优先级等CPU", "高优先级等临界区资源", "好 那这两个互不相让", "那我们就构成死锁了", "好 这是基于硬件同步操作指令", "来实现的同步办法", "好 它可以有很好的性能", "有很好的特征", "但它需要硬件的支持", "好 到这个地方呢", "我们就介绍完了", "这三种同步的方法", "那禁用中断呢", "它比较简单 然后", "它仅适用于单处理机", "并且它会对", "系统中断的响应时间呢会有影响", "那通常情况下", "我们只是在不得已的时候", "才会去用它", "也就说我没有其它办法的时候", "我才会去用它", "第二种呢是软件办法", "它依赖的条件会比较弱", "但是它的实现非常复杂", "那在我们现在这里头呢", "用的最多的呢", "是基于原子操作指令", "实现的同步的方法", "那它不仅适用于单处理机", "也适用于多处理机", "具有容易验证的特征", "好 这是我们介绍的三种同步方法", "好 今天的课就上到这里 下课"]}, {"name": "", "block_id": "2fdccda8fee34edd953892aeaa106489", "text": ["各位同学大家好", "那我们接下来给大家介绍一下Lab 1的实验过程", "Lab 1主要是关于操作系统如何启动", "以及如何去和中断函数调用栈", "相关的一些知识 给大家做一个介绍", "这里面呢 会从以下几个方面", "比如说X86的启动顺序", "这里面涉及到当硬件一启动之后", "怎么把操作系统放到内存中去运行", "这是讲这一块涉及到的一些基本的知识", "第二个是讲C函数调用", "因为我们知道", "在操作系统里面有很多的函数之间（的调用）", "C以及函数之间 C和汇编之间的调用关系", "那么它到底在具体细节上面", "怎么来实现一个函数调用呢", "我们要有所了解", "以及还有一部分是关于GCC", "GCC是我们编译内核的一个编译器", "它里面有很方便的内联汇编", "有了内联汇编之后我们可以在C语言里面", "就是C的文件里面嵌入汇编代码", "就不用单独写一个汇编的一个文件", "这样相对来说编起来会更加容易", "但是它有它的一些相应的规则", "这样的规则给大家做一个简单的介绍", "使得大家能够看懂 在我们的Lab 1中出现的汇编代码", "再接下来是关于中断这一块", "一旦我们的操作系统启动之后", "它很重要的事情就是要能够接管中断", "中断有很多功能 我们这边会讲一下", "在X86-32这个硬件下 它的中断处理", "也就是uCore的中断处理是怎么来完成的", "它怎么和硬件的这些特征来结合", "来完成跟中断相关的一系列的管理工作", "最后是小结", "这是我们Lab 1大致要讲的内容", "首先我们看一下这个启动过程", "那对于X86的启动过程来说", "我们需要了解它这个硬件平台从加电一下开始", "你一按电源开关之后", "那大致的一个整个执行过程是怎么一回事", "这需要有了解 怎么就启动到我们的uCore操作系统去了", "第二个要理解这个X86的一个实模式 保护模式", "我们前面在lab0的时候给大家介绍过", "实模式 保护模式有它的不同的特征", "那我们在这里面 为什么一开始的实模式", "后面又进入了保护模式 在保护模式下干什么事情", "以及去理解一旦进入保护模式之后", "段机制是怎么一回事", "这个是X86启动 在启动相关的一些知识需要去了解", "首先看一下 当我们的X86硬件加电之后", "会出现什么现象", "这个其实是讲了关于因特尔不同的处理器", "基本上是80386以后出现的处理器", "当一加电 相当于做了一次热起之后", "会出现什么现象", "那么它首先肯定会有一个初始状态", "那么可以看到这所有的寄存器列在这", "它的初始状态下 都有一个缺省的值", "那么跟我们uCore相关的寄存器有哪些", "大家需要注意", "这里面最主要的是它的启动地址", "那启动地址在哪呢", "第一个 段地址CS", "CS和EIP结合在一起", "来决定它启动的第一条地址", "那么EIP在这儿", "这两个结合在一起", "形成了启动之后 加电之后的一个地址", "只要一开电 那么CS EIP就设置成这么一个值", "这个值就决定了它在哪个地址取得相应的指令去执行", "这也是需要注意的", "其它还有一些标志位等等也很重要", "比如EFLAGS 我们前面介绍的标志位", "还有一些控制寄存器", "比如说我们后面会讲到CR0控制寄存器", "一般应用程序都不会碰到", "但是在我们操作系统里面会需要跟它打交道", "还有其他一些通用寄存器 也都会有相应的初始值", "这个比较简单都是零", "那我们重点关注的是什么呢", "先看一下CS和EIP", "那刚才已经看到了", "CS在初始的时候是F000", "EIP它是32位的 所以说四个零", "三个F一个0", "但是我们需要注意", "当X86一开始加电时候 启动是实模式", "早期的为了向下兼容", "以前的80 86一开始启动是16位的实模式", "在这种情况下 寻址按照实模式的寻址方式", "所以说 它是Base加上EIP", "CS的Base是多少呢", "这里要介绍一下", "CS是段寄存器", "段寄存器里面有一个隐含的叫做Base的内容", "这个Base代表基址", "这个基址 其实就是存的值", "刚才已经看到了是FFFF0000", "再加上刚才的EIP是FFF0", "所以说它们启动最终的一个地址是FFFFFFF0这个地址", "这个地址 其实就是我们加电之后", "要去取得那个内存所在的地址", "这个内存什么地方呢 比较奇怪", "这个内存是BIOS我们说 在PC中的一个固件", "叫EPROM 它所在的一块内存区域中的一个地址", "但是需要注意这个地址是只读的一块地址", "然后从这个地址会取得第一条指令", "这条指令一般是一条长跳转指令", "会跳到BIOS中去做初始化工作", "所以你可以看到 一开始的时候", "它会从这么一个特殊的地址", "会跳到一个可以被访问的1M的内存空间里面去执行", "这其实也是符合我们说的 在实模式环境下", "其实它的寻址空间只有1M这么一个特征", "我们接下来的实验其实有一个环节", "看看到底这个BIOS从第一条指令", "到底从哪开始执行 跳到哪去", "我们是在Lab 1有一个小的练习", "让大家去尝试去找一找", "好 当处于实模式", "根据我们说的CS EIP它的寻址", "CS它包含的是什么呢", "到了实模式里面 它这里面一共是", "CS是16位的一个段寄存器", "然后加上一个offset offset就是EIP", "里面也是有16位的地址", "一共为什么形成20位的地址", "是在于我们16位的段寄存器左移了四位", "左移了四位之后再叠加上我们的IP地址 IP里面的值", "才形成了所谓的最终的在实模式下的寻址方式", "所以它的寻址CS：IP", "其实这个：IP的意思就相当于CS左移了四位", "再加上IP形成的地址", "这是在实模式情况下的寻址方式", "这里面没有后面讲到的段机制 或者页机制", "因为还没有进入所谓的保护模式", "好 那假设BIOS完成它的工作", "BIOS做什么工作呢 其实主要是做一些硬件的初始化工作", "底层的硬件初始化工作", "保证这个机器能够进行后续的正常工作", "完成很多各种外设 CPU内存的质检", "完成这个检查之后它会干什么事情", "很重要 在这点呢", "这个固件会去加载磁盘或者硬盘的第一个主引导扇区", "这个主引导扇区是零号扇区", "把这里面的内容读到内存中来", "一个扇区的内容是多少呢", "一个扇区是512个字节", "会把这512个字节的内容", "读到一个固定的地址 0X7C00处", "读到这个地址 相当于是把这一块磁盘", "空间的信息加载到内存中去", "同时把它的IP地址跳到这个地方来 跳到0X7C00", "这样 使得它可以去执行这个扇区里面的代码", "那这个扇区里面的代码是什么呢", "其实我们说Lab 1一里面的bootloader", "就属于512个字节这么一个特殊的执行代码", "它完成什么工作呢", "它完成来对我们说的这个操作系统 uCore的进一步加载", "有同学比较好奇", "说那为什么我们的BIOS不直接加载uCore操作系统", "大家想想 这里面其实取决于BIOS的能力问题", "因为刚开始在设计的时候", "它完成的功能就只是加载一个扇区", "而我们知道一个操作系统", "它的代码容量是大于512个字节 它会比较大", "那这种情况下 你如果说靠BIOS", "来负责加载一个复杂的很大容量的一个OS的话", "其实不太现实", "增加BIOS工作的难度", "所以说干脆BIOS只加载一个扇区", "而这个扇区里面的代码会完成后续的加载工作", "那这个扇区我们称之为Bootloader", "好 既然我们说这个主引导扇区里面存着Bootloader的代码", "那么它要干什么事情呢", "别小看这512个字节", "在这里面真正执行的代码可能只有不到512个字节", "可能只有400多个字节", "这么点字节数 它能实现什么功能", "大家想想 其实它完成的事还挺多的", "第一个它要干的事情 首先要从实模式切换到保护模式", "为后续我操作系统的执行做准备", "这是干的第一个事情", "就是从实模式的16位的寻址空间切换到了32位的寻址空间", "从1M的寻址到了4G的寻址", "这是它干的第一个事情", "一旦Enable（使能）了这个保护模式", "也就意味着这个所谓的段机制也就自动的加载上来了", "就也使能了 也就是段机制可以正常工作了", "为此你要让它正常工作 必然要做相应的一些初始化工作", "这个事我们后面会讲到", "假设它进入了保护模式", "干的第二件事情干什么呢", "就是读取kernel 就是uCore的代码", "又从哪读呢 也是一样 存在我们的硬盘中", "它需要从硬盘里面把uCore的代码", "再从我们的硬盘的扇区里面读到内存中来", "但是这里面也可以看到", "即使是我们最开始的Lab 1涉及到的uCore代码量", "也不仅仅是一个扇区", "它会涉及到多个扇区", "所以它会去读取多个扇区的内容", "然后读到内存的固定地点", "然后也一样 和类似于BIOS干的工作一样", "最后把控制权交给uCore操作系统进一步执行", "怎么交 就只是把它所谓的EIP的值", "就是CS EIP的值指向我们操作系统内核所在内存中的起始点", "这个entry 有个入口点 跳这来", "之后就相当于是把控制权交给了uCore OS去执行", "这是Bootloader做的事情", "最后我们会结合代码给大家展示一下", "就是它到底怎么来完成它的功能", "好 在这里面呢", "首先需要理解个概念", "我们基本上是按照Bootloader这个执行过程", "来讲解这里面涉及到的一些", "跟X86相关的一些硬件细节", "那这些细节呢", "和我们操作系统里面对应的内存访问机制", "中断管理机制有直接的联系", "所以大家可以去看一看", "是否这里面讲的内容和那里面能够有个对应", "但是这里面的内容", "相对来说跟我们原理课讲的信息相比", "它更加琐碎一些 更加细节一些", "但这个琐碎和细节 可以让你更清楚的了解", "一个OS怎么来完成相应的中断管理", "怎么来完成相应的段的处理机制", "第一个可以看看 所谓的段机制", "段机制什么意思呢 其实你看看", "这里面段寄存器起了一个特殊的作用", "它这里面呢 它起了一个指针的作用", "它指向了段描述符", "在段描述符里面呢", "描述了一个段落的起始地址和它的大小", "这是最直接的两个特点", "所以说 我们说可以根据CS里面的Index的值", "来找到uCore代码段的起始地址在什么地方", "它的大小是什么地方", "这是我们认为可以这么来做的", "同理 数据段也可以用其它的一些特定的一些寄存器", "段寄存器 比如ES 或者DS等等来表述", "我们的堆栈段也可以用SS来表述", "这样看起来比较自然", "但是需要注意 但是由于我们后面还有页机制", "所以在段机制这一块 它的映射关系就搞得尽量简单", "什么叫简单呢 就是说它的限制", "在uCore设置里面它的限制是4G", "也就是说它的段落大小是4G", "它的段的起始地址从零开始", "其实也是意味着它的空间顶满4G空间", "应该说它是想起到一个分段的功能", "这个功能把它弱化了", "基本上是没有这个功能了", "它后面还有其他的功能", "还有特权级的一个保护", "想通过一个段 比如代码段 数据段", "想用段机制来实现这种分割", "在uCore里面没有做到", "这里面也有一个因是在于", "这份功能的实现 和后续的页机制的实现", "在功能上有一定的重叠", "我可以用段机制来实现这种分段", "我也可以用页机制来实现分段", "所以说相对而言", "我们更倾向于用页机制来实现分段", "这是我们后面 再讲Lab 2的时候会涉及到的内容", "这里面是给大家提醒一下", "好 但是这个段模式你不能消掉", "因为只要起了保护模式", "在X86里面 规定这个段就Enable了", "而且你的页机制还是建立在段机制的基础之上实现的", "那我们可以看到 能够把段机制建立好", "虽然它完成的功能是一个", "近似于对等的这么一个映射关系", "但是我们要把映射关系给建立好", "在一个段寄存器里面 会保存一块区域叫做段选择址", "这个选择址就是我们刚才说的是Index", "它的值就代表Index", "这个Index会查找一个在段描述符表里面的一个项", "叫做段descripter 就是段描述符", "找到段描述符之后 这个描述符是对应什么来的", "它是对应Index 因为这可以意味是一个数组", "找到这么一项", "然后这里面 段描述符里面会存着刚才说的很重要的两个信息", "就是它的起始地址和它的大小", "那起始地址加上一个Offset", "这里Offset就是我们的EIP", "就是偏移量 EIP偏移量", "那么这个EIP加上由CS 或者说其他段寄存器所指出来的基址", "叠加在一起形成线性地址", "在这里面 我们前面讲到", "由于还没有启动页机制", "所以说线性地址就等同于物理地址", "所以说我们可以看到", "所谓的段机制其实是一种映射关系", "如果我们在这个段描述符里面", "把这个Base的Address设成零", "那也意味着你的EIP的这个值也就是它的物理基址", "这是最简洁的一种设置方式", "好 我们另外也可以看看", "怎么能够把这个机制给建立好", "这里面很重要一点就是你需要有一个大的数组", "把各个段描述符给装进去", "数组在哪 数组是由我们操作系统来建立的", "那我们把它称之为全局描述符表 简称GDT", "那么这个GDT是由我们Bootloader来建立的", "虽然只有不到512个字节", "但是它可以把这个建立好", "它会描述好段描述符表的一个大致的空间", "然后给出它的位置和它的大小", "然后通过一个特殊的指令 比如GDT", "然后把这个GDT Descriptor这个地方列出来", "这里面给出了一个GDT的一个描述", "就可以让我们的CPU能够找到段表的起始地址", "GDT全局描述表我们也简称段表", "这个表的起始地址之后", "通过内部的寄存器叫做GDTR这个寄存器", "来保存这个相应的地址信息", "然后使得我们各个CS DS SS等等", "它可以和我们GDT表建立对应关系", "当然这个GDT表是你设置好的", "假设有四项 有五项", "那么你得CS可能二 三 四 五都有可能", "从而可以指向GDT大数组里面所对应的描述符", "当然在这里面你首先理解GDT之后", "再看GDT里面的每一项", "这个表称之为段描述符的一个很详细的表述", "虽然细节很多 但其实我们最主要关注两项", "我们前面说过的", "第一个就是基址（Base）在什么地方", "第二个这个段的长度（Limit）是多大", "我们也讲到了 在uCore里面把这个功能给它弱化", "基址都是零 段的长度都是4G", "所以在这里面也等同于一个最简单的对等映射", "好 我们在看看这边", "这边表明刚才说到的各个段基寄存器", "它怎么来产生这个Index", "就是这里面的全局描述表中的一个索引值", "其实大家都知道 前面说到了段寄存器", "它一共大致有16位", "其中的高13位放的就是GDT的Index", "然后接下来的两位 放的是一个叫做RP", "表明这个段当前的段的优先级的级别", "在X86里面 它用了两个bit来表示这个优先级别", "意味着它可以表示0 1 2 3四个特权级", "优先级 或者叫特权级", "那我们一般说我们操作系统放在最高的级别是0特权级", "而我们的应用程序会放在3这个特权级里面", "所以说这个标记 段寄存器里面的这个标记", "表明了它当前执行的时候", "特别是CS 当前执行的时候所处的特权级", "这个TI我们暂时忽略 我们一般设置为零", "因为我们这边用到是GDT", "我们这里面整个没有用到所谓的LDT", "本地描述符表没有使用", "我们使用的是全局描述符表", "好 解释了段选择址 全局描述符表", "然后是什么呢 这个是段描述符", "这个是指向全局描述符表起始地址GDTR的一个寄存器", "有了这些之后呢 我们就可以看到", "映射关系就建立好了", "建立好这个映射关系之后", "你还没有使能（Enable）它", "使能代表现在进入了保护模式", "段机制也能够正常工作", "当你建好所有的这些前期的准备工作之后", "我们还差最后一步 最后一步是靠什么呢", "靠对一个特定的寄存器 系统寄存器CRO", "这个寄存器我们称之为系统性寄存器", "或者控制寄存器 对于这个寄存器", "把它的第0号bit置成1", "那么就意味着现在的系统", "我们的CPU会进入到保护模式", "好 可以看到我们前面再总结一下", "你需要建好一个GDT", "这里面GDT里面的每一项是一个段描述符", "然后我还要把相应的段的段寄存器", "CS DS等设置好对应的Index", "使得CS DS等这些段寄存器", "能够指向全局描述符表GDT对应的项", "这个项我们称之为段描述符", "这个描述符指出映射关系", "从而可以在使能了保护机制之后", "使段机制能够正常的工作", "这实际上就是说启动保护模式", "在X86里面启动保护模式", "Bootloader要干的基本的一些事情", "好 进入了保护模式之后", "Bootloader要干第二个很重要的事情", "干什么呢 就是要加载uCore OS", "那我们的uCore OS编译出来", "后面会给大家讲Demo这个的源代码", "编译完之后会生成一个elf格式的一个执行程序", "elf格式的执行程序是我们在Linux里面", "很常用的一种执行文件的格式", "那么我们需要了解到uCore 它的名字叫kernel", "kernel这个文件它的内部的信息", "从而使得我们Bootloader能够根据这个文件的格式", "能够把uCore相应的代码 数据", "给放到内存中相应的地址", "这是我们说接下来Bootloader要干的很重要的第二个事情", "那它怎么能放呢", "需要去解析这个ELF格式的信息", "ELF里面有一个头 叫ELFheader", "ELFheader里面呢 指出了一个Program Header", "程序段的头", "程序段里面包含了代码段 数据段等等", "各种各样的程序段", "它会把这个头这个信息给表述出来", "比如说这里面有一个叫做Program Header的Table的Offset", "相当于这个ELFheader的偏移地址", "它的起始地址在什么地方", "以及它的个数 这里面有个个数PHnumber", "有了这两个信息之后", "我们可以进一步查找Program Header这个结构", "知道它的偏移位置之后", "把结构里的信息读出来", "很重要的两点", "它的虚地址要往哪个地方放", "因为你这个编出来的代码是要在某一个特定的地址上运行的", "它的位置在什么地方 这有个va", "以及这一块 这个Program Header", "比如我们说的可能是一个代码段", "它的起始地址在什么地方", "它的size是多少 代码段有多大", "这两个信息可以便于把内存中的相应一块区域", "用于存放我们的uCore代码段或者数据段", "还是从这个文件的哪个位置开始读呢", "这里有个Offset", "从这可以知道我们从文件哪个位置把代码段读进来", "把代码段读进来 把数据段读进来", "这是说我们这个加载ELF格式的uCore OS的一个大致的流程", "大致就是说它能够识别出很重要的一些关键信息", "然后把相应的代码段 数据段", "从我们的文件读到我们的内存中来", "另一个问题 我们这边还没讲到文件系统", "它读的是什么", "其实它读的是最原始的磁盘扇区", "它是把一个一个的磁盘扇区", "刚才说的Bootloader之后的连续的磁盘扇区", "连续读了四个磁盘扇区 读到内存里面来", "然后开始完成相应的分析工作", "但是需要注意 随着里面的uCore的size进一步增加", "也许后面还不止四个扇区", "可能还有更多的扇区 这是很正常的", "好 那我们大致就把Bootloader启动的过程", "它进入保护模式 加载uCore操作系统", "给大家做了简单介绍", "这里面会涉及到了一些保护模式 段机制的建立等等", "这一块的信息大家可以阅读相关的一些文档和网站", "这里面确实和硬件相关的信息比较大", "我希望大家能够读懂代码", "能够理解它什么意思", "基本上就OK了"]}, {"name": "", "block_id": "222263b13da945a3a4961c97faac21e1", "text": ["下面我们来讨论", "段页式存储管理", "那段页式存储管理呢", "实际上是我们前面段式和页式", "想把它做结合", "那这种结合的思路呢", "实际上是由于段式存储", "它分的块比较大", "每一块里头的", "存储的内容是同一个段", "这同一个段的访问方式和存储的数据", "都是相同的或者相类似的", "在这样一来的话", "它去做存储的保护是比较方便的", "而另一种做法 页式存储", "它是由于分了很小的标准大小的块", "那这样的话它在内存利用效率", "内存和外存之间的存储的后备", "这方面呢它是会比较有优势", "那这时候自然就会说", "这两种做法各有各自优缺点", "我们有可能把它结合吗", "那这就是说把段式和页式结合起来", "这种直观想法呢也很简单", "实际上做起来的时候呢会是啥样的", "段页式存储管理的机制呢", "它的做法呢是在段式存储管理基础上", "给每一个段呢加一级页表", "那我们原来说逻辑地址到物理地址", "这逻辑地址怎么分呢", "原来是要么是段号加段内偏移", "要么是页号加页内偏移", "变成是段号 页号然后再加上页内偏移", "如果说你在这个页表里头再是多级页表", "那这个地方页表还可以再分成多级", "然后从这儿呢", "最后变到的是物理页号加页内偏移", "那它怎么来做呢", "首先是段号由进程的段基址", "找到相应的段表基址", "找到相应的段表项", "这个段表项里头呢", "有相应段的段长度和段基址", "那这些呢加在一起 我们得到一个", "相应段的页表的基址", "好 这个再加上页号", "我就可以得到相应的页表项", "页表项里头呢就有", "对应的物理页的页号", "物理页帧号", "这个页帧号和你的页内偏移加在一起", "就可以访问到实际的物理存储单元了", "那这种做法呢", "它可以在这个基础上", "我可以很方便地", "实现我们的内存共享", "那么共享的办法是什么呢", "我可以在段表的基址上", "加上一个共享段", "指向相同的页表", "那这两个段就共享了", "那我们具体看一下", "这是我们一个段页式的访问方式", "段表其中有一个段指向它的页表", "它的页表指向它的存储地址空间", "那如果说我想把这个段", "和另一个进程共享怎么办", "另一个进程它有自己的段表", "那么这里头我们俩是同一个段", "这是我指向同一个页表", "那这一块区域", "那就变成是它们俩共享的", "那我们看到这里头呢", "在页式 段式和段页式里头呢", "这共享的做法呢都是类似的", "好 到这个地方为止", "我们说清楚了", "非连续内存分配的几种做法", "段式 页式和段页式", "它们的共同点呢是", "我分配给一个进程的内存块", "它是可以不连续的", "那它们的区别是在于", "我在这里头分配块大小有不同", "段式分配的块是很大的", "以一个段为单位", "页式分配的块是很小的", "以你比如说是1K几K这种尺度", "作为一个最小单位", "而段页式呢是把这两种结合起来", "把这种非连续内存分配做法里", "所面临的问题就是", "中间要加一级页表或者段表", "这个表的加入会使得", "我原来连续存储方式里所没有的", "一些问题在这里出现", "比如说页表大小很大", "针对这种做法我们又有一系列的做法", "比如说像快表做缓存", "比如像多级页表做间接存储访问", "或者说反置页表", "那这些做法都可以改进我们", "由于引入非连续存储所带来的麻烦", "那当然我们在这里说的", "是它的基本做法", "在实际系统里", "做法跟基本原理都是类似的", "但是其中有很多的实现细节", "需要我们在后续阅读当中", "来进一步了解", "好 今天的课就上到这里 下课"]}, {"name": "", "block_id": "c8de3e9f3dfb40869682e4571415d6c8", "text": ["好 那我们看看当产生了", "一个页访问异常的时候", "我们接下来ucore应该怎么处理", "首先可以看看一旦产生异常", "会出现所谓的一个异常的中断", "有个中断号 根据我们lab1", "中断这个建立中断处理机制呢", "一个中断号会落到相应的", "中断服务例程里面的入口地址里面去", "而对于缺页异常来说", "它是十进制的14", "那么14呢会跳到这个vector14这个地方", "这是一个地址 去继续执行", "这个地址位于这个vector.S", "这个汇编文件里面", "好 跳到这儿之后呢 从这个地方开始", "进一步会跳到_alltraps是一个汇总", "所有的这个中断一个入口的地方", "就_alltraps还是在trap_entry.s", "这个文件它会还有一个就是", "最后你处理完中断之后", "还要返回的一个地方", "也在这个地方来进行进一步的处理", "好_alltraps会调这个trap", "这个trap实际上到了c程序里面去了", "我们trap.c里面来完成进一步的", "跟所有需要特别关注的中断的处理", "那么trap_dispatch", "是它的进一步调用的函数", "好trap_dispatch", "最终会调到pgfault_handler", "这实际上是我们缺页中断处理例程", "这个都位于我们trap.c这个地方", "大家可以去关注一下", "这三个函数的实现", "那么pgfault_handler", "在一开始可以简单的去完成", "所谓的一个print ok", "当产生缺页异常的时候", "你这边能正常接收到这个相应的中断", "相应的中断 那这个过程是打通了", "但是光打通过程之后呢还是不够的", "我们知道只能说明", "页访问异常能够捕获住了", "但对于我们虚存管理来说", "捕获住这个页访问异常之后", "你还要做进一步的处理", "进一步的处理来确保", "如果是合法页的访问", "你应该能够有效应对这种情况", "来给它完成正确的读和写", "如果是一个不合法的这个页的访问", "那其实你应该报错", "这是不同的处理方式", "比如说我们写应用程序的时候", "如果你访问的是一个非法的地址", "那程序会crash", "或者被操作系统kill掉 那这是一个道理", "那如果程序访问的是一个合法的地址", "即使这个地址不在内存中", "那我们操作系统也能够有效应对", "这是我们页替换算法要去完成的工作", "所以我们会进一步对pgfault_handler", "做进一步的处理 会调do_pgfault", "那do_pgfault就开始判断了", "它需要找到你访问这个地址", "因为从这里面会除了说", "产生一个异常一个号之外", "还会给你一个说错在哪", "到底访问什么地址出现的错", "那这个find_vma假设是说看看", "这个地址是否是一个合法的地址", "上一页我们讲到我们首先要", "建立好一个vmm的一个环境", "这个环境由mm和vma组成", "它构造了一个使用者的一个虚存环境", "所以说呢在那个环境里面", "我们设定好了哪些页", "哪些地址空间是合法的", "哪些地址空间是不合法的", "所以它要去查找", "根据那个产生缺页异常之后", "反馈回来的这个异常地址来查找", "看这个地址是否属于某一个vma", "如果属于某一个vma的一个范围", "它有个开始地址 有个结束地址", "属于这个范围之内", "那这就是一个合法的地址", "既然是一个合法的地址", "那我们使用者就应该", "能够正确的去使用它", "而且还不用关注这种", "所谓缺页错误情况", "这些所有错误情况都是由我们说", "由我们虚存管理系统来完成", "帮它处理好 找到了这个", "是这个一个合法地址之后呢", "我们进一步要看看它是否是", "是否是一个位于硬盘中的一个页", "如果是位于硬盘中的一个页", "那我们要把这个页从我们硬盘中", "加载到内存中来", "OK 那这个过程是要走", "swap in / swap out这套机制", "我们前面已经讲了", "我们需要把这个硬盘的", "换入换出分区给建立好", "这个swap in会把这个地址", "把这个访问出现异常的地址", "转换成一个页号", "进一步把这个页号去映射", "对应到它所对应的", "那个磁盘扇区号里面", "把那个磁盘扇区里面", "存这个页的内容呢找着", "再通过这个对磁盘的read操作", "把所有数据读到内存中来", "读到内存中来 读到内存之后", "需要注意 读到内存之后", "我们重新还要建立好这个映射关系", "那我们读到内存来之后", "我们放到一个物理页里面", "我们需要把刚才产生异常虚拟地址的", "那个虚页和这个你刚才", "已经从我们这个硬盘中读进来", "这个物理页呢这两者之间", "建立一个对应关系 这个关系是什么", "就是我们页表的重新的建立", "这里面会分配相应的页表项", "甚至说可能会创建一个页表", "来完成对这个映射关系的一个建立", "这是它大致的一个处理过程", "一旦建立好这个映射关系", "那也意味着我们可以正确地", "让使用者去继续访问这一块内存了", "那也意味着 在这里", "处理完所有这些东西之后", "它要原路返回", "从这儿到_alltraps这儿", "再做一个iret", "把这个异常中断返回", "那这种异常它返回到哪去呢", "是返回到产生异常的", "那条指令重新执行", "正因为它能重新执行", "在第二次执行的时候需要注意", "第二次执行的时候", "由于你页表的映射关系", "已经重新建立好了", "所以说第二次执行的时候", "不会出现异常 当然前提是你做对", "如果做错了那还是会出现", "进一步的异常 需要进一步去处理", "假如说做对之后", "它可以继续往前走", "就把这个数据的读和写", "就可以正常的进行操作了", "这就是当产生页访问异常之后", "这个do_pgfault这个关键的函数", "它要去完成的一系列的工作", "当然这个函数的建立呢", "是需要我们刚才说到一系列的帮助", "需要我们的页表", "需要我们swap in / swap out这个disk读写", "需要我们vma环境的建立", "来一块协同起来 来帮助", "来完成这个do_pgfault这个工作", "另一方面我们可以看到就是", "页访问异常它里面我们说", "它怎么知道它错哪了呢", "它里面有一系列一些机制", "除了我们刚才说能够得到一个", "说到底访问哪个页出错之外呢", "其实它有一些不太合法的情况出现", "比如说我是一个用户态的一个程序", "我要访问一个内核态的地址", "那属于一个低优先级的一个程序", "要访问高优先级的一个内存就会出错", "这里面会有一些相应的位", "比如说U/S 就是user还是supervisor", "来区分这个页", "这个页到底是特权级的", "还是属于一般用户的", "W/R是区分是只读的", "还是可读写的等等", "这一系列的属性", "来映射了不同的关系", "我们这里面可以充分利用", "当然这里面我们用的比较简单", "只是说产生异常之后", "我们需要把这个页给映射回来", "所以说只要知道出错的地址在哪", "就OK了", "接下来后续的操作系统的讲解中", "也会用到这些相应的一些属性", "来完成特定的功能"]}, {"name": "", "block_id": "6d42e28cf9fb44bab036aa9f1dd7bf9c", "text": ["那接下来我们讲一下", "管程和条件变量的设计与实现", "首先我们再回顾一下管程的原理", "管程的定义是什么呢", "管程是一个特殊的结构", "在这里面包含了几部分内容", "第一部分是共享变量shared data", "这是需要互斥访问的", "第二部分呢是条件变量", "那是说当在里面某些操作中", "有可能某些条件满足或者不满足", "它会做相应一个等待", "或者唤醒的一个操作", "第三个呢是并发执行的进程", "在这里面有一系列操作呢", "它需要互斥去完成", "然后有一些进程可以进来", "来完成相应的一些操作", "而这些操作可以并发来执行", "但需要保证", "对共享变量的访问是互斥的", "第四个在管程做相应的启动之前呢", "它需要有一系列初始化过程", "这有一些共享变量初始化值", "以及对条件变量", "也有一定的初始化的一些要求", "那我们既然讲了大致原理之后呢", "我们看看怎么来定义这个管程", "那么管程其实主要用在", "一些高级语言里面", "会有管程的一个设计与实现", "包括对它的使用", "在操作系统里面", "这上面的使用稍微少一些", "我们看看在ucore lab里面", "怎么来完成这个管程的设计与实现", "首先我们对它要定义一个数据结构", "这是一个管程数据结构的定义", "那它有一个mutex", "来保证对这些操作互斥的执行", "需要注意这些操作里面", "是包含了对共享变量的一些访问", "所以需要互斥", "第二个呢有一个next和next_count", "next是一个semaphore（信号量）", "next_count是一个int（整型）", "这一块的具体解释", "我们在后面随着进一步的展开", "会给大家做进一步的讲解", "第三个cv就是条件变量", "对某些条件是否满足的", "所需要条件变量", "它类比我们这个信号量", "但和信号量的具体实现是有不同的", "这就构成了一个所谓的管程", "好 讲了数据结构之后", "我们看它大致的实现", "这个管程里面各个操作呢", "是以函数形式存在的", "function_in_monitor 对应这里面", "一个一个的操作", "好在这个操作里面", "我们可以看到", "首先在操作开始和结束", "它有一个sem.wait", "和sem_signal", "类似于信号量的P操作", "和信号量的V操作", "从而可以确保中间的一些", "对共享变量的访问", "是一种互斥的操作", "在这里面如果对某一个条件的判断", "发觉条件能够满足", "我们就会做cond_signal", "或者做进一步的操作", "如果条件不能满足", "那我们就需要做cond_wait", "来完成一个等待", "这个是用到了条件变量", "这是通常位于管程中的一个操作", "所要完成的一个流程", "另外呢我们也可以看到", "在管程里面有两个特殊的信号量", "和跟信号量相匹配的一个", "next_count这么一个记录", "这个记录和这里面的操作", "是有对应关系的", "它的具体含义", "我们会在后面进一步展开讲解", "这里面就不展开了", "好 那我们来看一下", "关于条件变量的一个定义", "那我们知道条件变量和管程", "是有一个紧密联系的", "应该说条件变量", "是管程重要的组成部分", "根据我们原理课的介绍呢", "我们可以知道条件变量", "这个是它的一个数据结构定义", "包含了等待在条件变量上的", "进程的个数", "第二是等待队列", "这是它的一个数据结构", "同时它也有一个wait操作", "和一个signal操作", "wait操作是什么意思呢", "就说当一个条件得不到满足之后", "我们会让当前线程睡眠", "这个所谓睡眠", "让它执行一个condition: :wait（条件变量等待）", "如果说这个条件得到满足", "那么另一个进程或者另一个线程", "它会执行一个condition: :signal（条件变量唤醒）", "来把这个睡眠的线程给唤醒", "这就是它大致一个执行过程", "看起来和我们前面讲的", "信号量呢很类似", "但其实它们在具体实现上", "是有比较大的不同", "那我们看看原理上这个条件变量", "和我们具体的实现之间", "是什么样对应关系", "可以看出来", "这个等待的这个线程个数呢", "这里面有个count", "和这个numWaiting是对应的", "这个等待队列需要注意", "在这里面具体的实验上面呢", "用的是一个信号量", "来代替了这个等待队列", "因为大家都知道", "前面讲的信号量实验中呢", "也用到了等待队列", "通过这个方式呢", "可以更加灵活来完成", "对线程的唤醒", "和让它睡眠这么一个操作", "另外条件变量和管程之间的关系", "通过另外一个monitor", "这么一个变量来建立好了", "这个条件变量是属于这个管程的", "这也是我们说", "条件变量是管程重要组成部分", "的一个体现", "这就是我们说关于条件变量的定义", "大致就这么多了", "第二个是关于它的两个操作", "一个是wait操作", "一个是signal操作", "对于wait操作而言", "我们可以看到它是它的原理部分", "它其实对应红色部分呢", "就是它的具体实现", "比如它对它的numWaiting ++", "我们cv.count++是和它对应的", "另外呢它会有一个", "信号量的signal机制", "来完成互斥一个通知", "与release(lock)是对应的", "最后呢sem_wait和schedule是对应的", "可以看出来", "对原理部分一些描述呢", "基本上在我们具体实验中有涉及", "但是需要注意还有很多地方", "是没有涉及的", "那这个需要结合我们signal一起来看", "比如说前面讲到numWaiting--这个操作", "其实在前面的waiting这个地方", "做了一个相应的实现", "而对于其它部分", "比如说要判断", "numWaiting是否大于0", "这里面是判断了什么", "cv.count是否大于0", "这里面wakeup唤醒操作呢", "在我们这里面是", "信号量一个signal操作", "起到一个唤醒一个作用", "但是也一样可以看到", "非红色部分呢", "这些操作在这里面", "没有直接的对应关系", "那这意味着什么呢", "其实这说明了我们原理", "和我们具体实现", "还是有比较大一个区别", "这个区别呢我们在后面具体实验中", "给大家逐一展开讲解", "那我们以两个线程来做一个表述", "假设我们存在两个线程", "都想对一个管程", "进行一个相应的操作", "首先线程A先进入管程", "然后在进入之后呢", "通过对共享变量的访问", "发现某个条件不满足", "那么它会执行一个条件等待", "我们说条件变量的等待", "这是线程A的一个大致工作", "那么线程B呢它后进入管程", "因为前面等待之后呢", "很显然另一个进程", "它有机会可以进入到", "管程里面去执行", "进入管程之后", "它会设置条件满足", "因为它会查询", "或者修改共享的变量", "然后把条件设成满足", "设成满足之后", "它就需要把线程A给唤醒", "这是线程A和线程B", "它大致的执行过程", "在这个过程中我们来体会一下", "想看一下条件变量是如何有效地", "来让进程A和进程B", "既互斥 又能够同步地", "完成它们各自的工作", "这里面可以看出来我们设置是", "线程A是在这儿 线程B在这儿", "线程A先执行 线程B后执行", "它们分别进入到管程里面去", "完成各自工作一个过程", "这是线程A在管程中", "大致执行过程的一个描述", "它首先会有一个互斥的一个操作", "比如说信号量的mutex", "以及对它一个释放操作", "这是wait 这是释放", "这是保证了中间的", "处理过程是互斥的", "然后呢它会完成", "对共享变量的一些访问", "然后判断条件是否满足", "如果条件不满足", "它会做cond_wait", "就是条件变量的等待", "这就是关于线程A的一个操作", "如果等待满足了它会被唤醒", "然后它会退出整个操作执行过程", "对进程B而言类似", "它有一个互斥信号量的", "一个等待和唤醒的一个操作", "确保了后续的中间这部分工作呢", "是能够互斥完成", "如果它发现它对某些共享变量", "形成的一个条件", "能够让它满足之后呢", "它会发出一个cond_signal", "这个操作呢会使得前面的线程A", "能够被唤醒并继续执行", "大家需要注意什么呢", "线程A和线程B", "它们在进入管程之后呢", "只有一个可以去互斥地", "访问那些共享变量", "所以说当它唤醒完线程A之后呢", "其实怎么确保这个互斥性", "是有一定讲究的", "这也是我们说在具体实验上", "和原理上有一些很细微的差别", "在我们具体实验中", "需要去仔细地去体会", "我们来看看一个大致的执行过程", "这是线程A的这个wait的", "条件变量的一个操作", "这是线程B的signal的", "一个条件变量的一个操作", "这是原理部分的内容", "那我们可以跟具体实现对照一下", "看看我们的实现是否能够", "满足原理的功能", "同时呢它和原理", "在实现上具体有哪些不同", "我们可以第一个看着", "既然要等待所以说", "对应的线程个数会做一个加操作", "那么唤醒的时候", "会把这个线程个数做减操作", "对应我们具体的", "条件变量实现可以看到", "这有一个cv.count++  cv.count--", "和这两个是对应起来的", "这一步是有直接的对应关系", "第二个对于条件不满足之后", "当前线程它会需要去", "做一个等待操作", "同时把自己挂到", "这个等待队列里面去", "这是线程A一个工作", "对于线程B而言它后进入", "它会发现当前有线程在等待", "但它条件也满足了", "所以它会把线程A呢", "从等待队列里面移出来", "同时唤醒线程A", "这是它的一个工作过程", "那么这个呢也是原理上一个实现", "我们看看如果落到具体实现上面", "怎么来完成", "OK 可以看着先执行线程A", "它会做一个等待的时候", "会有cv.count++", "然后接着它会由于条件不满足", "它会做一个sem_wait来完成睡眠", "需要注意的是它这里面", "用到的信号量是cv.sem", "不是管程里面那个信号量", "它这儿就睡着了", "紧接着呢我们的线程B会继续执行", "线程B执行到一定程度之后会发现", "条件满足同时有线程正在等待", "为什么呢因为cv.count是大于0的", "和这个是一致的", "如果cv.count>0它会去把这个线程A", "从等待队列里面移出来", "同时唤醒线程A", "那么这里面是用一个sem_signal", "就是信号量的一个V操作", "来完成对cv.sem的一个处理", "那么这两个是匹配的", "可以看出来", "这一步也是可以和我们原理", "是一一对应的", "再接下来我们看一下", "会发现线程A当它要睡眠的时候", "它会把刚才进入管程里面", "那个操作那个mutex要给释放掉", "这样才能使得其它的进程或者线程", "才有机会进入到管程中", "去执行对应的一些操作", "所以这里面有release(lock)", "这么一个操作", "在具体实现这上面也存在一个", "信号量的一个signal就是V操作", "来完成对关于管程那个mutex", "的一个释放操作", "但是这个和这边", "好像没有对应的关系", "大家觉得在哪呢", "它对应进入P操作在哪呢", "其实我们可以看到", "在wait具体实现中呢", "就是条件变量的具体实现中呢", "有一个sem_signal", "那么这个signal", "其实和我们另一个进程", "它的sem_wait是对应起来的", "这使得我们线程A", "通过执行sem_wait", "处于等待状态之后呢", "且释放了它所占用的互斥的信号量", "就是monitor.mutex的时候", "使得其它另外一个线程", "比如线程B可以进一步执行", "因为线程B这时候", "在执行sem_wait的时候", "它就可以继续往下走了", "这已经被释放了", "然后线程B在执行这个", "sem_wait之后", "它会去查询共享变量", "看这个变量所对应条件是否满足", "如果满足它会执行cond_signal", "就是关于条件变量一个唤醒操作", "那么执行这个条件变量唤醒操作之后呢", "它可以使得我们的线程A", "能够进一步执行", "但是这里面有一些", "微妙一些处理过程大家需要注意", "那我们看一下关于条件变量的signal", "它到底做哪些具体的实现", "前面我们说到的monitor中", "关于我们管程", "它有两个特殊的成员变量", "一个是next_count（在monitor中）", "一个是next信号量（在monitor中）", "那么这两者呢", "其实我们没有做进一步解释", "这里面我们可以展开看一看", "当我们发现有线程处于", "等待在某个条件变量的时候", "它的cv.count是大于0的", "一旦大于0它会做进一步的一些操作", "比如说", "把monitor.next_count做一个加操作", "发出signal信号", "这是cv.sem", "对应的就是wakeup", "那它会把另一个我们thread A给唤醒", "这是一个正常操作", "但是接下来 又做了一个", "sem_wait", "wait什么呢 是monitor.next", "就是在管程中那个next信号量", "那做了这个操作", "使得自身会陷入睡眠状态", "这也就意味着对于原理课上来说的", "wakeup(t)这一步操作呢", "除了唤醒我们的其他线程之外呢", "还把自身给处于一个睡眠状态了", "这是sem_wait干的事情", "OK 那这个wait之后", "谁来唤醒它呢", "我们再来看一下", "线程A中的一部分实现", "线程A中其实有一块判断", "如果monitor.next_count>0", "那么它就会做一个semaphore的唤醒", "唤醒的正好是这边所等待的", "monitor.next", "貌似thread A可以用来唤醒thread B", "但这里面有个时间差的问题", "我们先说了", "thread A是先执行的", "thread B是后执行的", "当thread A执行到", "sem_wait(cv.sem)的时候", "它已经处于睡眠状态了", "在这个时候", "这个if操作根本没有执行", "而我们的thread B", "当它执行到sem_wait的时候", "它唤醒的thread A在这个地方", "thread A可以继续往下走", "但是无法再回去执行", "所以sem_wait(monitor.next)", "不能靠这部分语句来帮它唤醒", "那是靠哪来唤醒呢", "大家想一想", "其实这个唤醒操作", "还要看thread A的后续的执行", "我们看看当thread A在等待cv", "就是等待条件变量", "满足了之后呢它会被唤醒", "进一步去执行", "执行到最后 会注意", "在thread A的某一个function中呢", "会执行一个", "sem_signal的一个操作", "而这个操作正好是", "执行的是monitor.next", "但需要注意的是", "执行这个操作有个前提", "是monitor.next_count>0", "也就意味着这个next_count", "其实它的含义是什么呢", "含义是发出条件变量signal（操作）的", "线程的个数", "当某一个线程", "比如在这里面我们是thread B", "它这个线程", "由于发出了条件变量的signal操作", "且把自身置于一个睡眠状态", "使得被唤醒的线程A呢", "有机会在它退出的时候", "把线程B给唤醒", "唤醒是monitor.next", "为什么要这么做", "好像把这个问题给复杂化了", "其实这是有一定的原因", "原因在哪呢", "就在于这是管程里面的一个函数", "这是管程里面的另一个函数", "这是线程B在执行", "这是线程A在执行", "这两个函数都会涉及到", "对共享变量的访问", "既然都会涉及到", "对动共享变量的访问", "那其实根据我们管程的定义呢", "只允许一个进程", "对这个共享变量进行操作", "也就意味着这两个函数中", "只有一个可以去执行", "另一个只能等待", "所以当我们的线程B", "把线程A唤醒之后", "它自身必须要睡眠", "这使得线程A的", "对应的函数才能继续执行", "才能保证对共享变量的", "一个互斥的操作", "但是线程A执行完之后", "在最后的阶段", "它需要把我们的线程B给唤醒", "使得线程B能够持续往下走", "这样就确保了两个线程", "可以对两个不同的操作", "互斥地访问", "这是它们的一个执行过程", "另外我们还要注意一点", "在这里面这个mutex出现了多次", "那么这个多次呢", "其实它有时间顺序", "它们之间不会出现", "我们说死锁或者说重复的现象", "为什么 大家注意一下", "以线程A开始执行为例", "一开始它要执行", "一个mutex的一个wait", "就是信号量的一个wait", "在0时刻在执行这个地方", "执行到wait_cv的时候", "它会再次发出一个sem_signal", "那么这个sem_signal呢", "实际上是把这个信号给释放掉了", "这个释放使得我们的", "线程B可以执行", "那么第三个时刻", "就是2标记的时刻呢", "会做一个sem_wait", "当线程B最后离开的时候呢", "又会做一个sem_signal", "来完成对这个互斥信号量的", "一个释放操作", "可以看出来 0 1 2 3", "这个呢是确保了", "我们的线程A和线程B", "互斥地来访问相应的共享变量", "或者是访问相应的操作", "且不会引起冲突", "另外大家还需要注意一点", "当线程A被唤醒之后呢", "需要注意它这时候位置位于", "sem_wait之后这一点", "根据我们的原理课的讲解", "在这里我们需要重新得互斥锁（monitor.mutex）", "但我们在具体实验中", "（线程A）并没有重新获得这个互斥锁（monitor.mutex）", "那怎么能确保", "这个互斥的正确执行呢", "那其实是在于线程A这时候", "它的互斥是通过线程B的", "这个操作来完成的", "所以说大家要注意 0 1 2 3", "2这一步呢", "实际上是帮助我们线程A", "继续保证了它后续的操作的互斥性", "大家这一点需要理解一下", "那我们来看一下", "想结合一下线程A", "和线程B的执行过程", "看看我们这个条件变量的", "等待操作和signal操作", "它们具体怎么来完成", "正确的同步互斥的执行过程", "我们这里面专门用0到17来标注了", "它的一个大致的执行的过程", "我们一步一步来分析一下", "首先线程A来先执行", "它首先通过monitor.mutex", "这个信号量进入到临界区执行", "它用到了sem_wait", "OK 这是第一步", "进去之后它发现", "它对共享变量所需要的那些条件", "得不到满足", "因此它会调用条件变量的wait操作（wait_cv）", "这个条件变量是在哪呢", "是在这里面来实现的wait操作", "所以这是第一步", "然后呢第二个时刻", "是进入了条件变量的wait操作的", "具体的一个函数里面去", "当前等待的个数", "条件变量的等待个数", "会做一个加一的操作", "在第三步因为在这个时刻", "monitor.next_count还是为0的", "所以说它是执行else操作", "第三步有一个sem_signal", "这个signal是把临界区的", "wait操作给退出出去", "它做了一个monitor.mutex的", "一个signal操作", "这是第三步", "那么第四步它自身要进入睡眠", "所以说有个sem_wait", "睡在哪呢 睡在条件变量的", "那个信号量里面", "就是cv.sem里面", "这是第四步", "当执行到这一步的时候呢", "我们可以发现", "线程A处于等待状态", "它已经不能再继续往下执行了", "那我们线程B能够继续执行吗", "可以看一下", "线程B一开始执行的", "也是一个信号量的wait操作", "这个信号量是什么呢", "是monitor.mutex", "由于前面在这第三步的时候呢", "线程A已经释放了", "这个monitor.mutex", "所以这一步可以进去", "这是第五个时刻", "进去之后也进入了一个临界区", "在这里面呢线程B会判断一下", "跟共享变量相关的一些条件", "发现这些条件可以满足", "因此发出一个signal_cv操作", "而这个操作会唤醒线程A", "具体怎么做呢我们看一下", "这是第时刻六完成的造作", "在这它完成对条件变量的", "signal的一个函数调用", "首先它的判断", "cv.count是否大于0", "这里面可以看着", "这做了++操作", "所以说在这里面count是大于0的", "会进一步去执行", "执行到哪呢", "sem_signal(cv.sem)", "这个是有什么用呢", "这一步会完成对线程A的唤醒", "这里面可以看着", "在线程A的条件变量的等待操作中", "它有一个对信号量cv.sem的", "一个等待", "通过线程B的", "sem_signal(cv.sem)", "可以完成对它的一个唤醒操作", "然后紧接着线程B", "自身再执行一个sem_wait 在哪呢", "wait在monitor.next条件变量上面", "使得线程B又睡眠了", "这是第九步", "那线程A会被唤醒", "唤醒之后会执行一个cv.count--操作", "从而使得cv.count从1又变成了0", "这是第十个时刻", "执行完之后呢", "这个函数就执行完毕", "它会跳出wait_cv这么一个函数", "这是第十一步 这一个过程", "并进一步判断", "当前的monitor.next_count是否大于0", "大家注意一下", "在第七步之后呢", "有一个monitor.next_count++", "这么一个操作", "所以这个条件是成立的", "所以它会执行sem_signal", "monitor.next信号量", "那么这个信号量呢", "会唤醒刚才线程B睡眠的", "那个信号量", "monitor.next在这sem_wait", "然后它自身就退出了", "退出了管程的一个操作", "那我们可以看着", "线程B这个时候它唤醒之后呢", "会在第14个时刻继续执行", "完成对next_count的一个减减操作", "使得count也变成了0", "然后这个函数会跳出", "跳出返回到15这个时刻", "然后继续往下走", "在15这个时刻它会进一步判断", "是否monitor.next_count大于0", "这里面做了一个减操作", "所以它已经是为0了", "这一步不会执行", "所以会执行第16和17", "就是else之后的这个语句", "完成对monitor.mutex", "这么一个互斥信号量的", "一个释放操作", "那么这个操作呢", "是和第五步的", "sem.wait monitor.mutex", "是对应的 那完成这一步之后呢", "使得线程A和线程B", "都完成了各自的对管程中的", "特定操作的一个执行过程", "且保证了正确的同步互斥关系"]}, {"name": "", "block_id": "e8b59d6ee0c942478a9055d11b48a0d9", "text": ["接下来我们介绍进程加载", "进程加载是指我们用户的应用程序", "通过系统调用exec()加载", "来完成一个新的可执行文件的加载", "那在这里头呢", "我们前面已经在介绍fork的时候", "已经说过它的使用", "用exec()这个系统调用", "就可以加载一个新的可执行文件", "到内存当中覆盖原来的", "那个当前进程的地址空间", "然后开始执行", "那在这儿呢我们会来说", "这个加载到底它在怎么做", "那我们还知道", "大家在系统加载的时候是啥样", "我们CPU加电", "加电之后去起动从BIOS里的程序", "BIOS里的程序运行之后", "就从硬盘上去加载引导扇区", "引导扇区加载完了之后", "是我的bootloader", "bootloader然后再到我的内核映像", "内核做了一系列工作之后", "现在到我们的应用程序这个地方", "那用户要想通过exec()", "加载一个可执行程序", "它类似于我们前面的", "这种系统加载一样的", "我把一个映像加载到内存当中", "然后我得跳过去到指定的位置来执行", "实际上这些呢中间就是有", "关于可执行文件格式的识别的问题", "不同的系统呢它可以加载的", "可执行文件的格式是不一样的", "这是我们首先要说的", "然后再由这里头我们加载的时候", "用户需要指定加载时候的参数", "你比如说在我们exec()里头", "要指定你后面有几个参数", "然后每个参数分别是什么", "好指定完了之后那这样的话", "如果成功", "加载成功了", "那这时候呢它是相同的", "跟加载之前是相同一个进程", "ID是一样的", "但是它执行了完全不同的程序", "那这时候你的代码 堆栈 堆 数据等等", "完全都被重写了", "这是程序加载的过程", "那在这里头实现这个加载的功能呢", "相对来说也比较单一", "也就是说我从外存上", "把可执行文件加载进来", "并且跳转到上面去执行就可以了", "这和我们引导扇区不一样", "引导扇区我读一块内容放那儿去", "我对它的格式是没有任何理解的", "但是我们现在", "到执行一个应用程序的时候", "你里头那可执行文件的格式", "是非常复杂的", "所以在这里呢主要的工作就是", "你可执行文件格式的识别", "那具体说起来呢在这儿呢", "分成三个主要的函数", "一个是sys_exec", "一个是do_execve", "一个是load_icode", "那第一个呢", "实际上是我在这里获取相应的参数", "核心加载功能是在这里头", "而在这里头呢最核心的部分呢", "是load_icode这实际上是", "识别你的可执行文件的格式", "并且把它加载到", "在内存里加载相应对应的段", "然后开始执行", "那在ucore里呢", "有一个sys_exec()这样一个内核函数", "它完成的呢", "就是获取我们创建进程的参数", "然后到这边呢它获取这些参数之后", "最后调到的结果", "我们可以从这儿可以看到do exec()", "这是内核关于", "进程加载执行的最主要的函数", "在这个函数里头呢", "它主要要做的工作呢", "是在这里创建新进程所需要的", "内存的相关的这些段结构", "比如在这儿", "这个地方是打开文件", "读你ELF文件的内容", "进来进行相应的创建", "然后下面这地方呢", "是它所需要的内存地址空间的", "映射的创建 mm_create()", "然后这地方是设置页表的基址", "然后这是我们刚才在那里看到的", "load_icode()这个函数", "这个函数在我们这里呢", "主要是解析相应的", "可执行文件的格式", "我们可以看到它在这里头的控制流图", "那在这里头呢", "它最主要的一个部分就是去读文件", "那这是它最主要的操作", "然后更具体的相关的实现呢", "希望大家下去之后", "利用这些工具可以很方便的看到", "好在加载完了之后呢", "那我们程序就开始执行了", "实际上我们在前面讲创建的时候", "也已经说过了", "我的系统里的第一个线程", "是在那个proc_init()里头来进行的", "proc_init()那在这里呢", "它手工的构造出一个进程控制块", "然后把它放到就绪队列里头", "然后开始执行", "这时候它起动的第一个用户态的程序", "就是这个init_main()", "在这里头呢做了", "我们下面会去走的shell的程序", "那在这里头具体的执行过程呢", "我们通过相应的实际代码阅读来完成", "接下来我们说ucore创建的第一个进程", "创建进程的函数呢", "是我们这里的proc_init()", "在这个函数里头呢", "我们刚才已经从kern_init()里头", "看到过这个函数", "它完成两个内核线程的创建", "idleproc()initproc()", "那在这儿呢我们可以通过", "它的流程图来给出一个简要的", "这是proc_init()的流程图", "好那在这里头我们看到", "它创建第一个标志性的操作呢", "是在这儿idleproc()", "在这里给它复制相应的状态信息", "这是利用alloc_proc()来创建", "idleproc的进程控制块数据结构", "然后下边这边呢就是initproc", "这是在这里呢", "用这里头kernel_thread()这个函数", "来创建一个内核线程", "执行的函数是init _main", "这个内核线程创建完毕之后呢", "它被赋值通过ID找", "赋值然后确认它就是initproc", "这是我们要找到的创建的第二个函数", "然后在这个init _main这个函数里", "它做了一些什么呢", "实际上它这里", "又创建了两个内核线程", "那这两个内核线程", "从这儿呢我们可以很清楚地看到", "这是第一个", "然后这是第二个"]}, {"name": "", "block_id": "e2e0da005f58497a9c1cc615c0845b9a", "text": ["好 那我们来看一下", "信号量的设计与实现", "首先回顾一下信号量的原理", "那所谓信号量 它的定义", "就包含了一个信号值", "一个整型的信号值", "还有一个呢 是等待队列", "这是组成了我们信号量的", "一个数据结构", "那么它的这个操作呢包含两块", "一块是P操作 一块是V操作", "对于P操作而言呢", "它会判断一下这个信号值", "信号值在做了减减操作之后", "如果小于0的话", "我们会把当前这个线程", "会加入等待队列里面去", "因为这时候它表明", "它满足不了信号量的需求", "同时呢 让这个线程进入等待状态", "这是P操作", "那么V操作呢正好是反的一个过程", "然后会把信号值做个加加", "然后进一步判断", "看这个信号值是小于等于0的吗", "如果是的话", "它就会认为我们现在有一个线程", "可以得到信号量资源", "可以去进一步执行", "为此呢它会把某一个线程", "从等待队列里面取出来", "然后呢 唤醒这个线程", "这就是P操作和V操作的一个", "大致一个原理的一个表述", "我们来看看怎么来具体实现它", "我们来怎么设计它呢", "其实可以一一对应", "我们可以看到原理", "和我们ucorelab", "它怎么来完成这个对应关系的", "对于这个数据结构可以看出来", "这个对应还是挺直观的", "这个信号值和这个value是对应的", "这里面的等待队列", "和我们刚才讲到等待队列", "也是一一对应的", "所以呢 从数据结构上来看", "这两个之间是一致的", "那我们看它的P操作和V操作实现", "有什么样的一些区别", "这是原理部分", "这是实现部分", "我们首先关注一下", "我们的实现呢", "是按照一些小的节来组成的", "首先我们看P操作", "其实在P操作的开始", "和P操作结束的时候呢", "应该是对一个共享数据的一个保护", "所以说我们有一个Local_intr_save", "和local_intr_restore 这两个函数", "放在头和尾的位置", "使得中间的操作", "不会被打断或者被调度", "这很关键", "因为对于不同线程而言", "这个sem 它是一个共享的变量", "有可能多个线程 或者多个进程", "会同时访这个信号值", "所以我们需要通过这种方式", "使得当某一个进程或者线程", "对这个sem进行操作的时候", "或者进行访问的时候", "比如这里面还有个判断", "其它的线程和进程", "无法对它进行操作", "这是通过这个操作来保证的", "就是我们说的Local_intr_save", "和Local_intr_restor", "我们说 屏蔽中断机制", "这已经用到我们刚才讲到的", "一个底层机制 屏蔽中断", "好 对于这两步", "我们说 想判断当前这个进程", "是否应该进入等待", "还是说继续去执行临界区代码呢", "用的一个这是sem- -", "和一个if判断", "我们这里面有点不太一样", "我们是直接判断", "这个sem->value是否大于0", "如果对于这里面大于0", "其实意味着这个if条件不满足", "也意味着它可以进入临界区去执行", "我们在这里面可以看出来也是一样", "如果semphore大于0", "它会直接恢复intr并restore", "这就是这一块的代码", "和这边代码对应关系", "这有点区别", "如果小于0的话", "我们就会把当前这个线程呢", "放到等待队列里面去", "同时让当前线程处于等待状态", "就这两步完成的事情", "那如果我们是在ucore里面实现", "怎么来做呢", "我们首先会申请一个等待项", "一个wait的等待项", "并且把这个等待项呢", "挂到等待队列里面去", "而这个等待队列呢", "是在我们这个semaphore里面一个成员变量", "我们semaphore成员变量是等待队列", "关联起来 使得我们这个进程", "或者线程呢 它能够处于一种", "就是等待状态", "它能够把那个状态记录下来", "同时呢还会去做一个schedule", "由于在这里面就是wait_current_set", "它已经把这个线程", "或者进程设置为等待状态", "所以说当执行schedule的时候呢", "也意味着会有一个新的进程", "会被选出来去执行", "而当前的线程 或者进程", "它会被处于一种等待状态", "那如果说我们当前这个", "等待的线程被唤醒了", "接下来会做什么事情呢", "对原理来说可以看着", "这里没有任何执行 直接就跳出了", "但实际上在具体实现的时候", "需要考虑这个问题", "什么呢 第一个 等待线程", "它所对应等待项是否被删除掉", "如果没有被删除掉", "我们会调wait_current_del来完成", "把这个等待项从等待队列里面", "删除这么一个操作", "这是一个问题", "第二个问题是说", "有可能当前的线程唤醒了这个原因", "就是wakeup_flag", "这个原因呢是和当时等待那个原因", "是不一致的 就是wait_state", "这两者不一致", "如果这两者不一致意味着什么", "意味着出现一种比较奇怪的现象", "我们会要把这个状态给返回回去", "让我们高层程序进一步判断", "是否是合理现象", "如果不合理 我们就说出现一些异常现象", "我们会做一些补偿的措施", "如果说我们这个wakeup_flag", "就唤醒这个状态和等待这个状态是一致的", "那我们就是一个正常的返回return 0", "这是说在一个线程被唤醒之后", "它要做的一系列操作", "那前面说的是P操作的过程", "那我们再看看V操作是怎么一回事", "首先也是同样", "由于它们对共享的变量sem", "做一个操作 和一个判断", "所以我们会把它用Local_intr_save", "和Local_intr_restore给它包起来", "从而保证互斥性", "这是第一步", "好 我们接下来看一下这个V操作", "这个V操作首先要判断一种情况是什么呢", "当前是否有线程处于等待状态", "当做一个sem++之后呢", "它会做一个判断", "是否sem>0", "如果大于0 意味着当前", "没有处于等待状态的线程", "所以它不需要唤醒", "这是原理上一个设计", "那么具体实现上呢有点不同", "我们是说首先判断一下", "这个等待队列是否为空", "这很好理解", "如果我们取出来这个等待队列", "上面这个元素是空", "意味着没有处于等待状态的线程", "这时候我会直接返回", "做一个加加操作之后就返回了", "这和我们红色部分是对应的", "另外一种情况是说", "如果现在有线程处于等待状态", "那我们需要把这个线程", "从等待状态变到就绪态 并唤醒它", "那是这两段完成的事情", "这是原理上讲的这个设计", "那对于我们具体实现呢", "其实用一个函数", "wakeup_wait", "就可以完成这两部分事情", "第一部分是从等待队列里面", "把对应线程给找出来", "同时把它的状态", "从等待状态变到就绪状态", "好 我们看一下", "怎么来调用信号量的P操作", "在ucorelab里面有一系列函数", "高层的函数", "它会通过这个down操作", "来完成对这个信号量的P操作的访问", "这个down是一个函数", "它会进一步调一个_down", "来完成进一步一些工作", "完成什么呢", "首先对全局变量一个互斥的保护", "通过屏蔽中断", "这两个屏蔽中断来完成", "第二个呢是把当前的状态", "从运行态变到等待状态", "然后呢挂到这个等待队列里面去", "完成schedule", "这样就使得当前进程", "就不再占用CPU了", "有新的进程会被选出来", "占到CPU去执行", "一旦后续的工作中呢", "如果说通过V操作", "把这个当前等待线程给唤醒之后", "我们还会做进一步的", "把这个等待项给它删除的一些操作", "从而可以继续去", "从等待状态变到就绪态", "进入到就绪队列里面去", "进一步去完成相应的执行工作", "这是说调用信号量P操作", "的一个大致执行过程", "第二个 是关于调用信号量V操作的", "一个执行过程", "也是一样 有类似一系列高层函数", "会调这个UP函数", "这个UP函数呢就对应V操作", "UP会进一步调一个_up", "然后它完成同样类似事情", "首先要对全局变量做一个保护", "通过屏蔽中断来支撑", "然后呢去查找等待队列里面", "是否有等待的线程", "如果有 会把它唤醒", "如果没有 就直接跳出", "让信号量做个加加就OK了"]}, {"name": "", "block_id": "021d85a0b71043cc9cd0568b8e216896", "text": ["那上操作系统实验课的目的是什么呢", "最主要的目标是在我们操作系统原理", "和操作系统设计实现上面建一座桥梁", "能够辅助同学能够更好深刻理解", "操作系统基本概念怎么产生的", "怎么具体实现的 这是一个很重要目标", "另一方面我们希望同学通过的操作系统实验", "能够对操作系统设计有个全局的感觉 全局观", "这一点也是很重要的一个特点", "因为操作系统相对而言", "在大学期间是同学能够碰到一个", "相对比较大型比较复杂的软件系统", "那么你怎么能够很好在一个全局的角度把握它", "能够对它进行改进扩展分析理解等等", "这对我们同学提供新的挑战", "这也是一个能力的锻炼和培养", "第三方面其实我们也知道操作系统", "它的实现相对来说还是比较复杂的", "并不是说我们每个同学", "都需要去能够对它进行很深入的理解", "然后能够对它进行改进扩展", "甚至从头实现一个", "其实提出了一个很高的要求", "我们其实也知道同学一般会分三等", "针对不同的同学我们其实应该有不同方法", "所以说我们强调什么呢 差异化教学", "那差异化教学体验在什么地方呢", "对于高水平 中等水平和较弱水平的同学", "我们分别有不同的要求", "对于高水平的同学在他完成基本的操作系统实验情况下", "我们希望他去做创新的实验", "甚至挑战一些没有尝试过的一些东西", "比如说举个例子", "现在的ucore它没有去对多核处理器有支持", "我们有没有同学可以挑战一下", "实现一个对多核处理器支持的这么一个ucore操作系统", "这是一个可以去尝试一个工作", "第二个对于中等同学来说", "我们最基本的要求是什么呢", "就是能够完成我们布置的基本实验", "你完成了基本实验 其实就基本说", "能够把我们操作系统原理上面的一些知识点对应起来", "在很大程度上体现了", "我们操作系统原理课讲的知识点", "那么你能够知道知识点怎么回事 具体实现怎么回事", "通过这样的话就可以使得同学", "对于操作系统理解会更加深刻", "对于比较弱的同学 我们希望他能够理解代码", "他也许编程还确实无法完成我们的实验", "但是我们也提供了实验的答案", "所以说通过理解这个代码", "他能够知道原来操作系统", "是这么来完成这么一个功能", "比如说我们后面讲到的内存管理", "文件系统进程调度等等 这些他能把代码读懂", "能够运行起来 能够调试分析它", "也可以很好地去把我们原理", "和我们实验给对接起来", "这是我们说对于相对来说比较弱的同学", "他的要求 这也是对差异化教学的一种尝试", "为此我们就要设计相应的操作系统实验", "我们主要思路是基于一些大量的开源软件", "来从各个层面来使的同学们更好掌握OS", "首先你的实验环境是什么", "就是我们这里面由于大量的工具是基于Linux", "所以说我们希望同学能够在Linux环境中", "来开展实验的过程 这是一个", "第二个你需要去理解代码", "理解代码有很多代码有这样的工具", "比如说我们讲的Eclipse understand", "这些工具都可以便于你去从一个细节", "或者从一个全局的角度来看这个代码", "还有就是生成一些自动文档", "也是便于理解和分析的 比如Doxygen", "你能够把你这个代码能够编译成", "最后能够执行的机器码  你需要一些编译器", "GCC Make 等等一系列辅助工作", "来帮你来把你写代码变成最终的OS", "一个可以执行的执行码", "那你编好了OS之后你要运行", "那运行在什么地方呢 我们有两种", "一种是说我们可以跑在真实的机器里面", "比如说我们这里面ucore针对是32个X86机器", "我们可以用真的机器来跑", "当然这相对来说比较麻烦一点", "我们也可以基于模拟器比如说QEMU", "它是一个软件 它可以模拟出一台X86的机器", "这个上面去跑我们编写的OS", "但是你在编写的过程中还可能出错", "出错我们需要调试 我们有调试工具", "比如说基于GDB和QEMU来进行调试", "而且我们还可以基于集成开发环境", "比如Eclipse的CDT来进行编辑", "分析 运行 调试 整个这个环节的工作", "更加简化 大家在完成实验中的难度", "这是我们提供一系列工具", "所有这些工具都在Linux里有很好的支持", "也有同学尝试在Windows里跑 也有可能", "配置的环境相对来说更加复杂一些", "所以我们这里面鼓励大家基于Linux", "来进行整个实验环境的建设", "和最后的实验过程的完成", "我们可以看看实验内容里面主要包含哪方面", "跟我们操作系统课的知识点是对应的", "我们一开始会讲到中断 外设", "你这个操作系统针对的机器", "针对一台计算机来进行管理和处理", "那么这里面会涉及到相应的IO管理和中断管理", "这是一块 这是跟外设相关的", "第二块跟我们计算机内存相关", "内存管理 它怎么有效管理内存", "来放置我们的代码和我们的数据", "第三个跟我们CPU相关", "那怎么有效的利用CPU来完成相应的工作", "需要分时 把这个CPU的时间", "分给不同的程序去运行完成特定的工作", "这也是我们操作系统很重要一个管理过程", "还有就是涉及到当多个程序在一起跑的时候", "它们有一些并发同步的一些管理", "这个也需要我们操作系统来保证", "才能使得整个程序正常工作", "否则就会出现类似我们说的", "后面我们会讲到死锁等等一系列问题", "还有最后你这些数据 你这些代码需要永久存储", "需要长期存储的环境 那这个环境是什么呢", "我们说的这个 我们一般都知道有个硬盘 磁盘等等", "但是操作系统为了能便于我们用户应用程序", "放置它的数据和代码 我们设计了文件系统", "从而更简单完成对操作系统管理", "这些部分都是覆盖在我们8个实验中", "我们会在实验过程中来体会讲到这些原理", "具体在OS是怎么实现的", "这是我们希望做到的", "那为了减少这个代码量其实大家都知道", "像比如说Linux Windows那是上千万行的代码", "太大了 不要说学生了 就是一个资深的工程师", "也很难把它全部掌握到", "所以我们希望能够减少代码规模量", "使得学生在有限时间内", "比如一个学期能够去掌握和理解这个代码", "我们理解是说大概控制在一万行代码量之内", "从Lab1到Lab8 Lab1可能只有几百行代码", "到Lab8大约控制在一万行代码以内", "从而可以实现对OS的更深入的理解", "同时我们提供的相应的讲义和文档来帮助同学", "甚至我们答案也提供大家", "可以更好的去理解和掌握实验是怎么完成的"]}, {"name": "", "block_id": "78c4412182ff4a08ad780be32d7e3c53", "text": ["接下来我们看第二部分", "第二部分讲的是什么呢", "讲的是说当我们的uCore操作系统得到控制权之后", "它还要进一步执行", "它需要了解函数调用关系", "那为什么要了解函数调用关系 这其实很重要", "特别是我们想象一下", "如果程序在某一点崩了", "那我们知道函数调用关系的话", "我们就可以知道从哪个地方调用", "到最后出现了问题", "你可以知道整个一个函数的执行调动的过程", "那可以很便于我们去分析理解错误在什么地方", "这个是一个很直接的用处 我们后面也会用到", "第二个你也知道 我们的编译器", "我们的GCC和我们的操作系统在执行程序的时候", "大致之间怎么一个协调", "GCC怎么产生这个代码", "使得它可以把函数的参数给压入到栈里面", "具体被调的函数能够取这些参数去执行", "最后还能够正确的返回", "这个执行过程应该说是很Detail的", "应该说在我们的编译 计算机原理和操作系统都相关", "这里面希望大家对它有进一步的了解", "能够更好的去分析理解这个程序的执行过程", "特别是操作系统的执行过程", "好 那我们这个分析又不太一样", "它不是在C这一级分析的", "是在我们机器码这一级来分析的", "我们这边可以看出来 这有一个栈", "这是一个Stack 这个Stack里面", "这是高地址 这是低地址 正好相反", "这是一段代码", "这段代码虽然是汇编代码", "但是我们前面也介绍了 这是基本的寄存器", "完成了一个Push操作", "把寄存器内容压栈", "调用call 调用一个函数", "这个foo可以代表一个地址", "调用完这个函数之后", "这个函数返回之后会执行一些pop操作", "来把刚才压栈的信息给弹出来", "后面又可以继续执行了", "这实际上是一个调用过程", "会有压栈 出栈 中间是call的过程", "那么这个函数在这 foo", "它会完成进一步的处理", "那这个处理到底什么意思 我们可以看看", "用这个图 可视化来展示一下", "当执行到这个地方的时候", "基本上是EBP指向caller's caller's EBP", "这好像看起来不知道什么意思", "但是没关系 我们走一下", "看接下来会出现什么情况", "特别是执行push1 &ebp的时候", "我们看到一些不一样的地方", "push ebp还有movl这两条指令", "当执行push al的时候", "实际上它把caller", "就是调用foo这个函数的函数 就是caller", "它会把相应的寄存器压栈", "再接下来呢 会把相应的参数压栈", "相当于是我调这个函数", "我需要有一个参数", "这些参数也压栈 这是实参", "然后再接下来 它调这个函数", "在执行这个函数的时候", "它会把它的返回地址压栈", "返回地址在哪呢 返回地址在这个地方", "call下面条语句 是它的返回地址", "Return address", "压栈之后就跳转到这个地方执行", "当执行这两条的时候 需要注意", "EBP到这来 同时这是做了一个push之后", "这里面的内容是这样的", "同时让ESP的内容付给了EBP", "所以说EBP从指向这跳到这", "指向这个地方", "虽然跳到这么一个地方", "但其实隐含着建立一个链接关系", "这里面的内容其实指向了这个地址", "那么这个呢 就形成了所谓的调用栈的链", "我们根据这个信息", "就可以把更深层次的调用关系给表述出来", "这也是我们在Lab 1中需要去理解和实现的一块练习", "执行到这的时候其实可以看到", "它也做了很多后续的一些压栈工作", "把它的局部变量给放到栈里面去", "然后做相应的处理", "假设执行完毕之后", "最后会做一个pop操作", "使得EBP又回来了", "最后在执行return的时候", "因为你这时候ESP已经指向了Return address", "所以说做Return 最后一步的时候", "它会根据这个Return address跳回来执行", "同时把它清掉", "所以你看它会执行到这来", "在执行这条之后", "又把刚才压的实参这个弹出来了", "又回复到这么一个状态", "接下来继续往下走相应的指令", "这是整个C函数的调用过程", "你看可以涉及到有caller", "有压栈 压栈完成对于实参的一个传递", "然后对调用函数的返回地址的压栈", "然后再调用函数", "调用函数有相应的对EBP和ESP的处理", "形成一个调用栈", "调用栈的一个链接关系", "然后完成相应处理之后", "还要把所有的参数给释放掉", "使得接下来的行参还有局部变量", "都能够释放掉 回复到一个正常的位置去继续去执行", "那么这就是C的函数调用的一个大致的实现", "这里面需要注意", "我们这里面用了很多push操作", "push操作其实是说把这些参数是用内存放在栈里面", "栈是内存的一块 所以是放在栈里面运行的", "其实为了效率更高", "把参数 或者函数的返回值", "也可以通过寄存器来传递", "同时效率更高一些", "取决于我们的编译器生成的调用的一个规则是怎么来做的", "另外不是需要去保存恢复所有的寄存器", "因为在执行的过程当中", "你可能用不到所有的寄存器", "你可能只是破坏了一部分寄存器", "所以我们前面说 最开始做保存寄存器", "后面做恢复寄存器的时候", "寄存器并不一定是所有的", "这主要是为了简单而做一个表述", "这里面如果提高效率的话就不需要这样", "好 如果大家对这个栈的执行过程有一个更深入的了解的话", "我们可以去返回下面一个网址", "更进一步去看看相关的一些信息", "这是关于C的函数调用这一块", "给大家介绍到这"]}, {"name": "", "block_id": "19d5e9bdefa24e70937e42fbd33be047", "text": ["下面我们来讨论另一个", "经典的同步问题", "那这就是我们这里说的", "读者写者问题", "读者写者问题呢", "是我们在计算机系统当中", "经常碰到的一个经典问题", "它存在于数据库等很多", "共享资源的访问当中", "所谓的读者写者", "是指我们对共享数据的访问", "有两类使用者", "一类是读者", "他是只是读取数据不会去修改", "另一类是写者", "他可能会读和修改", "读的时候呢", "我是可以多过线程同时读", "写呢 那是我不可以同时写了", "因为一段数据", "你A和B同时往里写", "各写一部分", "最后写出来结果是谁也没法用的", "好 针对这种情况呢", "我们需要在各个线程之间进行同步", "那我们把这个问题抽象出来呢", "就是我们这里的读者写者问题", "那这里头我们到底", "有些什么样的原则呢", "首先第一个 读读允许", "也就说在同一时刻", "允许多个读者同时进行读操作", "第二条是说读写互斥", "如果有写者正在写", "那这时候你读者去读是没有意义的", "因为他可能正写个半截", "你读出来东西也不完整", "你没有意义", "另一种情况呢是", "没有读者的时候你才能写", "因为如果有读者在读", "你这时候就写", "那么你写了一半的过程当中", "读者读到数据一部分是旧的", "一部分是新的", "那这时候这个数据呢", "拿到一起来也是没法用的", "第三个呢 是写写互斥", "也就说两个写者", "同时往里写数据", "这也是不允许的", "因为A写一部分", "B写一部分", "写出来的结果呢它是不可用的", "这是我们读者写者问题", "所要遵守的三条规则", "依据这三条规则", "我们来看如何用信号量", "实现读者写者问题解决方案", "在这里头呢", "我们把刚才这些约束", "描述成信号量", "首先第一个呢 是读写互斥", "当然 读写互斥也负责", "写者与写者之间的互斥", "某种程度上来讲", "你可以认为它就是一个临界区", "但是临界区和这儿有点不一样", "这一块访问的时候", "多个读者是可以一起来访问的", "作为互斥的话它的初值是1", "然后还会再有一个计数", "这个计数呢 Rcount", "它是用来记录", "正在进行读操作的读者的数目", "它的初值呢是0", "还有一个就是信号量 CountMutex", "这个信号量是用来保护读者计数的", "也就说如果我一个读者开始读", "那么这时候呢它要把这个计数加1", "如果说多个读者前后脚进来", "那么它们同时对这个", "计数进行加1的话", "就有可能这个计数会出问题", "它们俩之间也需要协调", "好 这时候的访问呢应该是互斥的", "所以我们就有CountMutex这个信号量", "它是用来保护", "读写计数的互斥修改", "这时候呢任何时刻", "只允许一个线程", "可以来修改这个计数", "所以这个初值呢也是1", "有了这三个变量之后", "我们来看 我们实现的", "读者写者的解决方案是什么样的", "在这儿呢我们给出了", "读者进程 写者进程", "两边要做的核心操作一个是读", "一个是写", "那我们要进行", "互斥保护这事做起来比较简单", "两边都加上互斥信号量的", "P操作和V操作", "这是写者", "它可以理解为", "完全是一个临界区问题", "在读者这头呢", "我们如果说跟写者相对应", "它也是一个临界区", "前面一个P操作后面一个V操作", "但是它有一些不同", "就在于我如果第一个读者", "进来的时候申请P操作", "跟写者进行互斥", "第二个来的时候", "它就不能那么申请了", "所以这个申请操作呢", "只是对于第一个读者", "所以我会在前面呢加一个判断", "如果说当前的读者计数是0", "第一个读者进来的时候", "他需要申请", "然后第二的话他就不用了", "第二个就相当于", "他只需要计数加1", "也就说第一个进来的时候", "不断申请并且计数加1", "初始值计数是0", "那他就变成一个", "好 第二个来说只加1", "等他出来的时候呢也是一样的", "计数减一这是每个都要减的", "但只是对最后一个离开的读者", "他才需要释放这个", "读写互斥的这个信号量", "好 这样的话以便于后边的", "写者可以开始写操作", "那这时候说我们刚才读者计数", "这个数的修改呢也需要保护", "那这时候我再在前面", "加上一个计数的信号量 CountMutex", "底下这个地方呢也是一样的", "有了这些操作之后", "我们再来对照说", "这是不是能满足", "我们前面说的三条原则", "仔细核对每一种情况", "这时候是满足的", "我们在满足前面三条的基础上", "我们看我们这个实现办法", "还有些什么样的特征", "大家看一下如果说", "我一直在里头有读者在读", "后面的读者是一直能进去的 对吗", "如果这个时候", "有一个写者申请写 会是什么情况", "那它就等着呢", "一直等到什么时候呢", "等到所有的读者全部离开", "如果说有一个读者在里头读", "这时候下一个读者又进来了", "好 那这时候他先于那个写者的", "头一个读者离开", "也就说后来的读者一定是会先于", "等待的写者进行读操作的", "那对于这种情况呢", "就是我们这里说的读者优先", "读者优先呢", "在某些情况下是有意义的", "比如说我们在这里头", "我读数据更是", "我优先级高这是可以的", "但是对于通常的数据更新来讲", "我们希望读到的数据", "都是最新的数据", "所以这时候呢我们希望是写者优先", "这就是我们这里说到的", "读者写者问题的两种优先策略", "一个是读者优先", "只要有读者正在读", "后续的读者就可以直接进入", "在这种情况下呢", "只要读者是持续不断地进入", "写者就处于饥饿", "而另一种策略呢是写者优先", "只要是有写者就绪", "那么写者就应尽快执行写操作", "这句话的意思是", "后来的读者就必须阻塞", "如果说有写者持续不断地写入", "那么这时候呢读者会处于饥饿状态", "这是两种不同的优先策略", "那这时候问", "这种如何来实现", "还有没有其它的优先策略", "那实际上还有", "就是我两边公平的", "有读者就绪了", "那么写者不能往里写", "有写者就绪了读者不能往里写", "这时候两边工程也是可以的", "那这些做法呢如何来实现", "就请同学们下去思考了", "这是我们用信号量来实现的", "读者写者问题", "那接下来呢我们用管程", "来尝试一下解决读者写者问题", "我们说管程是把", "你的这些同步操作", "封装到一个类里头", "这就是我们管程", "对于读者写者问题呢", "我们对外提供的基本方法有两个", "一个是读", "如果说在前面已经有写者", "我一直等到写者结束我开始读", "出来的时候呢", "我看是不是有其他的写者", "而另一个呢是写操作", "看前面有没有读者或者写者", "如果没有 他开始写", "写完之后看有没有另外的读者", "或者写者 把他们唤醒", "让他继续进行操作", "这时候我在管程里", "我维护一些什么内容", "我维护这样四个变量", "当前正在读的读者", "当前正在写的写者", "等待读的读者", "和等待写的写者", "这四个它有一些关系", "你比如说正在读和正在写", "这两个只会有一个是大于0的", "好 那等的呢", "可能都会大于0都有可能的", "好 然后我们在这儿呢", "管程里头设置一个锁", "然后我们设置两个条件变量", "一个是可以去读", "一个是可以去写", "我们看详细的方法如何来做", "那我们刚才说", "对外提供一个开始读一个完成读", "这是对于读者这一头的", "它内部的实现呢", "对于管程我们都会申请", "管程的互斥访问", "这是一开头 一结尾", "在内部呢 它开始读的时候呢", "一定是当前正在读的计数要加1", "那在什么时候会进行等待呢", "判断条件然后把它", "排到等的队列里头", "等的计数加1", "并且排到这个条件变量上", "等它出来的时候呢", "等待读的计数减1", "那关键的问题是", "在这里我加什么样的条件", "这个条件呢又体现出来", "我们到底是对读者优先", "对写者优先 还是两边公平", "我们在这儿呢设的条件是", "如果说正在有写者在写", "或者说有写者在申请写", "那这时候呢", "我就进入等待队列", "也就说写者是优先的", "只要有写者它都优先于这个读者", "好 然后它完成读的时候怎么做呢", "申请互斥访问管程 这是一样的", "然后计数减1", "然后关键的问题是说", "我需要唤醒哪一些", "那么这个唤醒的条件不同呢", "也体现你优先策略不同", "我们在这儿设的呢没有读者", "那这时候最后一个读者", "是不是有写者等着", "如果有写者等着", "那我就让他释放了", "另一头呢是写者这头", "我们也是开始写 完成写", "这两个需要你实现一个操作", "那具体来说呢", "申请和释放管程的互斥访问", "这个都是一样的", "开始写的时候", "当前正在写的计数加1", "那他最多会是1", "好 在这儿之前他会进行等待", "等待的时候呢", "等待写者计数加1", "并且加入到等待队列当中", "这是这里的条件变量", "好 关键问题也是一样的", "那地方的条件", "我们在这儿设条件呢是", "有正在写的写者", "或者说有正在读的读者", "我就会等着", "也就说如果有等待申请读的读者", "我是不等着的", "好 这种情况呢", "就说明它是写者优先的", "而对于释放的这一头也是一样", "计数减1", "当前正在写的写者计数减1", "然后唤醒哪些", "这地方我们设条件是", "先优唤醒等待写的", "如果说你释放的时候", "另外有一个等待写的", "我优先唤醒它", "如果说没有等待写的 else", "我才去唤醒读者", "等待读的这些读者把它唤醒", "所以从这几个角度来讲呢", "我们在这个管程里是写者优先的", "好 我们从这儿可以看到", "基于管程的实现", "我们更方便的能够把这种", "优先策略呢体现出来", "这种优先策略体现", "也是比较直接的", "所以从这个角度来说呢", "管程是简化了", "处理同步问题的实现方法", "好 今天的课呢就上到这里 下课"]}, {"name": "", "block_id": "744f70ae146d4cf88c03026e51148eda", "text": ["好 接下来我们介绍置换算法", "首先我们来介绍局部置换算法", "也就是说假定给一个进程的", "物理页面数是已经确定了", "那在这些页面里头呢", "我们来进行置换", "那第一个要说的置换算法呢", "是最优置换算法 最优置换算法呢", "它的基本思路是说", "我在任何一次缺页的时候", "我会去观察", "这内存当中存在的各个逻辑页", "它在未来什么时间会被访问", "那我们要置换的是在未来", "最长时间不会被访问的这个页面", "那这个思路我们怎么来做呢", "它的做法是这样的", "缺页的时候我来计算内存当中", "每一个逻辑页面的下一次访问时间", "假定你能计算出来的话", "然后我去看 比较它们的大小", "未来最长时间不访问的页面", "就是我要被置换的页面", "那这个思路很简单", "你把内存当中的所有逻辑页面排序", "排序的依据是下一次访问的时间", "然后最长的那个就是你要置换的", "那这种算法呢 它思路很清楚", "但是它的特征呢", "这是缺页的次数最少的", "但是它也有一个致命的问题", "就是它没法实现", "原因在于我无法预知该逻辑页面", "它的下一次访问的时间", "到底是在什么时候", "在这之前我要等多长时间", "实际上如果我知道那个", "等的时间有多长的话", "那我就把等的时间最长的那个", "放到外存里面去 这是最理想的", "但是这种做法呢", "为什么我们还要在这说", "实际上就是因为它可以作为", "其它算法性能评测的依据", "也就是说你设计了一种置换算法", "能跟这个最优置换算法相比", "你比它差多少", "那你最好是能达到它的状态", "你不会比它再好", "所以在这用它来", "作为评测依据是比较好的", "那具体怎么做呢", "是说我在模拟器里头运行该程序", "假定它的对外界的影响都是固定的", "好 那这时候我记录下", "它每一个页面的访问的情况", "第二次我再来运行的时候", "我就得到它的最少的缺页次数了", "那另设计一个算法和它比较", "你就能知道这个算法的好坏了", "这是最优置换算法", "那我们在这用一个例子", "来说它到底该怎么做", "在这里呢 上边是时间的顺序", "中间这一行", "是请求访问的页面的顺序", "这是逻辑页的编号", "我们用A B C D来表示", "好 这地方呢", "是物理内存分配的页面数", "那在这我们假定", "给它分了四个页面", "然后底下我们来记录", "它缺页的情况", "那我们执行起来会什么样子呢", "首先执行第一次请求访问C", "那这时候呢没有缺页", "第二次也没有 那我都能访问", "第三次D也能访问", "第四B在这里也有", "那我们这些都没问题 正常访问了", "等到你访问E的时候就会发现", "这时候不在你的物理内存里头了", "产生了缺页", "那在缺页处理例程里头呢", "我们就会引用最优置换算法", "最优置换算法就来判断", "当时我这几个选哪一个呢", "那我们就看在未来的时间里头", "它都会在什么时间会被访问到", "好 那我们看内存里有A", "A会在这地方访问到", "好 B是在这 C是9 还有个D是10", "这几个比较起来呢", "10是离的最远的", "那我们在这就把", "这个10对应的D给替换掉", "那替换完了之后结果", "就是把D变成了E", "好 那我这个缺页中断处理呢", "就处理完了", "回来你再来访问", "这个就算是成功了", "好 继续访问B没有问题", "访问A也没有问题", "再访问B也没有问题", "再访问C也没有问题", "好 那这时候说我们再访问D", "那这时候呢", "这个D又不在这里头了", "那这时候怎么办", "我们接着说未来会访问", "但是这时候已经再往后", "它的未来已经结束了", "那就你说什么都可以了", "所以在这呢", "后边你再怎么置换都无所谓了", "所以在这 最好的情况", "你是缺页两次", "那其它的算法你写完之后", "就看跟这两个比较", "在对于这个特定的序列", "谁好谁坏就清楚了", "那这是最优置换算法", "那它的毛病是在于", "我在缺页的时候", "我没有办法知道", "后边到底是什么样的访问", "特别是你比如说我的一个程序", "每次处理的时候", "它的数据是不一样的", "我们前边说", "你可以重复两次来用", "但是我通常情况下", "我们的程序每次执行的时候", "它处理的数据都是不一样的", "好 这个序列你也是没办法", "完全准确的预测出来的", "这是第一种做法", "那么第二个做法呢", "是先进先出算法", "FIFO那它的做法呢", "是我们想知道未来的情况 没办法知道", "那我们就采用一种最简单的做法", "那谁来进来 我按照进来的顺序排", "这实际上我们在很多地方", "我比较不出谁更好谁更坏的时候", "我们就按照先来后到", "这是我们在做各种各样算法的时候", "一种最基本的做法", "那它的依据是说", "在内存驻留时间最长的页面进行替换", "也就是说我第一个进来", "那它的时间是最长的", "最后一个进来它的时间是最短的", "好 那怎么做呢", "那维护一个逻辑页面的链表", "按先来后到的顺序 按驻留时间排序", "好 在头上的呢 是最长时间的", "你置换的时候就从头上选", "然后最先进来的呢 放在最后头", "那缺页的时候呢", "我从链首取相应的页面进行置换", "新加的页面呢 放在链尾里头", "那这种做法呢 它的麻烦是什么呢", "是性能比较差", "好处是我比较好实现", "性能比较差怎么说呢", "就是因为它只是按照", "你进内存的先后顺序再排序", "有可能你会出现这样一种情况", "我刚把一个页面拿出去", "它是在这里待的最长时间的", "好 你马上就会去用它", "如果说我们出现这种极端的情况", "那这时候呢 它的缺页率就会很高了", "好 甚至于会出现这种情况", "这种FIFO算法", "它可能会出现什么呢", "我分配它N个页面的时候它缺页M次", "我把它N+1之后", "可能那个通常情况下", "我们理解一个算法", "我分配的物理页面越多", "它的缺页次数应该更少 但这时候呢", "它有可能缺页次数不但不减少", "反而会增加", "这是我们后边说到的Belady的现象", "这个时候呢", "实际上从另一个角度上说明", "这个算法它是有缺陷的", "好 通常情况下呢 这种算法呢", "我们不会直接把它", "作为一个独立的算法来用", "它会把它揉到别的算法里来用", "所以我们在这还会继续去说它", "那我们也通过一个示例来说明", "FIFO的执行过程", "假定我这个进程分配了四个页面", "然后我维护一个链表", "然后在这依据它访问的顺序", "我来判断", "那这是我们刚才那个例子", "我们接着分配给它四个页面", "看看在FIFO算法里头", "它会缺页多少次 那在前边呢", "这地方先访问这四个页面没问题", "它肯定都在 这个你用哪个算法呢", "它的效果都是一样的", "好 开始不一样的地方是在这", "我在访问E的时候呢 它产生了缺页", "在最优算法里头", "我们是依据后来做判断的", "现在我得不到这个了", "我根据什么 我根据它进出的顺序", "在这我假定它进内存的顺序", "是按照A B C进来的", "那这样的话很容易", "我就知道我要用A来做替换", "替换完了把A换成了E", "好 然后后边再访问的时候", "B在里头访问得到没问题", "A这时候又缺页了", "这时候缺页怎么办呢", "我又要进行替换", "替换我选的内存当中的页面", "选哪一个呢", "选这里头时间最长的", "A进来之后 E实际上是排在最后的", "那这时候呢", "我把B替换了 B替换成A", "然后这个时候呢 再下一个", "我又访问了B 正好不错", "我刚拿出去就访问它了", "再访问B的时候", "这时候我有A E C D这几个", "按照先后顺序是C D E A", "好 那我们这个时候呢说我们换C", "好 把C换了", "然后到这来了之后呢", "再下一次访问C 它又出现缺页", "那么这时候呢 我们看 这内存有哪", "D E A B是这个顺序", "那这时候我们换D", "换完之后是这样一个结果", "然后我再换 再下一步", "那这个地方的时候呢", "我们看到这时候D被换出去了", "这里头E A B C 那这时候要换的是E", "那到这我们这个访问序列执行完毕", "我们看缺页几次", "1 2 3 4 5 5次", "和我们最优算法的两次", "比较起来它多了", "那你说你在这里头构造的这个例子", "正好是极端情况", "你刚把哪一个拿出去", "你下边就要访问哪一个", "那当然会是这样 那这时候是说", "是不是我任何一个算法", "都可能构造出一个极端的例子", "你的性能会很差 那实际上这个呢", "从理论上我们是可以证明", "最优算法它的这种特征是最好的", "好 这是FIFO算法", "那这种算法呢 它实际上过于简单", "那接下来我们说", "我是不是可以把这种简单的算法和", "不可实现的算法之间", "做某种程度的折中呢", "这是第一种折中的办法", "最近最久未使用算法 LRU", "那它的做法是什么呢", "我们刚才考察未来的引用情况", "这事我没有办法考察得到", "那怎么办 我们去考察过去", "选择最长时间没有被引用的", "也就是说我们原始考察当前时间点", "往后最远被访问到的", "我把它置换出去 那现在呢", "我是过去的情况我是可以统计的", "我在当前这个时间点", "看过去在内存当中", "这些页面的访问情况", "离的最远的那个", "最长时间没有被引用的", "我把它置换掉 这是可能的", "这种做法的依据是什么呢", "这种做法的依据是在于", "我们通常情况下认为", "在过去一段时间经常访问的页面", "那在未来也会经常访问", "在过去一段时间很少访问的", "在未来也很少访问", "基于这样一种假测", "我们依据过去来预测未来", "好 那这是它的思路 它怎么做呢", "缺页的时候我去看在内存当中的", "每一个逻辑页面", "它的上一次的访问时间", "那这个时间我是可以计算出来的", "计算出来之后", "上一次访问到当前这个时间", "最长的那一个那就是最远的", "那一次被访问者", "我把那个页面置换出去", "好 这样做法之后呢", "它有什么特征呢", "它是最优算法的一种近似", "但是这种算法仍然足够复杂", "以至于我们在这里要实施的话", "是不太可能的", "好 那这次说我们在这里头说的LRU", "我们也通过一个实例来看", "刚才这个序列它的执行情况", "那在这呢", "前边的几个正常情况下都没问题", "C A D B 这访问完了", "然后下一个E出现缺页", "那这时候呢 我们要去考察", "过去一段时间这几个的引用情况", "那我们看A在哪访问 第二个", "B呢 是第四个", "C呢 是第一个 D呢是第三个", "这个顺序和我们的最优算法很相像", "区别在哪", "区别在于最优算法是往后考察", "最近最久未使用算法是往前考察", "然后得出它上一次访问的时间", "然后我选其中最小的那个", "这里头是C 好 我替换C", "好 替换完的结果呢是这样的", "好 然后再继续往下走", "B访问在里头 A访问在里头", "B访问还在里头 C访问的时候", "那这时候又出现缺页了", "那这时候我们说我们又需要", "按刚才一样的做法去考察", "在内存当中的A B E D这几个", "它的上一次访问时间", "那怎么考察呢", "我们看这是A上一次访问时间是7", "B上一次访问时间是8", "然后E上一次访问时间是5", "然后还有一个D上一次访问时间是3", "那这时候比较下的结果呢", "这个D是最早的 我们把D替换掉", "替换成我这里的C", "替换完的结果呢 是这样的", "好 然后这时候说", "我接下来执行下一个 那这时候呢", "访问到的D正好是刚被替换出去的", "你又要出现缺页", "那这时候按照我们最优置换算法", "因为最后一个没有未来了", "给哪个都一样 实际上也是这样的", "但是在最近最久未使用算法里头呢", "我们就需要去看", "过去一段时间它的情况", "当然我们知道这种考察呢", "实际上对未来的执行是没有意义的", "从这个角度来说呢", "这个LRU 在最优算法的", "近似的过程当中", "它也有不准确的地方", "所以它是个近似", "好 我们看这时候呢", "A是7  B是8  E是5", "那唯一变化的就是这个C", "那它是9 这几个我选择下来呢", "这个E是最早的一个 我把它替换", "那这是替换之后的结果", "那我们看到在这里头呢", "它的缺页次数是三次", "和我们前边说到的", "先进先出算法要好很多", "和最优算法比较它又多一次", "那这是最近最久未使用算法", "那我们看到 实际上它处理呢", "是比较复杂的 在缺页的时候", "我要把所有内存的页面", "全部去统计一遍 那这个统计呢", "有可能你是在缺页的时候", "你再来做这个统计", "你已经统计不出来了", "所以这个统计呢", "应该是落实到你每一次访问的时候", "你才有可能统计得出来", "好 那这个呢", "我们就说到下一个它的实现办法", "第一种实现办法呢", "是我构造一个页面的链表", "那在这个链表里头呢", "它的排列顺序是按照", "最近一次访问的时间来排序的", "然后是链表的首结点", "是最近被访问过的", "链表的尾结点是最久未使用的页面", "好 然后在这里访问页面的时候呢", "每一次访问", "我都把访问到的那个页面", "把它从这个队列链表里摘出来", "放到它的链表首部", "然后缺页的时候怎么办呢", "缺页的时候我从最后一个", "来作为我选的这个缺页", "不像我们刚才给的那个表里头", "我是到每次缺页的时候", "再把那些重新计算一遍", "而把这件事情落实到平时当中", "每一次访问的时候来做这件事情", "但是这样做呢", "实际上你每一次访问的时候", "它的开销是很大的", "好 再一种做法呢", "是说我做成一个活动的页面栈", "思路都是一样的", "只是实现的手段有一些区别", "那访问的时候我把这个页号呢", "压到栈点", "同时压完之后我要把栈内相同", "也就是说 以前访问到的", "同一个页面的 过去的情况", "我就把它去掉了", "把这个结点从这里抽出来", "实际上这还是维护了", "跟前边一样的一个栈", "只是它做法是压进去之后", "把相同的页号抽出来", "那这时候我的链表的维护变少了", "但实际上这时候呢", "你压进去一个之后", "你要把整个这个队列呢", "完全的搜索一遍 去掉重复的", "实际上这个工作量仍然是很大的", "好 缺页的时候呢", "我从这个栈底的页面", "把它作为我被置换的页面", "好 那这时候呢", "说LRU算法它最大的问题是开销大", "那我们下边需要解决的就是", "我如何能让这件事情开销变的小", "我们先来看一下它到底", "都有些什么样的开销", "那我们用栈的方式来实现", "我们的最近最久未使用算法", "看实施的过程是个啥样子", "那我们前边说", "在最近最久未使用算法里头", "前面那个示例的时候", "我在访问的时候没有做任何事情", "现在我们把那个统计的事情", "放到你访问的时候来做", "那就会变成什么样子呢", "首先访问第一个页面", "那这时候我维护这个栈", "这里头只有一个元素", "好 我访问第二个页面的时候", "我就把这个页面作为压下一格", "在上边加上你刚才访问的这个页面", "那这就是这个栈里就有两个了", "访问第三步的时候 我再复制一遍", "然后把新访问的这个页面放到栈顶", "再访问B 第四次的时候再压栈", "这时候是刚开始没有缺页的情况", "缺页的时候访问E的时候", "它出现缺页 缺页的时候怎么办呢", "我们从这里头这个栈里头", "把最底下的那一个E", "这个C拿出来 把它置换掉", "然后把它换成E", "这个栈就是把底下那个取掉", "在顶上加一个", "实际上这个C在哪呢 在这个地方", "换完之后这个结果", "就把这个E换到C那去", "好 这是第一次", "那实际上我们在前边做些什么", "在这里维护这个栈", "是你平时访问的时候的开销", "好 正经到这缺页的时候", "我只需要从这里取出一个", "在栈顶再加一个", "那开销比我们前边做的时候呢", "已经要省事很多了", "好 再是访问B 那这时候呢", "从这里抽出来 把它放到栈顶", "这是你平常访问的时候需要的开销", "然后再访问A的时候呢", "那抽出来 把它放到栈顶", "那这是从最底下抽出来的", "所以移动的区域就会比较长", "然后再访问B的时候呢 一样的", "这时候抽出一个来放到栈顶", "好 再访问C的时候又出现缺页了", "那这时候怎么办", "把这D拽到最底下 把它置换出去", "然后把C放到D的位置", "那这是置换完的结果", "把C放出去", "好 然后再来 这地方呢", "到下一步再访问D的时候又缺页", "好 把这个E挪出去", "把这个D放到栈顶", "那这就变成这样了", "好 置换完的结果", "跟我们上一个呢 是完全一样的", "但是这时候呢", "我们跟前边的做法有什么区别", "前边的做法我到缺页的时候挨个去查", "现在我在每次的访问的时候呢", "做一些记录", "缺页的时候我只需要看一下", "这个数据结构我就可以换了", "那这种做法呢", "我们看到平时的这个开销是很大的", "特别是在这个地方", "你要把这个栈整个捋一遍 移一遍", "然后把最底下的那个挪到最上边来", "这个时候的开销确实是很大", "好 那接下来呢", "我们还会再进一步的去讨论", "我怎么把这个算法做进一步的近似", "使得它访问的特征不是太差", "但是它的开销呢", "会大幅度的减少"]}, {"name": "", "block_id": "5efc8b3aae924b31a897ef552641d92b", "text": ["这节课 我们来讨论文件系统", "文件系统呢是我们在操作系统当中", "负责持久数据保存的子系统", "我们在这里呢", "会首先介绍文件系统的基本概念", "然后是虚拟文件系统", "虚拟文件系统负责完成", "多种物理的文件系统", "它们之间对上提供的统一接口", "接下来一个部分呢", "是文件缓存和打开文件", "也就是说我在文件在读写的过程当中", "操作系统内部", "需要维护些什么样的信息", "那是在这部分里讨论", "接下来的三个部分呢", "是文件分配 空闲空间管理", "和冗余磁盘阵列", "这几个部分是", "讨论磁盘上存储数据的方法", "我们下面首先来讨论文件系统的概念", "首先什么是文件系统 什么是文件", "文件系统是操作系统当中", "管理持久数据的子系统", "在这儿呢它提供了", "数据存储和访问的功能", "具体说起来呢", "它是如何来组织持久保存的这些数据", "这些数据的组织", "放到文件系统当中的数据", "我如何来进行检索", "检索到了之后", "对于里头的数据我如何对它进行读写访问", "这是它的基本功能", "在我们现在用到的计算机系统呢", "大多数都有文件系统", "也就说你的这个计算机系统里", "只要涉及到数据的持久保存", "那么通常情况下它都会有文件系统", "广义的来讲呢", "我们现在用的谷歌它也是一个文件系统", "它在这里负责网上大量数据的保存和检索", "在这里头它最主要的功能", "还是在这里信息的检索", "什么是文件呢", "文件是具有符号名", "由字节序列组成的数据项的集合", "这里主要一个特征它是有文件名", "然后它的基本组成是一个字节序列", "文件是文件系统的基本数据单位", "也就说我存到文件系统当中的数据", "最小这个单位是以文件形式来存在的", "在这里头文件的名字呢", "是文件的标识符号", "我们在标识一个文件的时候", "通常情况下就用文件名来表示", "文件系统的功能呢", "我们有这样几个方面的功能", "首先第一个是为文件分配磁盘空间", "也就是说我在这里头管理一个文件", "它到底存在磁盘上的什么位置", "除了位置之外我们还会再有一个顺序", "这是已经分配给", "用来存数据的这些文件块", "再有一个呢是空闲空间的管理", "在磁盘上有很多的数据块", "可以来存储数据", "那么在这些数据块呢", "没存数据的时候", "这些数据块都分布在什么位置", "这是我们这里头", "管理空闲空间需要解决的问题", "我们需要记住它的位置", "我们在这里不需要它的顺序", "因为空闲的空间里头呢", "这个顺序对于我们来说是没有意义的", "再有一个是分配算法", "跟我们前面讲到的", "内存管理有类似的地方", "我在磁盘上有很多的空闲的磁盘块", "这时候我要分配一部分磁盘块", "来存文件数据的时候", "这时候我选哪一块", "这地方选择策略呢", "就是我们这个分配算法", "第二项功能呢是管理文件集合", "我有很多文件之后", "这些文件我怎么来管理它", "首先在这里要提供的一项功能是定位", "也就是说我给你一个文件名", "你需要告诉我", "这个文件名所对应的文件在哪", "找着它的位置读出它的内容", "这是定位需要做的", "第二个功能是说命名", "我们需要根据名字来找到文件", "这个名字你比如说在计算机里头", "我们很多时候是用数字来表示", "但这个数字呢对于人记忆是不方便的", "而我们的文件系统里头", "持久保存的数据呢", "通常情况下是要人能理解", "这时候我们会给它一个命名", "命名的方式在不同文件系统当中", "它有一些不同的做法", "和相应的一些限制", "第三个是说", "我如何把这些文件组织成一个整体", "那就是我们的文件系统结构", "文件的组织方式", "不同的需求这种组织方式会不一样", "第三个是说我持久保存数据", "就有一个数据可靠和安全问题", "首先安全是指文件系统里", "通常情况下从多个层次", "提供了数据安全的保护机制", "这是第一个", "第二个是可靠", "也就是说我的数据要想持久保存", "如果说在保存过程当中系统崩溃了", "存储介质出错了 或者说有其它攻击", "这时怎么办", "在文件系统里呢", "也会提供一系列的机制", "来对可靠性进行某种程度的增强", "这是文件系统提供的几个功能", "那这时候说我们对于文件", "我有一些什么样的描述", "这就是我们这里说到的文件属性", "文件属性是指我们前面已经说到的名字", "除了名字之外 还有其它一些信息", "比如说这个文件是什么类型的", "是一个可执行文件", "是一个文本文件等等这样一些信息", "然后这个文件存在什么地方 它有多大", "什么样的用户可以对它进行访问", "这是我们这里保护机制", "这个文件是谁创建的", "最开始的创建时间", "和最后一次修改的时间", "或者说最后一次访问的时间等等", "这些呢 在不同的文件系统里头", "维护了不同的文件属性", "这些属性呢起什么样的作用呢", "实际上在这里头", "这些属性是为了方便访问的", "为了更好方便访问", "把文件里的信息呢分成两部分", "一个是文件头", "文件头是存在文件系统元数据当中的", "文件信息", "这里存的主要内容是我们这里的属性", "和文件的存储位置和顺序", "有了这些文件头的信息之后", "我就能知道", "我要读写的文件数据到底在哪", "是些什么"]}, {"name": "", "block_id": "5bf6919b1ff840c6b020a1d39a83d43b", "text": ["下面我们通过一个", "生活当中的例子", "来说明同步的问题", "和相应的解决办法", "在计算机里头和生活当中呢", "实际上有些问题", "我们是可以来进行类比的", "这种类比的办法呢", "可以我们利用生活当中的常识", "来帮助我们理解", "操作系统当中的同步问题", "当然你在做这件事情时候", "也需要想到", "计算机和人之间的一些区别", "比如说我们在进行协调的时候", "我们人的一些假设前提", "和计算机是不一样的", "所以这时候呢", "他们的处理也会不一样", "好 我们先看一个例子", "这是一个家庭采购的例子", "说一家里头", "我们冰箱里头", "放有各种各样的食品", "好 那这时候问", "如果说冰箱里东西吃完了", "那这时候怎么办", "那家里的成员会说", "我去看冰箱里有没有面包", "如果没有", "那我就离开家去商店去买", "那到达商店之后", "买完再回来把它放进冰箱里头", "这件事情就算行了", "我想我们很多家庭里呢", "都是这样安排的", "但是在实际生活当中", "我们也可能会出现这种情况", "第二个人进来之后", "由于时间错开一点", "头一个人在去商店的路上", "第二个人呢开始看冰箱", "这时候他们俩没打照面", "当然你说我们俩", "去同一个商店买的路上会碰到", "那这事没有了", "但是每家基本上", "都会碰到过这种情况", "我买重的时候", "好 那这样的话这种情况", "我们怎么解决", "那你说我在家里通常情况下", "很少量的几次重复", "我们是可以接受的", "但是对于计算机来说", "这件事情是不好办的", "我们怎么能够把", "这件事情的协调做得", "很成功和高效", "那这时候呢", "就有这样几个条件", "一呢是冰箱里头没有面包之后", "我必须有人去买", "就说有人看到冰箱里没有了", "那他就会去买", "第二个呢是说", "我最多只能一个人去买", "因为如果说多个人一块去买的话", "这时就会买重", "那怎么解决这个问题呢", "那说 这是一种很极端的做法", "说我在冰箱上加一锁并且有一钥匙", "那买之前呢我把冰箱锁上", "然后我回来放进去之后", "我再把它打开", "好这样一来的话", "第二个人来看冰箱已经锁上了", "那这时候呢他就不会再去买", "那这时候说", "这种解决办法好像", "在我们生活当中不会这样做", "那比如说这里这种情况", "你把冰箱锁上仅仅是为了面包", "实际上冰箱里还有别的东西", "那别人想取别的食品的时候", "那它也取不出来了", "所以这种做法呢", "对于我们来说是不恰当的", "那我们需要在这里呢", "来讲解决办法", "我们怎么来做呢", "首先想到的一个办法呢", "是在冰箱上贴一便签", "然后用这个便签呢", "表示有人去买面包去了", "其他的人看到这个便签之后", "他就不会再去买了", "这一种做法", "我们把它比较具体地描述出来", "就是采购之前", "我留下一张便签", "完成采购之后我把便签去掉", "那别人看到便签的时候呢", "他就不去买了", "这是我们的自然语言描述", "然后我们把它变成伪代码的形式", "就是这样的", "先检查是否有面包", "然后检查是否有别人留下的便签", "然后如果没有的话我就留下便签", "然后去买面包", "然后把便签去掉", "整个过程结束", "那这时的问题是说", "如果用计算机来执行", "这段代码它有效吗", "那我们在这里呢说它会有麻烦", "仍然是偶尔会出现买多了情况", "那什么情况下会出现买多呢", "说 检查面包和检查便签之后", "在你贴便签之前", "如果有其他的人来", "检查面包和便签的话", "那这时候它也是没有的", "好 这时候呢", "就会出现两个人一块去买", "那你说在生活当中", "我检查便签有没有和", "往上贴便签这件事情", "两个是挨着的", "如果另外一个人来检查的话", "我们会看到", "但是把它放到", "计算机程序里来运行的时候呢", "你两个进程交替执行", "检查和后面的设置", "它俩是没办法做到这一点的", "所以在这儿呢", "这在生活当中", "这种做法就是有效的", "而在计算机里呢", "这种做法就是会有麻烦的", "好 我们下面具体来看一下这个麻烦", "首先是两个进程A和B", "第一个呢做检查", "检查是否有面包", "检查是否有人贴便签", "然后这时候呢做了进程切换", "切换到另一个进程B", "它检查有没有面包", "检查有没有便签", "这两个进程的检查结果", "都是没有面包没有便签", "好 那这时候它们会做什么", "那都会去采购", "好 这时候又切回到A", "它就留下一个便签然后去买面包", "好 然后这边呢", "也留下一个便签也去买面包", "这时候我们看到有啥麻烦了", "这两个都会买重复的面包", "那你说在这里头你这么切换", "这两者之间这个间距", "是我们在生活当中碰不到的", "或者说很少碰到的", "好 那在这儿呢他就会出现", "所以这个地方有问题", "因为它会有间歇性的麻烦", "而这种错误呢", "它并不是在所有情况下", "每次运行都会有", "它会很难调试", "并且这时候你需要知道", "我在什么地方", "可能会出现调度", "所以这种方案呢是我们不理想的", "那这时候我们怎么办呢", "第二种做法说", "我把便签挪到前面去贴", "我先贴上便签然后再来检查", "这时候是不是就没问题了", "好 那我们把这件事情也转换成代码", "贴便签一前一后", "中间做检查", "没有之后去买面包", "这种做法行得通吗", "好 我们也来看具体的一种可能性", "贴便签 切换 再贴便签", "这时候大家就已经会", "察觉到一个问题", "两个都贴便签之后", "那么不管你怎么切换", "它都会检查有没有面包", "没有 或者是有", "好有没有便签", "他会检查有便签", "好 那他就不会去买面包了", "好 这边呢也是一样的", "检查有便签", "他也不会去买面包了", "好 那等到你最后一个回来", "这时候会出现什么情况", "我们这两个买面包的动作", "没有任何一个进程执行", "他们都出来了", "这时候我冰箱里也没有面包", "好 这时候我们就找到了", "一种情况它会失败", "那这时候呢会出现什么情况", "谁也不会去买面包", "那这样就没面包了", "好 说你把这个便签", "挪到前边来也不行", "刚才我们说放到后面不行了", "挪到前面也不行", "那这时候是啥呢", "说你检查便签的时候", "没有区分到底是谁留下的便签", "甚至于这种情况", "只有你自己在执行的时候", "他也没法买回面包来", "好 那说 我们在这里怎么办呢", "我们把便签做得更准确一些", "A留的便签和B留的便签", "我是不一样的", "好 那这时候呢", "就转到我们的第三种方案", "第三种方案呢", "是在便签上加上标记", "以区别这个便签到底是谁留下的", "这样的话我只检查对方的便签", "那这时候呢", "我们给出相应的代码", "那我们仍然是在", "检查之前留便签 两边", "留便签呢便签上有标记", "那从这里我们写伪码上来说呢", "这两边的代码已经不一样了", "但实际上如果说你加上相应的数组", "并且用数组下标", "作为你这个进程标识的话", "那这个地方的代码呢", "仍然可以写成是一样的", "好 在这种情况下", "留下便签检查是否有对方的便签", "如果没有检查是否有面包", "如果没有面包那我去买面包", "两边都是这样", "好 那这时候说", "这个做法能行得通吗", "好 我们看一个实际的情况", "在这里呢大家", "第一个进程先留下便签", "然后第二个进程留下便签", "我们看这种极端的情况", "它会是什么样的结果", "切回去这边再来", "执行这个代码的时候", "因为他已经有了对方的便签", "那这时候他不会去检查是否有面包", "然后直接出来了", "好 那这时候说", "到这边的时候呢", "他检查是否有对方的便签", "那有 那他也不会检查是否有面包", "好 那这样一来的话", "实际上两边都没有去检查", "是否有面包就直接出来了", "好 那这时候说会出现啥情况", "实际上大家都留下便签", "并且我这便签上", "也能区分出是谁留的", "但是这时候呢", "由于我留便签的时候是说你要去买", "双方都认为对方去买", "好 这时候麻烦就出来了", "这时候谁也没买", "好 那这时候怎么办呢", "那我们说我们再来做一个调整", "我在这里头呢", "这边A和B我们代码做了一些修改", "然后说你在这里头呢", "其中一个进程", "在检查到对方有便签之后", "那我就重复的检查", "一直到对方没有便签了", "而另一个进程呢", "仍然跟前面的做法是一样的", "跟我们前面方案3", "好 那这个办法能行吗", "那我们来解释一下看看", "他到底在什么情况下是行得通的", "比如说我们仍然是刚才那种情况", "前一个进程留下便签", "第二个进程留下便签", "然后两边进行检查", "那在前面程序里呢", "后边这个检查有对方的便签", "它就直接走掉了", "那这个时候呢由于两边不一样", "我头一个在检查的时候", "他检查对方留有便签", "这时候我不是走掉", "而是在这儿一直等待", "一直等到B把便签撤掉", "那我会在这儿", "好 等到B把便签撤掉的时候呢", "我们刚才说如果说这个B", "留下便签的时候在它的前面", "那这时候呢他会看到A留有便签", "所以他直接走掉了", "那这时候呢他检查一下", "然后看有A的便签", "那他就直接走掉了", "好 他没有去买面包", "而这时候呢A呢", "由于一直等到B离开 好", "检查完了之后说那这时候离开了", "B没有去买", "那这时候他再去看是否有面包", "没面包他去买", "那这样的话在这种情况下", "他是能够回来的", "好 那这时候我们看到", "这两个进程呢", "它的代码是不一样了", "这时候我也没办法换方式", "让它俩写成完全一样", "那这时候问", "我们刚才那种情况", "它能够避免掉了", "它还会再有别的问题吗", "好 实际上在这里头呢", "我们需要把它所有可能", "这种切换的组合都想一遍", "想清楚每一种情况", "它都能通过的话", "枚举完 那这件事情呢", "它就能通过了", "那这时候实际上我们在做", "同步互斥问题的时候", "很多时候是需要很仔细去想", "像这种分的情况", "你比如说在这里头", "我们会关键想哪条呢", "一个是什么时间留便签", "你比如说一边留便签", "另一边没有参与这件事情", "那这时候说我检查是否留下便签", "是否检查对放有没有便签", "对方不存在", "好 那这时候呢", "他就直接检查有没有面包", "他自己就会去买", "所以你只有一个进程", "A运行的时候没有问题", "能正常买回面包来", "好 只有一个B呢也能行", "好 那实际上我们重点需要关心的是", "这两个他们之间检查的时候", "留便签的时候有交互", "一种是说B在A之前", "那B在A之前的话", "那他在这儿留便签的时候呢", "这个B有可能留下便签之后", "他检查没有A的便签", "好 或者说刚好检查有", "好 刚好检查B没有便签的时候", "A没有留下便签的时候", "那这时候呢他会去买面包", "买面包的话", "A再来检查在中间", "在这个之后某个时间", "他会检查B如果这时候", "正在买的过程当中他会等到这儿", "等完结束之后呢", "后面再来检查的时候", "那这边已经有面包了", "他不会去买", "所以这种情况也是行的", "好 那这时候说我这个B在A之后", "并且是在你检查完之后", "你比如我检查这个B没有留下便签", "我就怎么去看有没有面包", "如果这时候B在这儿留下自己便签", "情况会是什么样", "大家可以仔细去想想", "那我们说通过", "各种各样的情况组合到一起", "那这件事情是没有问题的", "那这时候问", "这个做法怎么样", "好像枚举的情况很多", "我们想起来很不容易", "所以这件事情呢", "它是有效的 但是很复杂", "你很难去验证它的有效性", "这时候说 我们这样做之后", "它的麻烦是两头代码不一样", "略微有一点不一样的时候", "它结果就会差很远", "好 那如果说我有更多的进程", "这事怎么干", "哦 一想这个问题好像更复杂", "还有一个问题是", "A他必须在中间要反复的去查", "这时候呢他不能干别的", "就好比说我们要去打电话找一个人", "我打完电话之后不在", "那我再去一次", "在我们这里呢称之为叫忙等待", "那这种呢他是要占用CPU的", "好 这也是他的问题", "那这时候说", "我们是不是有更有效的办法", "好 那我们在这儿呢", "我们给出一种假定", "假定我能用原子操作实现一个锁", "那我们这事就好做了", "什么原子操作实现的锁呢", "这个锁呢有这样一个功能", "首先我申请的时候", "在锁被释放之前", "我一直处于等待状态", "一直到他获得锁", "如果有两个进程", "同时在等待这个锁", "那么这时候呢他只会有一个获得", "另一个呢还继续等待", "如果说我们能做到这一点", "那这时候呢", "并且把它实现成一个原子操作", "在这中间呢不会被暂停", "释放呢就是解锁", "并且唤醒处于等待状态当中的进程", "有了这两条实现之后", "我们给出一个代码", "这时候呢是基于原子锁的解决方案", "刚开始申请", "然后在这里判断是否有面包", "去买面包", "然后到最后的时候呢", "释放这个锁 解锁", "好 那这时候呢被我们标准化成", "这部分代码叫临界区", "前面这一段呢叫进入临界区", "后面叫退出临界区", "相应的这两段代码保护下", "中间在这个临界区里头执行呢", "就只有一个进程", "好 基于这样的办法呢", "我们这件事情呢就能做的很好", "好 我们看到在这个例子当中", "两个进程为了", "协调他们之间的操作", "那中间的关系是很复杂的", "那如果说我们系统里有更多的资源", "这件事情会变成啥样呢", "好 我们在这儿呢做一个归纳", "进程之间的交互关系", "他们对对方的感知能到什么程度", "我们在这儿呢分了三种情况", "一种呢是完全不感知", "一种呢是两者通过", "一个第三方来协调", "你比如说都要占用共享的资源", "然后再有一种情况是", "两者需要直接进行通讯", "那这三种情况对应着", "他们之间交互关系呢是这样的", "没有关系的时候", "他是相互独立的", "相互不影响", "如果说我有共享的第三方", "这里我们需要通过", "共享这个资源来进行协调", "如果说两者有直接通讯", "那么这时候需要", "通过通讯来进行协调", "好 那在这种情况下", "他们之间的相互影响呢", "第一个情况独立的", "对这方没有影响", "第二个呢是说他的结果", "依赖于共享资源的状态", "有可能一个进程占用了资源", "另一个进程要想", "使用这个资源的时候", "他就没办法使用了", "要么等到这个资源可以用", "要么这件事情他以失败告终", "而第三个呢双方通讯的时候", "这个结果就依赖于", "双方的通讯的结果", "好 那这时候呢通讯结果的不同呢", "他结果也是不一样", "好 在这个过程当中", "我们的进程之间呢", "会出现这样三种关系", "互斥 死锁和饥饿", "分别是指什么意思呢", "互斥是指一个进程占用了资源", "其它的进程就不能使用这个资源了", "那必须等待使用资源的进程释放", "那在这个过程当中呢", "资源的使用是互斥的", "第二个死锁", "死锁呢是多个进程", "各自都占有了一部分资源", "那这时候呢形成循环等待", "那各自占用一部分资源", "这种情况是允许存在的", "好 那等到某一个能够得到", "他所需要的所有资源", "好 那他执行结束之后释放资源", "好 这样的话这个", "部分等待其他的就能有资源", "到最后大家都用完了", "那这件事情出来", "如果构成一个循环等待", "就好比说我们在一个十字路口", "四辆车叉成一个井字", "好 那这时候呢所有的他就等的", "就谁也不让的话", "那这件事情就堵死了", "这种情况呢", "是我们这里说到的死锁", "还有一种情况呢是饥饿", "饥饿是指一些进程轮流占用资源", "而导致一个进程呢一直得不到资源", "比如说像我们前面说到的调度", "有一个进程占用CPU来执行", "但是它的优先级低", "而比它优先级高的进程呢", "又一直在运行", "那这样的话", "它就属于饥饿的状态", "好 那我们说在实际的操作系统里头", "由于我们有资源共享", "我们就会出现", "互斥 死锁和饥饿这些情况", "但是如果说我们想避免这种情况", "那我们资源利用效率呢又不够高", "好 所以我们在操作系统里头", "就要提供一组同步互斥的机制", "来在保证资源的使用率的前提下", "避免这些同步所带来的问题", "下面呢我们会具体来", "介绍它的各种各样的解决办法"]}, {"name": "", "block_id": "812ea1d6cec84a0c86a41719f2b10121", "text": ["接下来我们介绍全局置换算法", "那在前边讲的", "局部置换算法里头呢", "我们没有讨论分配给一个进程的", "物理页面数到底是多少", "而全局置换算法呢", "我们在这里需要考虑这个问题", "也就是说考虑到不同的进程之间", "它对内存需求量的这种差异性", "那具体做法呢 我们这给出了两种", "一种叫工作集 一种叫缺页率", "工作集置换算法你可以理解为", "是我们前边说到的", "最优算法在全局里的一种体现", "它们之间有一定的关系", "好 我们说在局部置换算法里头", "它没有考虑到不同进程之间的差异", "也就是说在某些情况下", "你可能多给进程增加一个物理页面", "可能缺页率就会大幅度下降", "那么在这呢 我们先举一个例子", "在这是以FIFO", "实际上即使用LRU也会有类似的情况", "这地方呢 是说我有四个页面", "然后你分配给它三页 那这三页呢", "由于我这访问比较分散", "你分配给三页的时候", "在这给出来的例子是", "后边这是一片的缺页", "那缺页的次数有九次", "但实际上这时候对于这种情况", "你给它四页多一页之后", "缺页次数就变成了只有一次", "实际上这一次还是说", "我们因为两者之间的差异", "我把这一次算到里头", "那实际上按道理来说", "你把这四页全给它了", "它就没有缺页了", "对于这种情况你多给它一页", "实际上这时候所带来的好处是很大的", "那我们需要在全局置换算法里面", "就是要考虑到这种情况", "那具体说起来我们怎么考虑呢", "全局置换算法就是", "给进程分配可变数目的物理页面", "那分配可变 可变的依据是什么呢", "可变的依据会是说进程需求的量", "那这个需求量是变化的", "那我接下来的问题是说", "你要依据这个需求的不同", "而给它分配可变的数目", "我这个需求我怎么来度量", "好 那针对这个需求呢", "它度量是这样的", "我们先对进程的内存访问特征", "做某种程度的分析 在不同的阶段", "它所需求的量是不一样的", "你比如说我一个排序程序", "我可能会分成三段", "刚开始的时候是数据读入", "那这是一段情况 然后后边是一段", "中间一段我是排序", "排完了之后 结果我把它输出", "这三个阶段 你从直观上来想", "它肯定是它们之间有很大的区别的", "那有了这个之后", "我们依据这种需求", "来给它分配物理页面数", "那这时候算法要讨论的问题就是", "如何来确定我给它分配多少", "你可以把这件事情分成两段", "一个是用来确定", "给进程分配的物理页面数", "另一个是说我到底是哪些页面", "也可以把这两个问题混在一起", "我不考虑到底分配多少", "分配哪一个 我把它搁在一起", "你需要的时候我就往里加", "这种方式也可以", "好 在具体讨论做法之前呢", "我们再进一步来分析CPU的利用率", "和并发进程数之间的关系", "这是一张图说纵轴是CPU的利用效率", "横轴是并发的进程数", "我们直观上想象会是说", "你只有一个进程的时候", "CPU的利用效率肯定是低的", "那我可以让多个进程并发运行", "随着并发运行的进程的增加", "这条线 CPU的利用效率是增加的", "但是这条线大家也可以想象", "它肯定没有办法无限制的增加上去", "好 那增加到一定程度", "这个时候你的内存开始紧张之后", "这条线就增加的没那么快了", "然后到某一个位置之后", "你再往上增加", "它有可能就会直线下降", "好 那这种关系体现成什么样呢", "这样来描述CPU利用率和并发进程数", "存在相互促进和制约的关系", "前边是促进 后边就变成制约了", "那我们需要让CPU效率提的好", "就是我得掌握一个合适的尺度", "那怎么叫合适呢", "也就是说我在这里头", "我需要考察它的状态", "进程数少的时候那是前边这一段", "它CPU效率提高", "好 进程数增加的时候", "那这个访存的也增加了", "那再增加的时候到这", "那我的局部性就下降了", "因为并发进程的使用", "导致我们切换之后", "你执行两个完全不相干的事", "那这时候它的局部性", "我们前边说那些就没有了", "至少两个进程之间是没有了", "那这时候呢 它就会导致这一段", "如果再继续增加", "那它就会CPU用更多的时间", "来进行缺页处理", "而这个缺页处理的增加呢", "就会导致你CPU利用效率的下降", "那这样我们就能", "把这条曲线解释清楚了", "如果说我们把这条曲线解释清楚之后", "我们想要达到的状态是什么呢", "尽可能让系统里的", "并发进程数对内存使用", "在这两者之间这个状态", "好 那对这种情况我们怎么来描述呢", "我们引入一个概念叫做工作集", "工作集是指进程当前使用的", "逻辑页面的集合", "那这里头比较诡异的地方", "是在于当前俩字 什么算是当前", "过去一段时间 过去多长时间", "好 那在这我们也给它一个近似", "实际上这已经开始有近似了", "把它表示成一个二元组", "W（t,Δ）那在这里头呢", "t是你当前的时刻 随着时间的移动", "那你当前正在使用的逻辑页面数", "它是会不同的 然后过去一段时间", "我会有一个定长的访问时间窗口", "那这里头呢我们有一个定长两个字", "正常情况下根据你的", "程序的特征的不同", "时间的窗口可能也会不同的", "但是在我们这个算法里呢", "这一段我就没考虑了", "好 我把它设置成一个定长的", "然后在这里头呢", "得到当前时刻往过去一段时间里头", "它访问的这些页面所构成的集合", "就是这里的W 那也是这里说的", "W是我们当前时刻之前的", "Δ时间窗口内", "所有访问的页面的集合", "那这时候呢 就把我们前边说的", "当前俩字给具体化了", "也就是说我做了个近似", "然后这里头页面的数的大小", "就是你的工作集的大小", "然后在这我们给了工作集一个定义", "那具体说起来呢", "我们在这给了一个示例", "说这是你的一个进程的", "页面访问顺序", "然后在这我给它定了一个", "时间窗口是10 就是这一段", "然后我们看在这一段时间里", "它访问了哪些页面", "从当前起头的状态来看", "这是1 2 5 6 7 这是当前这一段", "我们把这个时间轴", "随着时间轴往后移", "这里的状态是变的", "在某一段时间呢 它是相对稳定的", "到这 到这一段的时候", "基本上到最后就只剩3 4", "因为这一段它在访问3 4", "我们考察了两个时间点t1和t2", "这是它最后访问工作集的大小", "那从这可以看到 在不同时间段里头", "它访问的页面的数目是不一样的", "好 如果说我能根据这个来确定", "到后边这段的时候给它分配两页", "到前边这段的时候给它分配五页", "那这样的话就能很好的", "满足进程的这种需求了", "刚才我们给了工作集的", "定义和一个图示", "给出我如何来看到", "一个进程它实际的工作集", "那接下来呢", "我们看一下工作集它变化", "有些什么样的规律", "那这是一个示意图", "说横轴是时间轴", "纵轴是工作集的大小", "那随着这个进程的变化呢", "它这条曲线会体现出某种规律", "这些规律呢 我们把它分成这样几条", "第一个是说我在刚开始起头的时候", "进程访问的页面是增加", "然后到一个阶段逐步稳定 就到了这", "然后在这些稳定的阶段呢", "大致稳定这些区域呢", "基本上是理解为我在系统里头", "这个进程正在做某一件事情", "你比如说这里头数据采集", "数据处理和最后的数据展现", "那根据你当前做的事情不同", "它所需要的内存量", "工作集的大小是不一样的", "然后在两者之间做切换的时候", "这个工作集会有一个快速的", "扩张和收缩的过程", "那这里头呢 就对应着我这个峰值", "这个峰值和这个峰值", "如果说我们给出来的全局置换算法", "能够很好的近似这条曲线", "那我们这件事情做起来就相对容易了", "好我们来看怎么来做这件事情", "为了对工作集有个刻画", "我们在这定义了一个叫常驻集", "常驻集是指什么呢", "当前时刻进程", "实际驻留内存的页面的集合", "实际上我们用常驻集", "来对进程的工作集做一个近似", "工作集和常驻集是什么联系呢", "工作集是进程运行过程当中的", "固有属性 它是它的特征", "随着你那个运行的过程的不同而不同", "而常驻集是系统分配给进程的", "物理页面数和置换算法都有关系", "那实际在的这些页", "那我们这个置换算法要干的事情", "就是依据置换算法", "和进程运行的特征", "来确定我给常驻集到底有多大", "里头都有哪些页面", "好 具体做起来的时候呢", "我们是以这样一个做法来实施的", "这就是常驻集和我的缺页率", "也就是说我通过控制常驻集", "来影响缺页率", "那这个缺页率和常驻集有什么关系", "如果说常驻集包含了工作集", "也就相当于工作集里当前正在访问的", "这些面都在内存里 都在常驻集里头", "那这时候它的缺页率是比较小的", "如果说你在这里头", "进程正在执行的功能 模块有切换", "那这时候工作集会发生一个变化", "这个变化呢", "你需要去调整你的常驻集", "这时候缺页率会比较多", "如果说我在这里头常驻集", "达到一定的尺度之后 你继续去增加", "也就相当于你能够满足它", "当前功能需要的内存之后", "你再加内存 放的其它东西", "实际上这时候对它缺页率", "并没有明显的影响", "也就是说它不会明显的下降", "你这时候再给它分配多的页面", "这个效率是下降的 在这种情况下", "我们希望是CPU的利用效率提高", "整个系统的并发程度提高", "好 有了这几条之后", "我们就可以来讨论工作集置换算法", "它的思路是什么样的", "它的思路是把不在工作集的页面", "把它换出去 这跟我们前边的", "讨论局部置换算法不一样", "局部置换算法基本上是说", "我把缺的那一页拿进来", "这个时刻来靠把哪一页置换出去", "来得到它的集合", "在这它并不一定是在", "你这个缺页的时候来做这件事情", "好 那这时候呢 怎么做呢", "在这里面还有一个τ", "这是一个参数 是窗口大小", "相当于我们在这考察的时候", "过去一段时间", "这个τ这个时刻就是它窗口大小", "具体做法是这样的", "我们在这里维护一个访存的链表", "有点像我们LRU里头的特殊的栈", "然后在访存的时候 这个算法呢", "需要去把不在工作集的页面 把它换出", "那我们说访存实际上是非常频繁的", "你要做换出的判断和动作呢", "它的开销是很大的", "那在这里头呢 而在缺页的时候", "这件事情反倒是简单", "它在缺页的时候只是需要", "把你缺的那一页加进来就行了", "那这时候 我们在前边局部置换算法", "复杂的地方是在缺页里头", "现在它把它复杂的地方", "放到了访存的时候 那这种算法呢", "相对来讲它肯定也是开销大的", "我们在这也还是用一个实例", "来说一下它的工作过程 它怎么在做", "以前我们基本上不考虑", "在刚开始的时候有哪几个页面", "为了让这个地方能够进行的顺利", "我们在这先假定了一个起头的时候", "这几个页面的顺序", "假设它的意思是在于", "我想知道在第一个时刻的时候", "过去有几个页面", "它是已经超出了工作集", "这只是个假例", "好 那在这里头呢", "我们访问第一个页面", "缺页的时候按照工作集置换算法", "它怎么做 缺哪个 把哪个补进来", "我在访存的时候 这个正好访存", "但是这时候我在访存的时候", "还需要判断", "我哪一个页面不在工作集里头", "我们这个τ是4 从这个开始往4", "那这个时候那个E", "就已经过去超过四个了", "没有访问过", "这时候我得把它去掉了", "再访问D的时候呢", "那这时候说在这的这三个", "D肯定是要有的 C A还在里头", "那这时候看的情况是这样的", "然后再访问B是加进来", "那这个时候 你在访问B的时候", "A也已经超过4个了", "过去是C D B这三个", "这个A就给剔除出去了", "再访问C还会有哪 C在里头", "那是访问成功的 然后B和D在里头", "那还是这三个 然后再访问E的时候", "把E加进来 E过去这四个", "应该就是这四个", "然后再访问C的时候", "C B 那个D应该去掉了", "这时候D去掉了", "再访问E的时候呢", "这四个加起来只有C和E", "这B也会去掉 然后再访问A", "这回是有一个缺页", "然后再访问D仍然没在里头", "再缺页 这时候A C E D", "这是它整个执行的过程情况", "那在这我们可以看到", "你平时在访问的时候", "你要做的判断是比较多的", "你维护了那个链表", "我们这时候可以理解为", "那个链表是什么", "是你访问的先后顺序", "这和我们的LRU的算法", "维护的那个栈是类似的", "所以在这 这个工作集置换算法", "它的开销也是很大的"]}, {"name": "", "block_id": "ffa4e2b62bba4a20b22c807c45cdf172", "text": ["接下来我们介绍虚拟存储的基本概念", "那在这里头呢我们前面已经说清楚了", "交换和覆盖这两种技术所存在的问题", "然后我们也说到了程序访问的时候", "它的局部性特征", "有了这个特征之后我们有可能来实现", "一个虚拟存储系统", "那么在这里呢虚拟存储呢", "它的直观思路很简单", "就是把不常用的部分 内存块 放到外存当中", "那有了这一条我们就可以做到这件事情了", "那具体的做法呢是这样的", "程序在开始执行的时候", "你需要把你的代码和数据加载到内存当中来", "原来的加载呢是把整个进程的", "地址空间内容全部加载进来", "那现在变成什么呢", "加载的时候只是将当前指令执行", "所需要的部分这些页", "或者是段加载到内存当中来", "那这是起头的时候", "然后在执行的过程当中因为你只加载了一部分", "在指令执行过程当中有可能就是访问到", "某一个指令或者访问到某一个数据的时候", "这时候不占内存", "这就是我们这里说的出现缺页或者是缺段", "好 这时候怎么办呢", "这个时候硬件处理器通知操作系统", "将相应的页面或者段调入到内存里头", "然后重新执行这条指令", "那这是装载和执行过程当中", "那如果说仅有这两条的话", "就是刚开始装一部分 后面缺哪个装哪个", "这样到最后结果是我们所有的全都装内存里头了", "好 为了提高它的效率", "操作系统呢会再多一件事", "你需要监控进程地址空间里", "在内存里的这些它的使用情况", "把暂时不用的页面或段保存到外存当中去", "这时候有个问题是说", "我怎么知道哪些是暂时不用的", "好 这就是我们后面讨论置换算法的时候", "需要讨论的内容 好 这个基本原理呢", "基本上我分成这样三条就足够了", "那具体说起来呢", "根据分块的大小我们还前面有", "非连续物理内存分配的时候", "讲到过有页式和段式", "那在这里呢我们说到装入", "或者说换出的部分是页面或者是段", "那到这儿呢在前面只要有往外换", "那就变成了加上虚拟", "这时候我们就有虚拟页式和", "虚拟段式这两种情况", "好 有了这两种情况之后", "那我们这个基本的概念就有了", "好 那 我们说如果我们在这里", "做成这种情况它会是一个什么效果", "这我们前面也说过", "根据目标我想建造一个抽象的地址空间", "里头不管是在内存里头还是在外存里头", "它是一个虚拟的地址空间", "它实际上会映射到物理内存或者是磁盘", "那这个时候呢我们可以得到什么特征", "不连续 你的物理页面分配可以不连续", "那这是我们前面非连续存储分配的特征", "第二个呢虚拟地址空间也可以不连续", "好 然后呢在这基础上", "我们说由于我可以把一部分放到外存里头去", "那这时候我就可以提供更大的用户空间", "我可以执行我的进程大于你物理内存的情况下", "我仍然可以在我的系统上执行", "同时交换技术是把整个进程地址空间全换出去", "这时候我可以把一部分换出去", "从而使得我可用的空间更大", "好 把这两条搁到一起之后", "实际上就是虚拟存储改进了原来的覆盖和交换", "两种技术的往前发展", "那到这儿呢 我们就可以实现虚拟存储了", "那我们具体说起来呢我们这里", "需要什么样的支持技术", "硬件需要地址转换", "这个地址转换在我们前面讲的", "非连续存储里头呢已经说过了", "那我们在那基础上就需要", "加上一个我如何能够知道它", "不在内存里而在外存里头", "这是硬件机构要做的事情", "而操作系统呢就要来换入换出这件事情", "是不能由硬件来做的 要由操作系统来做", "到底我哪些装进来", "哪些换出去是在你执行指令的过程当中", "出现了异常我才来做这件事情", "那具体装入的页面或者段是哪一个呢", "是由你操作系统里头的监控来实现的", "我知道哪些页面的使用情况", "从而呢完成这样一点", "好 这是我们说到的虚拟存储的基本做法", "那后面我们会具体下来介绍说", "虚拟页式它在里头到底怎么做的"]}, {"name": "", "block_id": "c6c6f43c82a241f68bf3f10924ba74b5", "text": ["接下来我们讨论进程的状态", "进程的状态呢是指操作系统为了", "维护进程执行的过程当中的", "所有信息的变化", "那它有必要知道进程", "在执行过程当中会出现哪些状态", "它会在什么情况下会发生变化", "那这是呢我们对进程", "在整个生命周期当中", "它可能出现的一些事件的划分", "这种划分呢在不同的", "操作系统当中它会不一样", "比如说在我们这里头", "把它划分成创建", "有可能你需要其中一个程序执行", "那这个启动过程", "就会导致一个新的进程的创建", "那创建完了之后呐", "它就会是程序进入执行的状态", "这是第二个", "它会占用CPU来执行", "在执行的过程当中它可能会由于", "等待某个资源或者", "等待某个数据而进入等待状态", "好那这个时候呢", "就导致进程进行等待", "好在执行的过程当中", "还会有另外一种情况", "你比如说", "我一个优先级低的进程正在执行", "这时候有一个高优先级的进程", "有等待状态结束", "就是它等待的条件已经成熟了", "已经满足了", "好那这时候它要马上开始投入运行", "有可能我当前这个进程是会抢先", "那这时候呢我这个", "先进入就绪状态这个进程叫抢先", "而当前正在执行这个进程呢", "叫做被抢占", "好那处于等待状态的进程呢", "它会碰到被唤醒的情况", "在外界条件满足的时候它会被唤醒", "唤醒之后呢", "又排到这个就绪队列里头", "也就说它等待占用CPU来继续执行", "那等最后回到CPU上执行", "执行到最后的某种状态呢", "整个程序的工作全部执行完", "那就有可能进到进程结束的状态", "那这时候到达结束", "那整个呢这是我们在这里头", "对进程的生命周期的一个划分", "这种划分呢在不同系统里呢", "会有一些变化", "大致的情况呢基本上就是这几种", "那我们具体来讨论一下", "这些状态的变化", "首先一个进程创建", "要创建一个进程", "实际上我们在前面说", "每一个进程有一个进程控制块", "那这些相关的它要占用内存", "把代码和数据都拷进去", "这些资源的准备过程", "就对应到我们这里进程创建", "那可能导致创建的事件呢", "有这样几种", "第一个系统初始化", "初始化完成之后", "我要创建第一个用户进程", "那这是一种情况", "然后在用户进程执行的过程当中", "我可能会要执行某项功能", "用户请求创建一个新的进程", "那实际上这个请求过程呢", "也会导致一个程序", "我会执行创建进程的系统调用", "这是我们操作系统对上", "提供的创建进程的API", "好创建好了这个进程之后呢", "我们就会放到内核里的", "就绪队列里头", "这时候进程控制块呢", "就排到这个就绪队列里头", "好那等待CPU调度", "那如果说这个处理机", "没有其它进程运行", "那我就会调度一个", "新的进程来运行", "这时候调度呢就会", "导致我这个进程进入运行状态", "那我如何来选择一个", "就绪进程来运行", "如果说你只有一个那我就选择它", "如果有多个我怎么选择", "那实际上这种选择的依据呢", "就是我们后面会讲到的", "处理机的调度算法", "那不同的调度算法系统会体现出", "不同样的进程执行的特征", "好在执行的过程当中呢", "有可能进程执行的", "某一项条件不成立", "需要等待的某个数据", "或者说外部资源不足够", "那这时候呢", "我进程会进入等待状态", "那这种等待状态呢", "可能的原因是说", "我等待的系统的服务", "并没有马上完成", "或者说我启动的某个操作", "比如说我读写磁盘", "那这个读的过程呢", "它并不能在很短的时间里给出来", "因为我指令执行的速度", "是远高于我磁盘读写的速度了", "好再有一个就是", "我等待需要的数据没有到达", "那这些都会导致", "我进程进到等待状态", "一旦这些等待事件出现之后", "它就会回到这儿那么", "在这中间呢还会再有一种情况", "在这里呢等待事件的进入一定是我", "正在运行这个进程", "本身内部的原因所导致的", "它不是由于外部原因", "所导致它进入等待状态的", "好在执行的过程当中呢", "还有一种可能的变化", "就是我正在运行的进程被抢占", "那这种情况呢会出现在", "我有高优先级的进程变成就绪", "它需要马上投入运行", "那会把我正在运行的这个进程呢", "变成就绪然后让它运行", "第二种情况呢是说", "我们在操作系统里头它的调度算法", "为每个进程分配了", "它可以执行的最长时间", "如果你分配的这个时间片用完了", "那这时候呢", "系统", "操作系统内核会强制把这个进程呢", "抢先让下一个进程投入运行", "那这是呢时间片在这里起到的作用", "好那这个地方呢是说", "我在什么情况会回到就绪状态", "那就是说我进程被唤醒", "那唤醒的可能条件呢是", "我们刚才进入等待的", "那几个条件的反过来", "我等待的资源满足了", "我等待的事件出现了", "那都会出现这种情况", "而和这个等待进入相反", "唤醒的条件呢", "一定是被其别的进程或者", "操作系统唤醒", "它不会是由于自身的原因直接回去", "那这是呢在这里唤醒的时候的情况", "那在执行的过程当中", "还有一种情况呢是说", "我在执行到整个进程", "执行结束那我要退出", "这是要干什么呢", "要把进程执行所占用的", "所有资源还给操作系统", "以便于它能把它分配给", "新的进程使用", "如果没有这个过程的话", "那分配出的资源就会丢掉了", "那在这个过程当中呢", "结束呢有这样几种情况", "这是我们希望的正常退出", "那在正常退出之外呢", "还有一些意外的原因", "你比如说出现错误", "错误呢分成一般的错误", "我可以做收尾的", "那就是错误退出", "有一些错误是没有任何理由", "它直接就跑不动了", "那这就是致命性错误", "那这时候呢你可能这个收尾工作", "就做的不是很完善", "还有一种情况就是", "你在执行过程当中", "其他的进程认为你有问题", "那可能这种认为也不一定是正确的", "好它强制把这进程杀掉", "那这是几种我们", "从运行到退出的情况", "那有了这些说明之后呢", "我们关于进程的状态的变化情况呢", "就有一个基本的了解", "那下面呢我们通过一个小例子", "来说明进程状态的变化情况", "那在这里头呢我们假定", "我写了一个小程序", "这个小程序呢进来之后", "执行的主要操作就是", "延时两秒然后结束", "那在这个小程序呢", "它会什么样状态", "首先我启动这个小程序的时候", "它会有创建", "创建呢去分配", "这个进程执行所需要的资源", "你比如说内存", "好相关的数据结构初始化", "完成之后那这就进入就绪状态", "进入就绪状态呢是说", "我把这个进程所创建的", "包括进程控制块", "挂到就绪队列里头去", "好然后在就绪队列里头等待", "占用CPU的进程结束退出", "或者说被抢先", "好然后这时候呢", "在CPU的调度下它就可以", "从这儿进到占用CPU来开始执行", "在执行的过程当中会执行到", "你的sleep这个系统调用", "这个调用呢它设置好定时器", "那这时候呢它就没事干了", "因为我们延时两秒", "中间这两秒它是做不了任何事情的", "好在这两秒钟的时候呢", "那它就会进到等待状态", "那等待状态结束呢", "是说我这边的在内核里", "它的sleep操作会设定时器", "定时器在两秒钟到了之后呢", "它会给系统一个中断", "好这个中断呢会导致系统说", "这个中断是原因是什么", "最后找到这个进程", "好通知它", "它可以进到就绪状态", "好那这时候操作系统内核代码", "会把这个处于等待状态的进程呢", "放到就绪队列里头去", "并且把它的等待事件设置为出现", "好然后等待CPU调度", "就处于就绪状态", "好等到它可以占用CPU来运行的时候", "那又进到运行状态", "那到这儿呢我们这个基本的操作", "就执行的差不多了", "接下来是说它要退出", "然后把它所占用资源全部还回去", "那我这个进程的整个生命周期呢", "就全部完成了", "那我们所有的程序在执行过程当中呢", "我们操作系统需要对这个过程", "进行全面准确的把握", "只有这样的话我才可以知道", "我这个进程执行的情况", "那么在这个里头呢", "我们还会涉及到一个问题是说", "我一个进程进入等待", "或者说被抢先或者说结束", "我都需要找另一个进程来继续运行", "那这时候就有一个进程的切换", "那这是我们在内存当中", "当前正在交替运行的N个进程", "那这个切换的过程是怎么进行的呢", "我们在这里头进程一进程二", "我们假定有两个进程", "好首先呢假定跟我刚才例子一样", "它进到这里头执行sleep", "这时候呢会导致进入内核", "这仍然算是这个进程执行的时间", "好然后呢", "内核里头会调用函数设置定时器", "那这是这边设备", "这个设备呢可以和", "我们CPU呢同时运行", "这是并行的好", "设置好了定时器之后呢", "那我这个程序就走不下去了", "那它就会执行调度", "这个调度呢会把", "当前的进程的", "占用的寄存器的状态呢", "都保存到进程控制块里头", "然后它这时候切换到第二个进程", "这是从就绪队列里找出来的", "然后让第二个进程呢开始运行", "那在这个运行的过程当中", "它可能会是说", "你的这个定时器的时间到了", "这个时候定时器呢会产生一个中断", "这个中断呢会在这里做响应", "这个响应的操作是", "让这个进程暂停下来", "并且保护进程二的现场", "恢复进程一的现场", "恢复完毕之后让进程一继续执行", "那么等到这个进程执行结束呢", "它就再回到操作系统", "这相当于我们最后那个", "结束那个进程", "好那实际上我们在", "这个整个操作系统", "在掌控内部正在运行", "所有进程运行过程呢", "就是从一个切到另一个", "再从另一个再切回来", "周而复始的这样来切换", "那这是进程切换的情况"]}, {"name": "", "block_id": "a9bf35b23062459d9ae7c2de49d52945", "text": ["好 那我们来看一下", "哲学家就餐问题一个实现", "在lab7中我们给大家提供了", "基于信号量的", "哲学家就餐问题的实现", "在这里面 我们需要大家去实现", "基于管程和条件变量的", "哲学家就餐问题", "既然是基于管程", "我们就需要考虑", "怎么对管程进行定义", "和完成相应的初始化", "这是第一步工作", "可以看到", "对于哲学家就餐问题呢", "我们和前面的讲解是一样的", "他会有一个哲学家一个状态", "包括了思考 饥饿 吃饭", "这三个状态", "同时我们还定义了", "跟这五个哲学家相关的条件变量", "这个self一共有5个", "那他的初始化代码在哪呢", "一开始的时候", "我们会把哲学家", "都初始化为thinking状态", "这就是他的初始化的工作", "这就是管程初始化一个", "大致一个表述", "我们会产生", "五个哲学家的内核线程", "来模拟哲学家的行为", "那这个内核线程呢", "他干事情是什么呢", "他实际上是一个循环", "在这个循环里面", "完成thinking然后感觉饥饿", "然后就尝试着去取两个筷子", "左手和右手的筷子", "当然这个取筷子呢", "实际上是调的是我们说", "管程里面的一些操作", "这个操作需要完成一定的", "同步互斥的一些要求", "然后拿到筷子之后他会eating", "如果拿不到呢", "很自然 他就会去睡眠", "好eating完之后呢", "他会把筷子再放回去", "这就是他大致一个过程", "需要注意的是 在这里面", "取筷子和放筷子呢", "都是管程的操作", "那我们看看 管程里面", "怎么来实现这些操作", "在管程里面", "我们提供了三个函数", "一个是取筷子 一个是放筷子", "还有一个是辅助取筷子", "和放筷子的一个Test函数", "那么这个函数实现", "和我们用信号量方式实现呢", "有很多类似地方 但是有不同", "需要注意 在哪呢", "关键两个地方 一个Wait_cv", "一个是Signal_cv", "这就是调用的信号量的", "等待或唤醒换作", "我们简单看一下", "第一个是pickup 就是拿筷子", "那他首先会把他自身的状态", "置成hungry 表示我现在饥饿了", "然后执行test", "看我自身的左侧邻居和右侧邻居", "是否是不处于eating状态", "如果不处于eating状态", "也就意味着他可以拿到筷子", "所以他会执行一个Signal_cv", "来把自身设置成一个", "可以去吃的一个状态", "同时 还会继续去进一步执行", "但是如果说他不这样的话", "那么他会执行什么呢", "执行完test返回之后", "如果他不是一种吃的状态", "那意味着他现在无法", "拿到足够的筷子", "他会通过执行Wait_cv操作呢", "来完成一个等待的一个过程", "这是拿筷子的过程", "可以看出 在拿筷子里面", "有可能他拿到筷子", "处于一个吃的状态", "也有可能拿不到筷子", "然后调用Wait_cv呢", "使自身进入一个等待状态", "当吃完饭之后呢", "他会再执行一个putdown操作", "那putdown呢", "会把他的左手筷子", "和右手筷子放回去", "在放的过程中 还会去探测", "他的左侧邻居 或者是右侧邻居", "是否可以处于eating状态", "如果发现他们可以处于eating状态", "他就会通过执行一个Signal_cv", "来把相应的邻居给唤醒", "且把他们状态置成eating", "这就是pickup和putdown的", "大致的一个实现", "那么大家基于大致的流程呢", "可以去尝试在lab7中完成", "基于管程和条件变量的一个", "哲学家就餐问题的实现", "当然这取决于", "你能够正确地完成管程", "和条件变量一个实现", "而我们条件变量", "是基于信号量来完成的", "好 那通过前面的讲解呢", "大家能够去了解信号量 条件变量", "管程是如何实现的", "以及他们之间的相互关系", "还有就是基于这些机制呢", "我们怎么能够去完成", "相应的同步互斥的问题", "比如说哲学家就餐问题", "好 祝大家实验顺利"]}, {"name": "", "block_id": "602560190a51423fa41737dea0920d30", "text": ["那前面给大家介绍了", "整个调度算法的一个支撑框架", "我们也知道", "支撑框架何时会去驱动", "那些调度算法的函数", "接下来我们看一看", "一个具体的调度算法", "是怎么来实现的", "那我们这里面是以Round Robin", "调度算法来作为一个例子来介绍", "这里面Round Robin", "就是我们叫做时间片轮转", "那么这个时间片轮转调度算法呢", "它主要是基于", "每个进程都有一个时间片", "当时间片用完之后", "它就会等到下一轮再去执行", "这是它的一个基本原理", "我们来看看它是怎么实现的", "前面已经介绍我们要完成一个", "就是schedule一个class", "要把这些相应的函数填完", "这些函数的具体实现", "就体现了你这个", "时间片轮转的一个特征", "它的接口是一样的", "包括初始化 进队 出队 选择和tick", "这是大致它这几个关键的一些函数", "我们看看它怎么来实现的", "首先是这个初始化", "我们可以知道一个运行队列", "就是说就绪队列", "需要来把所有这些", "处于就绪态的这个进程管理起来", "这么一个run_list", "同时还记录了一个", "当前这个进程的个数", "就是处于就绪态进程的个数", "这是一个关键的数据结构", "然后呢 在初始化的时候呢", "我们会把这个队列", "给做一个初始化清空", "使得这个proc_num等于0", "这是最开始的时候要做的一个事情", "那我们来看一下", "关于Round Robin调度算法", "它怎么来实现tick这个函数的", "首先我们要知道tick函数", "什么时候被调用", "它是在产生时钟中断的时候呢", "会触发这个函数的调用", "那么产生一次时钟中断", "意味着时间流失了一小段", "所以说呢", "它这个time_slice会做减操作", "减一这么一个操作", "在最开始初始化的时候", "一个进程", "它有它的一个time_slice", "一旦它的time_slice", "从它的减操作变成0之后", "也就意味着", "这个进程的时间片用完了", "它有必要就是放弃对CPU的执行", "让另一个进程去执行", "所以说就可以看到", "在这里面一旦time_slice等于0了", "我们就会把一个重要的标记", "就是need_resched", "就是存在着进程控制块里面的", "这个need_resched置成1", "代表着这个进程应该被换出去", "在接下来的中断处理例程中呢", "会探询这个当前进程", "这个标记位是否为1", "一旦为1 它就会执行schedule完成切换", "那我们再看看就是进队出队的实现", "我们说这个", "所有处于就绪态的进程呢", "它是在一个就绪队列里面", "就绪队列呢", "我们是用前面讲到的一个", "就是双向链表来实现的", "当有一个进程要进队列的时候呢", "我们会把它插入到就绪队列的头", "就是list_add_before", "这是它的一个大致实现", "同时呢 也会对它的其它", "一些参数做一定的调整 这是进队", "那如果说我们要去选择一个进程", "就是pick_next怎么来实现的呢", "它是从这个队列的尾选出一个进程", "这个进程代表当前应该去", "占用CPU执行的一个进程", "就是说所以说用", "list_next来完成这个选择", "一旦选择出这个进程之后呢", "我们会进一步去做switch_to", "来完成对这个进程的切换", "那接下来我们看一下", "完成这个pick_next怎么来实现的", "这个pick_next函数要选择下一个", "要占用CPU执行的这个进程", "OK 那会从处于", "就绪队列里面的进程选一个", "选哪个呢 list_next", "很明显可以看出来", "它是取就绪队列里面最尾的那个", "这个进程就代表当前", "应该占用CPU执行的进程", "这个list是一个双向链表", "就是我们前面在lab0的时候", "给大家介绍过的一个数据结构", "有两种情况", "有可能你得到这个元素entry可能是空", "或者是一个具体的值", "一个具体的值呢", "就代表我们选着了", "有就绪的这个进程存在", "但是如果是空的话", "就意味着选不出来", "当前没有就绪进程", "存在在就绪队列里面", "这时候怎么办", "这时候我们会让idle_thread去执行", "这个idle_thread是一个内核线程", "它干的主要工作就是不停的轮询", "看这个就绪队列里面", "是否有就绪进程存在", "如果有就会去执行它", "好 一旦我们选择到一个进程之后呢", "我们会把这个进程", "从就绪队列里面取出来", "前面只是选择没有取", "所以取出来是一个dequeue的实现", "那么这个list_del_init就完成了", "从就绪队列里面", "把具体的进程取出来这么一个过程", "从而就绪队列里面少这么一个元素", "OK假定我们实现了这些函数", "init 进队 出队 pick_next和tick", "其实我们就完成了这个时间片轮转", "可以看出来这个实现过程", "其实还是挺简单的", "然后呢 最后还有哪一步呢", "就是在schedule初始化的时候呢", "要让我们实现的这个", "调度算法的这个类呢", "指向具体的一个sched_class", "从而可以使得我们", "这个schedule这个函数呢", "可以找到一个正确的一个调度算法", "对应的函数去完成具体的调度过程", "这就是说Round Robin这个调度算法", "它大致的一个设计", "和实现的一个方法", "可以看出来比较简单", "只要能够明确这几个函数就OK了"]}, {"name": "", "block_id": "0d936e2504494cf3a57ecd5870422f9d", "text": ["接下来我们讲页式存储管理", "那在这里呢", "需要首先说清楚", "什么是页式存储管理", "它的基本概念是些什么", "第二个呢是说", "因为在页式存储管理当中", "它的地址映射或者地址转换", "是如何进行的", "那在页式存储管理当中呢", "它把物理的页面", "物理的地址空间", "分成的基本单位叫页帧", "或者叫帧 frame", "那这个大小呢是2的n次幂", "为什么这里头会是2的n次幂呢", "原因在于 我们要在这个", "地址转换的过程当中", "让这个转换的过程比较方便", "那在计算机里呢二进制的移位", "是做乘法的一个", "非常重要的快速的一个因素", "所以在这儿 一定要求", "它是2的整数次幂", "比如说我们现在在32位机器里头", "4K 4096 是我们常见的一种页帧的大小", "与此同时 逻辑地址空间里", "也要分成大小相同的基本单位", "这就是页page", "frame和page之间的区别是在于", "一个用来描述逻辑页面", "一个用来描述物理页帧", "好 有了这两个基本的划分之后", "那就有一个问题", "页面到页帧之间的转换如何进行", "这个转换呢它就涉及到一个页表", "那我在这里保存这个转换关系", "有了这个转换关系之后", "如何让这个转换能够高效地进行", "那就是我们这里的MMU和TLB", "是存储管理单元和快表", "那下面呢我们依次来进行介绍", "页帧是我们对物理内存基本块的名称", "下面我们用一个示意图", "来描述页帧号和帧的偏移", "那么在这里头我们看到", "这是我们的物理地址空间", "我们把物理地址", "组织成一个二元组", "f表示frame你的帧的帧号", "然后O表示偏移量", "在你页内的偏移量", "那地址呢我就把它分成两段", "S是帧的位数", "那剩下的呢是页号的长度", "那在这里头呢", "我们说它的一个地址转换是什么", "我数页数f 然后在页内数偏移", "这对应到我们这个地方", "我先用f去数它到底是第几帧", "然后在帧内 去看它的偏移", "是后面这个O", "用这种方式", "我们就可以得到每一个", "物理内存当中的存储单元", "它所在的位置", "它所对应的帧的表示 二元组表示", "好 那么有了这个基本的示意之后", "我们看一个实际的计算过程", "那在实际计算之前呢", "我们需要假定你的地址空间是16位的", "然后它的页的大小是512字节", "就是2的9次方", "有了这个之后", "我们来看一个实际的计算", "这是一个地址", "首先我把它分成两段", "1到9这是第一段 然后10到16", "然后表示成一个二元组呢", "这前面是3 后边是6", "那这时候它对应的位置在哪呢", "我们来说从这儿数到3 然后这一格里头", "一帧里头我数它偏移量是6", "那这过程什么样呢 在这儿进行计算", "需要知道你的S就是一帧的长度", "它是2的9次方 512字节", "前面是帧号的位数", "好 这两个数搁到里头", "去这边就能算出来", "它实际计算过程呢是这俩加起来", "最后得到这样一个结果", "逻辑地址空间的划分和", "物理地址空间的划分是类似的", "那划分成大小相等的", "这时候呢页内的偏移和", "帧内的偏移它俩是一样的", "但是页号和帧号", "通常情况下是不一样的", "因为我们逻辑地址空间的", "它的页号是连续的", "到对应的帧号呢它就不一定", "也是相邻的", "好 那我们下面跟那边一样的", "我们还是逻辑地址空间和逻辑地址", "我们也把它划分成一个二元组", "这个二元组的表示呢是P表示页号", "O表示页内偏移", "页内偏移长度", "和页的大小是一致的", "S位对应着它有2的s次方个字节为一页", "然后 页号呢实际上是前面这一段", "这个时候你逻辑地址空间", "的转换怎么来进行呢", "那是P左移S位然后加上O得到", "你访问的存储单元的位置", "有了这两个之后", "那我们就有一个逻辑地址", "到物理地址转换的问题", "那这个转换呢", "它在逻辑地址空间里头", "它的页号是连续的", "我从零开始到指定的位置", "但是到物理地址空间里呢", "帧号呢它是不连续的", "我这边存到的是p1对应的是f1在这儿", "p2对应的f2在这儿", "好这两者之间这个对应怎么来进行呢", "那这就是我们说到的", "中间要有一个对应的表", "这个表呢就是页表", "好 在页表里头它怎么来做呢", "逻辑地址空间里的页号是p", "物理地址空间里的帧号是f", "这两个对应如何进行呢", "那我们通过一条指令", "执行的过程来展示它", "这是你的程序在CPU里头执行", "那执行的时候呢", "它得到的地址是表示为p o", "逻辑页号和页内偏移", "然后用这个P到页表里去找它对应的f", "这个页表保存了", "逻辑页号到物理页号之间的对应关系", "好 这个表在哪呢", "这个表 它由页表基址", "来指定它的开始位置", "然后你用页号作为你的下标", "去查这个数组就能找到相应的页表项", "那每一个页表项呢有一个固定的长度", "那这个时候呢我们在这个", "帧号呢是页表项里头的存的字段之一", "有了这个之后 我就把这F和", "你这个页内偏移和帧内偏移是一样的", "把它俩加在一起", "得到你的实际的物理地址", "那这个转换呢", "由于我们刚才说每一页的", "每帧的大小是2的n次方", "那这时候呢这俩加在一起呢", "实际上就把你的f左移S位", "把后边的这个页内偏移加在一起", "这个加法很容易做", "好 就会找到你的页号了"]}, {"name": "", "block_id": "5435d451454d4d09aa5ab96033385c08", "text": ["既然ring 3的应用程序", "无法去有效的访问ring 0的数据的话", "那么我们怎么能够实现", "我们前面说的一个很重要的一个因素", "就是我们的操作系统", "要给我们的应用程序提供服务", "那既然它都不能访问了", "它怎么能提供服务呢", "其实我们还是需要有一种手段", "来实现不同特权级的一个跳转", "比如说我们应用程序选择了内核的访问", "通过一种机制要让我们控制流", "从应用程序跳到内核态去执行", "这是怎么来实现的", "在X86硬件架构里面有多种实现方式", "实现不同特权级的跳转", "但是在这里面我们只用其中一种", "就是基于中断", "通过中断来实现这个优先级", "或者特权级的转换", "那怎么通过中断来实现", "这里面有必要对中断要做一定的讲解", "我们前面其实在lab1里面", "已经对中断有所了解", "其实中断它会有一个中断门", "那么有了中断门之后 我们其实就可以", "通过我们前面讲到的中断描述符表", "建立好这个中断门来实现跳转", "这里面可以看到", "这里面中断的特权级的改变", "首先我们可以看到", "我们正在执行的时候", "它是在用这么一个栈在执行", "然后如果说这时候产生了中断", "中断有很多种方式", "比如说异常 外部中断", "或者是软中断等等", "我们说软中断就相当于是", "我们通过INT这条指令来产生中断", "当我们这个中断产生之后", "会出现一个变化", "那么这是产生中断之前", "这是产生中断之后", "那么我们一旦产生了中断", "在我们的内核态ring 0这个栈里面", "会压入一系列的一些数据", "以便于恢复被打断的程序继续执行", "压东西包含了压在内核ring 0", "这个栈里面的", "包括什么SS ES EFLAGS CS 和EIP", "那么前两个SS ES代表的是", "当前被打断的程序", "它的一个堆栈信息", "那么EFLAGS代表", "它当前执行的时候一些标志位", "比如是否溢出", "这些所谓的标志执行加 减这些", "可以看出来是否溢出", "那么这些标志实际上是", "放在EFLAGS里面的", "这个也有保存", "还有就是它的返回地址CS和EIP", "就是打断之后 这个地址", "如果执行完毕这个中断处理例程之后", "还要回去继续执行", "这保存了它回去的地址", "也可能还会有一些是错误代码", "这个异常相关", "那这是产生中断之前", "这是产生中断之后", "那么可以看到它的堆栈会产生变化", "那么这个栈我们再强调一下这个栈", "属于内核态的ring 0态的这个栈", "好 我们说产生中断之后你一定是说", "它会用到我们ring 0的栈", "那我们现在要考虑一下", "我们怎么能够从一个特权级", "跳到另外一个特权级里面去", "那我们开始完成lab1的时候", "其实已经注意到我们都一直", "在内核态里面来执行代码", "我们一个challenge的一个练习", "想让大家做一个不同特权级的切换", "那其实就是在这里面有所体现", "你怎么能实现", "从一个一开始处于内核态ring 0", "这个特权级很高的ring 0这个态", "往应用程序去转换", "怎么跳到用户态去让应用程序去执行", "那么这个就在于你怎么去构造一个", "所谓的一个特殊的栈来完成这个工作", "我们可以看看", "这是我们说的内核栈", "那么一旦产生一个中断之后", "它其实会有一些压栈", "那这些栈的信息需要注意", "因为你当前正在内核里面去执行", "所以在内核里面处于ring 0这个态的时候", "产生的中断还是ring 0", "它的特权级没有发生变化", "所以它会把这个", "EFLAGS CS EIP和Error Code存进去", "好我们现在希望的是让它回到什么地方", "回到ring 3里面", "就回到应用程序里面去执行", "那么首先构造一个环境", "让它能回到ring 3", "那我们就模仿了一个", "就是ring 3产生中断的时候的一个现场", "就是产生终端的这个现场", "跟同特权级的比起来", "如果从ring 3产生的中断", "跳掉ring 0里面去之后", "它会多存一些信息", "我们前面讲到了会存两个SS和ESP", "而且SS里面那个RPL是3需要注意", "这个RPL是3也意味着", "意味着什么呢", "意味着这个SS其实是在用的那个数据段", "用的是用户态的数据段", "而不是内核态的数据段 所以它RPL是3", "那同理我们前面在ring 0里面", "产生的中断它这个RPL是0", "代表了它当前运行在内核里面", "这个时候我们希望它回去", "能够跳到ring 3去执行", "所以我们会把它的CS", "会改成3 改成3之后", "也意味着如果说把这个栈构造好之后", "我们最后通过一条特殊的指令", "通过这条指令叫做什么", "IRET这条指令可以完成这个转换", "OK 一旦IRET指令执行之后", "它就会把这些信息给弹出栈", "来把这个内容恢复到对应的寄存器里面", "包含了EIP CS EFLAGS ESP和SS", "那一旦把这些值附给了", "我们那些寄存器之后", "可以看到这时候它的运行环境", "已经变成了用户态 为什么这么说", "因为它访问的数据 在SS这个访问数据", "它访问的代码CS 那它的RPL都是3", "所以说这时候", "如果我们这个跳过去的应用程序", "想去访问处于一个内核态的一个数据的话", "会报错 OK 这也意味着我们这个SS和", "内核里面的这个SS的栈不是一个数据段的", "应该是不同的数据段", "这实际上是一种特权级的转换", "你可以看到当这个发生转换之后", "这时还是内核栈它把这信息弹出来了", "同时需要注意同时新的一个栈到这儿来", "新的一个栈已经形成", "这个栈实际上是我们说处于用户态的一个栈", "它的SS和ESP已经变到这儿来了", "而且它的代码也是变到CS和EIP指向代码", "如果这个CS EIP不做改变", "那么它还是会直到", "它产生中断的下一条指令去执行", "好 那我们前面讲的是从ring 0", "跳到ring 3怎么来完成", "其实通过构造一个", "能够返回到ring 3的一个栈", "内核的一个模拟的一个中断栈", "来完成一个执行过程", "那么它最后通过IRET指令", "就可以完成数据的更新", "这一寄存器的更新", "来从而实现特权级的一个转换", "那另外一点就是怎么能够", "再从用户态跳到内核态去执行", "那这也是我们需要考虑的问题", "实际上这种机制也是被我们的应用程序", "无论是Windows Linux等等", "通常的这些操作系统", "它的应用程序都采取这种方式", "通过所谓的一个软中断或者叫trap", "来完成从用户态到内核态的转变", "那么这里面我们看看如果是基于X86架构", "怎么来完成从ring 3到ring 0的一个转变", "这也是一样", "这是一个处于正在执行的", "一个程序的堆栈信息", "那么一旦产生了一个中断", "那它实际上就已经实现了跳转", "那为了能够实现跳转", "你首先要把这个中断门给建立好", "就是IDT里面 要把中断门建立好", "中断门有一个中断描述符", "它会指出来产生了某一个中断之后", "它应该跳到哪儿去执行 但是在那个软件", "中断服务例程", "操作系统里面中断服务例程执行之前", "我们CPU已经一旦产生中断", "一定要保存一些信息 这些信息是什么", "刚才说到的就是SS ESP EFLAGS CS和EIP", "当一个应用程序运行到用户态的时候", "产生了中断 那我们的硬件", "会在处于ring 0态的", "那个栈里面会存这些信息", "这些信息其实是被打断那一刻", "那个应用程序它的堆栈", "它的执行的地址都保存在这儿", "这个信息有了 如果处理完这个", "中断服务例程之后", "我们再执行IRET这条指令", "就是中断返回指令", "它就会根据这里面的信息", "再重新返回到ring 3里面去", "那我们这时候不希望它返回到ring 3", "我们希望它返回到ring 0怎么办", "大家想想 其实和我们刚才的方法一样的", "我们可以通过对这个堆栈的修改", "就是内核态的修改", "使得它执行完IRET之后", "就是IRET这条指令之后", "可以继续留在内核态里面去执行", "我们做了什么修改", "首先就需要注意这个SS和ESP不需要了", "因为我们不需要回到用户态去 这是一个", "第二个我们会把CS会做一个修改", "指向内核态的那个代码段 这是一个", "第二个要把它的RPL肯定是0", "这里面也实际上是明确了", "内核态的那个代码段的PRL就是0", "会把它置成0", "通过把这个内核里面的堆栈", "改成这么一个堆栈之后 OK", "当然你要根据你要执行", "具体要访问到哪个地方", "去改变所谓的EIP", "假设如果不改的话", "那么这时候再去通过", "执行退出IRET这条指令", "中断返回指令 那么我们CPU硬件会", "把这个里面的堆栈信息给取出来", "然后返回到EIP和CS", "指向的这个地址里面去执行", "但需要注意在这时候", "依然是在ring 0里面执行的", "通过这种方式可以实现从ring 3", "到ring 0的一个转变", "那么如果大家能够把这个方法", "用在我们lab1的challenge", "这个练习里面的话", "就可以完成那个实验", "那如果有兴趣的同学也可以做尝试", "我们再想一想当一个应用程序", "通过不同手段实现从一个特权级到", "另外一个特权级的一个切换之后", "那到了另外一个特权级", "它怎么知道那个特权级里面的", "CS SS位于什么地方 这是一个问题", "CS有同学说 它的CS和EIP就表明它的地址", "这个地址我们可以通过它那个", "IDT描述符表里面建好了", "中断描述符表建好了", "当产生某一个中断", "应该跳到什么地方去执行", "这个地址可以搞定", "但是另一方面", "它的这个堆栈应该在哪儿", "这个信息在哪儿", "那这个信息其实是在IDT里面是没有的", "那么是在另外一个", "我们称之为任务状态段", "Task State Segment", "这么一个段保存了不同特权级的", "它所用到的很多寄存器里面的信息", "比如我们说的SS ESP等等", "那么虽然有很多 它很全面", "其实我们关注什么", "关注的是不同特权级", "里面的那个堆栈信息", "就是它的SS和ESP 那么可以看出来", "对于不同特权级的SS ESP", "这里面都有保存", "你看ESP0 ESP1 ESP2", "这是保存的 还有SS0 SS1 SS2等等", "这三个代表了它保存了什么", "保存了从ring 0到ring 2", "这三个特权级里面的堆栈信息", "所以为什么刚才说当一个应用程序在ring 3", "这个应用程序产生了一个中断", "或者说执行一个软中断的指令 INT", "这个INT指令之后 它可以跳到内核里面去执行", "但跳是跳过来了 它跳过来之后", "我们的CPU会根据TSS这里面存的这个信息", "来设置新的堆栈 这是一个", "然后再根据我们IDT表里面的那个", "中断描述符表的信息来设置新的地址", "所以说我们可以看到这里面比较清楚", "一旦从一个特权级跳到另外一个特权级", "特别是从高特权级ring 3跳到ring 0的时候", "我们的地址会发生变化", "我们的堆栈会发生变化", "而这个地址和堆栈都分别由", "不同的硬件机构来保存", "所以说这里面我们需要也要去设置好", "我们操作系统需要去设置好", "TSS里面的这些内容", "那么TSS它其实是一个特殊的段", "这个段位于内存中", "那它到底怎么去访问得到", "那运用到我们前面讲到的全局描述符表", "我们的全局描述符表里面", "有专门有一项是专门来指向所谓的TSS", "就是任务状态段这么一个信息", "称之为有一个特定的一个TSS的一个描述符", "放在我们全局描述符表里面", "那我们可以看到在这个全局描述符表里面", "它保存了这个TSS的一个描述符", "TSS Descriptor", "在这个描述符里面很重要的一个", "它保存了它的地址 就是TSS这个地址", "那么根据这里面保存的地址", "我们可以找到TSS里面的这个内容", "这就是说我们CPU怎么能够去找到", "当产生一个中断", "从一个特权级跳到另一个特权级", "找到另一个特权级里面的那些堆栈信息", "甚至还有其它信息 但这里面对ucore而言", "我们就用最简单的两个", "就是它的堆栈SS和ESP", "很明显那CPU我们硬件这么去找", "那么这里面的内容需要我们的软件去填写", "这也是跟前面介绍是一样", "我们的软件会去填写我们段描述符表", "就是全局描述符表", "我们软件会去填写IDT 中断描述符表", "同样我们的软件会把这个任务状态段", "里面的内容给填好", "那么一旦我们的TSS里面的内容", "这个段里面的内容填好之后", "我们需要我们的CPU", "知道这个段位于什么地方", "以便后续一旦产生切换之后", "它到哪儿去找这个信息", "对应这个比如SS ESP", "这个内容到哪儿去找", "那首先要知道这个段的基址", "这个段的起始地址在哪儿保存", "我们前面已经讲到了", "在全局描述符表里面", "你要去填写一项TSS的一个描述符", "它会指向这个任务段的相应的内容", "但是也需要注意这里面保存的信息", "这也是内存里面的单元", "所以说我们的硬件还有一个优化", "它会有一个专门的Task Register", "来缓存这个TSS里面的内容", "从而使得我们每次", "要CPU访问这个段里面的", "Task State Segment", "这个段里面的内容的时候", "它要去根据这个寄存器里面的内容", "直接找到这个相应的位置", "那么这个寄存器是一个特殊的寄存器", "那我们会在完成对TSS的初始化之后", "通过这个寄存器来加载它的基址", "这两步都可以有效的找到我们这个", "Task State Segment", "那我们前面讲的是", "大致的一个对硬件的介绍", "那其实我们ucore在操作系统里面", "也对此有相应的一些初始化的工作都涉及在", "分配一个TSS memory实际上分配一块内存", "要在这个内存里面", "把它作为一个Task State Segment", "来完成内容的填写", "再做初始化 对内存做初始化", "特别要设置对我们的SS0和ESP0", "再进一步会在GDT里面去填写TSS描述符", "最后还要设置TSS selector", "这是我们说Task Register相应的设置工作", "这里面在代码里面有对应的环节", "接下来我们可以看一下代码怎么来表述的", "好 那前面就把关于特权级的", "给大家做了一个介绍", "相关的一些进一步的信息", "可以看很详细的", "有关intel架构的一个技术文档", "它有专门的一个软件开发者的文档", "会有更详细的信息 这里面列出来了", "大致的一个位置", "小节一下我们这里面重点讲了特权级", "intelX86 X86架构里面有几个特权级", "我们怎么来完成特权级的一个切换", "你怎么知道你到底处于哪个特权级", "怎么去判断你的这个访问", "是否违背了特权级的一个规则", "以及最后还讲到了怎么去建立好", "从不同特权级转换的一个相应的机制", "特别是涉及到TSS这么一个机制", "把TSS设置好之后才能更好的完成", "从一个特权级到另一个特权级的转换", "好 这是这一部分的内容"]}, {"name": "", "block_id": "df01b04da6a648afbf1411e2382bb2a3", "text": ["那前面呢我们可以看到", "我们通过这个执行相应的", "do_execve这个函数呢", "能够创建出一个进程", "那么创建了一个鸡", "那么鸡怎么下蛋呢", "那我们可以看", "这个父进程是如何复制子进程的", "这是我们这一次讲的", "内容就是进程复制", "鸡怎么生蛋", "那么在原理课可以看到", "这里面讲到了有一个父进程", "通过一个fork就完成了", "把这个所有代码段 数据段 堆栈等等", "复制到另一个区域里面去", "产生一个子进程", "它们的PID不一样", "这是原理课大致的讲的内容", "我们可以看看", "如果说对应到我们Lab5实验", "这个原理上的内容", "怎么来具体的实现", "那这个函数呢叫do_fork", "一个内核函数", "它里面带了三个参数", "memory相关一个参数跟", "stack相关的有两个参数", "那么这个参数呢", "决定了就是说我们怎么去完成", "内存空间管理的一个拷贝", "这两块跟用户堆栈相关", "跟我们这个它的trapframe相关", "那也是一样", "就是通过这两个信息", "我们的子进程需要", "用到父进程的相关信息", "要复制一部分内容还要做一并修改", "所以这是三个重要的参数", "来完成了对这个do_fork一个调用", "我们看它怎么具体一步步实现的", "首先我们说父进程要创建子进程", "子进程和父进程是两个不同的进程", "所以说它有自己的进程控制块", "那创建了这个进程控制块之后呢", "我们子进程就有了自己的身份了", "也有它一个壳", "但光这个还不够", "我们还需要进一步去初始化", "很多其它新的一些必须需要具备的内容", "比如说第一个是kernel stack", "它在内核里面要能够执行", "它需要自己的栈", "这个kernel stack通过分配它相应的空间", "通过alloc_ pages得到一些空间", "然后通过这个proc->kstack", "来得到它这个内核里面这个虚地址", "从而可以把这个kernel stack给建立好", "这是完成建立功能", "还没有具体去执行", "再接下来呢我们需要干什么呢", "复制父进程的内存", "当我们创建个新的kernel stack之后呢", "我们的代码段 数据段希望能够", "复制父进程的同样的内容", "这我们说父进程创建子进程", "需要完成重要一个功能", "这里面用什么呢", "copy_mm和copy_range", "这两个来完成相应的功能", "那么copy_mm呢", "是为新进程创建一个新的VMA", "这是新进程创建好的", "第二个呢copy_range", "是把实际的这个代码段和数据段", "搬到新的子进程里面去", "同时再设置好相应的这个", "虚实映射关系就是把", "这个页表里面内容重新设置", "使得我们的子进程", "具有自己的内存管理一个架构", "mm_struct以及对应自己一个新的页表", "内容是复制了一份", "好 当我们把这个父进程的内存空间", "拷贝到子进程里面去之后呢", "再接下来我们需要", "让这个子进程能够正确的执行", "也意味着它要正确设置好trapframe和context", "这个context在我们讲kernel thread的时候呢", "给大家提到过trapframe之前也讲过", "这trapframe为什么要设置新的值呢", "可以看到", "因为当我们这个父进程和子进程", "都要做返回到用户态去执行的时候", "它们的状态是不一样的", "这里面可以看到它这里面干什么事情", "第一个要拷贝父进程的trapframe", "拷贝完之后还要做一定改动", "它的eax esp eip和copy_thread", "要做相应一些重新设置", "来完成这个拷贝和更新的工作", "大家可以去看一下", "这里面怎么来完成的", "假设做完这个之后", "我们还需要把我们新创建好", "这个子进程放到我们的", "进程队列里面去", "我们说有一个进程队列来管理了", "所有在操作系统里面存在的进程", "这里面有一个proc list", "然后呢一旦挂到这个队列里面去之后呢", "我们就可以用", "我们的进程管理的这个子系统呢", "来对这里面的进程做调度管理", "当然调度我们在Lab6中", "会做进一步的深入讲解", "一旦能够把这部分事情做完之后", "也意味着我们子进程", "已经创建完毕且可以去执行了", "可以去到running态", "然后跳到我们内容空间去执行", "好 那它们执行有什么区别呢", "我们前面讲到 说", "我们的父进程创建完子进程之后", "它子进程的返回值和", "父进程的返回值是不一样的", "do_fork的返回", "父进程返回是子进程的PID", "而子进程返回是零", "那在这里面怎么体现", "其实在最后这一步", "还会有一个把这个return做一个修改", "如果是父进程的话它会returnbPID回去", "所以说你可以看着父进程它的调用返回值", "正好是那个子进程的PID", "同时呢子进程他做的事不一样", "子进程它把它那个返回值就eax", "设成是零", "寄存器设置值是零", "那使得这个子进程的do_fork", "系统调用执行完毕之后", "它返回是零", "和我们父进程do_fork返回值是不一样的", "但是它们的控制点都是在", "do_fork返回这一点去执行的", "大家再回顾一下我们原理课讲的内容", "执行完do_fork之后", "我们父进程会得到一个子进程的PID", "而我们子进程呢", "会得到一个零继续执行", "它们就已经成了", "两条控制流去执行去了", "那大家对这个执行过程", "有深入理解之后呢", "对照执行代码就可以", "更好完成我们练习二的内容"]}, {"name": "", "block_id": "ab707ecbab854dc8b1fd7fb26e40b7b5", "text": ["那我们接下来看一下", "这个调度算法支撑框架", "那么有了调度算法支撑框架之后", "我们可以更有效的去完成", "对不同调度算法的一个", "具体的一个执行", "那我们前面已经讲了", "调度执行的", "一个大致的过程", "在这里面呢", "有一个很核心的函数", "叫什么呢 schedule", "那么这个函数呢会在", "不同的我们说调度点的时候呢", "会被调用", "它进一步去完成对", "调度算法的一个调用过程", "那么这个具体的调度点呢", "我们在后续有一个讲解", "那我们看一下这些调度点", "到底是做了什么事情", "好 第一个呢是do_exit", "就是代表一个进程要退出执行了", "就是它生命周期要结束了", "这时候呢 我们需要换一个", "新的一个进程去执行", "这里面会调schedule", "第二个是do_wait", "主要是用于父进程等待子进程结束", "来回收子进程的资源", "这个时候呢", "它本身处于等待和睡眠状态", "一旦被唤醒它就要去调用", "回收的一些工作来完成", "对子进程所占用资源的回收", "第三个是init_main", "其实它也是调do_wait", "来完成对其它一些子进程的一个", "占用资源的回收", "为什么这里面单独拎出来说呢", "因为它是所有用户进程的祖先", "当其它的就是没有父进程的", "那些子进程执行完毕之后呢", "就需要通过这个最终那个祖先", "init_main来完成对这些", "我们称之为", "孤儿子进程的资源的回收", "那么这第四个是cpu_idle", "cpu_idle代表什么呢", "就是idle kernel thread", "它是一个特殊的进程", "它主要在什么情况下被激活执行呢", "就是当前就绪队列里面", "没有就绪进程的时候", "这时候idle_thread就会执行", "它会不停的轮询", "然后去调用schedule来查找", "是否有处于就绪态的进程存在", "一旦有的时候", "它就会完成一个进程切换", "第五个是lock", "第五lock这一块呢主要是", "跟我们的lab7相关", "就是同步互斥相关", "这里面我们稍微讲一下", "它也是说想得到一个lock资源得不到之后", "它会调schedule来把自己挂起", "处于睡眠状态", "得不到这个资源了", "然后一旦资源得到满足", "它会被唤醒", "然后从而可以进一步进入就绪队列", "参与选择 执行", "第六个比较特殊 trap", "那trap实际上是说", "比如我们说产生了一个时钟中断", "时钟中断会打断", "当前正在运行的进程", "然后干什么事情呢", "它会去做当前一些跟调度相关的", "一些资源的一些调整", "比如说这个时间片", "这个时间片的这个资源", "我们时间片用完了", "那么你这个进程就要被换出", "那么时间片的改变是在哪完成的呢", "是在这个trap与时钟中断", "相关的处理里面", "对时间片做一个调整", "从而可以影响到后续的调度选择", "并进一步产生调度", "好 这一块呢", "是跟我们的调度算法", "是有紧密联系的", "那么我们这个调度算法", "它为了能够正常的运行", "它需要知道进程的那些事件", "那如何知道的呢", "有专门一个proc_tick这么一个函数", "这个从字面意思上可以看出来", "tick怎么叫tick呢", "实际上就是时钟的一个节拍", "那很明显可以理解到", "我们在去做中断处理的时候", "它会响应一个时钟中断", "而在那个时刻", "我们能够让调度算法", "感知到时钟中断的产生", "从而可以去调整它们那些参数", "比如说时间片的大小", "这是很重要的一个感知的一个功能", "第二个呢", "我们需要能够让一个进程", "从就绪队列里面进去和出来", "那这个进队和出队的一个过程", "这个和我们的调度算法的实现", "是有紧密关系的", "它不仅仅说是一个简单的队列", "你可以把它理解为一个", "抽象数据结构", "它可以用其它的", "堆 表 链表 数组来实现", "这是说的这个就绪队列这一块", "你可以有不同的数据结构", "但是你要保证两个操作", "第一个操作它能够进队列里面", "第二个是要从队列里面取出来", "第三个就是要pick up", "选取一个进程去执行", "那么这个选取的过程呢", "是和具体的算法相关", "所以说我们要实现不同的调度算法", "那么你这个pick up的实现", "有很大的不同", "最后一个呢", "一旦你选取完之后呢", "那你就需要去说和当前", "正在占用CPU的进程呢做一个交换", "选择新进程", "和这个老的进程来做交换", "这个是什么呢", "process switch就是我们说的", "进程切换要完成功能", "但是进程切换呢", "本身是和我们的算法是没关系的", "只是说当你的算法选择了", "一个新的进程之后要完成一个切换", "OK 那这些过程", "我们可以把它抽样成一些函数", "初始化 进队 出队 选择", "还有一个tick", "这么一个所谓的调度类", "就这么形成了", "我们就通过这种调度类呢", "来提供一个统一的接口", "形成一个所谓的调度算法的一个框架", "你只要完成不同的实现", "就可以对应着你的调度算法", "从而可以使得我们的ucore操作系统呢", "能够采取不同的调度策略", "来进行整个进程的一个管理和调度", "那么我们看一下", "就是刚才你实现的那些调度算法", "所涉及到的一些核心的一些函数", "是怎么被ucore来调度的呢", "这里面需要注意一个重要的函数", "叫schedule", "它是可以理解为一个总控函数", "由这个总控函数完成了", "对那个调度算法中", "各个核心函数的一个调用过程", "那么第一个函数呢 是进入队列", "就是enqueue这么一个函数", "那么这个函数呢", "实际上会调我们调度算法里面的", "那个进入队列的函数", "就是enqueue那个函数", "什么情况下会调用呢", "可以看到", "如果当前的这个进程current", "代表当前的进程", "它的状态处于就绪态", "runnable是就绪态", "在这种情况下", "它首先要把当前的进程", "放到就绪队列里面去", "这是为了做进一步的选择", "做这个考虑的", "接下来呢", "那么这个pick_next呢", "它会进一步去调用", "我们说的那个调度算法里面的", "对应的函数pick_next", "它会根据你这个算法的实现", "来选择一个新的一个进程", "好 一旦选择出一个新的进程之后", "我们认为这个进程应该占用CPU执行", "所以说它会把这个进程", "从就绪队列里面取出来", "执行一个dequeue", "那么dequeue呢", "也和我们的调度算法里面", "对应的dequeue的函数是对应的", "选择出来之后", "有可能有两种情况", "一种情况是说你选不出来", "它可能为空", "选不出来为空", "在这种情况下", "我们会进一步去调用这个idleproc", "这是一个特殊的内核线程", "它干什么事情呢", "它只干一件事情", "就是不停的循环去调用schedule", "查询当前的就绪队列", "是否有处于就绪态的进程", "可以去执行", "这是一种情况", "第二种情况你选出来了", "选出来就是一个新的", "一个next这么一个进程", "选择出来之后呢", "它会和current这个进程做一个交换", "通过调proc_run进一步调switch_to", "来完成进程的切换", "这就是说这个总控的一个调度函数", "那我们再回顾一下", "我们说这个schedule函数它很重要", "它是一个核心", "首先它会在不同的调度点会被调用", "调用这个schedule", "同时呢 它会调一系列的", "进一步的函数", "来完成对不同调度算法的", "核心函数的调用", "从而可以实现", "调度算法所要达到的功能", "在这个基础上", "我们可以实现不同的调度算法", "包括我们说的FIFO", "那FIFO先进先出", "就是和我们原理课讲的", "FCFS是一个意思", "先来先服务", "都是一个意思", "这是一种最简单的调度算法", "也可以实现我们后续讲到的", "Round Robin这个调度算法", "以及需要大家做实验去完成的", "stride这个调度算法", "这就是说这个大致的一个调度框架"]}, {"name": "", "block_id": "faafeea364ed4551bc5fb5531ff4323f", "text": ["好 我们看一下怎么来完成执行一个", "ELF格式的二进制代码", "这里面最主要就是这个函数", "do_execve 这个函数怎么来实现的", "那这个过程呢", "其实我们用一个通俗的比喻来说", "就好比说一个海螺本来", "是可以正常存在的一个生物", "结果有一个小螃蟹把海螺里面肉", "给吃掉了换了自己住在里面", "那结果导致呢这个海螺", "有了新的生命它成了寄居蟹", "这是一个简单一个比喻", "其实我们说这个do_execve", "干的是同样类型类型的事情", "首先它需要干的一步", "就是要把以前的资源", "这里面主要是内存空间给去掉", "但是还保留它的pid", "这个壳还留着", "然后呢再去把自己的内容换进去", "那我们重点要看看", "怎么来换自己的内容", "第一步我们先看", "怎么来把这个空间给清空", "怎么做的呢", "首先它是把它的这个页表", "cr3这个页表基址指向了bootcr3", "这bootcr3其实是我们", "ucore内核里面一个页表", "走向内核页表里面去执行了", "第二步呢完成了什么呢", "这三步退出mmap", "put_pgdir和mm_destroy", "那可以大致理解为", "它把这个进程的", "内存管理那一块的区域给清空", "把对应的页表清空", "所以说呢导致", "这里面的内存已经没有了", "OK 那第一步完成", "把这壳给清空了", "第二步要填入新的内存", "那这个填新内容呢", "重点是这个load_icode这里面完成的", "虽然是这一个函数", "但是这个函数完成功能确实比较多", "我们会单独对此做一个讲解", "那这个load_icode它会把执行程序", "比如说我们前面说的hello world", "给加载到这个新的壳里面去", "建立新的内存的映射关系", "从而可以去完成新的执行", "我们看看如果说", "这个load_icode能够执行完毕", "能够正确执行完毕", "那么这个整个这个函数都do_execve呢", "就可以正确返回了", "这个是它的一个大致执行过程", "看起来其实重点是在", "这个load_icode这里面来实现的", "接下来我们可以看看这个load_icode", "怎么来把这个同样的一个进程", "但是内容完全做了替换", "它的过程大致这么来可以看", "第一个前面已经就是说", "把整个内存管理mm struct给清空了", "那么首先要创建一个新的memory  space", "新的内存space", "那可以看到mm_creat和setup_pgdir", "从字面意思可以理解出来", "这个进程的", "内存管理一个空间呢重新创建", "建立好新的一个页表", "这是第一部分的工作", "空间先留出来", "那么一旦留出来之后", "你可以看到这里面的结构", "已经发生了变化", "它的内存已经指向不同的地方", "第二个呢 要填上我们说", "执行代码的内容", "这个执行代码内容在哪呢", "我们前面已经讲到了", "我们的bootloader", "一开始在加载ucore的时候呢", "顺道把那个放在hello world", "执行程序呢也一并加到内存中来了", "所以说我们只要知道那个hello world", "在内存中起始地址", "去解析那个ELF格式的执行程序", "就可以找到hello world", "它对应的代码段 数据段什么地方", "那可以看到在这里面它会重点关注", "是这个ELF格式的header它在什么地方", "以及根据header呢会进一步找到什么呢", "找到它的各个Section", "就是各个段", "比如说我们代码段", "数据段在哪", "这是把相应的代码段", "数据段找着之后", "根据这个代码段和数据段所设定的地址", "这里面会设定它的虚地址来建立一个vma", "这个vma这个结构", "大家想想我们在哪讲过呢", "我们在lab3里面其实已经提到一个VMA", "就是认为这个进程合法的地址空间", "我们用VMA这个结构来管理", "那这个结构呢", "如果是代码段那么它具有什么属性呢", "具有可执行的属性", "如果是数据段呢", "可读可写", "那么这块区域呢", "通过mm_map来完成了对", "这个合法空间的一个建立", "大家需要注意", "这个建立完之后还没有建立页表", "它只是标识了这个", "说这个是合法的", "在这一块", "再接下来呢", "一边从我们刚才说", "那个放hello world内存空间呢", "把相应的各个section考进来", "这里面可以看到", "这边是拷贝", "同时还要完成一个什么呢", "就是拷到一个物理内存空间之后", "来建立相应的虚地址", "和物理地址的映射关系", "那么这一块就是拷贝内容", "拷贝这个执行代码内容", "到我们这个进程空间里面去", "这样呢就形成了一个", "就是新的一个地址", "这个地址里面存的是", "我们新的执行代码", "且这个虚拟地址", "和物理地址映射关系", "也已经建好了", "再接下来干什么事情呢", "准备all zero memory", "什么叫all zero memory", "实际上说我们有一些bss段", "我们执行程序里面有一个bss段", "这个段里面的数据呢需要清空", "那么我会把这个区域给清空", "这是初始化的一些数据", "好 那我们可以看到", "刚才已经把", "ELF格式的二进制代码的内容", "从一个memory空间呢", "搬到我们进程空间里面去了", "搬到进程空间里去之后", "接下来还不能运行", "因为我们还没有设置", "相应的堆栈空间", "这个空间呢", "是不在我们的binary code里面的", "我们需要去构造一个user stack", "就用户态的一个stack", "从而可以确保我们应用程序去", "有效去执行各种各样的", "函数调用关系", "可以看到这里面又重新建立一个", "mm_map的user stack", "以及它的一个相应的一个", "页表的映射关系", "那就是我们前面说user stack的", "那一块区域呢给它建立好了", "那 建好这个映射关系之后", "也意味着这个内存空间", "这一块区域基本上是完成了", "包含了代码段 数据段 栈", "我们的stack都已经建立好", "建好之后", "我们最后还需要把我们刚才", "我们的页表的起始地址", "从ucore内核的起始地址呢", "换到我们新的一个起始地址", "我们新建好一个mm->pgdir", "因为我们已经创建的新的页表", "整个页表是新创建的", "当把这个完成之后", "也意味着这个的用户空间已经完成"]}, {"name": "", "block_id": "7b6411087c5b4742a3b883068c674d22", "text": ["下面我们来介绍", "进程的等待和退出", "等待和退出呢实际上", "是父子进程之间的一种交互", "完成子进程的资源回收", "那首先第一个是等待", "那个wait()这个系统调用呢", "可以用于父进程等待子进程的结束", "那具体说起来呢", "子进程通过exic()", "向父进程返回一个值", "父进程呢通过wait()", "接受并处理这个返回值", "那这时候就有一个问题说", "这两个到底谁先谁后", "wait父进程先等待", "还是子进程先做exit()", "这两种情况的不同呢", "会导致它下面的处理呢", "会有一些区别", "wait执行的调用呢", "在我们这里就是", "如果有子进程存活", "也就是说父进程创建的子进程", "还有子进程", "那这时候呢父进程进入等待状态", "等待子进程的返回结果", "好那等待的时候呢", "这就相当于是wait", "父进程先执行wait", "等到子进程执行的时候呢", "它执行exit ()", "这是exit ()是在wait之后执行的", "好那么这时候呢", "子进程的exit ()退出唤醒父进程", "父进程呢就由等待状态", "回到就绪状态", "等它得到CPU的使用权", "可以执行的时候", "那么父进程就处理", "子进程的返回的这个返回值", "这是wait在前exit ()在后的情况", "如果不是这样那就有一种情况", "就是有僵尸子进程等待", "这指什么意思呢", "就是子进程先执行exit ()", "那这时候说它返回一个值", "等待父进程的处理", "那这时候呢exit ()在前", "好在这个时候如果子进程", "还一直处在这个等待的状态", "在这里等待父进程的处理", "那么这时候呢", "父进程的wait就直接返回", "如果有多个的话", "就从其中一个返回它的值", "如果没有子进程在", "有可能我一个进程在执行的时候", "它执行了wait", "实际上它干脆就没有子进程", "或者说子进程已经结束了", "好那这时候呢它就直接返回", "这是呢wait的功能", "那接下来说exit", "在这里头呢它叫有序退出", "它指的是什么意思呢", "我执行这个exit", "这时候呢", "这个进程呢就会在这个", "系统调用里头", "就会进行资源的回收", "那具体的功能是这样的", "首先第一个是我们刚才说到的", "调用参数返回给父进程结果那exit", "然后父进程呢可以拿到它这个结果", "比如说我们在做一个编译", "你的编译是否成功", "这个编译成功之后呢我回复是0", "如果不成功我回复错误码", "这样的话我下面的", "调用编译的这个进程", "它依据你编译的结果", "来决定后续怎么做", "这是它第一项功能", "然后第二部分功能是资源回收", "你比如说我们占用的", "各种资源的回收", "占用的打开的文件", "分配的内存和创建的", "内核相关数据结构", "然后检查父进程是否还存活", "刚才我们说父进程会检查子进程", "子进程也会检查父进程", "子进程是执行exit的时候", "检查父进程", "父进程是在执行wait的时候", "检查子进程", "好如果这个子进程在exit的时候", "检查父进程如果父进程是存活的", "那么也就是这时候呢", "子进程就保留一个状态", "它自己进入僵尸状态", "也就是我们退出状态", "然后等待父进程对它结果做处理", "好如果说没有", "也就相当于创建完子进程之后", "父进程已经结束了", "那么这时候呢它就直接", "释放相应的数据结构并且进程结束", "好那在这儿呢", "同时这个检查完之后会清理", "所有的处于等待状态的僵尸进程", "好那么这样的话", "这个exit退出实际上这是", "把进程占用的所有的资源", "包括这里头申请了", "并没有显式释放的", "它都会给它释放掉", "这是退出", "我们先来看wait", "这是wait的实现", "那么我们先看有哪些函数会来调", "那各种平台上的sys_wait()会到这儿来", "然后它在这里头呢", "做的工作是在这里头do_exit()", "实际上是子进程的收尾工作", "然后把它放到队列里头去", "schedule()在这个地方", "是把它放到队列里头去", "好我们也可以通过它的流程图来看", "那在这个地方呢实际上就是说", "我们把当前进程改成了sleeping的状态", "这样的话它就变成阻塞状态了", "那也就是我们找到了wait()里头", "它是如何进到阻塞状态的", "在这儿呢你就可以看到相关的代码", "这是最明显的标志", "好接下来一个是do_exit()", "这是它的实现", "它实际上在这里呢", "就是保存在这里头呢", "是把它把这个进程给杀掉", "do_exit()把一个进程或者一个线程关掉", "那我们也可以通过", "它的调用关系图来看它的执行情况", "那也是各种平台上的exit()", "最后到这个地方来", "它在这里呢", "最后都是到这个地方", "来释放相关的这些数据结构", "这是它的相关的工作", "好我们仍然可以来看一下", "在这里它做的主要工作都是在干啥", "那在这儿呢前面的注释已经说了", "它把它地址空间页表", "存储的这一部分空间给释放掉", "然后把自己的状态改成叫僵尸状态", "同时唤醒它的父亲", "也就是说如果是wait的话", "在那边等着的那个", "我们也可以来看看它的流程图", "这是它最主要的工作", "是关于存储的那一部分的处理", "好在这个地方呢", "最后这一步是最主要的", "我们需要去wakeup_proc()唤醒", "处于wait状态的父进程", "好除此之外呢我们刚才讲到的", "这几个创建加载等待退出", "这四个系统调用之外", "我们对进程控制", "还有一些其它系统调用", "比如说优先级控制", "那在unix系统呢有一个nice系统调用", "它完成对进程的初始优先级的设置", "好在unix系统里头进程的优先级", "会随着执行时间的延续而衰减", "也就是说它的优先级是在不断变化的", "这是对优先级的控制", "然后还有一个呢", "是对调试的支持", "在我们目前ucore里头呢", "你没有办法在ucore内部", "调试你写的应用程序", "原因在于在我们这里", "这一部分支持还不好", "实际上在标准的操作系统里头呢", "unix里头它有叫ptrace", "这个系统调用呢", "完成一个进程对另一个进程的", "执行过程的控制", "这就有点像我们说的调试", "我让一个被调试进程继续执行", "在某处设置断点", "检查它的内存和寄存器的状态", "这是操作系统必须提供的一项功能", "然后还有就是定时", "我们前面说过sleep", "它可以让进程在指定的时间", "进入等待状态", "然后时间到了它进入就绪状态", "然后继续执行这是定时的功能", "好到这个地方为止呢", "我们就说清楚了", "进程控制的几个相关系统调用", "它们的实现和它们的功能", "那把这些控制功能和我们前面", "讲到的进程状态图进行一个联系", "我们会看到这样一种情况", "这是我们前面讲到过的", "三状态进程模型里头", "那核心的就绪运行等待", "再加上创建和退出这五个状态", "我们刚才执行的", "说到那几个进程控制的系统调用呢", "对这个状态呢都是会有影响的", "我们看看它的影响在什么地方", "首先是fork fork会有啥影响", "fork会导致一个新的进程的创建", "好创建在那里准备工作做完", "fork准备好了放在就绪队列里头", "的时候它就变成就绪了", "好然后再有一个是wait", "wait会什么 父进程执行wait", "会导致父进程由运行状态", "进入等待状态", "好然后再有一个是exit 退出", "退出会导致当前进程", "由运行进入退出状态", "同时子进程的exit", "会导致由于wait进入等待状态的", "父进程变成事件发生触发", "导致它进入就绪状态", "以便于它能再进行执行的时候", "对子进程的返回的结果进行处理", "那这时候我们还有一个啥没说加载", "这个系统调用它在什么地方", "实际上加载是你在执行过程当中的", "一种状态", "准确的来说", "那大家可以通过代码", "去阅读看看这里头", "我在加载可执行文件的过程当中", "它还有相应的状态变化", "好那到这个地方呢", "我们就说清楚了", "操作系统当中的进程控制", "那从进程的切换", "再到跟进程控制相关的", "创建加载等待退出", "这样主要的这几个系统调用", "那这是呢操作系统提供给", "应用程序用的最频繁的", "最主要的几个功能", "好今天的课就上到这里下课"]}, {"name": "", "block_id": "c4464c2d8ad64e0d8bff6b57903b2c59", "text": ["下面我们来讨论", "进程通讯机制的具体实现", "首先我们讨论的是信号和管道", "信号和管道是操作系统", "提供的两种简单的通讯机制", "首先是信号", "信号是进程间软件中断通知和处理机制", "我们在前边讲过中断", "它实际上是我们CPU", "在执行指令的时候的", "一种异常处理机制", "这种机制借鉴到进程当中来", "就是我们这里信号", "进程在执行的过程当中", "它有正常的执行流程", "如果说这时候我有意外的事件", "我怎么来处理呢", "并且是每一个进程", "有不同的处理的时候", "这时候我怎么办", "这就是我们这里的信号", "我们在实际系统当中见到的", "一个例子就是Ctrl-C", "我们在一个进程执行过程当中", "我们按Ctrl-C可以把这个进程停下来", "但是在你的实际代码当中", "并没有一段代码是完成对Ctrl-C的处理", "这个处理是在哪实现的呢", "这就是我们这里的信号", "操作系统在编译你的应用程序的时候", "它会缺省的加上", "对这些信号的处理例程", "如果说用户想", "指定自己的信号处理例程", "就需要在你的应用程序当中", "给出相应的实现", "比如说我们在这里看到的", "queue、stop、continue", "就是我们这里的几个常见的信号", "信号的处理机制有这样几种情况", "一种是捕获", "也就相当于进程执行的时候", "信号的处理例程 是由用户指定的", "每一个进程有自己不同的处理方法", "忽视或者叫忽略 那这时候呢", "是由操作系统的缺省处理例程", "来处理进程的信号", "比如说我们进程终止和进程挂起", "还有一种是屏蔽", "禁止进程接收和处理信号", "这种情况的一个实例是我们的登录程序", "你按Ctrl-C它是不能停下来的", "原因在于这时候", "把相应的处理给屏蔽掉了", "这种通讯机制呢", "它能够传送的信息仅仅是信号的类型", "它不能再传送其他的内容", "所以它传送的信息量是很小的", "这种做法它仅仅是用来", "做一种快速的响应机制", "它比别的通讯机制要快", "信号它的实现是如何进行的呢", "我们在这给出一个简单的图示", "在我们的ucore plus当中", "也有相应的实现", "有兴趣同学可以", "进一步去看相应的实现机制", "首先进程在启动的时候", "它需要注册相应的信号处理历程", "给操作系统内核", "以便于操作系统内核", "在有相应的信号送过来的时候", "它能够知道去执行哪一个处理函数", "这是注册 然后是有其他进程", "或者说其他设备发出信号的时候", "那么操作系统内核", "负责把这个信号送给指定的进程", "并且启动其中的信号处理函数", "然后执行信号处理函数的时候", "完成相应的处理", "比如说我把当前正在执行的进程掐掉", "或者说把它暂停", "或者说忽视", "都是由这来完成的", "接下来我们给出一个实际的例子", "在这个例子当中我们可以", "在linux里面来执行这一段代码", "它的主程序里头", "就是signal 实际上是", "我们的注册信号处理例程的系统调用", "你注册了两个信号", "它的处理函数到底是什么", "然后我这个进程", "就进到死循环里头了", "前边是它的实现 signal_int", "它完成的功能是打印字符串", "告诉你按了Ctrl-C", "然后就忽略过去了", "在前边加上这个重新注册", "是为了兼容性的缘故", "另外一个是退出", "如果你按Ctrl/这时候", "你的程序会结束下来", "因为如果没有这个的话", "你这个程序没有正常退出的时候", "因为我们在这是个死循环", "它就永远不会退出了", "我们按Ctrl/来实现原来Ctrl-C的功能", "这地方给出来你实现的退出", "这个程序执行起来之后的效果", "就是按Ctrl-C它给出一个提示", "然后程序继续执行", "按Ctrl/这时候程序退出", "这是信号使用的一个示例", "接下来我们说管道", "管道是进程间", "基于内存文件的通讯机制", "也就是说两个进程想通讯", "它中间的数据放在哪呢", "在内存里建一个临时文件", "把这个数据放这里头", "这就是我们这里的管道", "它利用父进程创建子进程的过程当中", "继承文件描述符", "这几个缺省的文件描述符", "在子进程里都是有继承的", "标准输入 标准输出和标准的错误输出", "那我们在这里头呢", "创建一个管道的时候", "我只关心我通讯的管道是谁", "并不关心另一头是谁往里放的数据", "这实际上是我们这里头说到的", "一种间接通讯机制", "这个数据可能来自于键盘", "也可能来自于其他程序", "或者说文件", "写出去的时候我可能会写到终端", "也可能会写到文件", "或者说给其他的进程", "那我们在这", "跟它相关的系统调用有这样几个", "一个是读管道", "因为我们创建的管道", "在这里有一个FD文件描述符", "创建完之后", "我就可以利用它来进行读了", "我们在实际的一个库函数scanf()", "就是基于管道的读来实现的", "另一个是写write", "这和我们通常的文件读写的", "系统调用是完全一样的", "我们上边的printf()", "也是基于对管道的写来实现的", "它把它直接送到屏幕上去", "再有一个是管道的创建", "这是一个单独的pipe", "创建的结果会生成", "一个文件描述符数组", "这个数组有两个成员", "一个是读文件描述符", "一个是写文件描述符", "我们就是利用继承的关系", "在两个不同的进程当中", "使用不同的文件描述符", "一头读 一头写", "那就实现了两者之间的通讯了", "我们也是给一个例子", "这是ls和more", "这是两个系统命令", "在这两个命令里头呢 中间加一个竖线", "实际上你就由share给它们俩之间", "建立一条管道", "我们可以用下面的图示", "来说明这个过程", "首先在执行这个命令的时候", "share程序解释这条命令", "它首先会去解释这个管道", "然后建立相应的管道", "然后前边有一个S", "它创建一个进程 来执行ls", "并且把它的标准输出", "接到这个管道上", "作为输入的这一端", "然后它会创建另外一个进程", "执行这个more这个命令", "然后它的输入来源于这个管道", "这样的话就把两个命令的一个的输入", "和另一个的输出接到了一起", "这个在我们的Linux和Unix系统里头", "是比较常见的一种做法", "这是管道"]}, {"name": "", "block_id": "1dca1ede459a47f881183e88b630273d", "text": ["下面我们来介绍", "如何利用信号量", "来解决同步互斥问题", "这就是我们这里说的", "信号量的使用", "那首先呢我们把信号量", "可以分成两类", "一类叫二进制信号量", "它的初值呢是0或者是1", "而另一类呢叫资源信号量", "它的资源数目呢", "可以是任意的非负整数", "这两类信号量呢它们俩是等价的", "也就说我用其中的一个", "可以构造出另一个", "可以由第一个构造出第二个", "也可以由第二个构造出第一个", "在使用信号量来解决", "我们的同步互斥问题的时候", "我们可以把它分成这样两种情况", "一种呢是互斥访问", "也就说在用它来控制临界区的互斥", "另一个呢是用它来做同步", "在两个线程之间实现事件的等待", "首先呢我们来看", "它具体是如何在做", "我们在这里的例子呢", "是用信号量实现临界区的互斥访问", "这时候做法呢", "是用一个信号量", "来对应一个临界区", "那这时候呢 由于我们说", "任何一个临界区在任期一个时刻", "只允许一个线程执行临界区的代码", "那这时候它的初值是1", "好 那我们先是完成它的初始化", "在这里呢初值取1", "然后我们来看", "它如何来控制临界区的访问", "那这是它的控制代码", "在前面呢有一个P操作", "在后面呢有一个V操作", "P操作完成申请 V操作完成释放", "它怎么来实现这个临界区的互斥呢", "首先这个信号量初始值为1", "所以第一个线程进来的时候", "它由它 把它1变成0", "所以它能进去 好", "如果说这时候有第二个线程", "也想进入临界区", "那么刚才第一个还在里头运行", "第二个来说它0变成-1", "好 那这时候呢", "它就在P操作这个地方进入等待状态", "好 那这时候", "在临界区的第一个线程", "它执行结束 进行V操作", "那么V操作呢就会导致", "它把刚才的这个信号量的计数", "由-1改成0", "那这时候呢它知道有", "第二个线程在里等着呢", "好 那么这个时候呢", "它唤醒第二个线程", "它继续往后走", "那这个时候呢 第二个线程", "就会在第一个结束的时候进入临界区", "那么利用这种做法呢", "我们就实现了临界区的互斥访问", "那用它来做的时候呢", "有几点需要注意的", "第一个呢 这里的PV操作", "必须成对使用", "也就说你有一个申请", "有一个释放", "如果说 不申请你直接释放", "会出现什么情况", "就会有多个线程", "进入到临界区里头", "如果说你只申请不释放", "那么这时候呢 就会出现", "缓冲区没有任何一个线程", "但是谁也进不去的情况", "用P操作保证互斥", "用V操作保证资源的释放", "然后这两个的顺序呢", "颠倒或者重复", "都会导致可能的麻烦", "第二个呢 我们用信号量", "来实现条件同步", "那这时候呢也是用一个信号量", "来描述一个条件同步", "那它的初值是0", "也就说在起头的时候", "那个事件还没出现", "出现之后 那这对于我们来说", "是一个资源 它就变成1了", "好 等待资源你申请", "那这时候事件出现之后", "那等待的就可以继续往下走", "具体怎么做呢", "初值它设成为0", "我有两个线程A和B", "分别有mn和xy各自的两个模块", "那我们需要做的事情呢", "是在B执行到x之后", "这个A才能执行n模块", "比如说我在这里这边要准备数据", "这边是使用数据", "如果说你的数据没准备好", "那你要想使用数据", "比如说n模块是", "对数据进行处理的话", "那你就没有可以处理的数据", "它们俩之间呢", "必须等到B执行完x", "A才能执行n", "好 那这时候我们怎么办呢", "在这里呢 一个P操作一个V操作", "在B里头 释放信号量的", "好 那么这时候它就会由0变成1", "好 如果说进程B", "先执行完x 到达这个点", "那么这个时候呢", "A执行完m的时候", "这个地方信号量的值就是1了", "好 它就直接能往下执行了", "假定不是这种情况", "是A先执行完m", "那么这时候呢它来申请", "进行P操作", "这时候呢信号量的初值是0", "那么这时候它变成-1", "这时候它堵塞 进入等待状态", "好 然后这个进程B呢", "执行完x到这儿它释放", "释放的时候我们刚刚还记得", "信号量的V操作的实现里头", "它是加一 如果说加完之后", "它是小于等于0的", "那这时候知道", "有另外一个线程A在等待", "好 那这时候唤醒A 它继续往后走", "这时候线程A呢", "也可以继续往下走了", "好 所以从这个地方呢", "我们就实现了一个条件等待", "线程A要等待线程B执行完x模块", "它A才能执行n模块", "这是我们用信号量", "来实现同步的两个基本的情况", "和我们这里的基本做法", "好 那我们下面呢", "来看一个更实际的例子", "就是这里我们所说的", "生产者 消费者问题", "这个问题的基本要求呢是这样的", "有一组生产者 一个或者是多个", "它们负责产生数据", "并且把这数据呢放在缓冲区里头", "然后另外呢还有一个消费者", "这个消费者呢", "负责从缓冲区里读数据", "进行后续的处理", "比如说我们在这里呢", "消费者就是对应我们打印进程", "前面呢就是对应着你的应用程序", "若干个应用程序", "会产生打印作业", "放在缓冲区里头", "打印服务器呢", "负责从缓冲区里", "读出你的打印数据", "然后进行打印", "那这个缓冲区呢有一个限制", "就是在任何时刻", "只能有一个生产者或者是消费者", "可以访问这个缓冲区", "不可以两个同时来做", "那它们在用的过程当中", "可能会有这种情况", "生产者往缓冲区里写", "那我的缓冲区得有空地才能写", "如果写满了 那它做不下去了", "消费者从里读数据", "里头得有数据它才能读", "如果没有数据它得等着", "好 我们就来看", "如何用信号量实现", "生产者 消费者之间的协调关系", "我们如何用信号量来解决它呢", "我们首先对这个问题呢做一些分析", "从我们刚才的描述里呢", "大家可以知道", "实际上这个缓冲区是一个临界区", "任何一个时刻", "只允许一个线程对缓冲区进行操作", "这可以描述成临界区", "除此之外呢还有另外两条限制", "第一条呢是说", "消费者要从缓冲区里读数据", "如果说缓冲区里没有数据 是空的", "我消费者是没办法进行下去的", "它必须等待生产者", "往缓冲区里放了数据之后", "它才能够继续往后进行操作", "另一个呢是生产者", "生产者必须等待缓冲区里头有空地", "你才能够往里放", "如果缓冲区满了 那生产者必须等待", "我们把生产者消费者问题的描述呢", "转换成了我们用临界区", "和条件等待的方式", "给它描述出来", "那这三条呢 对应过来就是", "我们这里的互斥访问 缓冲区", "然后生产者和消费者", "分别有一个条件等待", "是等待对方的", "那这时候呢 我们把它描述出来", "就变成这样几个信号量所做的约束", "第一个呢是二进制信号量", "它描述这里的互斥关系", "第二个就是fullBeffers", "它对应着 有数据我才能够往外读", "所以消费者必须等待缓冲区里有数据", "然后再有一个呢 是生产者", "生产者必须等待缓冲区有空地", "你才能往里写", "好 这两者对应这两个信号量", "它加起来之后呢", "应该是你缓冲区的总的大小", "好 有了这些分析之后呢", "我们基本上就把我们这里的", "生产者消费者这一个同步的问题", "转换成我们刚才说的", "互斥访问和条件等待", "那接下来呢", "我们把它转换成实际的代码", "首先呢 是对它的初始化", "二进制信号量", "它的初值是一个临界区 初值为1", "好 然后刚开始的时候", "缓冲区里没有任何数据", "所以缓冲区满", "这个地方它的初值是0", "好 然后说有多少个空缓冲区呢", "每个空缓冲区对应着一个资源", "生产者 消费者它是如何在做", "这是生产者 这是消费者", "它们对应的代码", "那在这里呢 往缓冲区里放数据", "从缓冲区里读数据", "是它们要进行的主要操作", "那首先第一个", "我们要实现这个是互斥访问临界区", "所以在这儿呢", "有一个P操作 有一个V操作", "是申请这个二进制信号量mutex", "好 在这边呢也是一样", "好 实现他们俩之间", "对缓冲区的互斥访问", "它仅有互斥是不够的", "如果说缓冲区里头没有空地", "你即使申请到了缓冲区的互斥操作", "你也没办法操作", "因为里头没空地了", "而这时候你又把缓冲区占掉了", "消费者已经没有办法帮你腾出空地来", "所以在这儿之前呢", "我需要来检查是否有空缓冲区", "有 我可以再进一步检查", "是否有另外一个生产者或者消费者", "在访问缓冲区", "好 如果没有", "那它就可以往里放数据了", "那这一条有没有缓冲区", "它在什么时候会去释放呢", "那消费者在从里头读出数据之后", "它在这里呢会释放一个空缓冲区资源", "也就相当于我给你腾出一个空地来", "而另一头呢", "消费者要想进入的时候呢", "它得看里头是否有数据", "好 在这个地方呢 负", "那实际上就是我看里头是否有数据", "那只有生产者往里写了数据之后", "我这个地方呢才能有数据资源", "好 那你才可以从里头读数据", "生产者在往里写了数据之后", "它就释放一个fullBuffer", "这样一个资源", "释放这个资源之后", "实际相当于我这个里头就多了数据", "好 这时候这个消费者呢", "他们俩是配合", "这时候有一个问题", "我在这个地方这个顺序可以调整吗", "在这里头 如果说", "你把这两个顺序调整了", "它就会出现死锁", "原因是在于我检查空和满", "你需要先检查", "然后我再去申请互斥访问", "如果说你申请了互斥访问", "那这个时候你已经占用了临界资源", "那别人不能读写了", "而这时候你又发现里头是满", "或者发现里头是空", "那这时候你进行不下去了", "但这时候呢别人也没有办法", "来申请到这个临界区", "那这时候它就会形成死锁", "这是用信号量机制", "来解决生产者消费者问题", "从这个应用的例子当中我们可以看到", "实际上用信号量来解决同步问题", "它是需要你有技巧的", "程序员在写的时候", "你必须很好的了解你的问题", "和很好的运用信号量机制", "并且这时候呢", "它是容易出错的", "我可能在某个地方", "忘了一个P操作", "或者忘了一个V操作", "或者说我把它的顺序搞倒了", "这些呢都是容易出问题的", "所以它没有办法避免死锁的出现", "你必须在你写程序的时候", "来解决这个问题"]}, {"name": "", "block_id": "c6191da059c34e3da27223f2cf702cd9", "text": ["下面我们来讨论文件分配", "文件分配是指我们把哪些块", "分配给一个文件来存它的数据", "在具体讨论分配方法之前呢", "我们有必要来分析一下文件的大小", "也就是说我分配的方法", "跟文件的大小是有直接关系的", "那首先我们来看", "文件大小的分布情况", "在我们现在想象里头", "或者说 在我们现在", "实际数据统计里头", "可以发现这样一些情况", "就是大多数的文件都是很小的", "所以在我们的分配方法里头呢", "那个数据块的大小不能太大", "因为如果说你的大部分数据", "放到一块里有很大的剩余的话", "那么这时候呢", "它的存储效率是比较低的", "所以我们在这儿呢", "需要对小文件提供很好的支持", "当然这个文件小呢实际上也是相对的", "比如说在我们用计算机早期", "我的数据呢 你比如说像邮件", "通常情况下就是几百个字节", "几千个字节就已经算是比较少的了", "但是现在的邮件呢", "实际上我们上头有一图片签名", "这一下子就是多少K出去了", "所以这个大小呢也是一种相对的", "并且随着时间的变化", "和应用的变化而不同", "与此同时我们还有一些非常大的文件", "所以在我们分配办法里头呢", "必须考虑到如何能支持这些大的文件", "比如说我们来描述", "分配给一个文件的数据块有多少个", "那这时候呢你有一个标识", "这个标识呢比如说用个整数来表示", "整数有多少位", "就跟你这儿能表示的", "最大个的文件的大小是直接相关的", "如果说你不足以表示", "实际用到的最大文件的大小", "那么你这个文件系统就没法来使用了", "所以我们需要对大文件有很好的支持", "要考虑到这个文件可能会比较大", "比如说像我们现在", "看到的一张光盘映像", "这个映像文件通常是几个G", "如果说我是一个虚拟机的镜像", "那这个镜像", "可能会是几十个G或者更多了", "那对于这种情况呢我们也需要做考虑", "所以针对这种文件大小的分布呢", "我们来看如何来进行文件分配", "分配是指说", "我把哪些数据块给一个文件", "但实际上这种分配的办法呢", "它背后的本质实际上是", "用什么样的方法来表示", "一个文件的数据块的位置和顺序", "因为这个位置和顺序的表示方法", "直接决定着你如何来分配", "那我们看有怎样一些分配方法", "这些分配方法呢在这儿", "一个是连续分配", "我分配一个起点", "然后连续的若干个数据块", "用来存在这个文件", "也可以用链式分配", "我告诉你在第一块里记第二块的位置", "一直到最后一块", "也可以采用索引分配", "我分配一块里头专门用来存序号", "说我这里都有哪些块存了数据", "这些块的顺序是啥样子", "这是几种常见的办法", "这几种办法呢", "我们在选择的时候", "考虑的因素呢一个是存储效率", "一个是读写性能", "存储效率呢是说", "我每次分配的最小单位是一块", "所以内碎片我们就没办法进行处理了", "我们在这里能做的处理就是", "你在选择数据块大小的时候做些考虑", "假定这个问题我们忽略", "我们来看外碎片", "也就相当于如果我是连续分配", "中间块数不够的时候", "你想表示大文件就是不行的", "所以在这儿呢", "你的选择算法有存储效率的问题", "当然我们说后两种算法", "它就没有外碎片", "所以这个问题就没有了", "但是它有后面的问题", "读写性能问题", "说如果我是顺序分配", "那我知道起点", "然后我就按照序号往下算", "我就能知道", "我要访问的任何一个位置在哪", "这样的话我的随机读取的速度会很快", "但是如果说你是链式分配的话", "那么这时候我要想找中间某一块", "我必须从头往后去找", "去遍历这个链表", "那这时候呢它的读写性能就会比较差", "这些都是我们在这里讨论", "文件分配的时候必须考虑的指标", "那我们对三种分配办法呢", "做一个简要的描述", "首先是连续分配", "连续分配呢是在文件头也就是", "我们所说的文件控制块里头呢", "记录起始第一块的位置和长度", "因为我是连续的", "所以我知道第一块和长度之后", "那么能说清楚每一块这个文件分配的", "所有的块都在什么位置", "我们用一个图示来表示", "这就是你的索引结点", "也就说文件控制块", "里头有一个指针指向第一块", "并且里头记录了它的长度在这儿", "就从这儿到这儿", "这是我的一个文件所占用的数据块", "那在这里头我怎么去找", "这个连续的这块区域呢", "最先匹配 最佳匹配", "我们在前面跟内存分配", "也有类似的讨论", "那些讨论的特征在这儿", "都有一定程度的体现", "在这儿我们就不仔细去讨论了", "这些做法它的特点有什么样呢", "文件的读取性能表现非常好", "也可以有很好的顺序", "和随机读取的性能", "它的麻烦是什么", "它的麻烦是碎片", "我想分配十块结果现在就剩五块了", "那这五块没法用了", "如果说我在这里头碎片很多", "实际上这时候", "它的存储效率会比较差的", "再有一个问题", "这是我们在前面", "内存分配里不太遇到的", "或者说不是很重要的问题", "就是文件长度的变化", "我减少长度这事还好说", "增加长度如果说分配的正好是这一块", "你给它增加", "那后面块已经被其它文件占用了", "那这时候怎么办", "因为我们是持久数据保存", "那这个保存完之后", "这数据长度会增加这是极有可能的", "对于这个问题呢我们不能忽视", "那怎么办 在这里说到", "我可以后面预留几块", "还是说我分配的时候再把它整个搬", "所以从这个角度来讲呢", "这个长度发生变化 特别是增加", "对于它来说是一个比较棘手的事", "这是第一种做法", "接下来我们讨论第二种做法 链式分配", "链式分配呢是指说", "我用一个数据块的链表来表示", "在文件头里头有指向第一块的指针", "然后第一块有指向第二块的指针", "这时候呢顺序走下去", "同时呢在头里头呢", "再加上一个指向最后一块的指针", "这样一来我们就可以表示清楚", "一个文件所占用的数据块", "第一块是在哪 都占用哪些块", "它的这些块的顺序是什么样子", "这种做法它有什么样的特征呢", "优点是这时候说我在这里头", "增加删除占用的数据块", "这都会比较方便", "由于任何一个数据块我都可以", "插到这里头来所以它没有外碎片", "但是它有什么问题", "它没有办法很方便地实现随机访问", "我想找第一块最后一块", "那这是你是直接从文件控制块里头", "就可以找到的", "但是我想找中间这一块怎么办", "我只能找到第一块然后顺序往后找", "我才能找到后面这一块", "由于我是单向的链表", "我想找倒数第二块", "我只能从正着数的第一块一直找过去", "从这个角度来讲呢", "它的访问特征呢是比较差的", "再有一条呢是它的可靠性", "我们在这里存到磁盘上", "数据放一段时间之后", "或者说多次读写之后", "里头数据可能会出错的", "如果说我在这里头", "指向下一块这个指针出了错", "那么从这个指针往后的数据你就丢了", "所以从这个角度来讲呢", "它的可靠性是比较差的", "这是第二种做法 链式分配", "第三种做法呢是索引分配", "也就说为每一个文件", "创建一个索引数据块", "里头来存都有哪些数据块我存了数据", "这时候这是这个索引数据块里的内容", "是指向所有数据块的指针的列表", "然后在你文件头里头", "有一个指向索引数据块的指针", "那么这样的话", "从文件头就知道这个索引块在哪", "然后在索引块里呢", "我能知道每一块的位置", "和它们之间的顺序", "从这个角度来说", "这种做法好像不错", "这是它的图示", "我在文件头里指向索引块", "索引块里呢", "有每一块的序号和它们的顺序", "这时候说它的好处有什么", "创建 增加 缩小都比较容易", "然后也没有碎片", "你想直接访问哪一块呢", "我读到这一块索引块也就行了", "所以这样一来它也可以支持直接访问", "那它有什么缺点", "这时候说如果我的文件很小", "它一块就能存得下", "你还分配一个索引块", "那么这时候我又得要两块", "这时候呢它的存储开销是很大的", "这是文件比较小的时候", "如果文件比较大呢 大到什么程度", "大到我索引块里存的这些序号", "它也用一块存不下了", "那这时候呢", "我这地方就得再加索引块", "如果说你在你这里头", "不支持加多个索引块的话", "那么这时候", "对大文件的表示呢也会有麻烦", "所以这是我们这几种办法呢", "我们看下来", "它都各自有各自的优点和缺点", "那在实际用的时候呢", "我们基本上会把这几种呢", "组合到一起来用", "那这时候对于大个的索引文件呢", "我们又可以在这里呢", "再往下组合新的方式", "链式索引块", "也就是各个索引块之间它怎么来组织", "总体上来说它是索引分配方法", "指向这里的块", "然后这地方是索引块", "索引块之间呢我用一个链式", "或者索引块之间呢再做一个索引", "这就变成了多级索引块", "这是对大文件的表示方法", "我们下面呢", "来看一个实际的索引分配方法", "看它怎么做的", "怎么来把我们前面说到的", "各种算法的优点集中到一起", "把缺点都去掉", "这就是我们这里的UFS的多级索引分配", "UFS是unix file system", "unix文件系统", "它的做法是什么呢", "在这个文件控制块里头", "我前面10个是直接索引", "你直接这10块的位置都标在这里头", "如果说你存的数据比较少", "只有10块以内", "我就索引直接到文件对应的数据块", "如果说大于10块", "那这时候呢我第11个指针呢", "写的是一个一级间接索引", "那在这儿呢 它指向一个索引块", "这个索引块里头呢", "再指向实际的数据块", "这是一个间接索引", "这时候我在间接索引块里", "能放多少个序号呢 假定说能放N个", "根据你每一个序号所占用的空间不同", "和你块的大小呢这个地方是不一样的", "有了一级索引", "那这时候我只需要11个指针在前面", "如果说你仍然加一个一级索引", "和前面十块加在一起还不够用 怎么办呢", "不是我在这里再给你加一个一级索引", "它是加一个二级索引", "这是索引块的索引 这是二级索引", "那么只要你大到一定程度之后", "我就不再采用一级索引了", "我采用二级索引", "那二级索引如果仍然不够用怎么办呢", "它会再加一级 三级索引", "相当于这是索引块", "然后这是一级索引", "然后这是二级索引", "那这时候我们看到后面这一块的话", "你要想访问到实际的数据块", "它前面是有大量要查询的", "这是我们多级索引它所面临的麻烦", "但是把这几个搁到一个实际系统里头", "我们就看到", "它表示文件的大小比较小的时候", "它的效率呢是直接索引", "文件比较大的时候呢", "它也能表示", "当然这个效率它是会有一定下降的", "我们看到在这里头呢", "这就把前面讲的几种办法呢", "很好地组合到一起", "从而呢变成一个实际的索引分配方案", "这是我们用一个实际的例子来说情况", "说10个然后在这里呢", "文件控制块里呢只有13个指针", "那下面我们看一下它所带来的效果", "这时候对于文件大小的限制", "我由于有三级索引", "那我可以表示很大的文件", "具体有多大", "我们会在练习里来进行计算", "然后说我对于动态分配", "我增加缩小都比较容易", "那这是索引分配方案的好处", "然后我对付小文件呢", "它的开销也比较小", "因为我直接在控制块里头", "填这个数据块的序号", "而对于大文件来说呢", "我使用间接索引", "所以这样它也能表示大文件", "只是说它的查询速度呢会有所下降", "到这个地方呢", "我们就把文件分配的几种方法呢", "有了一个大致的介绍", "也说明了它们各自的", "适用场景和优缺点"]}, {"name": "", "block_id": "ba02561a8c2d470caff35542b533a850", "text": ["下面我们来介绍优先级反置", "优先级反置呢指的是说", "我们在操作系统当中", "出现高优先级的进程", "由于等待低优先级进程所占用的资源", "而导致高优先级进程", "长期等待的现象", "这是一个例子", "进程T1它的优先级是40", "然后它占用的资源L1", "这时候另外一个进程T2", "它的优先级是50", "那它的运行过程当中", "要申请资源L1", "由于T1已经占用资源L1", "所以这时候它处于等待的状态", "那么按照正常情况下呢", "这时候T1就应该", "进入运行状态", "然后等到它释放资源", "然后高优先级的这个进程", "再获取这个资源", "但是在这个过程当中", "如果有另外一个进程T3", "它的优先级是46", "在高优先级的进程进入组合状态之后", "低优先级进程还没有得到CPU使用权", "投入运行状态之前", "那T3进入运行状态", "那么这时候呢T1就没有办法继续执行", "那它所占用资源呢", "也就没有办法释放", "那这样的话", "T2这个高优先级的进程呢", "就会一直等待下去", "这种情况呢", "就是我们这里说的优先级反置", "优先级反置导致", "这个进程长期进入等待状态", "在什么时候会出现这种情况呢", "只要你是用的是基于优先级的", "并且是抢占的调度算法", "那么都会存在这种情况", "好那这种情况怎么处理呢", "我们在这儿介绍两种基本的做法", "一种呢称之为优先级进程", "优先级进程是指", "占用资源的低优先级进程", "继承申请资源的高优先级进程的优先级", "这种做法我们可以通过", "这样一个图式来展示", "在这里呢有三个进程", "T1 T2 T3", "它们这3条线呢代表不同的优先级", "底下T3优先级比较低", "那首先呢是T3进入执行状态", "那到T2时刻 它占用资源", "然后在临界区进行执行", "在临界区执行的过程当中呢", "这时候 有一个", "优先级比它高的进程T1", "进入执行状态", "那么它这时候呢被抢先", "好 T1开始执行", "在T1执行过程当中它申请资源S", "好 那这时候 T1的申请", "导致T3的优先级提升", "那提升上来之后", "那么这时候呢它继续往下执行", "它执行到释放资源S", "那 释放资源S之后", "那这时候T1就可以获取这个资源", "然后继续它的临界区执行", "等到它释放资源之后", "那它再继续执行", "在这个过程当中", "如果说有T2出现", "那么它必须等到T1结束之后", "它才能占用CPU来继续执行", "在这个过程当中", "由于T3被T1强占", "所以这时候 会有高优先级", "等低优先级的这种情况", "T3申请到资源", "而高优先级的T1", "进入执行状态的时候", "那么这时候T3被阻塞", "它申请资源的时候呢", "如果它申请的正好是", "T3所占用的这个资源", "那么T3的优先级", "就会提到跟它一样的高度", "好 那这时候呢它就可以进入执行状态", "等到它释放资源", "好 那么这时候它优先级又回来了", "回来之后 那这时候呢", "T1就可以获取到这个资源", "因为它这时候进入执行状态", "并且它的申请呢就能获得批准", "好 然后一直到它释放", "那它正常执行", "那我们说 在这种情况下", "优先级反置的现象呢就没有了", "那在这儿呢 需要说明的是", "这个占有资源的低优先级进程", "只有在被阻塞的情况下", "它才会提升优先级", "如果不是这样的话", "那么它的优先级是不会被提升的", "另一种做法呢 叫优先级天花板协议", "它的做法是什么呢", "就是占有资源的进程", "和所有可能申请该资源的进程相比较", "那把它的优先级呢设置成", "这些可能申请资源的进程里", "优先级里最高一个", "用这种办法的话", "那它占用资源的时候", "其它的任何进程都不会", "阻止它使用这个资源了", "那这种做法呢 不管是否发生等待", "我的优先级都会提高", "实际上在这种做法里", "可能会有优先级滥用的情况", "也就是大家会把", "自己的优先级提的很高", "实际上所有都提到最高优先级的话", "提高优先级已经没有意义了", "好 所以在这儿呢", "由于高于系统当中", "所有被锁定资源的优先级", "好那这时候呢", "它在执行临界区的时候", "就不会被堵塞了", "这是两种理论上的做法", "在我们实际系统里头呢", "通常情况下都跟这有很大的区别", "详细的情况呢", "希望大家去看实际系统当中的", "相关的文档和代码", "好 到现在为止呢", "我们就讨论清楚了", "操作系统当中的处理机调度的", "基本原理和我们这些调度算法", "以及于对实时调度和多处理机调度呢", "有一个简要的介绍", "最后说明了在调度算法当中", "可能出现的优先级反置现象", "好 今天的课呢就到这里 下课"]}, {"name": "", "block_id": "e6f03103fcbb42ec8e6ee0f7dec180e8", "text": ["下面我们来介绍管程", "这是我们这里", "今天说到的第二种同步方法", "我们在刚才的", "同步方法介绍当中呢", "有了信号量", "它使得我们在操作系统参与下", "我们处理临界区呢", "比原来会变得更方便", "好 那接下来我们介绍的管程呢", "实际上是想改进信号量", "在处理临界区的时候一些麻烦", "比如说在我们刚才看到的", "生产者消费者问题当中", "信号量的PV操作", "是分散在生产者和消费者", "两个不同的进程当中", "在这种情况下", "我们PV操作的配对", "是比较困难的", "好 我们试图把这些", "配对的PV操作", "集中到一起", "这就是我们这里说到的管程", "它也是一种并发程序的编程方法", "那为了支持它呢", "我们在底下呢", "还得再加上一个条件变量", "这是在管程内部呢", "使用的一种同步机制", "下面我们就具体来看管程的做法", "管程是一种多线程", "互斥访问共享资源的程序结构", "它采用的是面向对象的方法", "也就说把共享资源相关的PV操作", "集中到一起从而简化", "线程之间的同步控制", "它保证的是任何一个时刻", "最多只有一个线程", "在执行管程代码", "那从这句字面上解释呢", "大家觉得管程好像", "和我们的临界区是一样的", "临界区也是允许一个线程", "在临界区执行代码", "管程也是这样", "那这两者有什么区别呢", "它的区别体现在下边这一条", "正在管程中执行的线程", "可以临时放弃管程的互斥访问", "等待事件出现时恢复", "这指什么意思呢", "一个线程在临界区当中执行", "它必须执行到它退出临界区", "它才可能放弃临界区的互斥访问", "而管程呢 允许我在执行的过程当中", "临时放弃", "那临时放弃之后呢", "那其它的线程呢", "就可以进到管程这个区域里头了", "这种做法呢一种形象的比喻", "像我们在赛车场", "假定赛车场的赛道呢", "为了安全我只允许", "一辆跑车在上头跑", "那它在跑的过程当中呢", "它可能会加燃料", "可能会更换零件", "那在这个更换零件或者说", "加燃料这个时间呢", "它处于暂停的状态", "这时候允许其他的赛车进入赛道", "这是管程的一个基本比喻办法", "假定它能干活了", "那我们这时候", "会需要做什么呢", "管程的使用就是", "我把我现在要同步的这些模块当中", "收集共享的这些数据", "然后编写对这些", "共享数据的访问方法", "有了这个之后", "那在各处用的时候呢", "它就不用在其它地方再做", "同步互斥这些操作了", "那怎么做到这一点呢", "首先我们把这个区域里的代码", "理解为我们的管程", "如果说你把它", "视为是一个临界区的话", "那这时候呢", "只需要在入口的地方", "加一个互斥访问的锁就可以", "管程也是一样", "在这个地方入口队列里头呢", "它只允许一个线程在管程内部执行", "如果说在这个内部", "没有其它共享数据的话", "这时候呢就和我们的", "临界区是完全一样的", "任何一个线程", "在进来的时候都在入口排队", "允许只有一个线程进来", "到它退出的时候", "另外的线程可以进去", "好 管程在这个临界区", "基础上又加了一条", "就是零个或者是多个条件变量", "如果是零个的话", "那就等同于一个临界区", "如果是其中有一个以上的条件变量", "那么这时候呢", "就是我们这里管程所特有的了", "它用来管理共享数据的并发访问", "需要这些共享资源的时候", "那么在这儿呢对应着", "有相应的条件变量允许有了", "那你才可以", "使用中间这些互斥的操作", "这是管程的基本思路", "那这中间就用到一个条件变量", "条件变量是什么呢", "条件变量是管程内部的等待机制", "进入管程的线程", "因为资源占用而进入等待状态", "那这时候呢它就等在条件变量上", "每一个条件变量呢", "表示一种等待原因", "它对应着一个等待队列", "有了这个之后 我们在上面", "再附着两个相应的操作", "一个是等待", "那等待将自己堵塞在", "等待队列当中 同时唤醒", "另外一个者 或者说", "放弃管程的互斥访问", "后面这两种情况就是", "允许另外一个线程进入管程", "它自己呢等在这个", "管程内部的等待队列上", "这是我们这里的条件变量", "还有一个操作呢是释放操作", "这个释放操作呢", "它将等待队列当中一个线程唤醒", "如果说没有", "这就相当于是一个空操作", "好 有了关于条件变量", "这种约定之后", "那下面是它的实现", "从这儿呢我们看到", "它和我们前面讲的", "信号量的实现呢很接近", "它在这儿条件变量", "是有一个整型变量和一个等待队列", "只是说跟我们的信号量不同呢", "条件变量的初值是0", "而在信号量里头呢", "它的初值是和你的资源数是一致的", "然后对应着它有两个操作", "Wait和Signal 等待和这里的释放", "那等待在里面做什么呢 计数加1", "好 那就相当于我正数表示其中", "有线程处于等待状态", "然后把它自己放到等待队列当中", "释放管程的互斥访问权", "然后执行调度", "这实际上就说有了调度之后呢", "我们就可以切换到另外的进程", "或者是线程来执行", "等到它回来的时候", "它再去请求管程的访问权限", "而释放呢", "它都是放在这一个if语句里头", "也就相当于如果说", "这个条件不成立的话", "这个操作相当于是空操作", "好 条件成立也就说有另外的线程", "等在这个条件变量上", "它会做一些什么呢", "好 把这个线程从等待队列里移出来", "放到就绪队列里头 让它可以执行", "然后把它的计算减1", "也就说这时候等的这个", "线程的数目呢少了一个", "好 基于这个实现", "那我们就可以来看", "如何用管程来实现", "生产者 消费者问题", "这是呢 刚开始的初始化定义", "两个条件变量一个入口等待队列", "入口的锁", "这和我们前面用信号量解决", "生产者 消费者问题的设置呢很类似", "然后在这管程内部的值呢", "它当时是0", "这个数呢用来表示", "你写的缓冲区里的数据的数目", "然后我们看这时候生产者", "和消费者分别对应着一个函数", "这是我们管程的封装作用", "把它封装到这两个函数里头", "其它地方要使用的时候呢", "只需要调生成数据和读取数据", "这两个函数就可以了", "那这里头本质性的操作呢", "是往缓冲区里写一个数据", "并且把这个计数加1", "消费者呢是从缓冲区里", "读一个数据并且把计数减1", "好 那我们在做这件事情之前", "各自需要一些什么准备呢", "首先我把它放到一个管程里头", "这是由管程进入的申请和释放", "那这是在管程内部", "你可以理解为这两个函数", "是构成我们管程的内部的代码", "我申请到了管程的", "互斥访问权之后", "那我在这里头呢", "我就可以往里写数据了吗", "不是 我得先看你是不是有空地", "那在这儿 就是去看是否有空地", "如果说没有", "就相当于我这里头", "N个缓冲区里都有数据了", "那么这时候呢", "我就等待一个条件变量上", "notfull 等在这个条件变量上", "有空地之后呢", "我再回来往里写数据", "这边呢跟我们前面的", "信号量做法类似的", "在消费者这头呢", "是读出一个数据之后", "它就释放一个条件变量", "说如果你在那里头有生产者", "等在需要空闲缓冲区的情况", "那么这时候它就把它唤醒了", "那这时候有一个问题", "我们用信号量解决的时候", "我必须先检查缓冲区的状态", "然后再申请互斥操作", "那现在在管程里头你把它倒过来", "这样就没问题了吗", "实际上这里的原因在于", "因为管程我在内部检查的时候", "如果不成功我还可以放弃", "管程的互斥访问权限", "而在信号量那个地方实现里头", "我进到那个临界区里头了", "好 我已经占用了", "对缓冲区的互斥访问", "那这时候别人就再进不来了", "因为我没有办法放弃", "所以这是这两者之间的区别", "也正是由于这个区别", "我可以把这个检查空满的判断呢", "放在管程的内部", "跟这相对应", "消费者呢读数据之前", "需要检查是否缓冲区里头有数据", "如果说没有", "就这个计数为0", "那么这时候呢", "它有放弃管程的使用权", "等在这个非空的这个条件变量上", "好 一旦里头有数据之后", "那有数据呢是生产者", "写完数据之后它做释放操作", "写完数据之后那这边释放", "好 它出来再检查成功之后", "它就可以往外读数据了", "好 那这是呢我们用管程来实现", "生产者消费者问题的解法", "我们比较基于信号量", "和管程的实现方案", "我们可以看到在管程里头呢", "它可以把PV操作都", "集中到一个模块里头", "从而呢简化和降低", "同步机制的实现难度", "在这里头我们", "还有一个问题需要来讨论", "管程里头条件变量", "到底是内部的线程优先执行", "还是正占用管程处于执行状态的", "这个线程有更优先权限来执行", "这两种不同的处理办法呢", "对应到我们这里的两种不同管程", "一种叫Hanson一种叫Hoare", "这两种做法的区别是这样的", "在Hanson管程里头呢", "一个线程T1等待条件变量", "那么它进入等待状态", "这时候允许进程T2开始执行", "在T2执行过程当中呢", "等待的条件成立了", "好 那这地方呢它在管程里头呢", "这T2给了一个释放", "允许x条件变量所对应的线程", "可以开始运行", "那在Hanson的做法里头呢", "它释放完了之后", "当前这个T2还会继续执行", "一直到它放弃", "管程的互斥访问权限", "然后T1才恢复执行", "这种做法呢", "是当前正在执行的这个线程更优先", "而Hoare的做法呢是倒过来", "第一个线程执行到", "等待条件变量的时候", "进入等待状态", "第二开始执行", "这跟前面都是一样的", "它们区别在于T2认为", "T1等待的事件已经出现了", "好 那这时候它唤醒T1", "唤醒完了之后这时候", "它立即放弃管程的互斥访问权", "好 这时候T1马上开始执行", "等它执行结束之后", "T2再继续执行", "如果说我们从通常的", "优先的角度来讲", "T1更优先是合理的", "这个呢在我们现在的", "基本原理介绍里头呢", "Hoare做法", "是更容易证明它的确定性", "而第一种呢", "它连续执行 它的效率会更高", "在这儿呢就少了一次切换", "所以这两种做法呢", "目前在真实系统里头呢", "一般用的是Hanson的做法", "而在教科书里头呢", "用的是Hoare的做法", "基于这两种不同的做法", "我们再来看", "它在生产者消费者问题当中的体现", "这是我们刚才生产者消费者", "问题当中基于管程的实现代码", "好 两种不同做法它们的区别在哪呢", "在这个地方 一个是while一个是if", "这两种区别怎么体现出来呢", "在这个地方", "条件变量等待的时候", "这种释放呢它仅仅是一个提示", "你回来之后你要重新去检查", "这是while的含义", "再次检查呢", "实际上相当于我要再重新去排队", "因为在前面那个释放操作里呢", "释放完之后它还会再继续执行", "有可能在这个执行过程当中呢", "这个地方的状态是会有变化的", "好 也正是由于这个原因", "在Hanson的做法里头呢", "当前正在执行那个线程优先级更高", "好 那这个地方呢你需要重新来检查", "所以这个地方是while", "而在Hoare的做法里头呢", "条件变量的释放操作", "表示条件变量的立即释放", "和放弃管程使用权", "那这时候呢", "它出来之后不再需要进行检查", "而直接开始后续的执行", "那这就是等待条件变量", "那个线程它的优先级更高", "这两种做法呢", "明显是第一个效率更高", "第二个呢效率会低一些", "因为它多了一次切换", "当然第二个行为的确定性", "会更好一些", "所以一个用在基本原理里头", "一个是在实际系统里头"]}, {"name": "", "block_id": "be3edbb4f3c24641b98b08a5835465fd", "text": ["接下来我们讨论系统调用", "系统调用是操作系统对上提供服务的接口", "他是在怎么实现的", "然后我们在这里会说", "你提供的功能可以通过函数调用", "也可以通过系统调用", "这两者之间到底有什么区别", "然后他们在实现的时候开销是什么样子", "我们在这一部分来进行讨论", "首先我们看一个标准的函数调用", "比如说我想在这里的", "我的应用程序这个大家前面都写过", "我有个printf我想在屏幕上输出一份信息", "我在这里有一个printf就可以了", "背后实际上他怎么做", "你写程序设计的时候", "看到情况是说他有一个标准C库", "C库里提供了printf底下就是printf", "来实现功能给你用就行了", "但是他背后实际他是转成了操作系统的write", "系统调用 然后write系统调用", "它的实现是在内核里的", "根据你write里头参数不同", "会把你print输出的文件", "可能输出的屏幕", "那把这个图再转换一种形式来看", "我们更关心系统调用这个接口的话", "你会看到跟这个很相似", "但是这是说这是我关心的 上面是应用程序", "把我们传统说的应用程序", "和你那个系统库都算到这个上面去了", "这是我看到系统调用接口", "在这个系统调用接口里头", "进到内核里头去 由于write", "你这个系统调用的编号的不同", "我在这选择不同的系统调用编号", "这个编号导致我write里头采用它的实现", "最后给出结果来 返回回去", "那我在屏幕上或者文件里", "就写出了我的printf内容了", "这是我们说函数调用", "那么对于系统调用来说", "实际上是说他在底下提供操作系统服务的接口", "通常情况下 我们是用C", "或者C++高级语言来使用这些的", "而你在写程序的时候", "通常并不直接去使用系统调用", "而把系统调用封装到一个库里头", "比如像我们标准C库", "应用程序是访问这些库里的库函数来实现的", "实际上接见访问系统调用", "下面这几个是我们常见的应用编程接口", "也就相当于我们系统调用最后封装完了之后", "用户用到接口是什么样的", "在不同的系统里面是不一样", "比如说在Windows它有一个Win32 API", "是用Windows操作系统内核的服务来实现Win32 库", "那在这个库里用户来使用", "而在Unix Linux这一类系列的系列有一个POSIX接口", "这个POSIX接口提供了用户需要用到各种各样的库", "而这个POSIX接口底下会访问系统调用接口", "来实现它的服务", "而对于Java虚拟机来说", "实际他上面有一个Java API", "让虚拟机里的应用程序间接的", "会转到我的系统调用接口上来", "这是外界使用的情况", "他内部实现是什么样", "每一个系统调用都有一个系统调用编号", "然后依据这个编号不同", "我们来使用不同的功能", "在这张图我们可以看到这是系统调用进来的入口", "从这通过软中断进到系统内核里来", "他首先体现为一个中断", "中断看是系统调用软中断", "这个时候就转到这个地方来", "这个地方你那里系统调用的编号", "在这编号", "在这是体现为一个功能编号", "功能编号不同我会选取不同系统调用实现", "OK 得到它的结果之后返回回来", "这是对外提供的系统调用编号", "从用户的角度讲", "我们关心只是从这进 这个地方出来", "其他部分我不关心了", "你不关心的底下内容", "但是在这里我们需要关心一个事情", "就是我在使用系统调用接口的时候", "我需要把我需要的服务告诉内核", "这是我要准备参数的地方", "你把这信息准备好之后", "我就可以系统调用在内部实现", "就可以知道我如何做处理", "处理完之后把结果返给你", "而我们通常在这用的时候", "这部分又封装到函数库", "而函数库我们在上面用就不用关心了", "接下来我们说系统调用和函数调用的不同", "那对于所使用的指令来讲", "系统调用使用的是int和iret", "而函数调用使用的是call ret", "这四条指令 他是在指令级是完全不同的", "那么他们的区别体现在什么地方", "实际功能区别在于函数调用", "我们知道你在程序的设计里已经学到过了", "我为了调用一个函数", "我需要把参数压到堆栈里头去", "然后转到相应函数去执行", "执行时候从堆栈获取我的参数信息执行", "返回的结果放在那里在返回回来", "这样的话你在上面的函数调用", "就知道我相关的返回的结果", "然后用这个结果继续往下执行", "而对于系统调用来讲", "他由于内核是受保护的", "而应用程序是他自己的区域", "在这为了保护内核的实现", "这个地方内核和用户态的", "应用程序之间使用不同的堆栈", "所以在这会有一个堆栈的切换", "切换之后由于处于内核态", "我就可以使用特权指令", "这些特权指令所导致的结果", "就是我这个时候可以直接对设备进行控制", "而你在用户态是不可能进行的", "这就好比说我们在银行里头", "你可以告诉银行的营业员", "我需要从我的某一个帐号里取多少钱", "这个取钱操作到银行的内部", "他的营业员是可以去直接打开保险柜", "打开保险柜取出你所需要的钱", "并且在你帐号上做相应的记录", "这些记录就好比说你记到你堆栈一样的", "他记到他自己内部的堆栈上", "以至于说如果说", "我们两用同一个堆栈会有什么问题", "我们两用同一个堆栈", "用户其他代码可以改你堆栈的信息", "这对于系统来说是不安全", "好比说你从里面取了钱", "结果你帐号上的金额并未减少", "这银行不干或者反过来说", "你把钱存到银行里去了", "但是银行帐号上钱并没有增加", "这个时候你是不干", "基于这种理由我这会有相应切换", "银行可以在里进行特权的操作", "当然我们在这里只是对int iret call ret", "这几条指令的最主要的区别做一个介绍", "如果说大家在实现新的系统调用的时候", "你可能需要去查详细的区别", "这是对X86来讲 它的CPU指令手册", "那在手册里头有相应链接", "因特尔在不停更新它的手册", "你会看到在这里不同的CPU上", "这些指令它的实现", "有什么样的一致性和相应的区别", "你要想在特定平台上正确的运行", "最后需要准确了解它的行为", "最后我们还有一个问题需要来讨论", "就是我在什么时候用中断", "用系统调用 什么时候用函数调用", "这个时候我们说系统调用", "会比你函数调用更安全", "但是它也有它的问题 它的开销会比你大", "原因是我有一个用户态到内核态的切换", "具体有哪些开销 我们在这列出来", "首先你有一个切换的引导", "这是硬件上需要做的事情", "再有一个是你在内核里有另外一个堆栈", "如果说第一次调用的时候", "这个时候会有内核堆栈的建立", "然后我在这里传参数的时候", "这个参数的有效性合法性是需要做验证的", "切换到内核执行的时候", "由于我访问的代码有切换", "那么在这种情况下", "内核需要访问到用户态的一些信息", "这个时候会把做一个地址空间上的映射", "这些映射会导致你的缓存会有变化", "这个时候你的TLB的内容也会有失效", "所有这些都会导致用户态和内核态切换的时候", "你的系统调用开销是大于函数调用的"]}, {"name": "", "block_id": "6444b60f71764e4aac87f89ef300f7bf", "text": ["下面我们来介绍三状态进程模型", "在前面我们介绍的进程状态当中", "我们已经说到了", "进程主要的几种状态", "实际上这时候呢主要的", "这个就绪运行阻塞或者叫等待", "这三种状态搁在里头呢就构成了", "我们这里的三状态进程模型", "那如果大家看这个图的话", "那这个图里呢不止三种", "还多了一个创建和退出", "但是从整个进程", "生命周期来讲核心的状态", "是这个就绪运行和等待", "那这三种状态呢是", "我们这个三状态进程模型里的核心", "这每种状态的含义是什么呢", "运行是指进程", "正在处理机上执行", "那这是第一种", "然后第二种状态呢是就绪", "就绪是指", "进程获取了除处理器以外资源", "等待得到处理机就可以开始运行了", "而等待呢", "是指进程在等待", "某一个事件的出现而暂停的状态", "那这三种状态之外呢", "再有两种辅助的状态", "一个是创建这个状态呢", "是一个过渡的状态", "进程正在被创建", "还没有完成", "这个创建的过程", "也就是它的分配资源", "分配资源和相应的数据结构", "完成初始化之后", "那它就放在就绪队列里", "这个创建的过程就结束了", "每个进程呢在整个生命周期当中", "它只会进来一次创建", "然后还有一个退出", "退出呢是指进程正从系统当中消失", "也就是说系统正在回收它的资源", "那在这个状态里头呢", "它会是进程结束的最后的这个阶段", "这五个状态呢是", "我们三状态进程模型里的状态", "在这个状态之外呢", "之间呢我们有相应的状态的变迁", "这里的变迁我们依次来介绍它的含义", "启动实际上是指我进入到创建状态的", "这是一个触发条件", "我一个新的进程被创建出来", "创建它的目的是为了执行一个程序", "好程序进程创建的过程", "创建完成了", "那这时候就导致一个状态的变迁", "那这就是由创建到就绪状态", "这个变迁呢是指你的创建工作已经结束", "就等待CPU的这个资源", "有了CPU这个资源之后", "它就可以开始运行了", "而被调度这个变迁呢", "是指我们在就绪队列里", "选择出某一个适合运行的进程", "然后分配给处理机然后", "它就可以开始运行了", "这是呢由就绪到运行的状态变迁", "再有一个是运行到结束", "这是指这个进程", "已经完成或者说出错", "那这时候呢由操作系统开始去", "回收它的资源的触发操作", "而从运行到就绪呢就是我们这里", "这里标的是时间片用完", "如果是被抢先的话", "也是这两者之间的一个变迁", "在这个变迁里头呢", "那进程的状态是由运行回到了就绪", "运行到等待呢", "是指正在运行的进程", "要等待某一个资源", "而这个资源呢现在还没有", "那这时候由此而进入等待", "它无法正常运行", "最后一个等待到就绪", "进程要等待的事件出现了", "到达了那这时候呢他就有阻塞", "由等待变成了就绪状态", "那我们在说这些", "状态的变迁的时候呢", "如果说我们在操作系统", "你看它实际代码", "你主要需要看的就是", "这些状态的初始", "它是在什么时间出现的", "那你要找的关键代码呢就是", "这些状态的标识的出现", "比如说我们任何一个进程它开什么", "开始是指我给它分配一个", "唯一的进程标识", "那这时候你就找到它", "创建所在的位置了", "而一个进程结束呢", "是指它的进程ID PCB被回收", "那这时你找到它的结束状态", "而在中间呢", "我们在进程控制块里头", "都有一个成员叫做它的状态", "那么这时候你去看那个状态的赋值", "就能看到当前进程所在的状态", "而这些对应着的这些变迁", "你都应该能够在", "进程状态的变迁过程当中", "找到相应的关键代码来知道", "我这个变迁是在什么地方进行的", "好有了这些呢", "我们就讨论清楚了三状态进程模型"]}, {"name": "", "block_id": "40268a205d534df0a6fdc8b4dc581246", "text": ["那最后一部分呢", "我们来给大家介绍一下", "这个文件系统的执行流程", "这里面举了两个例子", "第一个例子是关于文件系统怎么启动", "第二个呢 是看一下", "当用户程序发出open操作的时候", "我们整个这个执行过程是怎么回事", "首先看一下这个文件系统初始化过程", "从总控函数kern_init开始", "专门增加一个fs_init", "这是lab8增加内容", "在这里面呢fs_init呢", "进一步展开会分成三部分", "第一个是虚拟文件系统的初始化", "第二个是关于设备初始化", "第三个是SFS", "就是simple file system的初始化过程", "我们再把这个vfs_init呢看一下", "它干什么事情 第一建一个链表", "就是专门针对device的list", "使得它可以在后续过程中", "管理这些device的fs", "第二个呢是设置一个信号量", "这是由于很多对共享资源的操作呢", "需要信号量来进行保护", "那么对于dev_init呢 就是device_init呢", "它包含了三部分工作", "第一个初始化device", "disk stdin和stdout", "这分别代表了三类不同的设备", "再接下来是关于这个", "simple file system的一个初始化过程", "这最主要完成一个mount", "就是加载这个文件系统", "那么这三部分进一步细化可以看出来", "第一部分 是关于这个", "dev_list的一个初始化", "它主要是初始化一个双向链表", "这个双向链表是在我们整个", "uCore操作系统里面经常使用的", "然后也同样存在一个信号量", "来保证对这个list操作一个互斥的保护", "第二部分关于device的init", "它会分别去调用disk0的device_init", "stdin和stdout的device_init", "那么这后两部分呢", "我们在前面也给大家做了介绍", "它怎么完成它的初始化过程", "这个disk0的初始化过程", "希望大家能够自己去看一下", "对于simple file system而言", "它的这个mount过程包含两部分", "第一部分是vfs_mount", "以及具体的一个SFS一个do_mount", "那么在这个do_mount里面呢", "它会完成把自身SFS", "和VFS建立一个连接", "然后呢把它的根目录", "能够让我们的uCore", "操作系统能感知得到", "使得接下来的 针对这个文件系统的", "一个读写操作能够正常执行", "那这就是我们文件系统", "一个大致初始化过程", "这是整个一个初始化一个流程图", "接下来我们再看一下", "对于一个文件 我们要打开它", "便于后续的读 或者写操作", "大致执行什么事情", "这是应用程序通常的写法", "Open一个file", "那么这是一个字符串", "代表文件的名字", "它可能带一些目录", "它位于某一个目录下一个文件", "这是一个字符串", "那么如果这个open操作", "正常地执行结束的话", "它会返回一个fd", "那么这个fd代表了文件", "在这个进程控制块中的", "一个文件链表中一个位置", "从而可以根据这个位置", "能访问更具体的file信息", "那么当我们应用程序", "执行open操作之后呢", "它会进一步调系统调用 sys_open", "然后呢发出sys_call 这个系统调用", "sys_open这么一个信息", "然后让我们操作系统做进一步处理", "这是第一部分工作", "我们操作系统", "在接受到这个操作之后呢", "它会通过进一步sys_open呢来往下处理", "那么可以看出来", "它会把文件名的字符串一步步往下传", "然后到这儿 那么它会分配一个", "Fd_array中的一个项给它", "那么这个index", "就是我们最终要访问那个fd", "但是 需要注意是", "这里面fd所对应那个file", "它里面inode信息还没有", "所以我们进一步要把文件名", "所实际对应的inode信息给建立起来", "这就需要我们进一步去处理", "做vfs_open操作", "但是我们知道 vfs_open呢", "它只是一个壳", "它需要去找到具体文件系统", "做进一步打开操作", "有两方面 第一方面是要有一个", "查找文件名和inode对应信息", "一旦找到之后 会把inode信息", "给加载到内存中来", "成为我们操作系统能够进一步去访问的", "一个很重要一个关键数据结构", "那么lookup干什么", "vfs_lookup会进一步调什么呢", "大家想一想", "我们说这个lookup就要查找一个文件名", "包含了目录也包含文件名本身", "这么一个字符串", "把所对应的inode是什么", "我们需要进一步去看一下", "前面的vfs_lookup最终会调到SFS", "就simple file system的lookup", "这里面它会根据path", "就我们刚才说的文件名信息", "来一步步的 递归地查找", "一个文件它所对应的inode是多少", "因为它首先要查找到", "这个文件所在的目录", "假设我们这里面只有一级目录", "那会把这个目录所对应的inode找着", "然后查找这个inode里面", "所对应的目录项", "看目录项里面的文件名", "是否和path里面的最终文件名是一致的", "如果是一致的", "也意味着找着了这个文件", "它会把inode对应文件名给取出来", "然后进一步去load inode", "从而可以把inode的信息", "从硬盘加载到我们内存中来", "你看这里面 sfs_load_inode", "会进一步调sfs_rbuf 就是read buffer", "而这一个会进一步device的I/O", "最终会访问到IDE的read sector", "这个操作是我们硬盘驱动的一个函数", "从而把所需要的信息", "一层一层再返回到我们应用态", "那这就是整个open操作的执行过程", "好 那我们把lab8的文件系统呢", "给大家做了一个讲解", "可以看着这里面涉及的层次很多", "数据结构很多 调用关系很复杂", "但是相对而言 它整个调用关系", "是一个串行的一个调用关系", "而包含数据结构的依赖关系呢", "也是相对来说比较直观", "从上层到底层", "底层又返回来引用上层", "那这个过程呢 虽然数据量比较大", "但是大家通过阅读代码 调试", "和具体执行 我相信能够很好地掌握", "关于文件系统这一块的内容", "一旦完成了文件系统这一块内容呢", "我们可以让我们的uCore OS", "可以很好访问文件系统中", "存在那些文件", "去执行 或者读写操作", "完成了lab8之后呢", "我想大家应该有一定的收获", "可以对操作系统有更深入的理解", "同时我们也提供了进一步labx", "这个labx是希望大家在常规练习之后", "去做一些更有挑战一些练习", "我们称之为challenge练习", "我们在uCoreLab中也给大家列出了", "一系列的challenge练习", "如果大家对操作系统有兴趣", "那我们欢迎大家去迎接新的挑战", "好 谢谢大家"]}, {"name": "", "block_id": "f5bbe4beea354b1d9f94538e7f3c8a29", "text": ["下面我们来介绍调度算法", "那么在这里头呢", "我们的调度算法呢分成了六种", "大致可以分成这样几类", "第一类呢关于就绪队列怎么排", "然后第二类呢", "是关于每一次执行时间", "的长短的控制", "然后再有后面两种", "是关于多种算法", "如何把它综合到一起", "那首先是这几种算法的一个大致说明", "首先是先来先服务算法", "这个算法呢 它是按着", "到就绪队列里的先后顺序来排队的", "那我们在找就绪进程的时候", "也是按照这个先后顺序来的", "跟我们前面讲的FIFO是很相似的", "那在那个地方呢", "是用来做置换算法的", "第二个是说 第一种算法它", "按先来后到没有考虑到进程的特征", "那在这儿 第二类呢", "就是短进程优先", "这里头呢会有几种", "稍微有一些小区别的变种", "那它们是按照", "作业执行时间的长短来进行排队的。", "然后第三个 是高响应比优先算法", "在这个算法里头呢", "它考虑的是进程在就绪队列里的等待时间", "依据等待时间的长短呢", "来考虑它排的这个队的情况", "好 下面呢是时间片轮转算法", "那它是让各个进程", "轮流占用一个基本的时间片", "然后在这里头", "排到就绪队列里头呢", "仍然按照我们前面的", "先来先服务算法来进行排队", "在那基础上呢多了一个", "执行时间的最大长度限制", "你最长不能执行超过一个时间片", "在这之前 你可以由于等待", "或者结束而让出CPU使用权", "而多级反馈队列呢", "是把我们的就绪队列排成多个子队列", "不同的子队列里头呢", "我可以有不同的算法", "并且可以在多个队列之间", "调整一个进程所排的队列", "这样的话就形成了一种综合的算法", "而最后的公平共享调度算法呢", "它强调的是按照", "进程占用的资源的情况来进行调度", "保证我们每一个进程", "占用的资源呢是相对公平的", "好 下面我们具体来说每一种算法", "首先是先来先服务算法", "那这种算法呢", "它是按照进程进入就绪状态", "的先后顺序来排队", "那这是就绪队列里的排法", "取的时候怎么办呢", "我一个进程在进入 等待或者结束", "也就说进程主动让出CPU", "然后我从就绪队列当中", "选择下一个进程占用CPU", "那在这种算法里头呢", "它的特征是啥样子的", "那我们在这儿呢", "对它的周转时间做一个分析", "假定我有三个进程", "它们分别的执行时间是12 3 3", "然后假定它们到达的顺序", "是这样一个顺序", "好 那我们按照先来先服务算法的要求", "那就是第一个执行完", "执行第二个 再执行第三个", "第一个12 到了12", "然后第二个是3 到了15", "第三个是3 到了18", "好 这是我们来看它的周转时间", "周转时间假定它们到达的时间", "基本上是同一个时刻到达", "好 那这样它的周转时间", "就变成是12 15 18", "除以3得15", "好这时候我们直观上就感觉到", "由于第一个进程执行时间比较长", "后面两个等的时间比较长", "好 这样的话周转时间变得长了", "如果说我换一个顺序", "假定到达顺序是这样子的", "那两个短的在前头", "那么这时候它的周转时间是什么样", "那周转时间就变成了9", "从这两个比较的角度来看呢", "我们看到 这个算法", "它的周转跟你这个", "队列到达的时间有很大的关系", "如果说你运气不好", "排到一个长的执行时间的进程的后面", "那么你的等待时间呢那就很长", "好 这是呢我们这种算法它的特征", "它的好处是简单", "排队的依据很容易获得", "排队过程当中呢也不需要什么变化", "所以这种算法比较简单", "它的麻烦呢是", "平均等待时间波动非常大", "也就说如果你一个进程", "短的进程排在一个长的进程后面", "那你的等待时间就长了", "所以这时候呢你排的位置", "对你这算法特征呢影响很大", "再有一个呢是它资源的利用效率比较低", "那你说我一个进程进入等待", "另一个马上不就运行了嘛", "这时候它怎么会CPU利用效率低呢", "那我们看一种情况", "说有一个CPU密集型的进程", "那这时候它一直算", "算的时候它就会", "实际上I/O设备的操作", "可以和CPU并行的", "但是由于你CPU密集型进程呢正在运行", "那这时候I/O设备呢就空闲了", "那后面如果说你还有", "很多要进行I/O的这样一些进程呢", "也不会因为你当前CPU占用", "然后I/O设备空闲", "而让你可以先来执行I/O", "好 那这样一来", "你的I/O设备它的利用效率就低了", "好 那我们这时候", "要想对这种算法做改进", "改进怎么办呢", "我们排队的时候", "刚才说没有考虑到进程的特征", "那我们现在呢短进程优先算法", "它考虑到进程的特征", "考虑到进程什么特征呢", "考虑到进程的执行时间", "我在选择的时候呢", "选择执行时间最短的进程", "占用CPU进入运行状态", "那这时候说我选择最短的", "那这时候就按照预期的执行时间", "因为执行时间", "我是到执行的时候才会准确的知道", "事先我没有办法知道得很准确", "我只能是预期", "那这个预期就会有一个麻烦", "说我在这里头", "这是我们的进程状态图", "那我们在这里排的什么", "实际上排的就是", "把这个就绪队列按照这个来排了", "好 那在这里头呢", "这个预期的时间呢", "排完之后如果说我这里头", "还有一个新的进程到达", "并且它预计时间", "比当前正在执行的还短怎么办", "好 那这地方呢就有一个变种", "叫短剩余时间优先", "好 那也就是说相当于", "我一个进程正在执行", "它预期的执行时间很长", "我又来了一个新的进程", "它预期的执行时间", "比当前正在已经执行了一半的这个进程", "剩下那个时间还要短", "那这时候我允许它抢先", "那就是短剩余时间优先", "好 那这种算法有些什么样的特征呢", "那我们看", "它具有一个最优平均周转时间的特征", "也就说你别的算法", "你的平均周转时间都只能比它长", "不会比它短", "那我们看 它如何得到这个特点的", "在这儿呢我们假定有一个序列", "是进程的执行时间的序列", "好 那如果说我按照", "由短到长的这个顺序来排", "它的执行顺序", "那么这时候呢", "它得到的周转时间是什么", "这个地方ri实际上是", "从0到执行完毕这个时间的长度", "好 我们说这个时间呢", "是它的最短时间", "那我调整一下顺序", "是不是只会比它长吗", "那实际上这是可以证明的", "那我们看一下", "假定 我调整", "这时候不管你做什么样的调整", "都可以转换成一系列的基本调整", "我只要保证每一次调整", "它的时间你只会变长 不会变短", "那么你总的时间就不会比我这个还短", "那每一个最基本的调整是什么呢", "实际上我是把两个对掉", "那在这儿呢我把3 4 5倒了一下", "那在这里头呢", "2 前面两个还是跟原来一样", "现在不是执行3了 而是执行4", "那4呢 我倒了一遍之后", "这时候它的完成时间是什么", "是从这个点减去它的长度", "我给了这个表示", "然后5呢实际上是从这个地方", "5减去3 也就相当于它串到后面来", "把它俩往前串了", "然后这个P3执行结束呢", "本来就是一个r5", "为了后边我说起来方便", "我把它表示成r3在这个时间", "加上这两个的长度", "这里C3 C4 C5", "都是进程Pi的执行时间。", "好 有了这个之后", "我们继续来算它的平均周转时间", "这是把它全加在一起", "然后我做一个等式变换", "好 这时候呢把最后变的这一段加到这儿", "那我们看到", "由于我们这一个", "是按照由小到大排的", "所以这里的C3一定是小于C4 C5", "所以这个数 肯定是一个非负的数", "也就说 是0或者是一个正数", "那么这样一来的话", "你这个下面这个周转时间", "一定是比上面这个大的", "好 那从这个角度来讲呢", "我们看到短作业优先呢", "它可以有最优的平均周转时间", "这是它的好的特征", "但是它也会有麻烦", "它的麻烦是什么呢", "如果我一台机器里头", "就绪进程不断地产生", "不断地产生正在执行", "因为你是按照由短到长来排的", "那如果说我短的很多", "那这么长的就会一直得不到CPU的资源", "好 那这时候呢就会导致饥饿", "也就是说我有一个进程处于就绪状态", "由于它声称它的运行时间比较长", "好 所有的短的作业呢 进程呢", "都在它前面加塞了", "好 那这时候它就得不到CPU资源了", "好 那同时呢", "这时候还有一个问题", "它需要预知你的执行时间", "那我如何来估计CPU的进程", "的下一个执行时间长短呢", "那这和我们前面做", "内存的置换算法的时候", "的状态是一样的", "我们希望知道未来的情况", "但是要知道未来是很麻烦的", "好 那这时候我们用过去来预测", "那实际上在这里头", "我们的预测有这样几种办法", "第一个 我到底要执行多长时间", "我去问用户 用户你自己来说", "这时候就可能有两种情况", "一种是说用户", "因为我想很快能运行", "我告诉你我只需要执行一秒钟", "实际上我执行了一分钟", "那这时候怎么办呢", "那说对于操作系统来讲", "你声称你执行多长时间", "那你就排到相应队列里头", "好 那就把你声称时间到了之后", "你还没执行完", "系统可以把你强行终止掉", "那还有一种情况", "用户干脆我不知道我会执行多长时间", "因为它在某些情况下", "它不知道数据处理", "到底要什么样的复杂程度", "好 这种情况怎么办", "这时候我们还是有另一种做法", "就是用过去预测未来", "那这就是执行时间的预估", "那怎么来预估呢", "就是利用历史信息来预测", "预估未来的执行时间", "那具体的做法呢是这样的", "这是一个小事例", "说 我在这个程序里呢做一组循环", "读数据 数据处理 那这就相当于I/O", "然后进行CPU 执行", "那在这个过程当中", "我们给出这样一个公式", "说我下一次执行时间的预测", "在这里头呢", "就是这一次的执行时间", "你N次的执行时间", "前面加上一个衰减系数", "然后加上你上一次的预估值", "把它俩加在一起", "就是你下一次的预估值", "就实际上把当前时间", "和你上一次预估值做一个校正", "好 那这时候我得到一个新的预估值", "那这一种呢相当于如果我把它展开之后", "实际上就是把前面的", "每一次的执行时间做衰减", "当前最近的这一次呢", "它的影响权重是最大的", "后面呢以前的个次依次衰减", "到一定时间长度之后就可以忽略不计了", "这是在这里预测的做法", "那这种预测的做法呢", "带来的结果是说", "这是我实际的执行的过程当中", "的每一次占用CPU的时候", "进入等待状态之前它的执行时间", "好 然后在这上头呢我作为一个预测", "依据我刚才的公式 就是这一条线", "那么这一条线", "和我们前面这条黄的线", "它们俩之间可以有一个比较好的拟合", "那这就是我这里用过去", "预测未来的预测的结果", "好 那这是短作业优先算法", "然后第三个算法呢是最高响应比优先", "那在前面呢", "我只是考虑到进程执行时间的因素", "那有可能刚才说", "短进程优先", "会因为长进程等的时间而出现饥饿", "那现在呢我为了避免这种情况出现", "高响应比优先 我是在这里", "按照响应比R的值来排序", "这个R怎么计算呢", "W是你的等待时间", "S是你预估的执行时间", "那在这里头呢我这个等的时间越长", "我R因为它在分子 R会越来越大", "等的时间越长", "它的优先级越高", "那这样的话在一定程度上", "就可以避免我们刚才说的", "短进程优先里头的", "长进程等待时间长的这种情况", "而导致出现饥饿", "好  那么在这种算法里头呢", "那它是基于短进程优先算法之上的改进", "那在这里头呢它不允许强占", "好 那这时候呢它关注的是", "进程的等待时间 好", "这时候呢它可以避免无限期的等待", "因为你等的时间越长", "你的优先级越高", "最终你会变成最高优先级", "所以你能得到CPU的使用权", "好 到这个地方呢我们就说清楚了", "前面三种关于就绪队列排序的算法", "它根据先后到达顺序", "执行时间 等待时间", "这样几个指标来排序"]}, {"name": "", "block_id": "a5db783bcb824d72bdc8e33bd83ad72b", "text": ["好 那我们首先再回顾一下历史", "就是Lab1完成了什么事情", "我们lab1其实一开始的时候", "它有个很重要的功能", "就是printf能够输出", "能够输出字符串", "那别小看printf", "那么printf这个输出呢", "能够有效地帮助我们来知道", "我们当前执行在什么地方了", "可以通过输出一些有意义的一些", "字符或者数字来帮助你理解", "你程序的一个执行行为", "再接下来我们是完成了", "保护模式和段机制的建立", "那这个建立在我们80386", "这个硬件基础之上的", "那有了这个保护模式和段机制呢", "为我们后续的页机制的建立", "打下了一个基础", "且有了段机制和保护模式之后", "我们可以使用32位的地址空间", "这是一个很重要的一个", "就是在lab1要完成的事情", "然后我们还完成了中断的机制", "这一点很重要", "因为中断我们前面在原理课讲到", "中断是干什么呢", "中断可以来响应外设的请求", "第二个呢我们应用程序呢", "也可以通过中断这种机制", "来得到操作系统的服务", "甚至说我们应用程序写错了", "这所谓的异常 产生异常之后呢", "我们操作系统也可以有效地去处理", "那这里面呢 建立好中断机制之后呢", "为我们这次实验这个缺页异常", "缺页异常或者访问页异常", "这种情况的处理打下很好的基础", "那有了这三个的工作之后呢", "那我们在完成lab3的时候", "就可以做到有的放矢", "那我们再看一下", "这个中断机制怎么建立的", "大家还回顾一下有没有印象", "首先这里面有一个中断的一个", "中断描述符表一个寄存器", "它记录了中断描述符表的起始地址", "那中断描述符表是干什么的呢", "它其实是存了很多的中断门", "一项一项的中断门", "这个中断门指出了", "当产生一个中断之后", "它对应的中断服务例程", "应该位于什么地方", "就是干这个事情的", "那么这相当于存了一个", "相关的所有中断或者异常的", "一个记录它地址的一个地方", "这是IDT 那么我们在lab1里面", "需要把这个IDT给建立好", "还要完成一系列", "中断初始化工作之后呢", "我们中断整个机制就可以建好了", "那建好中断处理机制之后", "我们可以看到一旦产生了一个中断", "那么中断都是有个中断号", "那么这里面我说的中断", "其实也包含了异常", "中断 异常产生之后呢", "会根据它的编号", "硬件 我们CPU会找这个IDT", "我们lab1我们ucore建好这个IDT", "找到你对应的中断号", "所对应的那个我们说叫中断", "或者陷井这个gate 门 这个门", "在这个门里面呢", "很重要一点它有offset", "就是它有一个偏移", "这里面记的偏移", "同时还记录一个信息", "就是它那个selector", "我们称之为选择子", "这些概念其实在lab1里面都碰到过", "这选择子实际上", "跟我们段机制又结合起来了", "这个选择子作为Index作为一个索引", "来查找我们另外一个 另外一个表", "我们称之为GDT", "就是全局描述符表", "或者简单说就是段表", "有了段表之后呢", "根据它（选择子）的Index可以查找", "你到底它（选择子）属于哪一个段", "然后从而可以知道这个段的", "Base Address 就是基址", "这个基址加上offset形成了最终的这个", "中断服务例程的入口地址", "所以说你可以看到我们的硬件", "一旦识别产生了一个中断之后呢", "根据它的中断号或者异常号", "来再进一步查找IDT和GDT", "从而可以跳到我们说", "中断服务例程的起始地址去执行", "这是说中断机制建立完之后呢", "我们硬件可以干的事情", "那我们操作系统从哪开始工作呢", "就从这儿开始工作", "一旦我们这个EIP说", "我们程序计数器跳这个地方", "我们CPU跳出来执行之后呢", "接下来的工作就是中断服务例程", "整个处理过程也是我们ucore", "里面的lab1来完成的", "它完成了怎么去响应和进一步去", "处理这个中断或者异常这个情况", "那也意味着如果说我们在lab3里面", "产生了一个页异常的一个中断", "那我们相应应该有一个", "页异常的一个中断服务例程", "来应对这种事情", "这需要我们去在lab3中", "去完成这个练习的", "那我们再看看lab2", "lab1做了一个简单回顾", "我们再看lab2 那lab2是干什么呢", "lab2主要是完成对物理内存的管理", "主要完成这个页表机制建立", "所以说你可以看到", "它首先要去查找当前我们内存中", "有多少物理空间", "可以去使用 建立好一个", "就是对空闲物理空间的管理", "那这里面需要注意的是", "这个物理空间呢是连续的地址", "我们管理的是一块连续地址空间", "那和我们原理课里面讲的这个", "说连续地址空间内存分配呢", "是有紧密对应关系的", "第二个我们建立一个", "很简单的一个内存分配算法", "基于连续地址空间的内存分配算法", "这个算法其实在我们", "数据结构课里面也都会涉及到", "再最后就是要建立页机制", "它从而可以实现离散地址空间的", "一个有效的管理", "可以把一个所谓的虚地址", "映射到一块物理地址", "那么这是有页表机制在这里面", "完成了所谓的地址映射工作", "怎么去建立页表机制呢", "应该说是lab2里一个重要的实验内容", "好 页表机制涉及到什么呢", "涉及到我们说页表里面", "每一项一些功能", "那里面其实关注几个", "第一个页表呢它有一个起始地址", "这个起始地址是放在", "我们的CR3寄存器里面存着的", "它CR3寄存器这是", "我们一个特殊的控制寄存器", "它存着我们建立页表的", "起始地址在什么地方", "然后页表其实也是一个大数组", "里面每一项我们称之为页目录项", "或者是页表项", "如果是对于80386 32位机器而言", "它是一个二级的一个分层的页表", "所以呢它这里面会有所谓这个", "页目录项和页表项", "这两者是不一样的", "那么是二层的一个页表结构", "对于页目录项而言", "它里面的每一项存放着什么呢", "是存放着页表的基地址就是这一块", "这是一个项 那么这一项呢是32位", "那对于页目录项来说", "它很重要的一个信息就是这个", "page table address", "就是它所指向的对应页表的起始地址", "而对于页表项来说呢", "那它存的是什么呢", "存的是对应那个物理页", "页帧的起始地址", "那有了这个起始地址", "再加上我们说那个", "EIP所表示的offset", "就是页内的偏移", "我们就会形成最终的物理地址", "那这是整个说CR3", "然后这个是页目录项还有页表项", "这三者结合在一起呢", "就可以构成一个映射机制", "那这是我们lab2里面来完成的工作", "相信大家在完成lab1 lab2之后呢", "对我刚才提到中断处理机制", "页表机制有更深刻的理解", "那么有了这个基础", "等于是有了这个机制之后呢", "我们就可以来完成虚存管理了", "那我们虚存管理要干什么事情", "首先要充分利用lab1和lab2", "已经实现好的框架", "我们已经实现好的中断处理框架", "我们实现好了页表这个", "映射机制的框架 这个我们要重用", "在基础之上我们要去设计一个", "虚存的管理总体框架 从而可以达到", "我们刚才说的那个实验目标", "在实验总体框架之后呢", "我们要去针对总体框架关键部分", "来进行处理", "比如说怎么去有效处理这个页的", "缺页错之后这个中断处理例程", "中断服务例程这一块是要去完成的", "怎么去处理针对硬盘", "因为你要把页换入换出", "换入到内存里面 从硬盘换入到内存", "或者从内存导出到我们的硬盘", "那这个swap机制", "我们称之为swap机制你要去实现", "你需要涉及到硬盘的读写", "而这一块其实在我们的原理课里面", "讲的比较少一点", "因为它很具体的和我们这个", "外设disk有打交道", "而这个其实是分散的", "那再后面就是完成页替换算法", "这是我们专门的", "就是原理课很重要的部分", "就是讲各种各样的页替换算法", "那我们需要建立好", "前面这些机制之后呢", "就可以实现页替换算法", "从而可以最终的完成", "让这个页替换算法能够", "在我们这个系统中能够正常的工作", "来实现它所表达的功能", "就是换入换出的功能", "那这是说我们是整个虚存管理", "这个lab3的总体的一个框架", "那可以看出来它和我们原理课", "有很紧密的联系", "这里面涉及到很多的知识点", "在我们原理课里面都涉及到了", "那它和原理课之间的区别在什么地方", "区别在于实验是把原理课", "一些分散的知识点", "分散的关键的一些知识点呢", "给它集中在一起", "形成有机的整体来解决问题", "那这也是说希望大家做实验", "希望能体会到一点和原理课互相补充", "一个很重要的一个方面", "它的重要作用是什么呢", "希望大家把原理课里面", "所有学到的知识点", "能够通过做实验 能够融会贯通", "形成一体的一个感觉", "你能够知道做一个系统", "做一个操作系统应该", "怎么把这些知识点给贯彻在一起", "来完成相应的功能", "而不是说一个一个分散的一个点", "之间没有任何联系", "当你完成这个lab3之后", "你就会把前面介绍这些知识呢", "能够有效地整合在一起", "有效地整合在一起", "好 那我就把这个总体框架", "再逐一给大家做个简单介绍", "第一点是要完成虚拟内存的管理机制", "这里面最主要涉及到IDT硬盘的读写", "和缺页异常的建立", "好 那这个虚拟内存的这个管理呢", "首先是需要初始化一些相关的工作", "那初始化工作很明显就是", "我们在ucore整体初始化函数", "kern_ init这里面展开的", "这个函数其实从我们lab1到lab8", "都是从这个开始展开的", "所以说有同学说要看这个", "我看代码怎么去看", "首先从这儿开始看起", "可以从这个函数开始可以知道", "整个这个系统初始化的一个过程", "那在lab3之前是lab1 lab2", "它们完成的是什么呢", "是物理内存初始化", "pmm 以及中断的初始化", "比如PIC中断控制器IDT中断描述符表", "这两部分的初始化", "那这也是呢给我们进一步", "去做虚存管理呢也是奠定了基础", "第二步就是要设立这个页帧的空间", "就是虚地址和物理地址对应关系", "你要设置好这个", "我们说这个实验环境", "比如说我们说有5个物理页", "但是你现在有6到7个虚拟页", "那页不够了", "你把这个环境要建好之后", "才能够去进一步去验证", "后续这个页替换算法", "那为了建立好这个关系", "要把这个关系表现清楚", "我们还需要去进一步去阐述", "就是这里面有些不在物理内存中的", "合法的虚拟页", "怎么去表述这个属性", "因为有时候这个页被换出去了", "它从应用程序的角度或者", "站在使用者角度来说它还是存在的", "但其实已经被我们OS换出去了", "我们需要把这个特征给表述出来", "那你需要去考虑怎么去设计", "那第二点是关于我们说刚才", "前面提到要给内存的使用者", "提供一个虚拟的一个使用的内存空间", "那这个内存空间呢", "表示这是我们要去建立好的", "用了两个关键数据结构", "一个是mm struct", "一个是vma struct", "后续会进一步展开", "其实这两个数据结构呢", "我们可以把我们使用者或者", "将来我们这个用户进程", "它所使用的这个合法的一个", "虚拟内存空间给表示出来", "这是这一块的一些表述", "那我们再看第三点", "第三点要建立页表映射", "页访问异常处理等函数的实现", "这希望把前面两者给结合起来", "把页表映射和缺页中断这一块", "给有机的结合起来", "当产生了缺页中断之后", "我们需要把相应它缺失的页表的", "映射关系给重新建立起来", "从而可以使得在一个有限的", "物理空间里面能够访问", "更大的虚拟空间这么一个目标", "这是我们第三步要去完善的", "那第三点我们是需要去把这个", "缺页异常之后要把这个相应的", "物理内存和我们虚拟内存的", "映射关系重新建立起来", "为此我们需要完成一个", "重要的函数do_pgfault的实现", "它也位于这个vmm.c这里面", "这里面有很详细的讲解", "讲述了它一旦接收到这个任务之后呢", "它怎么来完成的", "它的call graph就是函数调用关系", "这是它列出来的函数调用关系", "那这里面你需要去完成一系列工作", "要识别到底是什么原因", "产生了这个缺页错误或者缺页异常", "那么结合你进一步去分析", "这个页呢是否是合法的", "如果是合法的", "你就要把这个映射关系建立好", "如果不是合法的那么应该报错", "甚至把当前这个系统给停下来", "这是说这个do_pgfault", "大致要完成的工作", "第四步呢就是要开始测试了", "就是我们说你前面", "建好这一部分之后呢", "我们怎么能够来看你建好这个页表项", "是否能完成虚拟地址映射", "其实如果说你正确完成lab2", "那么这一步", "我觉得第四步应该是比较容易完成的", "第五步呢第五步要检查", "你这个能否正确的表述", "我们这个虚拟页它到底", "是在内存中还是在硬盘中", "那么这个也需要考虑怎么去能够", "检测你前面的实现是否正确", "那第六点呢 实际上是说我们要看看", "当某一个虚拟的这个页表映射关系", "它实际是把这个对应的页呢", "是放到了硬盘上", "那能否正常的从硬盘读进来", "或者是写回去", "那这里面需要去再做一个检查", "我们需要去检查", "在做实验上需要注意", "基本上步骤一步步来检查", "你前面的实现是否正确", "那最后一步呢 假如说这些都做好了", "最后一步干啥呢", "就看你那个页替换算法", "是否正确工作了", "因为你的页替换算法其实是", "需要前面那些能够正常工作之后", "才能够去检查你的页替换算法", "是否正常工作", "所以说你最后才去检查你这个", "你实现的页替换算法", "是否能正常的完成它所需要的", "把先进来的页", "给先换出去这么一个功能", "那其实关于这个vmm这个后面测试", "其实有一系列的测试", "要确保我们刚才建立合法的", "虚拟空间是合理的", "这里面有个check_vma_struct", "这方面的一些工作", "第二部分是要测试什么呢", "测试你的page fault", "这个机制能够正确的响应", "就比如说我要访问", "一个合法的一个虚拟地址", "这个虚拟地址它其实", "是可以被正常访问的", "但是它的映射关系还没建好", "所以一旦产生异常之后呢", "我们这个do_pgfault需要能够建好", "check_pgfault", "是看你完成的那个函数是否建好了", "这是看函数正确性这一块", "就关于异常处理这一块", "关于缺页异常处理这一块", "怎么来完成", "这是一个check", "好 做完这个check之后", "接下来check什么呢", "check你的页替换算法", "所以我们重点看swap这一块", "这个check_swap实际上是要测试", "你的页替换算法是否正确", "当然你这边会涉及到什么呢", "涉及到怎么去有效实现页替换算法", "在swap_fifo.c和swap.h里面", "这里面有详细的描述", "你怎么去实现一个页替换算法", "在这个框架之下实现就OK了", "那整个这个关于", "实现所谓的这个不同的", "页替换算法框架在哪呢", "就是在swap.c和swap.h里面", "这里面建好了整体的一个框架", "你可以看到这个框架里面", "大致的一个关键一些函数", "在这个swap_manager里面要去体现", "这是要去测试的"]}, {"name": "", "block_id": "42ac38d5ff1c46c9a3fc3108534b8d6c", "text": ["各位同学大家好", "今天我们开始介绍存储管理", "计算机系统当中除了处理能力之外", "还有存储能力 存储能力相当于", "我们有一系列基本的存储介质", "我们要在这些介质当中", "来存我们的代码和数据", "为此我们在这里具体的来说", "对于计算机系统来讲", "它的体系结构当中就约定了", "我哪些地方可以来存数据", "然后在存数据的这些地方", "既包括CPU里的寄存器 也包括内存和外存", "这几种不同的存储介质", "它的容量 速度 价格都是不一样的", "为了组织一个合理的系统", "我们把计算机系统当中的存储", "组织成了一个层次结构", "针对这种层次结构下的存储单元", "操作系统需要对它进行管理", "操作系统当中的存储管理", "实际上就是用来管理这些存储介质的", "最基本的管理要求是说", "我们一个进程需要使用存储单元的时候", "需要从操作系统分一块给它", "等它不用的时候还给操作系统", "这是它最基本的分配和释放的管理要求", "针对这种内存管理的要求", "我们来看系统结构当中", "有哪些因素对它有影响", "这个图实际上是我们在前面", "讲系统结构的时候就说过了", "计算机系统包括CPU 内存和I/O设备", "我们在上一次课里", "也说到过CPU在加电的时候", "我们关心各个寄存器的初始状态", "那么在今天讲存储的时候", "我们会更多关注与存储相关的内容", "比如说在CPU里头", "我们可以往寄存器存内容", "寄存器可以存数据", "但是寄存器它的容量是非常小的", "通常是32位 64位的寄存器", "能存的数据也就几十个字节", "或者几百个字节这种尺度", "然后我们说内存是更多的存数据的地方", "我们在前面说到过它只是说能存就行了", "在这我们需要更进一步去说", "计算机系统当中内存", "它的最小访问单位是字节 也就是8bit", "而通常我们所说的计算机系统是32位的总线", "那所谓32位总线也就相当于我一次读写", "可以从内存当中读或者写32位", "也就是4字节", "这样以来我们读写的速度就会快了", "如果针对这种特点", "你在由于一次读写32位的有地址对齐的事", "你在访问的时候就不能", "从任意的地方开始一个四字节", "有可能这个读写就会被分成两次", "还有一个是说我们在CPU里头", "你还会看到高速缓存", "高速缓存是什么意思呢", "在你进行读写指令", "或者指令执行过程中", "访问数据都需要从内存里读数据", "这个时候如果说我有大量数据要读写", "而且我会重复利用的话", "我在CPU里加上高速缓存", "那这样的话它的读写速度会更快", "这个时候整个读写效率会提高", "所以在CPU里加了高速缓存", "这几个部分都对我们存储管理", "有至关重要的影响", "所以大家在实际做操作系统的", "储存管理实现的时候", "你必须很准确的了解对应的CPU的结构", "那么对于我们操作系统课来讲", "我们讲的是X86的系统", "那这底下是因特尔的X86的手册", "里头要想查最详细的内容", "从这个手册里就可以查到", "接下来我们更详细来看存储的层次结构", "那么我们刚才已经说了", "在CPU里头有两级缓存 这两级缓存", "我们如果说你在读写数据或者指令的时候", "在缓存里已经有相应的内容", "事先已经读过", "那这个时候我就直接可以从缓存里拿到", "这个时候速度是最快的", "然后说如果在这里头缓存不命中", "那这个时候你就必须上内存里去读", "而在上面这部分 我们在写程序的时候", "你是感觉不到L1L2 hash的存在的 实际为啥呢", "原因在于这部分完全是由硬件在做控制", "你写的程序不能显示的使用到它们", "而内存的访问就需要", "使用到操作系统的控制", "如果说你在内存里访问的时候仍然找不到", "这个时候还有可能我是存到外存里头去", "那么存到外存里头呢把它读进来", "你再进行访问", "这个时候就需要用到操作系统的控制", "那在这个体系结构当中", "我们可以看到从CPU内部", "一直到硬盘的外部", "这几个速度差的非常大的", "具体差到什么程度 我们这里有一张表", "最快的跟你CPU的主频是一样的", "那就是几个纳秒我就能访问到", "最慢是几个毫秒 这两者之间", "毫秒 微妙 纳秒", "差将近是百万倍的数量级", "所以在这套体系当中", "要想把它协调成一个有机的整体", "实际上对于存储管理来讲", "它的挑战性还是很大的", "对于操作系统来说", "我们存储管理最后想达到什么效果", "我们在这给大家一个描述", "首先我们看到系统当中的存储 内存", "我们刚才说了是以字节为单位进行访问", "每一个字节有自己的一个地址", "这个地址是物理地址", "然后说我如果数据存到外存里了", "比如像磁盘 这是外存", "磁盘的访问有扇区编号", "每一个扇区是512个字节最小单位", "那这是你能够读写存储的最基本的内容", "而写程序的时候我们希望看到的情况是什么", "是我有若干个进程 每一个进程", "它们都有共同的一部分的地址空间", "是操作系统的内核", "然后每一个应用程序自己又是不一样的", "它们各自有各自的内容", "我希望在各自写这些内容的时候", "它们的地址是可以重叠的", "相互之间是不干扰的", "这是我们希望见到的状态", "把下面这种内存的状态", "转变成我们上面逻辑的理想状态", "我们在中间加了一层存储管理单元", "存储管理单元就把逻辑地址空间", "转变成物理地址空间 这个时候说", "我实际操作系统代码存在哪呢 存在这头上", "通常情况下是在内存里头的", "而进程的地址空间", "随着它们运行的转换", "有些是在内存里头", "有些是放在外存里头的", "这个转换的过程", "由中间的存储管理单元来完成", "如果说我们能做到这样一步 实际就相当于", "存储管理要达到效果是抽象", "把线性的物理地址编号", "转变成抽象的逻辑地址空间", "然后我需要在这里头对地址空间进行保护", "每一个进程只能访问自己的空间", "尽管说在内存里它们是相邻存放的", "与此同时我们还要方便共享", "比如说在我们这里头大家可以看到的", "操作系统的内核的代码", "是各个进程都是一样的", "或者说绝大部分是一样的 这种一致", "如果说每个进程地址空间是相互保护的", "不能访问 这段你就得存多份", "这个效率是低的", "我们希望能够很好地把保护和共享统一起来", "这个目标是有一些矛盾的", "与此同时我们还希望它实现更好的虚拟化", "这说的是我们每个进程的", "地址空间编号都是一样的", "但是实际上每个进程", "都有自己一段用户地址空间", "到这里实际上物理地址空间", "存的位置是不一样的", "但是给每个进程看到的都是", "一个区域一致的一个地址空间", "甚至于说我们在逻辑地址空间里", "看到的可以存数据的地方", "它的大小是大于你的物理内存的总量的", "我们看到实际上要想实现存储管理的", "抽象 保护 共享和虚拟化", "实际上这几个目标还是很有挑战的", "具体说起来", "我们在操作系统里", "可能采用一些什么样办法", "我们第一个办法就是重定位", "实际上在最早的计算机系统当中", "它是直接使用总线上的", "物理地址来写你的程序", "我要想读写某个内存单元 它在什么位置", "我们在程序里见到的就是它的物理地址", "但是这种做法实际上有很大局限", "你写程序只能在指定类型的机器上运行", "我们第一个可以让它做灵活", "实际上相当于我可以整块的搬", "就是我们这里说的重定位", "如果说我们现在看到地址访问的时候", "说每一个地址是用一个段地址", "加一个偏移来表示", "实际上就是从重定位这个地方来的", "有了重定位之后我通过移", "我只需要改我的段寄存器的地址", "这个程序就能运行了", "这是第一种做法 为了实现它", "我在程序和操作系统里头", "都需要有相应的支持", "这些支持我后面会来说", "接下来一个问题是说我们在这里头", "在重定位的时候", "我一个进程分的存储空间", "是一个连续的空间", "我不可以把两个交错起来", "实际上这是一个很大的限制", "我们希望它能够不连续", "实际上我们在写程序的时候", "它的逻辑结构", "它并不是一个必须连成一片的区域", "而是说我们把程序分成数据 代码 堆栈", "这三个部分是相对独立的", "它不会说我从堆栈里头", "直接去访问代码段里的内容", "也很少有这种情况", "我从代码段里直接去访问数据段的内容", "依据这种情况", "我至少可以把代码 数据和堆栈分成三块", "每一块我要的空间就会变少了", "这就是我们这里的分段", "分段仍然你是需要一段的内容", "还是需要连续的", "这个要求仍然足够高", "接下来我们会说分页", "分页实际上就是把内存分成最基本的单位", "就好比说我们要盖一栋楼", "盖一栋楼需要各种各样的建筑材料", "但是我们用到的最基本的", "就是一块一块的方砖", "你可以把它加在一起之后", "变成你需要的各种各样的形状", "我们也希望是从最小的单位一页", "来构建你所需要存储区域", "当然你说我们最小的单位", "那就用一个字节不就挺好的吗", "但是实际上这个时候你一个字节的话", "你在访问的时候 它开销就力度太细", "以至于管理的时候难度很高", "所以我们在这要选一个合适的大小", "这一块最基本的单位是一个连续区域", "这就是我们这里的页 基于这个来构造", "你所需要的存储空间的内容", "在这个基础之上", "我们希望把数据存到硬盘上", "而硬盘外存上的数据和内存上的数据", "它们俩之间的倒换是由操作系统内部来实现", "这个时候就希望看到的是", "程序是一个逻辑的地址空间", "甚至这个逻辑地址空间", "是大于物理内存的空间", "那这就是我们的虚拟存储了", "在我们实际上操作系统里", "基本上就是这样几种方式来管理内存", "当然我们说所有这些管理办法", "它对硬件的依赖程度都是非常高的", "比如说MMU", "存储管理单元里的结构是什么样的", "然后我们CPU能够识别的页表是什么样的", "这些都直接影响到你存储管理方式的实现", "到这我们对内存管理的基本情况有一个介绍"]}, {"name": "", "block_id": "e23d122c70af4bc786a1735dde336d4e", "text": ["练习四呢", "假定进入这个保护模式之后", "我们Bootloader需要干的很重要一个事情", "就是要能够加载ELF文件", "为什么要加载ELF文件呢", "因为我们的kernel 就是uCoreOS", "是以ELF形式存在在硬盘上的", "什么文件呢 就这个文件", "可以看到这个kernel", "就是我们这个uCore", "它完成了刚才说的", "负责把这个中断初始化好", "然后产生时钟中断", "能够把这个信息显示在屏幕上等等", "这些功能都是uCore完成的很基本的一些功能", "那这里面比较有意思的是", "Bootloader怎么能够", "把uCore给加载到内存当中去", "其实它需要完成很重要的两步事情", "第一步 是怎么能够读取硬盘中的信息", "这需要Bootloader能够访问硬盘", "第二个是Bootloader把这个硬盘数据读出来之后", "要把其中ELF格式这个文件给分析出来", "从而知道我们uCore它的代码段", "应该放在什么地方", "应该有多大一块空间放这个代码段数据", "哪一段空间是放数据段的数据", "然后把它加载内存当中去", "然后同时还知道", "跳转到uCore哪个地方去执行", "那这一块代码 其实我们也是一样的", "有专门一个小的Project来完成这个事情", "我们的Project2就是干这个事情的", "那在Project2我们可以看到", "跟Project1比起来 它增加了一段代码", "这个代码主要是能够", "刚才说到这个 读扇区", "和分析这个文件", "读扇区呢主要是这个函数 readsect", "这是读取扇区 它用到了这个in b", "和out b这种机器指令", "那我们可以看到这里面", "其实inb和outb的实现", "都是用我们说的", "刚在lab0中介绍到过的", "内联汇编来实现的", "它采取了一种IO空间的寻址方式", "能够把外设的数据给读到内存中来", "这也是一种X86里面的寻址方式", "除了正常memory方式之外", "还有IO一种寻址方式", "好 那这一块细节呢其实大家不用特别看", "只是知道我们这个Bootloader", "知道怎么去从哪开始", "把相应的扇区给读进来", "以及它读多大 读完之后", "它就需要去进一步的分析", "那这个分析呢 需要去了解", "了解相应的格式ELF的格式", "好 我们可以看到在bootmain里面呢", "它有一个对ELF格式一个判断", "它怎么知道读进来这个扇区的数据", "是一个ELF格式的文件呢", "它其实是读取了一个ELF的header", "从磁盘中读取ELFheader", "然后判断它的一个特殊的成员变量 e magic", "看它是否等于一个特定的值", "如果等于特定值", "就认为是确实是一个合法的ELF格式的文件", "那我们在lab1里面", "有更详细把这个文件的ELF格式文件信息", "给读取进来一段判断", "大家可以看这个", "在这个bootmain里面呢有相应一些实现", "这个bootmain函数", "它怎么能够根据ELFheader和proghdr程序头", "来读出相应的代码段和数据段", "然后加到相应的地方去", "最后这一条比较关键", "这就决定了到底Bootloader把这个加载完之后", "到底要跳到什么地方去", "把控制权交给uCore去执行", "这就是Bootloader干的最主要的事情", "那其实也可以看到 我们练习一到练习四", "主要是对lab1Bootloader这一块", "给大家做相应一些练习", "那么练习五和六", "主要是针对这个uCore本身了", "那练习五主要是考虑的是", "怎么能够分析函数的调用栈", "练习六呢 主要是建立中断", "这两块相对来说要复杂一些", "需要大家去编程", "这里面显示练习五", "这一段输出呢 是正确的输出结果", "可以看出来", "如果你能正确的分析出这个栈帧格式", "栈帧它这个依赖关系", "栈帧格建立的链表", "那我们就可以把相应函数代码关系给展示出来", "那这就是一个最后展示的结果", "那怎么去把正确的ESP和EBP给读取出来", "这是完成这个lab5实验的关键", "这里面其实填的内容很少 就两句话", "但是你要把相应的细节要掌握清楚", "才能够正确的填写相应的代码"]}, {"name": "", "block_id": "b7efdbcb685947e6a3d847b8eb18d832", "text": ["各位同学大家好", "那我们今天呢给大家介绍一下lab7", "就是同步互斥上面的一些实验", "这是我们整体的一个介绍", "就是包括了总体的一个概述", "然后讲一下我们lab7要完成的", "这个同步互斥所需要的", "一些底层支撑", "以及两个关键的部分", "一个是信号量", "另外一个是管层", "和条件变量的设计", "最后呢我们想看看", "怎么基于这个管层和条件变量", "来设计我们这个哲学家就餐问题", "这是我们整个实验的部分", "第一部分是总体介绍", "那我们希望是达到是什么", "就是说 能够在", "我们的ucore操作系统里面呢", "来完成一个哲学家就餐问题", "这里面有目标练习和流程概述", "我们先看一下", "首先我们需要什么呢", "需要把这个信号量 条件变量", "以及建立信号量和条件变量", "所需要的禁止中断 定时器", "和等待队列呢 给大家做个介绍", "有了这些呢 我们会在内核里面", "再重新开始初始化", "然后呢 完成一个内核线程的", "一个哲学家的一个表述", "然后让这些多个内核线程呢", "来模拟哲学家就餐问题", "这就是我们整体的一个情况", "为此 我们看一下我们的目标", "就是这里面需要干什么呢", "首先你要理解一下", "操作系统内部的 这个同步互斥的", "基本的一个原理", "这是在我们这个原理课里面", "给大家做了介绍", "基于这些原理 我们看看", "怎么能够用我们这些", "操作系统提供的一些", "实现的一些技术", "比如说禁止中断 定时器", "和等待队列呢", "来支撑我们后续的", "信号量的设计与实现", "以及管程和条件变量设计与实现", "有了这些同步互斥的", "一些机制之后呢", "我们就可以来理解和完成", "哲学家就餐问题", "这是我们希望达到的目标", "为此呢 我们要完成练习", "包括了在内核里怎么实现信号量", "以及基于内核级信号量的", "哲学家就餐问题的一个表述", "这一块是有一个具体的实例", "大家可以看一看", "有了这个基础之后呢", "我们再看看怎么来基于这个信号量", "来完成条件变量", "这是我们要完成的练习", "同时还要完成一个什么呢", "基于管程和条件变量呢", "来完成这个哲学家就餐问题", "也就说哲学家就餐问题呢", "我们有两种实现手段", "一种是基于信号量的", "一种是基于管程和条件变量的", "那我们把这个大致的流程", "给大家做一个简单的介绍", "首先我们看看上一个实验", "我们lab6呢 重点是讲述这个调度", "其实涉及到很多的调度算法", "正是由于有这个调度机制的存在", "我们可以使得进程随时可以被打断", "这里面我们没有区分进程和线程", "我们上堂课 给大家介绍过用户进程", "还有更早 还有内核的线程", "在lab7实验中呢", "重点关注是内核线程", "但同样是被我们这个", "lab6所涉及到的调度器所调度管理", "而且可以随时被打断", "那随时被打断意味着什么", "意味着进程和线程之间呢", "它们的执行的时间顺序", "是不确定的", "正因为这个不确定性", "使得我们要保证这个线程的", "执行的一个正确性的话", "我们需要有相应的", "同步互斥机制的一个实现", "为了能够实现我们原理课讲到的", "信号量 或者说是管程", "我们首先要有一些底层的支撑机制", "这里包含了什么呢", "怎么去屏蔽中断", "来完成一个互斥操作呢", "第二个 通过等待队列", "主要是完成进程之间", "由于等待资源不到而带来的", "让这个进程去睡眠", "处于一种等待状态", "还有定时器 也是一样", "我们说 给这个进程设置一个定时器", "让它可以sleep 睡眠一会儿", "等时间到了之后 再把它唤醒", "这是三种底层支撑机制", "有了这些机制支撑之后呢", "我们就可以完成", "信号量的P操作 V操作", "还有条件变量的Wait和Signal操作", "而这些机制都是和我们这个", "处理器调度有紧密的联系的", "处理器调度呢会影响到它们的实现", "它们的具体实现也会反过来", "对处理器调度产生一定的影响", "相互之间都有影响", "有了这些支撑之后", "我们就可以来完成", "哲学家就餐问题了", "这是我们说这个", "大致的一个整体流程"]}, {"name": "", "block_id": "36ab9f5a6230450f9cb857cc280dc4d2", "text": ["下面我们来讨论I/O数据传输", "在I/O子系统当中", "设备和CPU之间的数据传输性能", "也是我们这里关注的一个重要的问题", "CPU和设备之间的数据传输", "有这样两种方式", "第一种是程序控制I/O", "也就是说CPU通过in/out指令", "或者说load/ store指令", "如果说后一种情况", "你是做了内存映射的话", "那它是通过load和store指令", "来完成设备和CPU之间的数据交换", "那这种方式由于需要CPU的参与", "它的硬件实现相对简单", "编程也是比较容易的", "它的问题主要是在于消耗的CPU时间", "和你要传输的数据量是成正比的", "数据量越大", "它的传输时间开销也就越大", "这时候它适用于简单的小型的设备I/O", "如果说你传送数据量大的话", "这种方式对CPU的占用就是比较多的", "第二种方式是DMA直接存储访问", "它是让设备控制器", "直接可以访问系统总线", "然后设备控制器和内存之间", "直接进行数据交换", "这种方式呢 它的特点是", "CPU可以在数据传输的过程当中干别的", "不受影响", "当然它的开始和结束也需要CPU的参与", "这时候它适用于高吞吐量的设备I/O", "这是我们CPU和系统之间的", "两种数据传输方式", "我们在这儿", "再用磁盘数据读取这个过程", "来细化一下", "看它的交流过程是什么样子的", "首先我们看到", "这是我们系统里的连线图", "CPU通过系统总线", "连到内存和DMA控制器", "然后DMA控制器", "通过PCI总线连到我的磁盘设备", "我们在这里", "一次磁盘读取过程是什么样的", "CPU在执行用户代码的过程当中", "会产生磁盘读取请求", "这个请求转到设备驱动", "在内核里执行", "设备驱动需要我把磁盘上的", "什么地方的数据", "读到内存的什么地方去", "这个设备请求就会转换成", "对磁盘控制器的操作", "这个操作导致", "磁盘控制器开始读取数据", "读取数据之后初始化DMA传送", "然后把数据通过PCI总线", "传到DMA控制器", "然后DMA控制器", "再把数据传到内存的指定区域", "也就是我们这里这个X", "完成传送之后", "它产生一个中断请求", "CPU响应这个中断请求", "来判断我最后这个操作是否结束", "最后呢回到应用程序里", "这是通过DMA和中断的方式", "来完成磁盘数据读取的这个过程", "另外还有一个方向是说", "设备如何通知CPU", "如何通知操作系统", "在这里操作系统需要知道设备的状态", "完成时间", "比如说遇到的错误之类的", "然后在这儿有两种方式", "一种是轮询 一种是设备中断", "我们在这里一个一个来讨论", "轮询是指I/O设备上定义了", "一组状态和控制寄存器", "操作系统定期的检查这些状态寄存器", "从而知道设备的状态", "比如说我的数据是否发送完了", "我的缓冲区是否还有空地儿", "或者说我的缓冲区里是否有数据", "这种做法相对来说它是简单的", "但是如果你在这里操作频繁", "多长时间会产生一次 不可预测的话", "那么这时候开销和延时都比较大的", "在这里开销大是说", "我需要频繁进行操作", "延时大是因为我不知道", "我什么时候能知道设备状态的改变", "我只能在我查的时候才能知道", "如果说设备状态改变之后", "很长一段时间没有去查", "这个延时就大了", "所以这是第一种方式", "第二种方式是设备中断", "在这种方式里头", "CPU布置好I/O操作之后", "它就可以去忙活别的了", "然后这时候I/O设备", "进行相应的I/O请求处理", "处理完之后 产生中断", "触发CPU 让CPU响应", "CPU接收中断", "然后执行相应的中断处理例程", "这是它的一个交互过程", "那么在这个交互过程当中", "它是处理不可预知事件效果比较好", "只要你一产生中断", "CPU马上就能给出响应", "原因在于CPU是在每两条指令执行期间", "会去检查一次是否有中断请求", "如果中断比较多", "那这时候CPU被中断的频率就会比较高", "这时候它的开销相对来说", "和DMA方式传送数据的时候", "它的开销也是大的", "实际的做法是什么呢", "会是在一些高速设备", "会把两种办法结合起来", "比如说在我们这里的高速网络设备", "第一次的时候", "它是采用中断方式来进行响应的", "如果有数据包的接收", "那这时候呢", "CPU会响应中断来处理这条数据", "由于输入输出数据比较多 量比较大", "那这时候第一次中断处理完", "相应的数据之后它会再进行轮询", "如果有数据马上就要处理", "这样的话后面就变成轮询方式了", "一直到没有的时候 它才结束", "下一次中间隔的时间比较长的时候", "它再会转到中断方式", "这是设备中断", "下面我们具体来看一下", "中断I/O的处理流程", "首先是CPU在执行指令的过程当中", "产生了I/O请求", "这时候设备驱动会初始化这个I/O请求", "当中的I/O控制器会初始化I/O操作", "然后由设备进行相应的操作", "操作完成或者出错", "这时候它产生中断", "CPU在完成I/O请求初始化之后", "它就可以去干别的了", "这时候它在每执行一条指令之后", "它会检查中断请求", "如果不做这个检查的话", "那你这边有请求之后", "它是不能做到及时响应的", "正是由于CPU在设计上就已经做到了", "用硬件来检查每一条指令执行期间", "是否有中断请求 如果有", "它就不去进行下一条指令的执行", "而转到中断的处理", "那么这时候CPU接收到中断请求之后", "在当前指令结束之后", "它就可以来进行这个响应", "所以你这个延时通常是", "最长是一条指令的执行时间", "那么收到这个请求之后", "它分发给相应的中断服务例程", "由相应的中断服务例程进行处理", "这是它的处理", "处理完毕之后", "CPU恢复被中断的进程的执行", "在这个执行的过程当中", "又可能执行到某一个地方去", "再产生新的I/O请求", "这是基于设备中断的", "I/O请求的处理过程", "有了这些描述之后", "I/O的数据传输的方式和流程", "我们就说清楚了"]}, {"name": "", "block_id": "611068ae0b694df58f230909a6e6e383", "text": ["好 那接下来我们看一下", "这个进程的内存布局", "这个布局呢和我们之前的", "前面的实验它的", "内存布局是不一样的", "尤其它虚存管理", "有它自己的一些考虑", "那首先我们可以看到", "我们的这个内核的虚拟内存布局", "那这部分和就是前面的lab是一样的", "lab4之前是一样的", "它有一块第一个是", "对实际物理空间的一个映射", "从0xc0000000一直到0xf8000000", "这一块区域呢", "我们会映射为一个物理空间", "它们呢只是相差0xc0000000", "这么一个差值的一个一一映射", "然后呢还有一块是页表的建立", "就是当前的page table", "这个page table呢 在一开始时候", "只是存在在这一块虚拟空间里面", "管理的呢", "管理是整个这个内核空间", "里面的一个映射关系", "这是之前的", "但一旦有了这个用户进程之后", "我们的页表需要扩展", "我们的段表也需要扩展", "我们前面讲段表里面", "会增加一个用户的代码段和数据段", "它特权极是3", "而不是我们之前说的0", "所以说你可以看到特权级它降低了", "3是最低的一个特权级", "同时它的page table里面", "也需要管理用户态的空间", "那我们来看一下", "这个关于用户空间的这个进程", "它的一个内存布局怎么回事", "那么如果是个用户进程", "它的空间是这么一个区域", "在一个低端的位置", "那低端位置里面", "虽然0xc0000000以下的地址呢", "都其实分给了用户空间", "但其实我们用户空间的程序呢", "只用了一部分", "可以看到这两个部分", "是最主要内容", "第一个它有一个堆栈", "第二个有它的代码段", "数据段和它的堆", "这个堆是用于动态内存分配用的", "那么这两块区域", "是合法使用的区域 没有问题", "就是写应用程序的时候", "可以充分的利用这两个区域", "完成函数调用", "完成数据访问", "完成一些计算等等", "这个区域呢", "STAB有点奇怪", "这个区域在这个位置", "那么放什么东西呢", "放的是调试信息", "我们说一个应用程序可以被调试", "可以被debug", "那是由于它里面", "有一个很重要一个源码的数据和", "符号和具体的地址一个对应关系", "在这里就存在一个关系便于我们debug", "当然我们这里面可以暂时不用理会", "另外一块有三个invalid memory这个区域", "它们其实都在低地址空间", "但是我们把设置成invalid memory就是非法区域", "那非法区域什么意思呢", "就如果你的应用程序", "访问了这块区域的地址", "它会报错 会产生page fault", "那为什么设成非法区域呢", "是在于我们应用程序通常来说", "比如说你有一个空指针", "空指针是0", "空指针一般是0", "这个0地址呢非法的", "只要你访到这儿", "它的页表没有对应的映射关系", "它就会产生page fault", "可以看出来前面讲页表的那一块", "需要把这个", "整个这个空间呢给建立有效的映射", "这两块user stack和heap program建立映射", "但是这个红色的invalid memory", "这一块呢不建立映射", "它可以确保当我们的应用程序", "访问到这块区域的时候", "会产生page fault", "那这个产生这个好处什么呢", "其实是便于我们", "查出我们这个程序的问题", "第二个呢我们也说到", "通过内核的page table呢", "我们可以对", "进程的访问空间做个限制", "可以使得你不能够随意访问", "任意的地址空间", "这也是我们说进程管理", "很重要的一个功能", "接下来我们看一下怎么能够", "就是加载ELF格式的二进制代码", "比如说我们刚才说的hello", "能够到我们这个用户的进程空间去执行", "这是我们第二部要考虑的问题", "首先给大家简单介绍", "它大致的执行过程", "我们说这个图呢", "可以看出来是我们一般应用程序", "是放在什么地方呢", "放在我们硬盘里面的", "比如放在执行程序", "然后呢通过操作系统呢", "会加载到内存中去执行", "这是我们通常说的就是", "一般操作系统做的这个功能", "我们现在在lab5这个阶段呢还做不到", "但是当我们完成最后一个lab", "lab8的时候我们可以达到同样的功能", "那我们现在呢更简单一点", "那是什么呢", "是没有我们的这个文件系统", "和我们的存储", "没有storage 没有file system", "我们就memory OK", "我们一开始时候我们的bootloader", "已经把我们的kernel和程序", "放到内存中来了", "那这个程序呢", "是这么一个架构", "一开始的时候呢ucore kernel", "和我们这个应用程序是放在一起的", "存在我们的地址上面", "然后我们的bootloader呢一下", "把这些东西都加载到memory中来了", "那可以导致一个什么后果呢", "在后续的创建进程过程中呢", "我们会创建一个壳", "然后从直接从内存中", "把这个program放进来去执行", "那么通过do_execve", "这么一个内核的函数来完成什么呢", "把这个用户进程创建好", "且把相应的这个程序", "放在中间去执行", "那么这是说do_execve这么一个函数", "它要完成主要功能也是", "我们后面要重点讲解的一个功能", "就是怎么去执行一个用户的进程", "那我们再看一下这里面提到", "用户进程壳的概念", "我们在lab4中用到什么呢", "用到是一个叫做TCB", "就是线程控制块", "我们这边是什么", "进程控制块", "进程控制块和线程控制块", "有什么区别呢", "大家想一想", "对这个控制块", "本身的数据结构而言", "可以看到它也是用的proc_struct", "就是我们说在lab4中", "同样的一个数据结构", "完全一样", "没有区别", "大家可以回顾一下在lab4中", "我们重点讲解了分析了", "这么一个TCB的一个结构", "叫Thread Control Block 那我们这里", "把它换一个名字叫Process Control Block", "但是用的结构是完全一样", "可以看出来在ucore里面呢", "我们的进程管理和线程管理", "所共用同一个数据结构", "就是所谓的进程控制块", "和线程控制块其实是一样的", "这是没有什么区别的"]}, {"name": "", "block_id": "beb3ed20d82849ef8979ed1350c0bca0", "text": ["下面我们来介绍进程创建", "那进程创建呢", "是操作系统提供给", "用户使用的一个系统调用", "完成新进程的创建工作", "在不同的操作系统当中呢", "进程创建的API呢", "或者叫系统调用接口呢", "是不一样的", "比如说在Windows里头", "那它的创建接口叫CreateProcess", "而且在这里头呢", "它可以有多种不同的参数", "比如说在这里创建的时候", "关闭所有的文件描述符", "在创建的时候指定子进程的环境", "运行环境", "好这些呢都是在Windows里的做法", "而另外一大类呢", "是在unix系统里头", "也包括我们用到的linux系统", "它是采用fork execute", "两个系统调用来", "完成新进程的创建的", "那么在这里头呢", "fork完成把一个进程复制成两个进程", "这时候呢", "它们所执行的程序是一样的", "但是在这里头呢", "它的变量有一个地方是不一样", "就是进程的ID PID", "父进程里的是", "原来执行那个进程的ID", "子进程呢", "是分配给它的一个新的ID", "好完成这个复制之后", "接下来由加载execute", "把一个新的程序加载到", "内存当中重写当前进程", "也就是这里新创建子进程", "好这时候呢它的进程ID呢", "是没有发生改变的", "好等这个系统调用返回的时候", "那我们这个就变成是两个进程", "并且第二个进程呢我已经变成", "一个新的程序在运行了", "那这是呢", "新进程创建一个基本的做法", "那这是一个示 例说明", "我如何用fork和execute", "来创建一个新的进程", "执行一个新的映像", "fork在这个地方完成复制", "到这个地方回来的时候", "这个系统调用返回时", "那我们这个系统里呢", "就已经有两个进程了", "并且这两个进程当前指令指针呢", "都指向fork完之后的这一行", "好这一行接下来就说", "你fork成两个之后同时往后走", "一样的执行那有什么意义呢", "实际上到这一步的时候呢", "父进程和子进程的返回值是不一样的", "子进程的返回值是零", "好那执行红的这一段", "如果父进程返回的是子进程的ID", "那它就蹦过这一段", "执行后面代码去了", "好在这子进程里头呢", "我再加一个execute", "好这时候我可以", "加载任何一个程序", "指定它有多少个参数", "这些参数分别是什么", "这是它的基本的引用模式", "好在这个引用模式当中呢", "我们说fork是完成了", "一个进程的子进程的创建", "它的内存是完全复制的", "它的CPU的状态是完全复制的", "当然在这里呢", "所谓的完全复制", "是需要有加注解的", "那这里呢", "会有特殊一些寄存器有变化", "那这时候以便于我们区别", "到底父进程和子进程的ID的不一致", "好这是呢这两个系统调用", "这个系统调用它准确的区别", "父进程返回子进程ID", "子进程返回是零", "好然后说我们在这里头", "父进程这个fork", "在进行子进程创建的时候", "它的地址空间的复制", "到底是怎么进行的", "那我们说复制完了之后", "它有一点小区别", "那我们下面呢", "通过一个图示 来说明这个", "地址空间的复制过程", "这是一个示例 程序", "执行到S1 这一段代码的时候呢", "整个进程还是一个", "到fork的时候", "这一句执行完就变成俩了", "好然后这两个往下执行", "由于返回值的不一致", "子进程会进到这一段代码", "父进程会进到下一段代码", "好这两段都执行完了", "如果说你在后面没有用execute", "这时候再往后两个进程", "可能直线代码也会一样", "但是这时候", "由于其中 的变量不一样", "它俩的处理 结果也会不一样", "好我们看一下", "我把这个程序加载到内存", "这是我们前面已经讲过的状态", "好在这里执行的时候呢", "执行到这一句的fork的时候", "它做复制", "复制一个跟它完全一样的", "但是它俩有一个", "不一样的就是这个地方", "好那在这儿呢", "这两个不一样", "好不一样之后就会", "导致后面的变量不一致", "那它的执行内容", "也就不一样了", "这是呢 fork的地址空间复制的过程", "那大家需要注意", "这是一个完全的复制", "但是有这两个的区别", "好这两个区别", "就导致后面它可以完全不一样", "好然后我们说后面的加载呢", "是用一个execute", "用一个新的可执行文件", "来替代当前的进程", "那么在这个替代的过程当中呢", "我们看到这是一个例子", "红的这一段就是", "我们加载新进程的代码", "execute指定可执行的程序", "有多少个参数", "具体参数多少", "那在这个执行的过程当中呢", "我们看看它在操作系统里头的变化", "fork进程创建起来之后", "这个程序在执行的时候", "操作系统内核里头呢", "就给它维护了", "一个相应的进程控制块", "在这个进程控制块里头呢", "有它的相关的ID和相关信息", "那执行到fork它会是啥情况", "fork执行的时候做了一个复制", "复制完了之后给它一个新的ID", "这个地方127", "这变成128", "然后其它都一样", "然后接着往下执行", "这一句的时候呢", "父进程执行到这儿了", "因为它不等于零", "子进程执行进到这里头", "然后执行这一句那是程序加载", "那这个加载呢就会导致", "把它地址空间里的代码都换掉", "然后这个地方呢", "加载的这个文件呢", "也被换掉", "好这样以来两个进程", "就可以执行不同东西了", "好那这是我们从代码的角度来说", "而从完整地址空间来讲呢", "这就是我们前面说", "这地方的一点变化", "我在这里头这是代码", "然后上面是堆栈堆", "好这是创建时候的情况", "然后复制", "两个一样", "除了这个地方不一样", "好那这时候呢我们这个地方", "除了代码之外还有数据堆栈", "这些都是一样的", "然后我的加载什么呢", "加载就把整个地址空间", "内容全部换掉", "除了保持这个ID继续一样", "那这是我们这里fork和", "execute的过程", "那接下来我们用一个", "稍微复杂一点的例子", "让大家看一看这个", "fork它在执行过程当中", "这个复制到底是", "保持了哪些是地方是一致的", "哪些地方是变化的", "这是一个例子", "在这个例子当中呢有一个循环", "我在循环内部呢有一个fork", "假定说这个循环循环三次", "大家想想一个循环", "循环三次", "这时候我会", "这个fork会被执行几次", "对于我们通常循环来说", "循环三次", "那这里头的fork函数", "也会被执行三次", "但是在这里头大家需要注意", "fork一下的时候", "我们整个就复制了一遍", "这时候一个进程变成了俩", "你再往后复制的时候", "就是两个继续复制了", "好正是由于这种原因", "我们下面来看它到底有几个", "好在这个进程里做的事情", "比较简单", "先上来做一个检查", "我这个fork是否成功", "不成功那直接就退出了", "如果成功那这时候在", "子进程里呢我打印一行信息", "然后就开始等它的子进程结束", "最后整个进程结束", "那我们来看一下这个进程", "在执行的时候它到底这个", "进程的复制的过程是啥样子", "好这是最初始的时候", "这个进程开始执行的时候状态", "假定它的进程ID是1166", "好然后执行到循环体里头", "第一次fork", "fork就只有一个进程它在执行fork", "fork完之后这一次变成俩了", "那执行完是这个情况", "好在子进程里头呢", "它有一段代码说是", "给出相应的一些提示信息", "说自己的ID和父进程的ID", "这是自己ID是1167", "父进程的ID是1166", "好然后进行第二次循环", "第二次循环的时候呢", "我们这个I实际上", "已经复制了两份", "在两个地址空间里头", "所以它们的修改呢", "是分别独立进行的", "好那这时候这两个同时fork", "那1166和1167分别进行fork", "那这时候呢又出了两个新的进程", "到现在有几个了", "三个新进程", "总共有四个进程了", "好这个时候新创建出", "来这两个进程呢", "又各自给出一条提示信息", "那这是1168 1170", "它的父亲分别是1166和1167", "好这时候第二次循环执行结束", "然后那这时候我有四个进程", "再做第三次循环的时候", "这时候有几个再循环", "四个好一二三四", "它们同时进行fork", "那又产生了四个", "这新产生的四个呢", "又在这儿呢又给出四行的提示", "那从这儿看", "我们循环第一遍的时候", "一个变俩", "第二遍 的时候两个变四个", "第三遍 的时候四个变八个", "那在这个过程当中", "我们需要有一点注意", "就是在这个地方", "如果说按我刚才创建顺序", "而我们新的PID的分配呢", "是加一来给的", "那你说好像你", "这个顺序并不是顺序再加", "这是为啥呢", "实际上就相当于", "我们创建的一个新的进程", "它是新创建进程呢", "放到就绪队列里面", "那这时候由于调度算法的影响", "所以新创建的这几个进程", "并不是像刚才我们说的", "严格按照我们刚才说的顺序在执行", "第一步 只有一个创建出来", "这个1166到1167没有问题", "第二次执行的", "那如果按照我们刚才说的", "那就是父进程1168先算", "好它创建了一个新进程", "它创建完了之后", "又放到就绪队列里头去", "好实际上这个时候", "这个进程呢它的执行", "创建出来还执行之前", "实际上已经进到这里的", "第三次循环到1169", "好那这样的话", "创建顺序是它创建第一个", "然后它创建第二个", "它创建第三个是这个先完", "然后是7创建70 71", "然后是72 73", "这样一个顺序", "来执行新的进程了", "所以这地方这个输出顺序呢", "有可能会有些变化", "好到这个地方呢", "我们基本上说清楚了", "从通常道理来讲fork", "它是在怎么创建新的进程", "这个创建行为有可能产生的变化", "如果说我们在这里头", "各个进程里头还有一些变量的话", "这个变量的变化", "搁到这一起", "那这时候呢", "你需要想清楚地方就会更多了", "好那我们看实际的系统里头", "它会是在怎么做", "ucore里的fork是在怎么做", "fork呢实际上我们就说", "要进行准确的复制", "并且给它一个新的ID", "把它放到就绪队列里头", "这是很粗的来说fork所做的功能", "具体说起来呢", "我们在fork里头呢", "我们可以用这样两张图", "来说明它的执行情况", "左边这一个呢是说我们在系统里头", "操作系统内核里头这是这个fork", "fork它的实现调用了哪些函数", "然后它是在什么情况下", "哪些系统调用会产生进行fork", "然后右边这个图呢", "说明了fork它的内部的实现过程", "它在这里头做哪样一些复制", "和哪样一些改动", "这是do_fork", "ucore里实现进程创建的", "最主要的函数", "在这里它完成的功能是", "分配进程控制块数据结构", "然后创建它的内核堆栈", "设置它的地址空间", "那这时候设置地址空间呢", "对于创建内核线程来说", "它就是共享或者说复制", "那创建独立的新的用户进程呢", "那它就是复制", "然后修改子进程的状态", "变成运行状态", "那这个函数呢", "实际上我们可以看到", "它在里头呢做的最主要的工作", "我们对于创建来说", "可以看到它的调用关系", "在这张图当中这是do_fork", "我们跟它相关的系统调用呢", "有各种平台的fork clone", "这些系统调用呢", "最后都会转到do_fork", "do_fork里做的主要的工作呢", "我们从这里可以大致见到", "说我进行相应的一些复制", "这里头进行的几个复制", "我们关心的主要的是copy memory", "然后copy thread", "这是我们看到的", "跟它相关的最主要的数据结构", "然后在这里头", "在这个函数的实现当中", "我们看到它的时间很长", "我们转换成它的流程图这样的话", "可以比较简洁的看到它的实现", "那么在这个do_fork的实现当中", "我们看到的最主要的函数呢", "是在这里头", "这是它的进程控制块的", "相关信息的填写", "比如说在这里头我们看到", "它填的它的父进程", "就是当前创建的这个进程在这儿", "然后我们还关心一个新进程", "在进行一系列的判断之后", "我们看到的最主要的一件事情", "那在这里呢", "我们要去设置它的进程标识", "那在这儿呢", "我们就是创建了进程之后", "给它设置相应的标识", "在这个地方", "好有了这些之后呢", "我们一个进程就算是创建完了", "这是关于的fork的ucore实现", "好再有了fork的实现的环节之后", "我们在系统里创建了哪些进程呢", "比如说我系统起来的时候", "第一个进程是啥样的", "第一个线程是啥样的", "好那我们在这儿呢", "对这些做一个简要的说明", "首先我们要说的是空闲进程", "也就是说我们操作系统", "它通常情况下执行用户的代码", "如果用户没代码", "用户的进程都执行完了", "系统没有新的任务要执行了", "这时候系统处于什么状态", "那我们说处于暂停的状态", "但实际上这时候暂停", "CPU并没有完全停下来", "它还是在执行指令", "这执行是哪的指令呢", "通常情况下我们就是", "让它来执行空闲进程的处理", "好空闲进程的创建是怎么来做呢", "它是在我们的初始化文件里头", "那proc_init", "在这个函数里进行的", "那它怎么做呢", "它这里呢通过alloc_proc", "这个函数来完成相应的创建过程", "首先给它分配所需要的资源", "比如说这函数会调用kmalloc", "分配存储资源", "分配完相应的资源之后呢", "对它进程控制块进行初始化", "填入它的一些相关信息", "这是造出来的进程控制块", "好然后呢", "对这个进程呢", "再在这个proc_init进行", "完成剩下的部分的初始化", "初始化之后放在就绪队列里头", "没有其它进程的时候", "那它是优先级最低的", "然后就让它来执行", "这是空闲进程", "接下来我们看空闲进程的创建", "空闲进程的创建呢", "它首先是从kern_init()这个地方", "这个函数呢开始内核的初始化", "这个我们在前面的实验当中呢", "已经多次看过这个函数了", "其中有一个proc_init()", "这是页表的初始化", "我们找到它的定义", "那这是它的页表的初始化", "好首先在这里呢", "它创建的第一个就是idle", "那在这儿", "然后创建的第二个呢", "是用来执行init main这个函数", "那我们看在这里头", "首先是idle的创建", "idle proc的创建", "这一行是它最主要的工作", "也就用alloc proc这个函数", "来创建idle proc的相关信息", "那这个函数呢我们对应过来", "我们查看它的定义", "这时候你会看到", "它主要的工作是在这里头", "对进程控制块的数据结构", "进行初始化的设置", "好完成这些设置之后呢", "那我们一个进程的初始化呢", "就基本上有了", "然后这是设置这个进程的状态", "另外一个呢是我们的初始化进程", "那在这儿呢", "用的是kernel_thread", "这个创建函数来创建一个线程", "执行init_main", "作为它的内核函数", "那这里头我们看它的实现", "我们还是以它的调用图的形式来看", "好我们看到在这里头", "从我们这个地方initial", "过来到这个地方", "它在这里最后绕到哪去了", "我们从这儿可以看到", "最后绕到do_fork上去了", "所以在这儿呢", "创建内核线程和创建用户态进程", "它的最后的实现呢", "都在这个do_fork里头", "好那么它们的区别在于", "复制的时候这个地方的参数", "是会不一样的", "好我们再来看这是我创建完之后", "第一个init_main()", "好这是相应的创建的工作", "就是我们用户态进程初始化之前", "先创建了一个内核线程", "这个内核线程呢", "就是我们这里的initproc", "这个也是在proc_init里头来创建的", "在这里头怎么做呢", "是通过kernel thread", "这个函数来实现的", "那我们说kernel thread", "也是会调用do fork", "和我们线程和进程都用一个", "函数在ucore里来实现", "但这时候它俩实现的时候", "那进程创建和线程创建", "我们说不是不一样嘛", "实际上这时候不一样", "是靠它里参数来区别的", "这个过来的时候呢", "它的地址空间是共享的", "然后在这里头呢", "拷贝现场所需要的信息就够了", "比如说这里最主要一个", "就是创建它的内核堆栈", "好分配它相应的资源", "然后在这里呢", "初始化这个进程的进程控制块", "然后在这里呢初始化它的内核堆栈", "这地方没有拷贝了", "那它的堆栈从哪来", "它得新创建一个堆栈", "好然后建立起它的内存的共享", "也就说它和其它的内核线程", "共享同一个内核地址空间", "然后把它放到就绪队列当中", "然后等到它下一次调度的时候", "那调度它开始执行", "那我们就可以创建", "第一个用户态的进程了", "我们刚才说的init proc", "这一个函数呢实际上我们也是在", "也从这个proc init这个函数开始来看", "那到这儿来之后呢", "我们有一个附值在这儿", "我刚才创建的这个函数到这个地方", "它把它这个地方创建了一个新的", "它执行的函数是谁", "然后它的ID", "最后把它标识呢", "设置成在这个地方", "这一行最后给它附值为init proc", "这是我们创建的第一个内核函数", "它所执行的函数就是这个init proc", "好在这里头呢", "它执行的相关的操作是在这里", "我们进行了相应的设置", "好那在关于创建呢", "我们还需要讨论一个问题是", "fork的开销", "那我们知道fork任务呢", "是复制父进程的地址空间", "内存和它的寄存器的状态", "那这个复制的地址空间呢", "通常情况下量是不小的", "它的开销是非常大的", "那我们开销大呢", "我要创建这个东西", "我必须干这个事", "但实际上我们在这里", "有这样一种情况", "我们在fork完之后", "马上会执行加载", "这个加载呢", "会把你刚才创建内容", "复制内容又给覆盖掉", "所以实际上在大多数情况下", "你刚才这个复制都是没有必要的", "没起到任何的作用", "所以在这儿呢", "这个开销呢", "实际上是我们可以节约的", "这种节约呢", "就在Windows做法", "它通过一个系统调用", "用来完成创建和加载", "那这时候呢", "我们说在Unix里头呢", "早的时候也有一种做法叫vfork", "它是在创建的时候", "不进行复制", "等到你在用的时候", "那再直接进行加载", "那这个复制就省掉了", "这种呢就称之为叫轻量级fork", "而我们现在的系统里呢", "通常都支持写时复制技术", "那这样的话", "任何一个进程创建的时候", "都是在你后面要用的时候", "它才延迟过来进行复制", "那如果说", "你在这里头直接就是覆盖", "那这个地方这个复制它就不进行了", "所以在这儿呢", "我们这个地方这个开销呢", "也是可以节约下来的", "好这是关于fork的实现"]}, {"name": "", "block_id": "c5e8684161994d20a1ac52e428452fd3", "text": ["好 各位同学大家好", "今天呢我们给大家介绍一下", "lab5就是用户进程的管理", "那这一部分呢 可以看到", "我们主要讲以下几部分内容", "第一个是总体介绍", "大家知道我们这个实验", "大致要完成什么样的功能", "以及相应的一些总体的一些概述", "第二个呢是", "关于我们创建个用户进程", "它的内存布局怎么回事", "和我们前面讲有点不太一样", "这是给大家做个介绍", "第三个呢", "我们既然要创建个用户进程", "就需要执行一定的程序", "那怎么能够把一个程序", "放在进程里面去执行", "这是这部分内容", "以及我们说在原理课里面讲到", "可以通过父进程创建子进程", "那么具体这个进程复制", "是怎么完成的", "也会给大家做个介绍", "最后一部分呢", "是一个比较扩展一个内容", "也是我们challenge的练习", "就是怎么能够结合", "内存管理的copy on write机制", "来实现更有效的进程复制", "这是我们这次总体", "要介绍的一部分内容", "首先看一下这个总体介绍", "那么其实包含了", "这次实验的目标练习和流程概述", "那我们的目标是什么呢", "其实我们希望通过这个练习呢", "大家能够知道我们前面的三个实验", "从lab1 2 3", "那么是介绍了中断和内存管理", "第四个实验已经有了内核线程", "但是所有这些实验呢", "都在什么地方呢", "都是在内核空间里面来", "完成各种各样的工程", "还没有碰到像我们说", "像这次实验课我们会提到什么", "你要创建一个在用户态", "执行的一个进程", "那这个呢是", "第一次我们的实验", "从内核态跳到了用户态", "那我们也就希望能够", "把这个过程给大家展示出来", "通过前面的lab1到lab4的工作呢", "我们在lab空间里面", "可以创建一系列的线程", "最后来构造出一个用户态的进程", "让它能够在用户空间去执行", "这是说我们这次课希望达到一个目标", "那把这个目标细化一下", "我们这边要了解什么呢", "第一个就是要了解一下", "一个用户进程的创建过程", "他怎么从零变到一的", "从没有用户的进程到", "存在用户进程怎么创建出来的", "鸡和蛋怎么出现的", "第二个呢是了解进程管理的实现", "这里面主要是讲的是什么", "主要是说我们怎么能够让", "一个程序的内容能够", "放到一个进程里面去执行", "那这里面要了解什么是程序", "什么是进程", "它们之间的区别是什么", "在原理课里面给大家做了介绍", "那么通过实验呢", "希望大家能够加强对", "这两者之间的这个关系", "和差别的理解", "第三个是要了解", "系统调用框架的实现", "那这个和前面两个不太一样", "前面两个需要大家去coding", "需要去动手实验一下", "那么对于最后这个呢", "是大家是看一下", "那么来看懂就OK了", "相对来说我们的重点是放在前面", "这个虽然很重要", "因为通过系统调用呢", "我们可以实现用户进程", "得到内核的服务", "但这一块呢", "只要大家能看懂就OK了", "因为对于系统调用的", "这一部分的内容呢", "其实和我们lab1中断管理呢", "是有很紧密的联系的", "它们有很大的一个相关性", "但是也有一定的区别", "那么你如果对lab1那个实验", "有充分的了解之后呢", "再看系统调用它的实现", "其实是比较简单的", "那我们在前面内容里面也讲到了", "这个从一个特权级跳另一个特权级", "怎么来完成呢", "那其实也和我们这个", "中断管理机制是相关的", "那么大家可以回顾之前的一些工作呢", "可以对此有更深入的理解", "好 基于这个目标", "我们要完成练习也是一样的", "正好是说我们要去coding", "去加载应用程序并执行", "那么要去理解它大致", "加载执行的这个过程怎么回事", "然后完成我们需要完成的一个功能", "第二个呢 我们要考虑一下", "父进程怎么去复制子进程", "这里面要考虑的一些细节问题呢", "在原理课里面", "可能涉及的比较少一点", "我们希望通过实验呢", "能够知道这里面的细节", "是怎么来完成的", "怎么来通过父进程", "能够创建出一个子进程出来", "第三个呢 是要分析系统调用", "和进程管理的实现", "因为我们知道我们的用户进程呢", "它需要通过系统调用", "来得到操作系统服务", "这是一个 第二个呢", "操作系统对进程本身也有管理", "从最开始的创建到最后进程的消失", "这有个生命周期的管理", "在原理课里面也讲过", "那我们会通过阅读代码呢", "能对此有更深入体会", "那我们的重点放在前面", "前面是你怎么知道创建一个进程", "当你知道怎么去创建一个进程之后呢", "那么后续的一些工作", "比如说进程状态的改变", "相对来说比较简单一点", "还有一个呢进程的卸载", "比如说我们进程的离开退出", "那么这个呢", "相对来说就是", "我们前面创建过程的一个逆过程", "所以说也比较容易理解", "这就是练习希望达到的目标", "OK 那大家听起来好像感觉还不够", "不知道到底跑什么程序", "其实很简单", "可以看到这个所谓的hello应用程序", "和我们通常写的简单hello world很类似", "没啥区别", "这也是我们在ucore操作系统里面", "支持跑的一个简单的应用程序", "你可以看出来他干什么事情呢", "一个main函数它就是打印字符串", "第二个呢有系统调用叫getpid()", "就得到当前它这个进程的ID信息", "然后就退出了", "从创建到最后return之后呢", "我们的操作系统会把它给它kill掉", "让它退出出去", "那这里面就包含了系统调用", "包含了创建一个基于", "这个内容的一个用户进程", "它的一个执行的一个状态的管理", "以及最后生命周期一个管理退出", "虽然这个程序很小", "但是ucore操作系统呢", "对它的管理是全面的", "我们希望大家能够对这个", "管理过程能够比较清楚的认识", "好 那这个整个这个实验", "我们说lab5的实验", "我们最主要说要给应用程序", "需要提供一个用户态的运行空间", "那这个呢其实包含了两部分内容", "一部分什么呢", "一部分是内存管理", "一个进程要运行", "那必须要有个内存空间它所", "运行所需要的代码段", "数据段有内存空间", "它有个内存空间的管理", "和我们的lab2lab3有紧密的联系", "第二个呢 进程管理", "这也是我们这次实验的重点", "但是我们已经有lab4", "其实已经有一部分的进程管理", "但是那时候我们叫内核线程", "进程和线程的关系是什么呢", "那么在原理课里面是讲过", "大家想一想", "进程和线程什么关系", "那么这里面多了一点不同在哪呢", "用户进程和内核线程", "它们之间的关系和区别是什么", "在这里面我们ucore操作系统呢", "对这个用户进程和内核线程呢", "有一套几乎统一一套管理体制", "但是它们有很大的区别", "那这里面我们希望通过完成", "lab4和lab5呢对", "这两者有更清楚的认识", "对于内存管理而言", "我们还需要知道", "怎么去创建一个用户态的虚拟空间", "我们之前的实验都是在内核里面", "创建内核态的虚拟空间", "那这里面不一样", "我们要新增一个用户态虚拟空间", "这需要去了解的", "对于进程管理而言呢", "我们需要知道怎么去加载", "一个应用程序到", "这个进程空间里面去", "怎么去复制", "怎么去创建新的子进程", "就所谓的复制", "我们叫fork", "第三个呢 怎么去管理", "整个进程的生命周期", "第四个怎么让进程得到", "操作系统服务", "这是进程管理的功能", "那么这一部分内容呢也是新的", "那么也是在我们的lab5中", "希望通过实现", "实现相应的一些练习和阅读代码呢", "能够对这些内容呢", "有一个比较清楚的理解", "那我们可以简单的看一下", "怎么在lab5中构造出一个用户进程", "它的流程大致这样的", "首先我们要创建用户代码段", "和用户的数据段", "那么这对我们的lab几", "大家想一想", "对我们lab1中的", "段机制的管理呢做了一个扩展", "我们在lab1中", "只讲到了内核的代码段和数据段", "那这里面多了两个", "用户的代码段和数据段", "这里面有个扩充", "有扩充之后呢", "第二步呢我们能够创建内核线程", "这一点是在lab4中完成了", "创建内核线程的目的", "是为进一步创建用户进程做好准备", "所以说在这里面呢", "我们首先要创建用户进程的壳", "所谓创建它的壳呢就是说", "要能够创建一个进程的控制块", "以及进程控制块", "所管理的很多关键的一些数据", "比如说我举个简单例子", "后面看到它的ID", "它的执行状态等等", "这后面会进一步展开", "有了壳之后呢", "我们需要具体的执行内容", "这个内容从哪来呢", "是我们应用程序里面", "提供了它的具体执行", "比如前面讲的hello world小程序", "它有具体的执行内容", "我们把这个内容呢", "要放到这个进程里面去", "比如说这个进程的代码段的空间里面", "我们要把具体程序的内容放进去", "从而可以使得它可以进一步执行", "放进去之后呢", "就可以执行这个用户进程了", "但需要注意的是跟前面的不同在哪呢", "这个执行是在用户空间执行的", "不是在内核空间执行的", "这是我们前面四个实验没有碰到", "你怎么能够从内核态跳到用户态去", "这涉及到特权级的一个转换", "那在回顾一下", "我们在前面实验中专门讲过", "特权级它的特点是什么", "它怎么去实现转换的", "和我们中断管理机制有很紧密的联系", "在执行应用程序过程中", "它可能需要我们操作系统的服务", "为此呢我们需要去", "完成一个系统调用的一个管理机制", "从而可以实现怎么去有效", "我发这个请求", "怎么能得到操作系统有效的服务", "当用户进程执行完毕之后", "那我们操作系统需要", "把这个用户进程所占的资源", "比如内存空间等等给回收回来", "从而可以退出这个进程", "那么我们就要有", "结束用户进程管理体制", "这里面就涉及到", "进程的生命周期管理", "从最开始创建到最后的结束", "那么这就是整个我们说lab5里面", "会碰到的一些实验的一个过程"]}, {"name": "", "block_id": "395013d7d338468bb470bf17e4a04149", "text": ["好 那我们接下来再看一下", "X86内存管理单元MMU", "那这一块为什么要跟大家讲这个", "是在于我们原理课讲到", "我们有对连续地址空间的管理和", "对离散地址空间的管理", "那么离散地址空间的管理需要", "所谓的一种段机制和页机制", "那么在X86里面正好", "这种CPU它两种机制都存在", "而且是可以共存的", "可以实现所谓的段页式的一种管理", "那我们可以看看X86", "怎么来有效的来建立这个段表 页表的", "那我们可以知道需要去", "进一步了解页表或者段表的一些格式", "以及如何操作页表项", "那么有了这些知识之后我们就可以", "在我们的硬件里面建立一套所谓的映射机制", "把我们段机制和页机制都建立起来", "完成对这种更大的一个空间的一个管理", "以及对离散空间的一个管理", "那么它的管理效率会更加高", "那这也是我们说CPU很重要的一个功能", "那这一块我们会讲解有关页表的一些信息", "以及怎么去建立好段表 页表", "以及怎么去操作页表项", "这是我们这一章讲的内容", "那么它和我们的lab2", "要完成的练习是一一对应的", "首先我们看一下这个段机制", "其实在lab1里面我们已经接触到段机制", "只是我们没把重点放在那个地方去讲解", "而是把它留在lab2来讲解", "因为段和页它都属于", "我们的内存的管理的一套体系", "我们可以看着在X86 MMU里面", "它首先是有一套段机制", "这个段机制包含了", "比较多的一些功能的一些部件", "第一个是有一系列的寄存器", "我们说CS ES一直到GS", "第二个有段描述符", "那么寄存器里面的一些信息它的前面的", "最高端的十几位它是专门用来作为一个index", "作为一个索引来找到全局描述符表里面的一个项", "全局描述符表就是一个叫GDT", "可以理解为一个大的数组", "根据数组里面找到对应的数组项", "一项就是一个所谓的段描述符", "在段描述符里面表明了你要访问", "比如以CS为例 CS加上EIP", "它要访问的那个地址 对应的映射关系", "这里面有它的一个Base Address这是最主要的", "有了Base Address之后再加上", "把这个EIP作为Offset合在一起", "基址加上Offset形成最终的线性地址", "如果没有启动这个页机制的话", "那么线性地址就等同于物理地址", "从而可以完成前面由我们的CS ES", "以及CS加EIP ES或者是DS加上一个地址", "所形成的虚拟地址 到线性地址的一个转换", "这边是虚拟地址表示", "这边是最终的物理地址或者线性地址", "它中间通过我们段机制的段描述符", "来完成映射关系 段描述符里面", "重点是一个基址和它的一个段的限制", "这两块信息很重要", "我们有这两块信息之后", "就可以知道怎么完成这个转换", "那其实可以看出来这些信息", "是需要这些段描述信息", "这个CS里面它的index", "都需要我们的软件提前设置好", "这个软件是谁呢", "很明显就是我们的ucore操作系统", "好 那有同学可能会提出质疑说", "你说的这个GDT它到底是", "放在内存里面的还是放在CPU里面的", "大家想一想", "其实GDT是放在内存里面的 为什么", "因为它占的空间比较大", "如果放在CPU的话 那么它这个开销太大", "对CPU的压力比较大", "所以说既然放在内存里面", "我每一次地址映射的时候", "都要去查所谓GDT全局描述符表", "简单我们也可以称之为段表", "访问这个段表 那其实开销很大", "我为了访问一个地址单元", "我要再去访问这个地址", "memory的速度远远小于我们CPU的速度", "这我们之前讲计算机原理课的时候", "会给大家提到的", "那我们有什么办法", "来加快这个选择的速度呢", "其实靠我们的硬件来完成", "这一点跟软件没有关系", "那我们的硬件会把刚才我们的软件ucore", "建立在GDT里面那个", "段描述符里面的关键信息", "给放在一个特殊的位置 隐藏的部分", "这隐藏的部分就是我们几个寄存器", "CS SS一直到GS", "它这里面有一部分你看得见是16个bit", "那个段寄存器的值 但是还有一大段", "你是看不见的 是隐藏在后端", "我们的硬件直接控制", "它里面缓存了我们的基址", "还有限制等等其它一些信息", "这里面只关注两个 基址和它的段的一个大小", "那么有了这个信息之后 这个信息是放哪儿", "是放在我们的CPU里面的", "所以它可以通过CPU内部的一个访问", "就是我们说的MMU", "CPU内部的一个访问", "来加快整个段的一个映射的过程", "从而会提高效率", "好我们可以看到这里面说", "通过这些操作在entry.S里面我们的ucore", "会建立好这个映射机制", "那么这是我们的操作系统", "建立的第一次映射机制", "另外需要注意的是它建立映射机制", "它完成了和我们前面讲的lab1所用到的", "bootloader的建立机制不太一样", "为什么这么说 因为lab1建立的是对等映射", "也就说我们的虚拟地址是0", "我们的物理地址我们线性地址也是0", "我们虚拟地址是1000", "那我们的物理地址也是1000", "它们完全是对等", "那么在lab2里面它和lab1有比较大的区别", "为什么这么说 因为link的时候", "它用到那个描述文件是", "实际上指出了它的偏移是0xC0000000", "且还是负的 为什么 这也是一个问题", "那也意味着如果这么来设置的话", "我们访问", "如果我们虚拟地址是0xC0000000的时候", "实际上对应的这个线性地址是0", "它们是这么一个映射关系", "就是虚拟地址比我们线性地址要大0xC0000000", "它这么一个映射 为什么这么映射", "我们后面会进一步讲到", "刚才那页讲的是说", "操作系统ucore在开始执行的时候", "它建立的映射关系", "那其实我们再回顾一下lab1", "我们lab1里面在一开始", "它的bootloader也建立了一个映射关系", "那个映射关系是一个对等映射", "就0地址对应着0地址 1000对应着1000", "它的大致建立过程是类似的", "只是唯一的不同在哪儿", "就是它用到的那个映射的关系", "放在我们的GDT里面那个", "段描述符里面的信息是不一样的", "这导致了它们的映射关系完全发生了变化", "我们现在是说我们希望", "我们的操作系统能够用上页机制", "那其实段是一种映射机制", "我们的页又是另外一种映射机制", "这时候有一个取舍", "到底是两个都充分利用", "还是强调其中一个", "而忽视或者说弱化另外一个映射机制", "大家想一想 我们在课上", "也对段机制和页机制做了一个讨论", "那我们可以看看到底选择哪个更加方便", "或者更加合适", "那么其实对我们硬件架构来说", "选择页机制相对来说有助于", "我们硬件机制对它进行有效的处理", "所以说你可以看到当前主流的CPU里面", "比如除了X86之外还有MIPS ARM PowerPC等等", "都采用了这种页机制为主的一种页映射关系", "所以说在这里面我们的ucore也是一样", "还需要通过段机制里面的安全保护手段", "来确保整个系统的安全", "但是我们弱化了它的映射机制", "怎么弱化 那既然我们说要选择页机制", "来完成这个映射", "就是从0xC0000000的虚地址", "映射到一个物理地址为0的这么一个过程", "那用页机制首先我们还是希望能够说", "把我们的段机制又恢复回去", "为什么要恢复回去", "这个大家想一想 恢复到什么", "恢复到我们前面说的对等映射", "那它的过程是一样的 改变的是什么", "改变的仅仅是我们说的那个对段表", "全局描述符表里面的内容改变", "因为那个内容里面", "记录了每一个段的Base Address基址", "那个实际上是用来映射用的", "所以说那个做那么一个操作", "做这个操作 为什么要做这个操作", "是为了能够建立我们说的", "这个页机制做好一个准备", "否则我们的段机制", "它也要完成一个从0xC0000000", "到0的一个映射 这没必要", "为什么这么麻烦 我还搞两次", "这一点也是留一个问题大家去考虑一下"]}, {"name": "", "block_id": "c03f093d2ced4d86a0a5b917e6e46bf8", "text": ["下面我们来介绍反置页表", "反置页表也是一种", "为了减少页表所占用", "存储空间的一种做法", "那它是怎么做的呢", "提出反置页表的原因", "还是说我们多级页表", "它访问存储空间的次数比较多", "然后特别是在大地址空间的情况下", "那这时候呢", "由于大地址空间和多级页表", "它和逻辑地址空间", "的大小呢有对应关系", "每一个逻辑页面", "都会对应着页表项的一项", "那这样的话我的进程数目的增加", "都会导致你页表的数目", "占用的空间增大", "好 针对这种情况呢", "反置页表和页寄存器", "是两个类似的做法", "那它们在这里头做法是", "让页表项和物理地址空间", "的大小相对应起来", "而不是说像多级页表里", "和逻辑地址空间相对应起来", "那这样的话 你的进程数目的增加", "和虚拟地址空间的增大", "都对这页表占用的空间没有影响", "下面我们来讨论页寄存器的实现", "那么在页寄存器里头呢", "它是把每一个物理帧", "和一个页寄存器相对应", "那在这个寄存器里头", "存的内容有些啥呢", "一个是 这个物理帧", "是否被某一个进程占用", "这是使用位", "第二个就是页号 占用页号", "那么在这个", "占用页号相当于", "我一个进程占用了这一页", "它的逻辑页号是多少", "那我在这里头给它保存", "那这样的话我就知道", "这个物理帧它分配给了哪一个进程", "它的逻辑地址是多少", "另外还有一个保护位", "是来约定这一页的访问方式", "你比如说可读 可写", "有了这样一种对应关系之后", "我们看它占用的存储的情况", "在这儿通过一个例子来说明", "在这个例子当中呢", "它整个系统里有16M的物理内存", "然后页面大小呢是4K", "那这时候呢16M 4K", "那这时候呢我有4096个页面", "好 那这4096个页面", "它的页寄存器占多大呢", "那在这儿是说 假定", "每一个页寄存器占8字节", "那4096乘8是32K字节", "那这32K字节", "和16M物理内存比较起来呢", "占到的比例是0.2%", "那这个比例相对来说还是比较小的", "那这时候 它和虚拟内存的大小", "就没有关系了", "那这时候我在里创建多少个进程", "它只是每一个物理页面", "和一个页寄存器相对应", "那这是它占用存储的情况", "那具体说起来这样的话", "这种方法它的好处是说", "我跟物理内存相比较起来", "它占用的空间比较小", "而且和逻辑地址空间没关系", "但是它也有很大的麻烦", "它的麻烦是什么", "在多级页表里头", "我们这个信息查询呢", "我是从逻辑页号到物理页号", "利用下标查里头的内容", "我就可以找到它的页帧号", "而现在呢我排序的办法呢是页帧号", "我要从 找的是里头的逻辑页号", "是否是我想找的那个", "那这样的话", "就要在页寄存器里头进行搜索", "那这个搜索是会比较困难的", "下面我们来讨论", "页寄存器机制的地址转换", "CPU生成的是逻辑地址", "那在页寄存器机制下", "它所对应的物理地址是多少呢", "那么这个多少呢", "是把逻辑地址做Hash", "Hash的原因是这样", "我可以减少搜索范围", "然后呢如果说有冲突", "Hash之后的值 它可能是", "两个不同的逻辑地址", "对应到同一个Hash值上", "那这种情况下Hash值相同", "那这时候我就会产生冲突", "这种冲突是需要解决的", "好 这时候呢", "我们可以利用快表来和", "这个页寄存器机制搁到一起来用", "那么这时候的做法什么呢", "逻辑地址进行Hash", "然后在快表当中去查找相应的页表项", "如果说查找的过程当中出现冲突", "这时 我就需要遍历所有的冲突链表", "好 如果说查找不到", "那么这时候呢它就会出现异常", "好 那么在这里头", "它也有一个问题", "和我们前面的快表是一样的", "由于快表它的容量有限", "这时候呢快表的功耗又很大", "这对于我们页寄存器机制", "还是有很大影响的", "比如说在这里说到StrongARM上的", "快表的功耗占到27%", "这是不可以忽视的", "好 接下来我们说反置页表", "反置页表和页寄存器的做法的区别是", "在于它把进程ID也考虑进来了", "那它和页寄存器做法一样的", "它需要进行Hash", "不同的地方是把进程标识", "也加在里头一块做Hash", "Hash完的结果呢也可能会有冲突", "那也需要解决冲突", "那Hash完的结果呢", "它是以页帧号来作为排序的", "那我在这儿找到的结果是说", "我需要到相应的页表项里去核对", "Hash之前的结果和之后的", "里头的进程ID和逻辑号是否一致", "如果一致呢这就是我要找的那一项", "我就可以得到相应的物理页号了", "如果不一样", "那这时候呢它就会产生冲突", "那么对于冲突情况呢", "我们以这个例子来说", "一个逻辑地址加上它的进程ID", "那我首先做Hash", "Hash完的结果是在这儿", "到相应的反置页表当中进行查找", "看进程ID和逻辑页号", "是不是跟Hash之前的一样", "如果不一样那就是说明有冲突", "这时候告诉你下一项在哪", "这地方是有冲突", "好 告诉你下一项", "然后我再到下一项里头进行核对", "这时候呢这两者跟那儿是一样的", "好 那么这时候呢", "我要找这个地方", "它的序号就是我的页帧号，", "好 页帧号和页内偏移合到一起", "那就得到它的物理页号和页内偏移", "那到目前为止呢我们介绍了三种做法", "来缓解或者是解决页表所带来的麻烦", "一种是快表 它是通过缓存的机制", "来减少对物理内存 对页表的访问", "第二种是多级页表", "多级页表的做法呢", "通过多级来减少页表的大小", "反置页表是另一种减少页表大小的做法", "这几种做法呢都可以有效的解决", "或者是缓解我们引入页表所带来的麻烦", "那在这些麻烦解决掉之后", "我们现在用到计算机", "都是采用这种页表的机制来进行转换的", "那这是呢 我们说到的这个页存储机制"]}, {"name": "", "block_id": "08f56c1dae4f4c828b9987d60b78a59d", "text": ["那这个执行流程呢", "我们可以看到", "它涉及到了几部分工作", "第一部分是我们说ucore os", "最开始初始化的kern_init", "它会进一步调用什么跟进程相关的", "我们说这里面内核线程创建相关的", "proc_init", "那proc_init会完成一系列的", "比如说我们创建内核线程", "去执行内核线程整个过程", "那这里面会涉及到很多函数", "这里面重点关注呢", "有两个一个是proc_init", "以及还一个do_fork", "这两个函数涉及到我们进程创建", "和执行很多细节一些信息", "我们在后面会逐一展开讲解", "好 那我们来看看", "怎么来完成内核线程的创建", "首先我们创建第0号内核线程", "这为什么是第0号", "跟我们计算机这个术语相关", "我们经常表示首个是从0开始", "那么这是第0个内核线程", "那么其实它这个内核线程呢比较特殊", "我们叫idleproc", "它代表了我们ucore os", "来完成一系列的管理工作", "包括后面的完成的对", "所谓的内核线程init proc", "创建和调度执行过程", "所以这是一个说", "代表一个ucore os一个管理", "在这样既然代表ucore os管理", "它需要完成自身的一些初始化工作", "比如说它要创建自己的TCB", "为此它要alloc_proc", "来得到一个TCB的内存块", "那TCB的内存块呢", "会完成相应的初始化工作", "来表明它的身份", "那到底完成哪些细节呢", "我们可以看看", "那可以看到这里面包含了什么", "第一个是PID", "就是它的本身一个ID标识0", "正好和他第0进程是对应的", "第二个呢它的状态", "它当前是可以runnable", "就是当前处于就绪态", "第三个是它的堆栈", "这里面专门给它设置一个内核堆栈", "专门有一个bootstack这么一个地方", "第四个need_resched 就是它需要被调度", "为什么呢", "因为它被调度之后呢", "才能切换到其它的内核调用去执行", "我们前面讲到我们这个要完成", "一个显示字符串的一个内核线程", "那需要把这个线程呢从idle_proc", "切换到我们显示字符串的init_proc里去", "所以这里面需要设置它是", "需要能够去允许被重新调度", "最后呢设置一个它的名字idle", "这就是它最基本的初始化功能", "有了这个之后呢我们继续往下执行", "去创建我们说的第一个", "能显示字符串的一个内核线程", "那么这个内核线程呢", "就跟前面的idle_proc比起来", "它初始化工作完成更加复杂一些", "因为它要做好各种各样的准备", "它的地址", "它的执行", "它的上下文等等", "只有做好这些准备之后", "才能够正确进行线程间的切换", "可以看到这里面", "采取一个重要的函数是什么呢", "是do_fork", "它完成了后续一系列这个初始化工作", "那我们说在这里面它初始化工作", "其实要把我们刚才线程控制块里面", "很多数据结构呢", "都要进行进一步的初始化", "我们这里面挑一些重点部分", "给大家做一个讲解", "这里面我们讲哪部分呢", "第一部分是trapframe", "就是怎么能够对这个进程", "或者线程控制块的trapframe", "进行初始化", "它涉及到怎么去能够", "跳到它的入口地址去", "正确执行线程这么一工作 这一块", "第二个呢是跟context相关", "完成线程切换的时候 context相关", "这两部分是我们这里面", "会给大家描述重点", "也是比较难以去理解的", "那我们看第一部分trapframe", "它初始化什么地方", "初始化关于它地址空间", "可以看到他用到的", "kernel_cs和kernel_ds", "这什么意思呢", "意味着我们内核现成它的代码段", "和数据段是在内核里面的", "它不是user(用户态)的cs和user（用户态）的ds", "Ok这第一步", "第二步呢我们要设置好", "我们说这个线程的起始地址在哪", "因为当切换完成之后呢", "我们这个线程要从", "它的起始地址开始执行", "所以你可以看到它有两个地方", "一个是kernel thread entry 还有一个fn", "fn呢是代表我们说实际的入口地址", "但是在执行实际的入口地址之前", "我们需要完成简单初始化工作", "这就是kernel thread entry", "这是最开始的初始化的地方", "当把相应的一些初始化", "一些变量设置完之后呢", "会去进一步去调这个fn", "这个function的入口地址", "从而可以完成", "比如说打印字符串这个工作", "这是跟它相关的", "这个arg是设置跟这个fn相关一些参数", "比如说你要传一个字符串", "它的起始地址在什么地方", "这是相关的一部分入口的初始化设置", "这是第二部分", "那第三部分呢是关于trapframe的一些", "有关它的esp和它的eip的一个设置", "那这里面esp设置是", "中断的相应的堆栈一个信息", "我们可以看到tf_esp实际上设当前一个esp值", "然后还有一个context.-esp", "设是proc->_tf", "也意味着我们内核的堆栈里面", "有一块区域保存了我们trapframe所有内容", "我们trapframe跟这个进程相关所有内容", "它保存在这个内核堆栈里面", "这是一个信息", "第二信息是说它有一个eip设置的forkret", "那么forkret什么意思", "实际上需要注意context.eip", "那意味着我们当完成了context switch之后呢", "我们当前这个init proc", "它首先执行的forkret", "那它和我们刚才讲到的", "函数的本身的入口地址", "比如说fn或者说那个 kernel thread entry", "那个地方是不一样", "这个forkret主要完成什么呢", "它主要完成对返回中断一个处理过程", "也意味着它会去设置相应一些操作", "最后执行iret", "然后iret会根据trap-frame里面设置的信息", "来跳到我们说init proc", "这个内核线程入口地址去执行", "也意味着forkret是进行了", "中断的一个恢复执行的一个过程", "当设置完trap-frame和context之后呢", "我们还需要去进一步去设置有关init proc", "其它一些执行相关的一些信息", "比如说它的stack", "它的内核堆栈", "设置好内核堆栈之后", "我们可以看到", "我们就可以说这个相应一些", "初始化工作基本上准备就绪了", "我们就可以把这个init proc", "放到就绪队列里面去 管理起来", "以及把它的状态设置为runnable", "更刚才一样设成runnable", "这代表它可以去被调度去执行了", "那当设置完之后", "我们接下来工作就要执行它", "那么执行是从idle_proc里面去执行的", "因为idle_proc", "就是我们当前正在执行的ucore os", "那么他干什么事情", "怎么开始执行", "我们可以看一看", "首先它要设置我们现在", "不能够重新调度", "我们现在已经处于调度状态了", "我们不能在这个调度状态中", "再去递归去调度", "这是不允许的", "就是unable reschedule", "这是在调度时候", "要完成第一步工作", "第二步工作", "我们要找到当前线程队列里面", "哪些是属于就绪态的", "我们可以看到它这里面至少存在", "init_proc", "找到这一个 找到这个之后", "就开始执行proc 就开始执行", "其实还没有完成切换", "做好相应的准备", "所谓开始执行就要切换什么呢", "第一要切换两个线程的kernel_stack", "第二步要切换所谓他的地址空间", "但是需要注意这个切换地址空间呢", "对于我们后续lab5的用户态", "的进程是有关系的", "但是对我们内核线程来说", "它们是共用一个地址空间", "所以这一块其实没有太大意义", "再接下来是切换context", "这context是我们前面", "专门给大家介绍context数据结构", "我们后续会给大家展开", "看看怎么来切换context", "一旦切换完context之后", "会完成一个return一个返回", "那么也意味着它会", "执行到forkret这个地方去", "然后进一步去根据trap frame", "来完成ret一个返回", "然后从而可以跳到", "跳到我们说内核线程入口地址", "就是kernel thread entry", "kernel thread entry再会去执行什么呢", "执行那个function:fn", "从而可以得到我们说去", "完成那个打印字符串一个功能的", "那个函数的一个执行过程", "这是整个这个执行内核线程", "一个过程的一个描述", "那么我们会对这个switch context", "做进一步的讲解", "那我们看看switch context", "实际上是一个函数", "实际上被c语言调用的一个函数", "那么它本身的实现", "需要注意它本身的实现", "是用汇编语言来实现的", "因为这里面涉及到", "大量对寄存器一些操作", "那我们可以去理解一下", "from是从 比如说我们这里面具体讲", "就是从idle_proc切换到to", "to是什么呢", "To是init_proc", "怎么从from的切换到to的这个context", "实际上我们说这里面", "要做两部分事情", "第一部分是save", "save这个idle_proc的context", "这是第一步", "第二步呢是restore恢复", "\"to\"thread是什么呢", "就是我们说的init_proc它的context", "保存(save)恢复(restore) ret就完成了这个过程", "那么具体怎么做的", "我们再逐一看一下", "这个参数我们说的idle_proc的context", "这个参数呢是我们说init_proc的context", "ok 我们进一步看一看它的汇编代码", "首先因为它这是一个参数", "我们再回顾一下我们在lab1时候", "讲解过函数调用栈里面的存储信息", "就是我们一个函数", "调另一个函数的时候", "它压的相应栈的结构", "我们可以知道esp", "向上那四个字节存的是什么呢", "存的是那个参数from这个参数", "这个from是什么呢", "就是idle_proc context的地址", "好 有了这个地址之后", "我们接下来就可以", "完成一系列的保存工作", "比如说move esp到这个地方来", "就把esp的内容保存到了", "我们说的这个idle_proc的context里面去", "同时呢还需要注意这个\"popl\"是比较特殊的", "\"popl 0(%eax)\"", "它通过一种特殊的手段", "来完成了把当前的idle_proc的eip保存到了", "也一样保存到了", "我们说swap_context里面去了", "那会完成一系列保存工作", "把context把信息给填满", "也意味着它会完成对", "idle_proc的context的完整的保存", "把这些寄存器的内容", "全都保存到相应的数据结构里面去了", "这是说保存这一步", "save这一步", "第二个呢还要干的事情就是要恢复", "就是restore \"to\" thread context", "那么\"to\" thread就是我们说的init_proc", "那么这里面的context", "它在前面已经做好初始化了", "而我们前面的idle_proc呢", "是在刚才做了保存", "那么这个初始化信息", "要全部都要读出来", "从哪读出来呢", "可以看着它又取到了\"movl 4(%esp),%eax\"", "这实际上就取到了", "我们说init_proc的context的指针", "然后把这些内存里面的信息", "再逐一倒到相应的寄存器里面", "比如说ebp ebi等等", "就是完成了对所有寄存器恢复", "然后到最后一步需要注意\"pushl 0(%eax)\"", "实际上把这个eax给push进去了", "为什么要push到栈里面去", "因为你最后还要执行一个ret", "ret会从这个栈里面把这个地址取出来", "从而可以完成这个切换", "所以说我们想想这个eip等于多少呢", "在做前面初始化的时候", "我们这个eip赋成了什么呢", "赋成了fork ret那个地址", "大家有没有印象可以看一看", "所以说一旦在执行完这个", "ret这个return之后呢", "我们这时候呢已经切换到了", "init proc的最开始地方", "就是forkret起始点去执行", "这就是它的context swich完成的工作", "所有这些工作在内核里面来完成", "好 大家分析到这一步之后呢", "大家结合实验可以进一步去展开看看", "当fork ret继续往下执行之后", "会怎么来完成打印字符串", "这么一个完整的过程", "这需要大家在实验中", "去进一步去体会和理解", "好 这部分内容就介绍到这儿"]}, {"name": "", "block_id": "2f8ced75c6af48ae804ba6bae5cf85d9", "text": ["下面我们来介绍进程控制", "在进程控制当中呢", "我们会涉及这样几个问题", "一个是在内核当中的进程切换", "也就是说我一个进程", "在运行过程当中", "内核如何来实现它从一个进程", "到另一个进程的切换", "后面的三个呢", "实际上为用户提供的系统调用服务", "那是用户在执行它的应用的过程当中", "它有需求要创建一个新的进程", "好在这里头呢", "我如何来创建一个新的进程", "在这里头运行一个新的程序", "那这个是进程加载", "父进程创建子进程之后", "它们俩之间呢", "需要有一些协调的关系", "你比如说子进程结束之后", "父进程负责回收它所占用的资源", "那这个时候", "它们之间有一个通讯关系", "这就是进程的等待和退出", "下面我们一个一个的来", "首先是进程切换", "进程切换呢", "有时候也称之为叫上下文切换", "它是暂停当前运行进程", "把这个进程呢", "从运行状态变成其它状态", "这里所谓的其它状态呢", "可能会是由于进行IO操作", "或者等待事件而进入等待状态", "也可能是由于被抢先", "又或者说时间片运行完", "那转回到就绪状态", "另一个是说", "我把当前的进程停下来之后", "那我会调度另一个进程", "让它从就绪状态变成运行状态", "也就是说我从就绪队列里", "找一个新的进程然后恢复", "并且让它继续运行", "这是进程切换所要做的事情", "好那具体说起来", "有一些切换的时候", "我们有一些什么要求呢", "那在切换之前", "需要去保存进程的上下文", "也就是说", "你下一个进程在执行过程当中", "需要用到这些CPU的寄存器", "状态寄存器", "好那这些呢你需要先做保存", "好切换到下一个进程运行的时候", "在切换过来之后", "下一个进程开始执行之前", "我还要继续把它上一次", "暂停时候的当时的", "寄存器的状态恢复回来", "好恢复回来之后", "那它才能够从", "上一次暂停的位置继续往下执行", "还有一个要求是说", "由于我们现在计算机系统里", "进程的切换是非常频繁的", "通常情况下是10毫秒左右", "就会有一次进程切换", "那这样以来的话", "为了保证系统运行的效率", "这个切换的速度必须非常快", "所以通常情况下", "它都是由汇编来实现的", "那具体说起来我们在这里", "要保存一些什么样的信息呢", "实际上保存就是进程在整个", "生命周期当中它所维护的信息", "大致说起来呢", "包括这样几个方面", "寄存器", "那我们在CPU里头通用寄存器", "好CPU里头状态信息", "然后就内存地址空间里的信息", "那你说通常情况下我们", "在切换的时候", "内存里头的这些信息", "是不会被另外一个进程", "因为它各占一段区域", "是不会被另一个进程所替代的", "所以在这里头呢", "那内存里的地址", "空间内容大部分不用保存", "下面我们通过一个图式", "来说明进程的切换过程", "那在这里头呢", "我们假定系统当中有", "P0和P1两个进程", "它们的执行过程当中呢", "先是P0处于用户态执行", "那执行过程当中", "P1处于空闲状态", "那可能会是就绪", "也可能会是等待", "好那在这里头呢", "执行的过程当中", "碰着一个系统调用", "或者是中断", "假定我们这是时钟中断", "那它的时间片用完了", "到这儿来之后切换到内核", "那切换过程当中", "它需要保护现场到PCB0", "也就进程零的进程控制块里头", "把它的当时执行到状态", "都保存下来", "保存下来之后那这时候说", "如果说时钟中断", "时间片用完", "那这时候我们需要选择", "下一个就绪进程", "假定这时候", "你选择下一个进程是P1", "好那到P1需要恢复P1现场", "恢复完之后", "那这时候呢", "状态就已经切到进程P1了", "好那这时候P1开始运行", "继续运行", "好运行到一段时间之后呢", "假定说它的时间片又用完了", "这时候又产生时钟中断", "时钟中断又切回到内核状态", "好那这时候它要保存", "进程P1的现场", "到它对应的进程控制块PCB1", "好那在这里头我们假定你又决策", "我需要选下一个进程", "这时候又选P0", "那这时候恢复P0的现场", "那这时候从PCB0里头", "这两个是对应的", "PCB0里头恢复现场", "好恢复进程状态之后", "它切到进程0", "然后继续执行", "到这个地方呢", "我们一个从进程零切换过去", "再切换回来一个完整的过程", "就在这儿展现出来了", "跟它相关的呢", "执行正常执行", "然后这个地方呢", "是保存现场到PCB0", "从PCB0里恢复现场", "好中间是PCB1", "这边恢复执行到保存", "那从这一过程来讲", "它是比较清楚了", "那这时候我们要在PCB里", "记住一些什么信息了", "记录进程的运行状态", "好那状态呢是放这里头", "然后我们把状态呢", "它相同的状态", "我放到一个队列里头", "这时候维护出若干个队列", "比如说就绪队列", "它有一个起头", "然后相应的进程串在一起", "那可以用各种各样的办法", "来形成这样一个队列", "好如果是等待呢", "我们就会把它分成", "若干种不同类型的等待", "比如说在这里头每个设备", "等待的设备不同", "那它有各自一个队列", "比如这里列出来的", "磁带01和磁盘0", "好然后还有一类呢", "就是处于这个", "运行到退出的状态的", "这时候它的收尾状态", "这时候僵尸队列那它对应的", "在这里头那处于这样一种状态", "这是进程块里头", "保存信息和它们如何来组织", "好那实际上接下来", "我们是说到底会有", "一些什么样信息保存到", "进程控制块里头呢", "那不同的系统里", "进程控制块呢是不一样的", "比如说在我们 ucore和ucore plus里头", "有一个数据结构叫PROC STRUCT", "好在这个数据结构里头呢", "它保存了进程的相关信息", "大致的信息", "我们可以把它分成这样几类", "一类是进程的标识信息", "比如说它的执行", "是哪一个可执行文件", "它的ID是多少", "它的进程ID", "好然后它的父进程是谁", "好这是一类", "然后再一类是进程的状态信息", "比如说我们在这里头CPU里头", "状态寄存器的相关信息", "然后地址空间的起头的位置", "第一级页表的起始地址在哪", "然后进程的状态和它", "是否允许调度等这样一些", "执行状态的信息", "还有一类呢是进程所占用的资源", "比如说它占用的存储资源", "那所有分配给", "它存储那组织成", "相关的数据结构MM", "好那上边那个是", "它占用的内核堆栈", "还有一类呢", "是我们保护现场用的", "那在中断和进程切换的时候", "它都需要保护现场", "那这些现场的内容呢", "我们刚才说是保存到", "进程控制块里头", "实际上就是指这个地方", "好你两个进程需要复用的部分", "就需要在这儿做保存", "除此之外呢", "这些进程它在", "不同的时候处于不同状态", "这些状态组成不同队列", "那在这里还有几个", "相关的指针结构", "用于描述我当前进程", "到底是在哪一个队列当中", "好有了这些信息之后", "那我们这个操作系统", "就对进程的执行状态呢", "有了一个准确的把握了", "好我们在ucore里用到", "还是比较简单的", "对于实际的像Linux windows", "那么这时候它的数据结构", "比我们要多得多", "这是进程控制块的数据结构", "在ucore里的完整定义", "在我们这里头呢", "大家需要注意到的是", "我们刚开始说的", "这是进程的状态", "进程的ID信息", "进程ID 线程ID 组ID", "然后是进程执行的相关信息", "是否需要调度它的父进程是谁", "然后这个地方是", "进程的内存管理的数据结构", "然后下边两个呢", "是进程的现场保护的", "上下文现场和中断保护现场", "然后底下是CR3", "CR3呢实际上是页表的起始地址", "然后它的标志位", "可执行文件的进程的名字", "然后是进程的哈希表和链表", "那这和我们前面讲的", "这里的数据结构呢", "是能够完全对得上的", "我们在这儿呢是介绍的大致情况", "在这里头呢实际上是完整的列表", "希望同学下去之后有机会", "把这个完整的列表呢", "能够有一个基本的了解", "好那在这里", "我们需要特别说明呢", "是内存地址空间的数据结构mm_struct", "那在这个数据结构当中呢", "我们关心的内容是说", "第一个它到底有哪些内存块", "内存逻辑地址空间里头", "映射是在哪个地方", "对应的地址空间是啥样的", "好这是第一个", "在这里呢", "是它的第一级页表的起始地址", "pde_t *pgdir", "那这是地址空间的起头", "然后说如果它有共享的话", "那么它又共享了几次", "然后如果说在这里头", "有跟外存之间的置换", "那这时候置换相关数据结构", "好有了这些之后", "那我们对进程的运行情况就了解了", "这是内存管理的内存的数据结构", "对应 到代码当中呢", "是这个数据结构mm_struct", "在这里头我们关注的几个内容呢", "是它也会组织成映射的链表", "然后这是页表的起始地址的指针", "然后这是引用次数", "和对mm数据结构进行写的时候", "它相应的锁标志信号量", "好然后再一个进程里头", "ucore里头的进程队列", "它怎么来组织呢", "那在这里头呢", "我们看到基本上是链表", "你比如说在这里头", "我们有双向 链表", "然后说如果说", "你这个链表很长", "那这时候检索的开销是非常大的", "所以在ucore里头又加了hash list", "如果说这里链表长的话", "先加一级hash队列", "然后每一级队列里头呢", "hash值相同的", "再组成相应的自己的队列", "那有了这些办法之后", "我们就知道它在这里头", "到底它的队列是如何来组织的", "好那么具体的在ucore里头", "它的一个切换过程是什么样子呢", "不管由于什么原因", "最后只要你导致切换", "都会到schedule内核函数里头来", "好到这个函数里头", "它干些啥呢", "它首先清楚调度标志", "那我现在正在调度", "不能再进行改调度 标志", "然后我这儿呢", "查找新的就绪进程", "一种可能情况", "就是查找完了之后我有可能", "还是找回来还是我自己", "那这种情况是存在的", "好找着一个新的进程", "然后说我修改进程的状态标志", "那把前头那一个改成", "是就绪或者是等待", "然后把新那一个", "改成是运行状态", "好然后接下来进行切换", "切换这儿有一个switch_to", "这是最后切换的代码", "好那在这里头", "这个过程大致的流程就有了", "好那么实际说起来我们看看这里头", "这个图里说的呢", "是ucore里头的函数调用关系", "那不管是你由于", "各种各样的情况出来之后呢", "它最后都会到schedule这地方来", "比如说在我们这里", "是由于退出所过来的情况", "好到这个schedule里头来了之后呢", "它到这个地方去做选择", "和这地方是在做切换", "那到这个地方", "最后到switch_to这一段汇编呢", "它是完成切换的", "而准确的切换代码", "是什么样的呢", "准确的切换代码是跟你平台相关的", "每一个CPU平台上", "它所需要保存的寄存器是不一样的", "而为了保存的速度比较快", "恢复速度比较快", "那在这里头呢", "我们所有切换代码switch_to()", "都是用汇编来写成的", "那大致的格局呢", "是前半段保存切换过去之后", "实际上改CR3", "改完之后下半段恢复", "然后就继续执行了", "好这是进程切换的函数调用关系图", "那对应到我们实际系统当中呢", "这是我们的切换函数它的实现", "那我们需要关注的问题", "是在于这个地方在切换的时候", "它会去改进程的状态", "然后选择下一个被调度的进程", "从调度队列当中把这个进程取出来", "然后后面进行一系列的判断", "那我们在这儿呢", "这一部分内容呢", "我们直接看关注的是它的调用图", "那在这儿我们可以看到", "schedule()这个函数它调用的地方呢", "基本上是我们各种事件出现的时候", "你比如说数据发送", "然后这个后面会讲到信号量的触发", "然后接收到事件", "CPU处于空闲状态", "发送消息等等一些信息", "最后都会导致到我这schedule()", "schedule()里呢我们刚才说到proc_run()", "这是我们这里关键的函数", "到这个地方下来之后有一个", "switch_to()", "在这个函数里头呢", "实际上我们通过跳转", "转到我们的汇编代码上了", "这个汇编代码呢", "就是我们这里的这一段", "在这里头呢前面是保存", "上一个进程的寄存器的工作", "下边是从堆栈当中恢复", "进入运行状态的进程的寄存器的值", "恢复完毕之后然后返回", "那就新的进程就开始继续运行了", "那在刚才那个地方呢", "switch实际上是通过这里头", "这一句C语言的函数", "最后跳转到刚才的", "这个汇编代码当中来"]}, {"name": "", "block_id": "9d58786cc84c4f1f9a2af5d4b1f0bccc", "text": ["各位同学好", "那么我们这次课呢", "是讲解lab6", "lab6是关于处理器调度", "那这一节呢", "主要有一个总体介绍", "调度的过程的一个分析", "以及我们说", "为了支持不同的调度算法", "我们要设计的一个支撑框架", "就是调度算法的一个支撑框架", "然后呢 给大家介绍一下", "在实验中已经提供的", "Round Robin的调度算法", "希望同学能够实现什么呢", "是一个Stride调度算法", "这个算法呢 在原理课里面没有讲", "我们希望通过同学的分析 理解", "能够在lab6中完成", "首先我们来看一下总体介绍", "那总体介绍 主要介绍一下", "我们这个实验的目标 练习", "和一个大致的流程概述", "可以看到 在我们完成了lab5之后", "我们说 我们可以创建前面的", "内核线程和用户进程", "当我们的操作系统中", "存在多个进程的时候", "比如说有多个进程的时候", "那就需要知道", "有些进程它会占用cpu执行", "有些进程可能会等待cpu执行", "这里面有一个生命周期的管理", "那我们这里面重点研究的", "是什么时候 基于什么原则", "来选择哪一个进程去执行", "这是我们说调度要考虑的问题", "这是我们lab6中", "重点需要去理解", "和掌握的一个知识", "好 那我们的目标可以看看", "细分一下 第一个是", "理解操作系统的调度管理机制", "第二个是熟悉ucore", "这个调度器的设计框架", "第三个是理解Round Robin调度算法", "第四个 我们要去根据你对Stride", "调度算法的理解来完成它", "到底怎么去实现它这个调度算法", "这是我们的目标", "为此你需要去对ucore的", "lab6里面的源码进行一个分析", "包括调度器的框架", "Round Robin调度算法", "以及Stride调度算法", "那其实我们可以看看", "对于应用程序而言", "比如hello这个应用程序", "看起来它这里面", "和操作系统的调度没有任何关系", "但其实呢", "操作系统在管理这个进程的", "从创建到最后它消失", "这个过程呢 其实我们操作系统", "有多次的调度的机会", "去选择让这个进程执行", "或者是不让它执行", "这其实是在后面", "我们操作系统的底层", "来完成了整个调度的过程", "而所有的过程", "对我们应用程序的执行来说", "是透明的 看不见的", "好 那我们再把大致的流程", "给大家介绍一下", "首先我们回顾一下", "这个调度 其实并不是说", "在lab6才出现", "在早期的lab5", "其实已经出现了调度", "我们可以回顾一下 看看怎么回事", "lab5中它完成了", "对用户进程的管理", "那在这个管理过程中呢", "涉及到对整个进程", "生命周期的管理", "我们这边其实已经存在了", "对一般进程它也有个调度", "只是这个调度很简单 是FIFO", "我们说先进先出这么一个调度算法", "这里面呢 一个进程当创建完之后", "它处于就绪态", "然后一旦被我们的ucore选择", "去让它在CPU上执行的时候", "它就从头执行 直到结束", "中间不会被打断", "只有结束之后", "我们的ucore才会去查找", "下一个处于就绪态的进程", "让它去执行", "那么这个查找下一个进程", "是由谁完成的呢", "是我们的idle", "idle实际上是一个内核线程", "我们在里面其实大家再注意一下", "我们在讲lab4 lab5的时候", "虽然说它是一个是内核线程", "一个是用户进程", "但是它们的调度 它们的管理", "这一块其实是大同小异", "基本上是一样的 有一些区别", "大家再回顾一下 有哪些区别", "那么这个idle这个内核线程呢", "它会不断的遍历这个进程池", "直到找到第一个", "runnable状态的进程", "所谓runnable 就是就绪状态", "然后找到这个之后呢", "就会完成一个进程切换", "把自身给挂起", "然后去执行找到的进程 去执行它", "那么这就是一个最简单的", "基于FIFO这种调度策略的调度算法", "我们前面讲到了lab4和lab5", "其实都和进程管理相关", "大家来回顾一下lab4和lab5", "它们完成的内核的", "线程和用户的进程", "它们在管理上面", "到底有哪些事情要做", "那这种方式我们来给一个评价", "这种方式怎么样呢", "其实这种方式呢", "它体现不出", "进程和进程之间的一些特点", "比如说我们说进程有优先级", "这个进程运行时间太长了", "其实它应该在更短的时间就应该结束", "让给其他的进程去占用CPU", "去完成它各自的工作", "如果是基于FIFO这种方式", "虽然我们的调度实现很简单", "但是呢 它的效率不高", "这个在原理课上已经讲过", "不同的调度算法", "它们有不同的评价指标", "我们基于这个评价指标", "来衡量这个算法它的好坏", "那么我们就是为此", "重新设计了lab6这个调度框架", "这个lab6里面它主要完成两块", "一块是关于调度的初始化过程", "一块是具体的调度过程", "那么在初始化过程中", "首先我们需要去实现一个调度算法", "那基于一个调度类来实现的", "我们这里面用了C语言", "来实现一个函数指针的一个列表", "这个函数指针的列表呢", "接口是统一的", "但是具体的调度的", "这个算法的实现是不一样的", "那我们说在ucore的设计里面", "设计了一种机制", "可以用C语言来实现", "一种类的表示方式", "通过这种方式呢", "我们具体完成一个调度算法的实现", "然后绑定到ucore里", "缺省的调度类里面去", "从而可以使得我们的ucore", "可以去调用你的这个调度算法", "在哪调用呢", "为此我们需要", "进一步去设置相应的调度点", "所谓调度点 或者叫抢占点", "就是说当产生一些特殊的事件之后", "我们需要去触发", "我们的ucore操作系统", "去完成一个调度", "把这个设置好之后", "就完成了整个调度的初始化过程", "那接下来我们看一下", "当产生了一些事件之后", "我们就会在ucore里面", "得到这些事件的一些信息", "然后就到特定的调度点", "去开始做两个事情", "一个事情是要调整一些调度的参数", "因为我们的调度算法", "是基于这些参数来具体的去选择", "最后应该选择哪一个进程去执行", "还有就是要调用相应的调度算法", "这是他们要干的两个事情", "当调用调度算法的时候呢", "调度算法会做两个事情", "第一个是要选择新的进程", "第二个完成进程切换", "这里面呢 分两种情况", "首先是如果有新的一个", "优先级更高的进程", "那么我们要选择这个进程 选出来", "那基于里面的算法", "我们可以有不同的选择策略", "假定你选出了一个新的进程之后", "我们就要进行进程切换", "这是一种情况", "有新的进程去运行", "另一种情况呢", "有可能说你这个调度的过程当中", "发觉没有就绪进程了", "在这种情况下", "我们就会切到idle线程去运行", "这时候idle线程干什么事呢", "它只干一件事情", "就是不停的去查询", "是否有就绪的进程", "如果有 它就做切换", "如果没有 它就在不停的查询", "做一个循环", "这就是说idle线程", "在这里面起到新的作用", "接下来我们介绍一下调度过程", "那么这个调度过程呢", "比前面讲的那个总体介绍的过程", "稍微要具体一点", "那么使得我们可以更清楚的认识到", "我们原理课堂讲的那些调度算法", "怎么能够在ucore操作系统里面", "能够具体的得以执行", "首先我们看一下", "就是怎么能够产生调度", "这里面就涉及到触发的一个过程", "第一点我们前面讲到有一些触发点", "由于有一些事件的产生", "使得这些触发点能够被调用", "那么触发点呢", "就是最终能激活", "调度算法的一个执行", "这是第一步", "那么一旦调度算法得以执行之后呢", "那么它干的第一个事是什么事呢", "第一个事就是要把当前的这个进程", "放入到就绪队列里面去", "这是第一步", "第二步呢 从就绪队列里", "选取一个 它认为最合适的", "一个进程去占用CPU执行", "pick up一个process", "第三步呢", "就是把这个选择的进程呢", "从就绪队列里面取出来", "因为我们需要把它去做", "完成一个接下来的切换", "使得当前的进程和我们选出来这个", "新的进程能够完成一个switch", "一旦完成switch之后呢", "我们就可以让这个进程去执行了", "所以说这就是", "让进程执行的这么一个图示", "在这里面我们可以看到", "所有处于就绪态的进程", "也就是说Runnable的进程", "它会在一个队列里面", "我们会有专门的数据结构叫run_queue", "来管理这个处于就绪态的进程", "也就意味着我们这个算法呢", "它会从就绪队列里面", "选取一个它认为合适的进程去执行", "当然还存在另外一种情况", "什么情况呢", "这个进程呢 它会睡眠或者等待", "因为当某一个进程", "它需要的资源得不到满足之后", "它就会去等待和睡眠", "这里面就存在一个所谓的等待队列", "或者睡眠队列", "来放置这些特殊的进程", "那么这两类呢", "就形成了我们整个这个", "进程的管理的一个过程", "那么我们这个lab6呢", "它的调度算法这一块", "主要设计的是处于就绪态的进程", "和正在运行的当前进程", "它们之间的一个相互切换的过程", "我们的调度算法主要涉及这两块", "但是呢 进程", "它有其它状态", "比如说刚才说得不到资源", "它会处于等待或者睡眠的一个状态", "以及当进程执行完毕之后", "它会退出整个生命周期", "那么这两个态呢", "其实也和调度是有关系的", "但是不太涉及到调度算法", "所以说我们重点关注的是", "怎么能够从就绪队列里面", "选取一个新的进程去占用CPU执行", "后续呢 在这一块", "会做进一步的展开讲解"]}, {"name": "", "block_id": "470248fa0bba41aba7ef848f03879371", "text": ["各位同学 大家好", "今天我们来介绍死锁和进程通讯", "死锁呢 是进程之间", "由于共享资源所导致的一种", "无限期等待的情况", "那在这里头呢", "我们会讨论死锁的基本概念", "处理死锁的方法都有哪些", "我们会具体介绍银行家算法", "和死锁检测算法", "这两个具体的算法", "另外一个部分呢", "是进程间通讯", "也就是说两个进程之间", "它们有一些什么样的通讯手段", "那在这里呢", "我们会介绍四种 信号和管道", "消息队列和共享内存", "那首先呢 我们来介绍死锁", "死锁是由于竞争资源或通讯关系", "两个或更多个线程", "在执行的过程当中出现的一种", "永远相互等待其他进程", "才能引发的事件的状态", "那这时候呢 我们先通过一个", "具体的例子来看一下", "这就是单向通行桥梁", "那在这里头呢 这个桥梁呢", "我们可以认为它是一种共享的资源", "桥梁上只能单向通行", "那这时候呢 不同方向的车", "会共享这个单向通行的桥梁", "那桥梁的每一部分呢", "是一个资源", "如果这个桥梁整个是一个资源", "它也不会出现问题", "那要占用就整个占用", "实际上我们在这里", "是由于部分占用所导致的问题", "在这里呢 桥梁在使用的时候", "可能出现死锁", "比如说在这里头", "对向行驶的两个车辆", "在桥梁上正相遇了", "好 那这时候谁也没有办法继续前行", "都等待对方", "而这种等待呢 是没有结果的", "这种情况下呢 在我们通常做法呢", "是一个方向的车辆倒退", "好 那这样另一个方向呢能通行", "这实际上就是我们在这里头", "给到的一种死锁的解决办法", "就是资源的抢占", "与此同时呢", "即使不出现这种情况", "也会出现饥饿的情况", "一个方向的车持续的运行", "而另一个方向的车呢", "就没有办法通过这个桥梁了", "这是实际生活当中的一个例子", "我们在操作系统里头", "对于资源共享的情况", "也会有一个跟它很类似的情况", "那在具体讨论如何解决的办法之前", "我们需要比较深入的来分析一下", "死锁它出现的相关背景情况", "你比如说我们资源的使用过程", "出现死锁的条件等等", "首先呢 我们来看", "进程访问资源它的流程", "在系统里头呢", "我们存在各种类型的资源", "比如说像我们这里说到的", "CPU的执行时间 内存 I/O设备", "每一类资源呢", "可能会有多个实例", "你比如说像你的CPU", "可能有多个CPU", "对于这些资源呢", "我们在访问的时候", "通常是什么样的流程呢", "那进程访问资源的流程是这样的", "说这个资源为系统所占用", "进程在使用的时候", "首先我需要申请", "申请系统当中空闲的资源", "然后申请到了之后呢", "这个资源的状态", "就由空闲变成被进程占用了", "然后进程占用资源使用", "这有一个持续的时间段", "等它用完了之后 它会释放资源", "释放资源之后呢", "这时候资源的状态呢", "就由占用变成了空闲", "这是一个资源的使用的流程", "那在这个流程当中呢", "我们可以看到", "资源和进程之间的相互关系了", "然后为了更进一步的讨论", "我如何来解决死锁的问题", "那我们有必要对资源的特征", "进行一个分析", "在这里头呢", "我们就把资源分成了两类", "一类叫可重用资源", "对于这些可重用资源呢", "它的这些资源是不可以删除的", "任何一个时刻呢", "只能有一个进程使用", "一个进程使用释放之后", "另外的进程就可以重用了", "比如说像CPU", "你占用一个时间段 再使用", "好 过一会儿之后", "你用完了 你释放", "另外一个线程就可以来使用CPU的资源", "大家交替使用", "这就是我们前面所说到的", "调度所要解决的问题了", "那对于这种资源呢", "它有些什么样的实例呢", "那我们这里头处理器  I/O通道", "存储  I/O设备 那这些都是", "这是硬件资源", "也有一些软件资源", "你比如说文件 数据库等等这些", "都是我们这里的资源", "这些资源呢 是不可以被删除的", "那至少是在这里头", "文件我们是可以删除的", "但实际上这是对应于", "进程在访问这些资源的过程", "当中的一种情况", "还有就是在这里", "它可能会出现死锁", "那出现死锁的原因是说", "一个进程我会占用一部分资源", "并且请求另外一部分资源", "如果说你是一个整体的话", "这种情况也没有了", "这是可重用资源", "还有一类叫消费资源", "这一类消费资源", "它有一个创建和销毁的过程", "比如说这里头我们看到的一些实例", "中断 中断又出现和处理例程", "信号 消息 这些都是有一个进程产生", "另一个进程使用 这样一个过程", "那在这里头呢 它可能出现死锁", "比如说我们在这里时常见到的", "通讯双方相互等待对方的消息", "这是时常出现的一种情况", "那这时候相互等下去", "就出现无限期的等待了", "好 我们在这里头呢", "对资源有了一个描述", "对进程访问资源的过程有了一个描述", "好 那这时候我们如何来描述", "进程和资源之间的关系呢", "这是我们这里的资源分配图", "它描述资源和进程之间的", "分配和占用关系", "这是一个有向图", "那这个有向图里都有些什么内容呢", "首先第一个它有两类顶点", "一类是我们系统当中的进程", "每一进程用一个圆圈来表示", "然后另一类顶点呢 是资源", "每一类资源对应着一个顶点", "资源里头的实例的数目", "在这里用小圆点来表示", "好 那这是我们顶点的情况", "然后这些顶点之间的关系有两种", "资源请求边", "一个进程指向一类资源", "表示这个进程要请求", "这类资源当中的一个实例", "还有一类呢", "是资源分配边", "这表示一个资源实例", "已经分配给了某一个进程 在这", "用这个资源分配图我们就可以表示出", "进程和资源之间的申请和占用关系", "这是一个实际的例子", "我们从这张图里可以看到", "有四种资源 有三个进程", "它们之间有请求关系", "也有占用关系", "在这个图里头呢", "我们想知道 会不会出现死锁呢", "我们看下去之后 比如说这里头", "进程P3占用资源R3", "它用完了之后它释放", "那这时候呢", "P2就可以得到运行", "运行结束之后 那所有这些", "请求的编就都会得以分配", "所有进程都能执行完", "那这种情况呢", "它是不会出现死锁了", "再看下一个图", "这和刚才的图就多了一条边", "这时候呢 我们就看到", "在这里 出现了一个循环等待", "P2请求R3", "R3已经分配给了P3", "P3又请求R2", "R2已经分配给了P2", "这时候就有一个循环等待", "并且这个循环等待呢", "它没有结束的时候", "好 那这时候呢", "我们知道它会出现死锁", "对于这种简单的情况呢", "我们直接从这图上就可以很清楚的看出来", "但实际上我们遇到的麻烦是", "在系统当中有几百个进程", "有几十种 或者更多的资源", "这时候你再来做判断", "那就会有时间开销和比较困难", "这是一个资源分配图", "那里头也有一个循环", "但它会出现死锁吗", "细分析下去之后", "跟我们刚才情况一样的", "它不会出现死锁", "但是它要循环", "好 那这时候我们说", "不能仅仅依靠循环来判断是否出现死锁", "具体说起来我们会怎么来做呢", "那这就是我们这里的", "出现死锁的必要条件", "必须满足我们这里说到的四个条件", "同时满足才会出现死锁", "第一个条件呢 是互斥", "我们必须有某种资源", "任何一个时刻 只有一个进程使用", "如果说你的资源是可以共享", "不需要互斥的", "那不会出现这种情况", "第二个是持有并等待", "也就是说我一个进程", "如果说它本身不占有任何资源", "那就不会有别人等它", "它不会请求别的资源的话", "那它也就不会等别人", "好 那这样的话就是", "必须你持有至少一种资源", "并且正在等待获取其他进程占有的资源", "这时候才构成我们这里的第二个条件", "持有并等待", "然后第三个条件呢 是说非抢占", "那这类指的是", "资源只有在进程使用后自愿放弃", "我不可以强行剥夺", "比如说就像我们刚才说的", "单向通行的桥梁", "两个都走到中间相互等待了", "那这时候司机通常情况下", "都希望对方主动放弃", "那实际上在这里头呢", "通常情况下 这个是不容易满足的", "好 这是第三个条件", "第四个条件呢 是循环等待", "我在这些资源的请求和占有关系中", "我必须存在一个循环等待", "也就是说存在一个等待进程的集合", "0等1 1等2", "N减1等N", "一直到N等0", "这样构成一个循环", "如果没有这个循环的话", "也不会出现死锁", "有了这几个关于死锁的讨论", "那我们在这张图里呢", "去判断它是否有死锁", "那就看刚才说的那四个条件", "是否都成立", "那这时候我们刚才那两个例子", "一个是有死锁的", "一个是没有死锁的", "好 有了这些讨论之后", "我们下边就可以来具体地讨论", "我们对付死锁到底都有一些", "什么样的处理方法"]}, {"name": "", "block_id": "e0dff5efdfe2433491650398337706a5", "text": ["好 接下来给大家介绍一下", "X86中的中断处理的过程", "这里面会涉及到三部分", "第一个是谁产生了中断 就是X86的中断源 这是第一个", "第二个需要了解是CPU和操作系统", "软件和硬件如何结合在一起来处理中断", "第三部分是说你为了能够处理中断", "前面要做很多的初始化的工作", "把这个前期的环境给建好", "能够对中断向量表进行初始化", "这是三块内容", "那么有了这个知识之后", "大家能够对基于X86这个硬件的中断处理", "有更深入的理解", "其实在这个原理课中", "我们也提到了中段 异常 比如说陷入等等", "那中断 异常在具体的CPU上面它有不同的表现形式", "那对于X86而言", "它把中断 异常作为特定的两种不同类型来分别处理", "但是它的实现机制是统一的", "对于中断而言", "我们可以看到外设会产生中断", "外设包括了硬盘 网卡 时钟 串口等等", "我们的软件也会产生中断", "软件通过什么呢", "通过刚才说的int", "比如int80这种产生的软中断", "那么软中断用在什么地方呢", "用在我们的系统调用", "我们的应用程序可以通过软中断来获得我们操作系统提供的服务", "异常是另一类 异常是我们的程序在执行过程中做了不应该做的事情", "比如说除零错？？", "或者访问了一个非法的地址等等都会产生异常", "那异常也有严重程度一般的", "还有很严重的异常", "针对不同类型的异常", "我们的操作系统应该有不同的处理方式", "它的来源可以看到主要有三类", "外部中断 内部中断或者称之为软中断", "还有异常", "它们的特点 它们产生的时机 它们的严重程度", "他们的目标是什么 都是不一样的", "这边有个了解", "那中断产生之后 我们操作系统怎么办", "一般来说中断是由于外设", "假设是外设产生的中断", "我们操作系统就应该能够理解外设需要我们做什么", "然后产生相应的反馈", "比如说举个简单例子", "网卡产生的中断 那它得到了一个数据包产生了中断", "那我们操作系统就应该对这个数据包做进一步的处理", "来发给相应的应用程序", "需要这个数据的应用程序去做操作", "这实际上是我们操作系统干的一个事情", "它需要去做相应的响应", "那如果说是一个异常产生了", "那么异常产生之后呢", "我们的操作系统要根据这个异常的严重程度", "才能把运行的这个程序 我们称之为进程", "把这个进程给kill掉 给杀死", "也有可能是我们的应用程序产生的软中断", "那我们的操作系统就可以去完成这个服务", "最终让我们的应用程序可以得到这样的服务", "这是不同的处理方式", "那无论哪种方式 其实一个中断 异常", "或者说是我们称之为的软中断", "两种：硬中断 或者叫外中断", "内中断 （也叫）软中断等等", "这些都和所谓的中断号有一个对应关系", "比如产生的中断 它对应有一个中断号", "那么中断号唯一标示了这一个中断的特征 这是一个", "第二个 对于每一个中断号", "都有相应的中断处理的一个例程", "来完成对应的操作", "这个是我们操作系统需要去建立好的", "每一个中断或者异常都有一个中断服务例程", "简称ISR 就是Interrupt Service Routine和它关联", "关联之后一旦产生了某种类型的中断或异常", "就可以调用相应的中断服务例程去执行相应的操作", "那这个关联的建立", "是我们说操作系统需要去考虑和实现的", "我们需要去完成相应的处理过程", "但这个处理过程 也和我们的具体硬件是相关的", "所以说我们是需要去了解在X86环境下", "怎么来完成这个关联的建立", "那我们可以看看", "在X86环境中它有一系列的硬件机制", "来支持这种对应关系的一个建立", "它有一个IDT 就是中断描述符表", "跟我们刚才看到这个全局描述符表很类似", "只是它专门用来描述中断的", "这里面也是一个大的数组", "里面的每一项我们称之为中断门或者陷阱门", "trap就是我们说的软中断", "中断门或者陷阱门对应相应的中断号", "一个中断号可以有一个index", "我们根据这个中断号", "可以找到它所谓的一个中断门或者陷阱门", "基于这个中断门或者陷阱门", "我们可以进一步获取到", "跟这个中断门 陷阱门相关的段的选择址", "我们前面讲的段机制里面 有段的选择址和它的段类的偏移", "有了这两个信息 我们就可以知道", "一个中断服务例程的地址 就在这里面得到了表述", "所以说可以看到 IDT结合我们刚才看到的GDT两个合在一起", "就可以完成硬件的中断", "或者是异常和中断服务例程对应的链接关系的建立", "就可以搞定了", "那么这个表本身呢 它有一个起始地址", "放在IDTR里面去", "需要告诉我们的机器", "告诉我们的CPU说你这个IDT在什么地方", "所以说可以看出来", "这个IDT也是需要我们的操作系统来建立的", "这是第一个", "第二个它的起始地址", "要通过一个特定的指令来告诉我们的CPU", "说这个IDT在什么地方", "那么我们后面会讲到", "要怎么来完成相应的工作", "好 对于刚才提到的IDT表中的每一项", "我们称之为中断门或者陷阱门呢", "它有它相应的格式", "这里面最主要的两个一个是段描述符", "第二个是它的offset 这两块", "这两个信息其实也就意味着", "它的中断服务例程的起始地址是知道的了", "这是一个大致的一个展示图", "产生了一个中断之后", "根据这个中断我们可以知道它的中断号", "CPU会根据这个中断号来查这个IDT到底属于哪一项", "知道它的index", "找到相应的中断门或者陷阱门", "然后从这里面取出它的段选择址", "以这个选择址作为index进一步查找GDT", "我们前面讲了GDT 就是全局描述符表", "既然它作为index来查 查什么东西呢", "GDT里面存的是什么呢", "存的是段描述符", "段描述符里面有一个基地址 Base address", "再加上它谁在里面存的Offset", "合在一起就形成了相应的线性地址", "从而可以指向我们说的ISR 中断服务例程", "所以说一旦产生了某一个中断", "CPU可以自动的在硬件这个层面访问这两个表", "需要注意这两个表 是我们uCore建立好的", "一旦建立好之后 那我们的CPU就可以基于这两个表", "来查到相应的中断需要对应的中断处理例程", "当然这个例程是我们操作系统来实现的", "这样可以确保 一旦产生了某个异常", "或者某个中断之后", "我们的操作系统能够及时的响应", "去调用相应的函数来完成相应的处理", "这就是中断处理的初始化的过程", "另一方面需要注意的是 当产生中断之后", "中断会打断当前正在执行的程序", "然后去执行刚才说到的中断服务例程", "执行完毕之后再返回到当前被打断的程序继续让这个程序去执行", "那么这有一个打断和恢复 就是打断就需要一个保存", "最后要返回去要恢复 这么一个过程", "那么我们前面讲到了 在不同的特权级", "它的处理方式是不一样的", "特权级是由谁来决定的 是我们的段描述符里面会有看到", "那么段描述符里面会设定它到底处于哪个特权级", "比如说我们的CS它的低两位", "它如果低两位是0 代表是运行在内核态", "那么CS它的最低两位是3", "代表运行在用户态", "在内核态产生的中断依然在内核态", "但是在用户态产生的中断也会跳到内核态里面去", "那这是两种不同的方式", "因为这里面产生了特权级的变化", "对于这种特权级变和没变呢", "中断的保存与恢复也是不一样的", "我们可以看一看 这边是代表是说产生了中断之后", "在同一个特权 意味着在内核态里面产生的中断依然在内核态", "这时候会发生什么变化", "第一个可以看到 它的Stack", "它的栈还是用同一个栈", "没有发生变化 只是在这个栈上面压了一些寄存器内容", "被打断的那一刻寄存器的内容", "第一个是什么呢", "可以看到有Error code", "这个Error code代表是特意的严重的异常", "不是每一个中断或者异常都会产生Error code", "第二个会压入EIP和CS", "是当前被打断的那个地址", "或者是当前被打断的下一条地址", "第三个是EFLAGS", "当前被打断的时候的标志性的内容", "第三个是由我们的硬件", "一旦产生中断的时候硬件会压栈压进去", "但可以看到它是压在同一个栈里面", "第二个如果说当发生中断的时候处于不同特权级", "意味着产生中断那一刻 我们的应用程序正在用户态执行", "在用户态执行的时候 我们可以看到", "第一从用户态到内核态", "他们用的是不同的栈", "Stack1 Stack2 用的是不同的栈", "所以说当由于特权级变化产生了中断的时候呢", "除了压刚才说的那些内容之外", "还有很重要的两个信息是ESP和SS", "这两个内容是当时产生中断的时候", "在用户态里面的那个栈的地址", "就是SS和ESP", "可以看出来它们有很大的区别", "很明显在执行完毕要恢复的时候", "对于这边而言", "它还是恢复到同一个特权级", "还是在同一个栈里面继续往下走", "对于这边而言呢", "它一旦恢复到用户态去执行", "也会产生变化 不会用内核态去执行", "这是不同特权级下 中断切换对堆栈的影响", "给大家做一个简单的介绍", "那么X86 当它完成中断服务例程处理完之后", "我们还需要返回到被打断程序继续执行", "这里面对于中断服务例程来说", "它会通过一个iret指令来完成这个返回", "但对于我们通常的程序来说", "它是通过ret和retf完成函数的返回", "而这个是中断服务例程的返回", "也意味着他们的处理方式是不一样的", "对于没有改变特权级的方式我们可以看到", "它其实是把在同一个栈里面", "把这个弹出", "根据CS和EIP 来跳到当前被打断那个地方继续执行", "同时还要恢复它的Eflage的值", "这是iret弹出来的时候干的事情", "但对于ret而言 它只是弹出了EIP", "跳到当时调的那个下一条指令去执行", "对retf而言 除了弹EIP之外", "还会把CS也给弹出来 恢复CS", "实行一种远程跳转的功能", "这是他们处理不同", "当然这里面说到的是", "对于没有特级变化的情况的中断的返回", "对于特权级变化的中断的返回会我们可以看到", "它弹出的东西更多 这些都要恢复", "EIP CS EFLAGE还有 ESP SS", "当这个中断服务例程要返回的时候", "它需要完成这个弹出的工作", "从而可以确保被打断的用户态的程序能够正常地继续执行", "不受到影响", "当然其实这里面还需要注意", "这只是硬件完成的功劳", "如果中断服务例程需要对其它寄存器进行修改的话", "那么在修改之前 你的中断服务例程需要把寄存器保存起来", "在快结束的时候 在iret返回的时候", "需要把寄存器恢复回来 然后再恢复这些寄存器", "从而可以确保 跳回到这个被中断的应用程序时", "程序执行的时候才可以正确执行", "大家可以想像 万一这里面的某一个寄存器的值", "由于中断服务例程的改变发生了改变", "其实你就不能保证我们的应用程序", "能够按照它没打断的那样去继续执行了", "这实际上说的是中断服务例程要完成的工作", "可以看出来 它很重要的是要完成", "整个这个被打断程序的一个状态的保存与恢复", "这是由我们的硬件 这是硬件自动干的", "还有一部分没有描述 我们的软件 我们的操作系统", "在中断服务例程处理过程中需要去保存和恢复的", "这是通过这两块的结合", "才能够确保整个的中断处理过程的正确的执行", "接下来我们再看一下", "通过中断处理来实现所谓的系统调用", "系统调用其实可以理解为一种特殊的中断", "它称之为trap 陷入 或者叫软中断", "有不同的称呼方式", "我们这里面可以看到", "我们的应用程序通过系统调用访问OS的内核服务", "这一段按照它的实现来说", "应该属lab5的内容", "直到有了用户态的进程之后", "才会通过系统调用来获得OS的服务", "但是这里面给大家做个简单的介绍", "因为从具体的实践上来说", "系统调用的这个机制的建立 和我们中断机制的建立", "其实是很接近的 基本上没什么区别", "只有一点微小的差别", "在实践上面需要考虑 需要如何指定中断", "如何完成从用户态到内核态的切换", "以及从内核态回到用户态去", "这一块有些特殊的一些方法", "或者是你通过一种特殊的指令", "SYSENTER或者SYSEXIT", "这种特殊的新的一些机器指令可以完成相应的功劳", "我们在uCore用的还是传统的嵌入的方式", "比如说int 80", "这种通过软中断的方式来完成系统调用", "但是为了完成系统调用", "你需要在建立IDT 中断描述符表的时候", "要对此要特殊考虑", "这跟其他的中断的处理不太一样", "因为这里面很明确的指出了是从用户态执行int80", "或者int 某一个数能够切换到内核态", "它有一个从低优先级到高优先级的转变", "这个机制需要我们在IDT表里面", "给它设置好相应的权限才能够完成这种转变", "好 那我们可以看到", "后面的demo也会给大家做进一步的讲解", "这是相关的一些参考资料", "那我们这里面大量的出现的这个", "IA-32 Architectures Software Developer's Manual", "这是一个Intel英文的文档 很详细", "但是也比较琐碎", "也希望大家有时间的话", "可以去仔细看一看", "相信对你这个代码的理解会有更深入的一个掌握", "好 那我们最后来小结一下", "我们可以看到", "在Lab 1里面我们介绍到其实很多还都是基本的知识", "还没有真正讲代码", "那我们后面在demo会给大家做一个代码的讲解", "可以看到 我们需要去理解保护模式 段机制", "从而可以知道我们的uCore操作系统启动之后", "处于一种什么样的运行状态", "它怎么被我们的Bootloader给加载到内存当中去的", "第二个 操作系统中它怎么来完成函数调用关系", "怎么来建立这个函数的调用站", "其实这实际上靠我们的编译器GCC来完成的", "但是我们可以通过一种方法", "在我们Lab 1里面需要能够把这个", "GCC建立的调用栈给展示出来", "展示出来之后 便于我们后续的", "对这个出现错误的时候 或者说对它进行一些更深入的理解", "知道函数调用怎么产生的", "它为了完成某个事情 它调用了多少函数", "形成了怎么一个调用关系", "这实际上是说C函数调用是需要去了解的", "另外 我们也知道操作系统用到很多的一些特权指令", "而这些特权指令或者机器指令呢", "没法用C语言来表述", "为此可以用汇编语言 或者用内联汇编", "在C的文件里面嵌入一些汇编", "更简洁的实现一些特定的功能", "比如说加载页表 加载全局描述符表 加载中断描述符表等等", "这些都可以通过内联汇编来实现", "为此给大家介绍了一下内联汇编大致的含义", "使得大家在阅读这个uCore代码", "特别是碰到内联汇编的时候不会感到陌生", "知道它大致的一个含义", "最后给大家介绍一下关于X86下面的中断处理机制", "这也是我们Lab 1里面一个很重要的环节", "知道怎么中断建立的", "一个外设产生的一个中断", "或者应用程序产生的异常等等", "那我们应该有一套机制能够应对这种情况", "能够及时的响应这种情况", "正确的响应这个外设的请求", "或者是说能够及时的处理这些异常 错误的状态", "这都是我们操作系统去完成的功能", "所以在这里面呢", "给大家做了一个简单的介绍", "看看在X86硬件情况下", "怎么能有效的去对它进行管理", "好 这也是我们Lab 1的基本知识的部分", "谢谢大家"]}, {"name": "", "block_id": "a4dab9544f1342a0b6322b4bee733c9e", "text": ["那接下来我们会把这里面", "涉及到的一些比较关键的", "一些流程和关键的数据结构呢", "给大家做一个介绍", "流程一开始一样的", "就是我们要完成初始化工作", "那在lab3开始之前", "我们lab1 lab2已经有一个", "很重要的一系列的初始化", "比如涉及到的物理内存的初始化", "这是我们在lab1和lab2里面", "其实已经碰到了", "第二是中断初始化和IDT初始化", "这一块其实也是在lab1和lab2里面", "也都会相应的一个实现 那这个呢", "其实还是在给我们lab3打基础", "并没有涉及到lab3的一些功能", "如果要实现lab3的功能", "我们需要还做进一步初始化", "特别是这个swap_init这一块", "还有vmm_init", "那这两块 swap主要是说", "假设我能够读写硬盘之后", "我怎么能够去建立交换分区", "从而可以使得我们把一些页", "可以写入到我们的硬盘的", "特定的分区里面去", "或者从这个分区里面", "把这个对应的页给读进来", "这个就是叫swap这一块", "它要完成的工作", "它要完成对以页为单位的读写", "对硬盘的读写", "第二个呢vmm_init这一块是干什么呢", "就是我们前面说到的", "你要搭好这个环境来进行检测", "假设你前面已经完成了", "中断的异常初始化", "你已经完成了这个页替换算法", "完成了这个swap的这个读写", "那么在vmm_init里面", "它又把这个模拟环境建好", "那我先要分配大约4个", "假如说举个例子4个物理页", "但我这里面存在6 7或者8", "更多的虚拟页", "这种情况下我访问虚拟页", "还能够正常的工作 那怎么来完成", "就需要前面建好的中断机制", "swap机制 还有你这个页替换算法", "都能够正常工作之后呢", "才能确保这个vmm_init里面", "才能够完成相应的检测", "这里面就是建立这个模拟环境", "进行测试这就是vmm_init里面", "重点要完成的工作", "好 那在检查的时候呢", "这里面有两块需要注意的是", "在vmm_init里面它要检查", "我们说要搭好虚拟那一套", "就是使用环境", "这里面有个check_vmm和check_vma", "后面会讲到这个mm和vma", "是关键两个数据结构", "会给大家做一个介绍", "第二个呢是要check_pgfault", "就看你这个刚才说那个", "假设你产生了缺页异常之后", "你能否正确的进行响应和处理", "这一块就是这两块是说", "要完成相应的检查", "当然你只有在", "正确建立好了vma和page fault", "以及mm这个结构之后", "才能够完成", "我们再看看这个vma这个结构", "什么叫vma 叫virtual memory area", "简称叫vma", "其实这个词我们是从Linux里面来的", "跟它是一致的 vma这个结构", "vma结构重点是描述什么呢", "它描述了就是一个一个的", "合法的内存块的一个空间", "那么这一个一个合法的内存块空间呢", "可以说我们可以用来形成一个", "应用程序的一个大的应用空间", "合法使用的应用空间", "所以说呢一个一个相对离散的", "用户空间块", "那其实就是形成了一个list", "也用到我们前面在lab0讲到的一个", "list一个结构", "来把这些离散的空间给管理起来", "然后呢还有一个什么呢", "就是它有一个总的一个头", "就是说一个 假设用户进程", "我们这里做实验 还没有用户进程", "假设用户一个进程", "它需要把所有空间给管起来", "它有自己的页表", "那页表的相关信息", "总体的信息是放在一个所谓的mm（即指mm_struct）", "这么一个结构里面有vm_mm", "这个结构里面等于是它一个根", "这个根下面有一堆", "有一个list 这个list就是", "来表述了不同的分离的", "这个合法的内存 这里什么叫合法", "所谓合法就是说我们的应用程序", "我们跑这个程序可以去访问它", "访问它肯定是可以得到一个反馈", "可以正常读或者写的", "无论这个页对应的内存页", "是在我们内存中", "还是在我们硬盘里面 无所谓", "它是透明的 对我们应用程序来说", "对我们访问者来说是透明的", "这一点是虚存的很重要的一个概念", "第二个是mm这个struct", "这个是一个总述 它这里面呢是建立", "刚才说到的一个总的信息", "比如说对于一个应用程序来说", "它有它自己的页表", "页表起始地址在什么地方", "以及它映射了多少块", "这个vma这个结构等等", "还有呢就是可能很重要一点", "就是它如果说是需要", "去做一些查找工作的话", "就是它有一个排序", "对这里面地址空间有个排序", "可以便于后续去查找", "当一个应用程序", "访问一个内存地址之后", "这个地址到底处于哪个vma", "那么它有一个排序", "这是一个所谓的mmap_list这么一个结构", "这个结构和前面vma里面那个list", "形成了整个一个链表", "那这里面呢还有一个sm_priv", "这个是和swap机制是建立了联系", "可以看到这个是和我们", "后面会讲到swap manager", "就是说专门管理", "怎么去有效去把一个页", "给写到我们硬盘中或者读进来", "那这个就是跟它建立一个link", "那我们可以看到当vma和mm", "这两个结构对应的", "全局变量建立好之后呢", "我们就可以完成检查", "来看你这个vma结构", "就是所谓描述合法虚空间", "是否是正确工作的", "这是用什么的", "就是check _vma_ struct", "这个函数里面有一系列的检测", "它可以看到它有创建mm_struct", "创建vma_struct", "然后再塞入一系列测试数据", "模拟出来使用者的一个虚拟环境", "虚拟内存环境", "然后最后呢通过一系列的assert来检查", "应该当插入做完这个操作之后", "应该是具有什么样的值", "这里面有一系列的find", "来确保你是对的", "你整个结构建立是正确的", "那这是建立一个合法的", "虚拟内存空间的一个检查工作", "好 假设我们已经建立好了说有了mm", "有了vma 那其实可以描述", "描述一个应用程序", "或者是一个使用者", "它所需要的一个", "合法的虚拟的内存空间", "那么我们有了这个信息之后", "我们看看操作系统怎么去应对它", "可以看着这里面", "总体上有个mm_struct", "它会形成一个list双向链表", "双向链表由一系列的vma组成", "每一个vma表述了这个使用者", "所用到的一块虚拟的连续空间", "好 这虚拟连续空间", "所有的空间都应该是合法使用的", "就是我可以正常去做读或者写", "这是合法的 所谓合法那也意味着", "其实你这个里面描述的虚地址", "那么通过我们这个页表机制", "你们有页表", "我们在lab2里面不是建立好页表了吗", "那所有这个地址", "那么都应该在这个页表项里面", "有对应的映射关系", "它是以页为单位的映射关系", "好 有这个映射关系之后呢", "我们就可以来完成从一级页表", "到二级页表的一个转换 然后找到", "可以找到对应这个物理地址空间", "那个物理页帧就可以找着了", "也就是说这里面vma一个结构", "就是一个连续地址空间这么一大块", "其实可能映射到在这里面是", "多块离散的这个物理页帧", "这是通过我们页表机制", "来完成这个映射的", "那在这里面还会出现什么其它情况呢", "有可能 由于我们的给一开始", "给这个使用者分配这个虚拟空间", "虚拟空间呢超过了我们物理空间", "比如说在这里面只有1 2 3 4 5", "只有5个物理页帧", "但其实我们给它分了7个", "7个虚拟页 分了7个虚拟页", "那很明显一定会有两个虚拟页", "它没有对应的物理页帧", "那么如果访问到这两个虚拟页", "会出现什么情况呢", "很明显在这个里面", "应该说在我们实验里面会涉及到", "在二级页表里面它会什么", "它会没有对应映射关系", "一旦没有对应映射关系", "会出现什么现象呢", "一旦我们的使用者访问了", "某一个没有对应的映射关系的", "一个虚拟页的一个地址", "会出现什么情况", "大家考虑一下这个问题", "那其实就会产生缺页异常 OK", "一旦产生缺页异常就需要我们后续", "我们后面讲到这个缺页异常", "怎么处理啊", "一旦你建立好所谓do_pgfault", "这么一个机制", "也意味着你可以正确处理", "当一个合法的虚地址不存在的时候", "我怎么能够把这个映射关系建立好", "没有对应物理内存对应的时候", "需要把映射关系建立好", "怎么来检查正确性", "这有个check_pgfault", "在这里面一开始是完成", "对这个虚拟环境的建立", "虚拟内存环境的一个建立", "OK 建立完之后", "那也意味着当前访问到的", "虚拟内存是合法的", "因为vma里面有相应的表示", "也就是说 在这个合法区域里面", "虚拟内存可以进行正常读或者写操作", "这里面就是完成了相应的读写操作", "但是由于它没有建立", "相应的映射关系", "所以说一旦执行操作的时候", "读写操作的时候", "其实会产生缺页异常", "一旦你能够正确实现缺页异常", "那么这一部分的工作", "最后这个assert是可以得到确认的", "也就这句话是可以过的", "这个语句过了之后呢", "那基本上证明你的工作是做对了", "那么这里面会有一个", "打印你这个do_pgfault是成功的"]}, {"name": "", "block_id": "f326580069f6480dbddb232fbfba36e6", "text": ["接下来我们讨论", "全局置换算法当中的缺页率算法", "那缺页率算法呢", "实际上它是依据缺页之间的间隔", "来调整我哪些页面放到内存里头", "哪些页面被置换", "在具体说明缺页率算法之前", "我们需要对缺页率", "给出一个准确的定义", "通常情况下我们理解的缺页率", "是缺页的次数和访存次数之间的", "一个比值 这个比值实际上", "在我们缺页率算法里用的时候", "它比较不好把握 那我们更多的", "会用缺页平均时间间隔的倒数", "这个来作为我们缺页率", "也就是说两次缺页之间", "它有个间隔 这个间隔可能长可能短", "那我们在这取它的平均值", "然后给倒数作为它缺页率", "好 那缺页率受哪些因素的影响呢", "影响缺页率的因素有这样一些", "我用的置换算法", "然后我给进程分配的物理页面数", "这个页面的大小", "以及与我在实现我程序的时候", "我所用的方法", "比如说像前边说的 我的局部性", "跟我的实验方法有关系一样的", "这几个因素里头", "我们目前能控制的是置换算法", "我们希望通过置换算法的选择", "来影响这个缺页率", "具体的做法是这样的", "说我们的缺页率会随着分配给", "进程的物理页面数的增加而降低", "物理页面数越少 缺页率会越高", "那我们的缺页率算法的思路", "是什么样子呢", "是说我通过调节常驻集的大小", "这个调节过程当中呢", "会使得缺页率有变化", "我去观测它这个变化", "让它的缺页率保持在一定的范围里头", "那具体说起来怎么保持呢", "如果说缺页率过高 那这时候呢", "明显是我的分配给它的", "物理页面数比较少", "好 那在这我就增加它的物理页面数", "使得这条线能够回到下边来", "好 然后还有一种情况呢", "是说我往里加 那不会越加越多吗", "那缺页率会低", "低到一定程度之后", "我的并发度就会降低", "然后我的CPU的利用效率也会下降", "好 那这时候我会增加第二条", "缺页率过低的时候 我减少常驻集", "这时候呢把一些页面给置换出去", "那这样的话我的缺页率", "就会回到一个合理的范围里头", "那这是我们在这里", "缺页率置换算法它的基本思路", "那它如何来实现呢 它是这样来做的", "访存的时候我们去设置引用标志位", "这和我们前边的", "局部置换算法是一样的", "然后不同的地方是在于", "出现缺页的时候的处理", "出现缺页的时候", "我就计算上一次缺页的时间", "和当前这个时间", "也就是这一次缺页的时间", "它们之间的间隔", "根据这个间隔的大小的不同", "我来做不同的处理", "这个大小的不同实际上就是对应着", "我们刚才说到的", "缺页率置换算法里头的上界和下界", "好 在这里头我们有一个常量T", "如果说这两个间隔是大于T的", "也就是说这一段时间隔的比较长", "这表示什么意思", "这表示我这里头缺页比较少", "那对于这种情况我就会把", "在这一段时间没有引用的这些页面", "我就把它置换出去", "这样的话我就是减少常驻集的大小", "就相当于缺页率比较低", "然后我把这些不用的页面", "我就把它置换出去", "这样我可以", "把它用到更有意义的地方", "另一种情况是小", "如果说这个缺页的间隔", "小于这个时间T 那这时候我认为", "这个缺页率是比较高的 那这时候呢", "我增加它的常驻集的大小", "所谓增加怎么办呢", "就是把你缺失的那一页", "放到常驻集里头 那这样一来的话", "我们就实现了我们这里所说的", "缺页率置换算法", "那具体说起来呢", "我们还是通过一个实例", "来给出它到底是如何工作的", "在这假定这个窗口是2", "这和我们刚才说的", "工作集里的那个窗口 然后我们在", "每次访问存储单元的时候", "相当于正常访问的时候", "你就直接访问做标记", "缺页的时候我们来看它怎么处理", "那首先第一次出现缺页", "那这第一次没有以前了", "那这时候直接往里加", "然后接着往下访问", "C不出现缺页 正常访问 你做修改", "访问D也是一样的", "在访问B的时候出现了缺页", "那这个时候呢 时间间隔是3", "大于我们的2", "那这时候我们说大于2的话", "我就需要把在这一段时间里头", "没有访问过的页面把它剔除出去", "那这时候我们看", "在这里头没有访问过的", "这2里头访问的是哪", "C和D 只把C和D留下", "那这时候它就变成是", "加上你刚才缺的这页B", "就变成这个样子了", "剩下的A和E就被置换出去了", "在访问C的时候是正常的", "在访问E的时候又出现缺页", "那这个时候这个间隔是2", "那小于等于我们刚才这个值", "我直接加上 再访问C是正常的", "然后再访问E也是正常的", "再访问A的时候 它又出现缺页了", "那这个缺页的时候呢 我们再来看", "在这里头我要把哪些留下", "我在这一段时间里头访问过的", "这里头就相当于是C E A这三种", "这是目前这种情况", "那实际上在这里头呢", "再来访问D又缺页", "这两个间隔比较小", "我直接把它加进来 那到这个地方呢", "我们缺页率算法就算是说清楚了", "那实际上我们看到", "在这个执行的过程当中", "进程驻留在内存里面的", "页面数是有变化的", "那这就是我们的常驻集的大小", "在缺页率置换算法里", "它会自动做调节", "你比如说在这段时间里头", "我是有四个页面", "那分配给它的物理页面数就是四", "然后在这一段时间里头呢", "它是只有三个", "在这一段时间里呢 又是四个", "那到这变成三个", "这样的话每一个进程", "它的物理页面数是在", "整个运行过程当中动态调节的", "某种角度上来讲", "我们这个算法就是在逼近", "我们刚才前边说的工作集", "那个变化的那条曲线", "我们希望它尽可能的接近", "同时我又把这开销降下去", "那这时候缺页率算法", "和前边的工作集算法的区别在哪", "区别在于原来你去看", "我淘汰哪一个的时候", "我是在每一次访问的时候", "来做这件事情", "那这个开销太大了 现在怎么办呢", "在中间你访问的时候", "只要间隔足够大", "那这时候我就认为这是需要加进去的", "只是间隔大到一定程度之后", "我才认为那里头有你不用的", "我把它淘汰一次", "这样的话我就把置换这件事情", "放到缺页中断里头来完成", "这和我们局部置换算法又一致了", "这时候它的开销也就降下来了", "好 这是我们说到的缺页率置换算法"]}, {"name": "", "block_id": "b80fa0406afd4da9be0f9d9eaf526cd1", "text": ["下面我们来讨论实时和多处理机调度", "实时调度呢是对时间有要求的调度算法", "而多处理机调度呢", "是指在有多个处理机的系统里", "它的调度算法", "那在这里 我们只能对它", "做一个简要的讨论", "实时操作系统是指", "它的正确性依赖于时间", "和功能两方面的操作系统", "也就说你操作系统实践", "它不仅仅是要求功能", "而且要求在指定的时间内", "完成相应的功能", "好 实时系统呢", "它的性能指标要求呢", "就是时间约束的及时性", "也就相当于", "我必须在约定的时间内", "完成约定的工作", "速度和平均性能相对来说就不重要了", "那在这里头呢", "它最显著的特征是什么呢", "它最显著特征是在于", "要求时间约束的可预测性", "也就说我必须知道在什么情况下", "我的这些时间约束是能够达到的", "那在说调度算法之前呢", "我们首先来定义一下实时任务", "任务是指我要做的一件事情", "比如说计算 读写文件", "或者说信息传递", "那对于时间的要求呢", "就是它的属性", "它有时间的参数 在什么时间完成", "然后它要占用哪些资源", "这是任务的相关属性", "那这个属性", "我们可以用这样一个图示来表示", "首先在一个时刻发出任务请求", "好 这时候呢我要来", "由操作系统来做这件事情", "然后呢 还有一个呢就是", "操作系统的执行时间", "我要来处理这个任务的时候", "它需要多长时间", "然后再有一个就是截止时间", "截止时间呢 有准确的时刻", "和从请求到截止中间这个长度", "那分别是相对截止时间", "和绝对截止时间", "好 这是一个实时任务它的要求", "然后通常情况下我们在实时系统里呢", "它是处理周期性这种类似的任务", "这叫周期实时任务", "那对于周期实时任务呢", "我们可以这样来描述", "除了我在这里头有一个请求时间", "截止时间和它的长度之外", "那还有一个就是它的规律性的重复", "那么有了这个规律性的重复之后呢", "这件事情我们就会定义这样几个参数", "一个是周期 它的这个间隔", "第一次请求到第二次请求", "然后它的执行时间", "在这里呢要求是你最大的执行时间", "因为中间有可能会快", "如果你要想保证实时的话", "你必须保证最坏的情况它能算出来", "然后再有一个呢就是使用率", "我这一块使用", "占我整个CPU时间长度来讲", "它能占多大比例", "那最好是100%，", "但实际上100% 很难保证它的实时性", "那我多少能保证的", "这是其中一个重要指标", "好 然后在这种情况下", "我们对满足实时要求呢", "又把它按照要求的强烈程度不同", "分成硬实时和软实时", "硬实时是指", "错过这个时间截止实现", "那么这时候呢它就会有灾难性", "或者非常严重的后果", "所以这时候 对系统的要求是", "必须验证 在最坏的情况下", "能够满足这个实现的要求", "而软实时呢", "是指我系统通常情况下", "能够满足任务的实现", "如果不满足的话", "系统可以降级提供服务", "那这时候呢 要求系统", "尽量保证满足系统任务的实现", "但不是必须", "好 那么我们在实时的系统上", "要求系统周期性完成一系列的", "周期性的任务", "好 在这种情况下", "我们来定义可调度性", "也就相当于我的调度算法", "在什么情况下", "它是能够满足实现的要求", "可调度表示一个实时系统", "它能够满足任务的实现要求", "那可调度系统呢", "我们可以用这样一个图来表述", "说我有三个周期性的任务", "它们出现的频率", "和执行时间是各不相同的", "那现在的问题是", "在这个系统里头", "执行这样三类周期性的任务", "它可调度吗", "它可以满足这个实现的要求吗", "好 那如何来判断这个呢", "我就需要确定一个任务的执行持续", "如果说你能给出一个任务的执行持续", "满足所有的任务对实现的要求", "那么这时候呢", "这个系统就是可调度的", "那这样一来我在这里头", "给了这个任务之后", "我如何能知道", "它能不能满足这个可调度性的要求呢", "那这时候就是我们这里说的调度算法", "那在这儿呢我们有两类", "一类是静态 一类是动态", "静态是指 我事先把执行顺序排出来", "然后你就照这个调度就行了", "我可以从理论上保证", "我一定能够满足你的要求", "另一种呢动态", "动态呢我没有办法事先给出你来", "那这时候执行的过程当中我来给", "那这时候呢 执行的过程当中", "我也需要保证", "我最后能不能达到它的要求", "好 那对这两个算法呢", "我们做一个简要的介绍", "一个呢是静态的调度算法", "那叫做速率单调调度算法", "它的做法是什么呢", "它根据你这个任务的周期", "来安排它的优先级", "频率越高 周期越短的", "优先级越高", "然后调度的时候呢是", "周期越短的先执行", "周期越长的后执行", "那你说这个调度算法好像很简单", "实际上它麻烦的地方在哪呢", "麻烦的地方在于", "我这个系统里到底", "执行多少任务的时候 它是可调度的", "好 那实际上呢我们在这里呢", "你有相关的文献可以证明", "你在一定的使用率的情况下", "速率单调调度算法", "是可以满足可调度性要求的", "好 相关的证明呢", "大家可以下去之后看相关的文献", "第二种呢是动态调度算法", "那这里是最早截止时间优先", "那它的思路呢也很简单", "告诉你说 我截止时间越早的", "我优先级越高", "那后面已经请求的这几个任务", "到底哪一个的截止时间最早", "那我先执行最早的", "好 然后呢执行", "截止时间最早的任务", "那这个算法就清楚了", "好 那这时候也有同样的问题", "我在什么样的情况下", "我有多少个周期性任务的时候", "动态调度算法是可调度的", "那这些问题呢我都只能是在这里提出", "详细的内容", "希望有兴趣的同学", "下去之后阅读相关的文献", "多处理机调度是指", "在有多个处理器的系统当中", "它的调度算法", "那多处理器调度呢", "它的特征有这样几条", "首先第一个 它是针对", "多个处理机组成的系统", "然后在这上头呢", "一条系统总线上连了多个物理的CPU", "每个CPU里 可能有多个逻辑的核", "然后在这里头", "我们来做它的调度算法", "那这个调度算法", "可以在各个处理器之间呢", "实现负载共享", "好 那么我们现在", "用的最多的一类系统呢", "是对称多处理机系统", "在对称多处理机系统上的调度算法呢", "通常有这样一些特点", "一个是说每个处理机", "有自己的调度程序", "各自进行调度", "然后它们之间", "访问共享的资源的时候需要同步", "实际上对于多处理机调度来说", "同步是其中很大的一个问题", "多处理机调度算法", "其中很重要一个问题就是进程分配", "我们把一个进程", "到底放到哪个处理机上运行", "那在这里呢分配的办法有两类", "一类叫做静态进程分配", "那么这时候呢", "进程是从一开始执行", "就把它分配到一个固定的CPU上运行", "一直到它结束", "在这儿中间呢它不会切换", "好 对于这种情况呢", "每个处理机呢有自己的队列", "也就相当于我在起头的时候有一个分配", "然后就变成是一个单处理机的", "系统上的调度算法了", "好 这时候呢相对来说它的开销比较小", "因为每一个进程在调度的时候呢", "只需要管自己一个CPU", "而且进程分配给它之后", "它也不会再变了", "好 那这时候呢可能出现的问题是", "各个处理机它的繁忙程度会不均衡", "有可能你分配到某个处理机上", "里头的任务负载比较重", "那它就会很繁忙", "而在另外一个处理机上", "它的负载比较轻", "那这时候呢它就可能很空闲", "好 那你说这种做法不是很好", "那还有一类呢就是动态分配", "那么进程并不一定", "在某一个处理机上", "从头到尾一直在上面执行", "那它可以在中间的时候呢进行切换", "到任意的空闲处理机上运行", "这种做法呢", "它要求各个处理机共享一个就绪队列", "那这样的话", "以便于我能从一个切到另一个", "这就变成各个处理器共享的资源了", "在这种情况下", "你对它的访问就是需要进行同步了", "好 那样一来的话", "调度的开销就比较大", "因为我每一次选择的时候", "我都要去指定它到底在哪个处理机上", "这时候呢它的好处是", "我可以实现负载的均衡", "所以在我们实际系统当中呢", "这两种做法呢都是有采用的", "好 这是我们对多处理机调度的", "一个简要的介绍"]}, {"name": "", "block_id": "4896244292074daca5c92a37a06ff478", "text": ["各位同学大家好", "今天给大家介绍一下lab8", "也是我们最后一个实验 文件系统", "那这主要包含以下几部分", "包括总体介绍", "以及对ucore文件系统架构的一个描述", "还有就是simple file system", "一个具体文件系统的一个分析", "以及virtual file system", "就是虚拟文件系统的一个", "展开的一个分析", "还有涉及到就是", "对I/O设备接口的描述", "然后最后对整个执行流程做一个概述", "通过这个描述呢", "使得大家能够对", "我们lab8要完成的实验", "有更清楚的了解", "这是这次实验的大致内容", "首先我们看一下总体介绍这一部分", "其实lab8呢 主要是说", "怎么去有效把硬盘里面的数据", "进行读或者写", "那这个读写呢", "如果说直接对硬盘数据进行访问", "很明显 它是操作繁琐", "不具有可移植性 也不简便", "为此 我们操作系统提出了", "一系列的抽象", "来简化对上层应用", "它的一个访问", "这里面有哪些抽象呢", "我们可以看看 有文件", "文件就是 大家知道", "我们可以把磁盘中的数据呢", "以文件的形式来表示出来", "从而可以方便地进行读写", "那么如果文件比较多的情况下呢", "我们可以组织成目录", "所以每个目录项呢就是一个文件", "还有呢就是什么呢 索引节点", "那文件和目录呢", "是给我们应用程序看到一个抽象", "那对于我们底层的实现呢", "我们需要考虑到索引节点", "它是一个真实的", "对硬盘上文件的一个具体描述", "安装点呢 是需要把我们文件系统", "放到一个地方", "使得我们可以从这个地方作为起始点", "来访问这个文件系统中所包含的文件", "这是文件系统四个抽象", "那有这个抽象之后还不够", "我们需要有相应", "针对这些抽象的一些操作", "比如说针对文件有什么呢", "打开 关闭文件 以及读 写文件", "对应目录项也是一样的", "目录项是目录的组成部分", "这里面会涉及到打开目录", "以及读取目录中的目录项", "等一系列的操作", "对索引节点而言", "我们其实需要知道的是", "一个具体的文件", "它对应到磁盘中的哪些数据", "这就是通过索引节点", "来把磁盘中的数据", "和应用程序能看到的那个文件呢", "建立起一个对应关系", "这是索引节点这一块", "安装点呢也是一样的", "它会涉及到 你要安装一个文件系统", "以及要卸载一个文件系统", "那就是有mount unmount这两个操作", "那么这些操作呢", "它组成了我们文件系统的", "主要的实现部分", "好 我们可以看看", "这个呢可以理解为是", "我们ucore文件系统的一个大致组成", "可以看到确实它涉及的面比较多", "从底层的存储的I/O设备", "以及具体文件系统", "比如说我们后面会讲到的", "simple file system", "还有呢虚拟文件系统", "它可以抽象出文件系统的", "一些共性的东西", "形成针对不同类型的", "文件系统的一个接口", "可以更方便地给我们上层系统调用", "提供一个进一步的文件访问接口", "使得我们用户态程序", "通过一个C库", "可以很方便地对硬盘中的数据", "进行读写操作", "那可以看出来", "这是文件系统一个大致一个概貌", "有用户态和内核态两大部分", "这也是为什么它叫文件系统", "而不是叫文件子系统", "因为我们知道在操作系统里面", "有很多子系统", "我们说有进程管理子系统", "内存管理子系统", "但只有文件这一块呢叫文件系统", "这在某种程度上也体现出来", "这个文件系统它本身的一个", "比较复杂这么一个特征", "好 既然我们也知道", "一个文件系统的大致一个组成", "我们可以看看在我们ucorelab中呢", "我们其实在lab8中", "已经按照我们这个初始流程", "idle init", "init之后呢会完成", "对文件系统和磁盘外设的初始化", "因为我们知道 我们需要把数据", "要放在磁盘里面", "我们需要对磁盘进行读写", "所以说这两块 一个是device", "一个是file system", "这两块需要初始化", "这是在我们之前的lab1到lab7中", "没有涉及到的部分", "有了这个初始化之后呢", "我们就可以把我们在硬盘上建立好的", "simple file system", "这个文件系统里面一些程序呢", "放到内存里面来", "可以看到", "然后呢它会变成进程", "去进一步去在用户空间里面执行", "这就是我们在lab8中", "需要让大家能够理解和掌握的", "关于文件系统的一些知识", "好 那我们看看lab8的目标", "第一个目标 你要知道", "我们站在用户的角度", "它怎么能够访问文件系统", "及完成open close read write", "这个怎么操作的", "一个大致了解", "第二个呢 我们需要去了解", "simple file system", "一个基于inode这种结构的", "一种具体文件系统", "它怎么来设计实现的", "在硬盘上怎么组织", "怎么把它读到内存中来", "来完成相应的这些操作", "同时我们还需要理解", "一个文件系统的抽象", "其实我们操作系统有各个层面的抽象", "那么在文件系统里面", "也有一层抽象叫Virtual file system", "通过Virtual file system呢", "它可以给我们应用程序", "提供一个很简洁的一致接口", "不管底下你是一个硬盘", "你还是一个其它的设备", "只要你以文件的形式存在", "那我们都可以通过VFS", "来进行有效的访问", "及我们可以用它来干什么呢", "open close read write OK很简单", "好 我们还需要通过练习", "来完成对文件系统更进一步的了解", "这里面包含两部分", "一部分是说要完成", "读文件操作的一个实现", "就是我们在从应用程序", "发出这个读请求之后", "一直到最后", "从硬盘中把这个数据读进来", "那么整个执行流程中呢", "有一些环节我们留出来空", "希望大家能够填写出来", "你需要去理解整个执行过程", "然后再把相应缺的地方给补上", "第二个呢 是完成基于文件系统的", "执行程序机制的实现", "这和我们进程管理相关", "我们进程管理在do_execve", "这么一个操作里面呢", "它会完成对一个elf格式的", "文件解析和加载 以及运行", "我们可以回忆一下", "在lab5里面我们会完成相应的事情", "那么当时那个实现", "是在内存中完成的", "我们需要把这个文件", "从硬盘中读出来", "那就需要对我们当时文件加载过程", "重新进行扩展", "使得它能够从硬盘", "把这个数据和代码读进来", "并产生进程的一个主体内容", "好 我们再回顾一下lab5的工作", "在lab5中 我们当时是进程创建和执行", "当时呢 在一开始", "我们bootloader就把整个kernel img", "包含了我们的应用程序", "一股脑地加载到我们内存中来", "然后呢后续的ucore呢", "它是在内存中完成了", "对elf格式的文件的读取和加载", "它跟我们的硬盘没有关系", "那这个呢比较简单", "但是我们现在", "假定我们lab8有了文件系统之后呢", "其实这一步就可以从", "我们的硬盘直接读到内存中来", "而不需要一开始", "通过bootloader读取的方式", "那么可以更加灵活地来完成", "对文件的加载和执行的过程", "lab8文件系统呢", "它在整个这个实现中呢", "包含了很多的数据结构和函数调用", "而且它和我们进程 内存", "都有很多关系", "所以相对来说 它的数据结构", "和函数调用关系比较复杂", "其实涉及到好像感觉比较简单", "比如说 实际上就是完成", "硬盘和内存数据一个交换", "它需要从硬盘中读数据", "或者把内存中的数据写回到硬盘中来", "这就是两个它主要干的事情", "但是怎么能够", "很方便地给我们应用程序提供一个接口", "来完成这个工作呢", "这就需要我们文件系统", "整体地来做一个设计和考虑", "为了能够更好理解和分析", "uCorelab8这里面的文件系统呢", "我们可以采取以下一些方法", "比如说 自下而上", "从硬盘往内存这么一个角度来分析", "也可以自上而下 站在用户的角度", "它发出一个请求 这个请求怎么完成的", "最终把这个数据写到硬盘上", "或者是 把数据从硬盘读到内存中来", "这是自上而下", "还有呢我们要理一下关系", "这里面很多数据结构的关系", "实际上体现在数据结构的包含关系", "谁包含了谁", "以及在你访问这个控制流的时候呢", "你要知道谁访问了谁", "采取这种方式呢", "我们可以比较容易地把握", "文件系统整体的一个概貌", "其实我们希望大家能够在头脑中", "浮现出文件系统", "在内核中的一个执行过程", "以及它相应数据结构一幅图形", "而这个图形之后呢", "你去掌握和理解文件系统", "就更加容易一些", "为此我们也采取一种方法", "来进一步地分析这个", "ucore里面文件系统的架构", "以及用户怎么访问文件的", "还有就是内核中跟文件相关的数据结构", "它们之间的关系是什么", "好 我们可以举个简单例子", "我们站在一个比较高的角度", "来看一下文件系统到底怎么回事", "首先 我们在一个硬盘上", "当然这个硬盘是一个虚拟的硬盘", "我们用qemu生成了一个文件", "这个文件就是模拟硬盘的", "整体的一个结构", "在这个结构里面呢", "会有一个具体文件系统 SFS", "那这个文件系统在后面会展开说", "然后有了这个文件系统之后呢", "我们就要实现一系列的层次", "来完成对这个文件系统的一个操作", "比如说它I/O层次", "它能够去通过I/O接口", "来访问这个device 访问这个硬盘", "通过Simple FS呢来读取这个硬盘中", "保存的这个文件系统的结构", "通过VFS呢 给我们上层应用", "提供一层一致的接口", "那么自然它有一个", "file system相关一个system call", "这是第二层", "然后有了这个接口之后呢", "应用程序就可以去", "通过这个文件系统相关的接口", "来从上到下去地执行", "从而完成对这个存储在硬盘中的文件", "或者目录的数据一个访问"]}, {"name": "", "block_id": "75cc936e115d47dfabfd440ab3009c3e", "text": ["今天我们来介绍处理机调度", "处理机调度呢", "是计算机操作系统当中", "用来管理处理机执行能力的", "这一部分资源的功能", "那在这里头呢 我们首先会涉及到", "处理机调度它到底都要干些什么", "这是它的基本概念", "然后会说处理机调度的调度算法", "那在这里头调度算法呢", "我们有单处理机的", "那这时候呢 它只有一个CPU", "有实时调度算法", "这些调度算法是有更强的时间要求", "有多处理机调度算法", "那这时候 我们调度的时候", "更多的考虑是有多个CPU", "它们之间如何来协调的问题", "那今天呢我们首先来介绍", "处理机调度的基本概念", "那在在前面呢我们讲过了进程切换", "进程切换呢实际上就是", "CPU资源的当前占用者的一种切换", "它通过这种切换", "实现CPU资源的时分复用", "那具体说起来呢", "我们在前面也讲过", "进程管理里头 进程切换是", "保存当前进程的执行上下文", "放到你的进程控制块里头", "然后恢复下一个进程的执行上下文", "那这时候 我们在前面讲", "这个进程管理里头说到的进程切换", "那这个就和我们这里说到的", "CPU资源的时分复用相关", "那就是我们这里的处理机调度算法", "那这调度算法的功能是什么呢", "是说从就绪队列当中", "挑选出一个进程", "占用CPU进行运行", "也就说挑选下一个执行的进程", "如果你是多处理机的话", "这时候还会有另外一个问题", "就是我从多个可以用的CPU当中", "我要挑选出一个CPU", "给我下一个就绪进程来使用", "这是处理机调度要做的功能", "那对应着处理机调度的呢", "我们有一个调度程序", "这个程序是指 在内核当中", "用来挑选就绪进程的这个函数", "如果说是多处理机的话", "还有负责挑选可用处理机的这个功能", "好 那在这个调度程序里", "要解决什么问题呢", "一个是调度策略", "也就说我依据什么来选下一个进程", "那还有一个呢是调度时机", "也就说我找着一个进程可以运行", "那这时候我在什么时候把它切过去呢", "那这个时机的选择呢也是非常关键的", "下面我们就对此来进行进一步的介绍", "首先我们来说调度时机", "在前面呢我们有一个进程状态模型", "这是我们这里说到的三状态进程模型", "那在这些进程的状态里头呢", "我们操作系统的进程控制", "会来维护当前进程所处的状态", "那我们这个调度", "在什么时候能切换是最合适的呢", "那大家想想 也就是说", "我进到堵塞 我退出", "没有新的进程运行了", "我需要来做这种调度", "那实际情况是什么样呢", "那这个是我们执行调度程序的条件", "第一个是 有进程从运行状态", "切换到等待状态", "这个切换呢是说", "我由于要等待某一个事件", "我现在即使你给我CPU资源", "我也没办法往下算了", "好 它把它放到就绪队列里头", "这样CPU资源就空闲出来", "这时候我可以", "再把一个就绪进程放到CPU上", "让它切换回来 恢复运行", "然后还有一种情况呢是说", "我进程退出了", "那进程退出之后 那收尾", "好 那我这时候CPU资源空出来", "我又可以加载一个进程", "这里所说的这两种情况呢", "是对应着我们的非强占系统", "也就说如果你的CPU资源", "分配给了一个进程", "操作系统不会主动地剥夺", "这个进程对CPU的占有", "那如果说你是一个强占系统", "那么这时候呢", "就可能再出现一种情况", "说我在有中断请求的时候", "或者说有系统调用的时候", "那我会呢在这里", "再把当前这个进程转成就绪状态", "那具体说起来", "我在什么时候会出现这种情况呢", "有两种情况", "一种 如果我们是依据时间来进行调度的", "你分配给你的执行时间已经结束了", "好 这时候呢", "我们的定时会有时钟中断", "这个时钟中断 它的处理", "会导致把当前正在运行进程", "重新放回到就绪队列里头", "然后再去找一个新的进程来运行", "还有一种情况是说", "我有某一个处于等待状态的进程", "它由等待变成了就绪", "而这时候呢它更急迫", "需要来占用CPU", "那也会把抢占", "会把当前正在运行这个进程", "放回到就绪队列当中", "好 这是说到的时机", "基本上是说我们在状态发生变化的时候", "来完成这个调度是比较合适的", "其中某一些状态的变化呢", "时钟中断也正是由于", "以这个调度的原因", "所导致的这个状态切换"]}, {"name": "", "block_id": "62435d4086fe46dc860e6d1802d06f2d", "text": ["下面我们来讨论磁盘调度", "前面我们说了I/O的特点", "I/O的结构和I/O的数据传输", "下面我们举一类", "具体的设备的优化问题", "这就是我们这里的磁盘调度", "在具体讨论磁盘调度之前", "我们有必要讨论一下", "磁盘的工作机理和它的性能参数", "这是一个磁盘的基本结构", "它由若干个盘片和一个磁头组组成", "磁头组上呢", "每一个磁头上有一个读写头", "分别对应着盘片的正反面", "我们可以在这里读写相应的数据", "中间这些盘片", "是围绕着磁盘轴进行旋转的", "在这个旋转的过程当中", "我们要读写的数据", "是分布在各个盘片上的", "这里磁道 柱面和扇区", "这是我们要找的", "每一块数据所在的位置", "你在这里要读写磁盘上的数据", "首先必须移动磁头", "到达指定的位置然后读写", "那我们看到在这里花时间最长的", "是这个磁头的移动", "这就是我们这里的寻道时间", "定位到指定的磁道所需要花的时间", "然后再有一个是旋转延时", "也就是说中间这个盘片", "它是一直在匀速旋转的", "这个旋转不会因为", "我想读的位置不同而有所改变", "所以我们在这里要想找到指定的扇区", "必须是等待它旋转", "那这样一来我们基本上是说", "在这里从当前位置", "旋转到你想要的那个位置", "这中间时间是我们这里的旋转延时", "有了这个之后", "那我们基本可以说", "这个旋转延时基本上是转半圈的情况", "也就是说我在任何一个位置开始", "读到我想要的那个位置", "那通常情况下中间平均的延时", "是要转半圈的时间", "这是磁盘的结构", "和它相应的几个影响参数", "下面我们来具体分析一下", "磁盘I/O它的时间都花在什么地方", "首先第一个是我要读写某个设备", "我要等的这个设备是可以访问的", "等待设备可用这是一段时间", "然后第二个是等待", "我这个设备要想跟它进行交流的话", "DMA通道或者是I/O通道它必须可用", "这是一个时间", "这两个时间基本上", "跟你实际的设备操作关系不大", "然后是寻道时间", "这相当于磁头移到指定的磁道", "然后是旋转延时", "最后我到了指定地方之后", "我还有一个数据读出的时间", "后面这三个时间", "都会有机械动作", "所以我们在这里", "计算这个传输时间的时候", "基本上是把这三个时间加在一起", "这三个时间", "加上前面这个通道的等待时间", "这是我设备忙的状态", "这是我们给出来的传输时间的公式", "这是我最后算出来的访问时间", "它由三个部分组成", "实际上这是我们已经简化过的", "一个是寻道时间就是中间这一段", "然后是旋转延时", "第一个寻道时间", "跟你磁头移动的距离是相关的", "那它花的时间是最大的", "第二个旋转延时", "基本上是说我们转的速度它的倒数", "就是你转一圈的时间", "那我们在这儿", "基本上是平均时间是转一圈的一半", "就是2r分之一", "然后再有一个数据读取的时间", "这是传输时间 这里头这个时间", "它这几个参数是什么意思呢", "就是要读多少个字节", "你这一圈磁道上有多少个比特", "然后你的转速是啥样的", "这三个数rN分之B", "就是你这里头传输的延时", "从这个分析我们可以知道", "我们主要需要优化的是TS", "这个寻道时间", "为了寻道时间的优化", "这就是我们这里磁盘调度所要干的事", "那它通过优化磁盘访问的顺序", "来达到提高磁盘访问性能的目标", "访问顺序如何来影响这个寻道时间呢", "实际上我们有这样几条依据", "第一个寻道是磁盘上最耗费的时间", "所以我们有必要对它进行优化", "如果这时间很短 那优化的空间不大", "那我们就没有必要在这里", "来做这个优化", "然后再有一个我必须在同一个磁盘上", "同时会有多个I/O请求", "如果一个磁盘上只有一个", "那你不管怎么优化", "你都要到指定位置的", "同时有多个我可以调整这个顺序", "就好比说图书馆的管理员要去书库取书", "它同时有多本书要取的时候", "它可以看看这几本分布的位置", "我优化出一条线路来", "如果说你只有一本的话", "那相当于我就直接去 直接回", "没有什么好优化的", "再有一个是随机进行磁盘的I/O请求", "那这时候它的性能是很差的", "基于这样几条", "我们可以通过优化这个顺序", "来优化磁盘的访问性能", "具体说起来呢", "我们在这里给出这样几种优化算法", "第一种是FIFO先进先出", "它就是按照请求的顺序", "来顺序的进行处理", "这个算法它是公平的", "但是它在很多情况下", "它的性能是不好的", "接近于你的随机访问", "那我们用一个例子来说", "它是在怎么访问", "在这个例子给了一个访问的序列", "并且约定了我磁头当前的位置", "来按照FIFO的做法", "看看它总共磁头移动的距离是多少", "我们要优化的目标", "就是这个移动的距离", "当前位置是53", "我第一个是98", "第一个要移动53到98", "这时候移动了45个单位的距离", "这样的话一个一个移动下去", "到最后", "到这个地方我到67", "我总共加在一起", "它总和是640个单位", "那我们看到这来回左移右移", "实际上走了很多的冤枉路", "这种做法呢它的性能是很差的", "我们首先想到的第一个优化是什么", "我就近", "离的这后面这一段里", "哪一个最近我按哪一个", "这就是我们下一种做法", "最短服务时间优先", "在这里头呢", "它依据磁头当前的位置", "来找移动最少的那个I/O请求", "所在的位置", "这时候总是找最短寻道时间的", "当前寻道最短的那个", "那我们还是以刚才这个例子来说", "在这个序列里头", "我们仍然是这个序列", "仍然是这个当前位置", "我们看按最短寻道时间优先", "它的结果是啥样的", "我们在这儿53", "离它最近的是哪个 是65", "然后67 最后两个", "然后67之后再往哪", "37是离它最近的", "然后这样一直走下去到最后", "最后到哪 到这个地方 183", "是它最后一个", "这时候236和我们刚才的640", "差不多差了接近3倍", "那这时候我们看到这种做法", "比刚才那个又有了很大的优化", "原因在于刚才那个根本就没有考虑到", "它的位置分布情况", "这个做法是不是还可以优化呢", "那我们再有第三种做法 扫描算法", "它的做法是在一个方向上进行移动", "一直到所有的访问全部完成", "然后直到到达磁头的最后一个磁道", "这种做法呢", "它主要是因为我们在磁盘上", "磁头是两个方向来回移动", "哪些地方会是优待呢", "中间那一部分会是优待", "所以我沿一个方向走到头", "然后再到另一个方向", "这样一来的话", "我换方向之后 再从那头扫回来", "这种做法有点类似于", "我们电梯里的控制算法", "电梯的话", "它是从最顶上到最底下", "然后再从最底下到最顶上", "这是我们这里的扫描算法", "我们用扫描算法再来试一下", "刚才那个序列", "同样的序列 同样的起点", "但这时候起头有一个方向的假定", "我们在这儿", "假定是往编号低的方向走", "这时候我沿路扫到头", "一直有多少个我就扫到那儿", "这样一来的话基本上我转一圈", "是从第一个到最后一个", "200个单位这样的距离", "也就是说极端的情况", "如果说你是从最头上开始", "不管你中间有多少个请求", "它移动的距离就应该是不超过200", "从这个角度来说这个算法呢", "它的性能也是不错的", "在我们这儿看到", "它算出来和我们刚才那个", "最短寻道时间优先的算法", "的结果是一样的", "这种做法它的特点是", "我沿着一个方向走 顺序扫过去", "这个地方我的判断会比较简单", "不像刚才那个", "我需要去找到底哪一个是最近的", "每一次找的时候呢", "都要来挨个去算一遍", "我在这儿沿着一个方向就可以了", "与此同时这种做法有一个问题", "就是在于中间这些磁道", "我会有更好的访问性能", "而两头我到的时间会比较少", "所以在这儿又有一种变化", "叫做循环扫描", "它仅在一个方向进行扫描", "另一个方向呢是直接走到头", "这种做法呢", "它主要的目的是为了提高它的公平性", "那我们看", "刚才说你把从一个方向走到头", "最外头那个地方", "即使没有你要访问的I/O请求", "你也要走到头", "这个实际上是不合算的", "所以在这儿就有一个C-Look", "它和我们刚才说的扫描算法", "唯一的区别就在于", "它只是走到最后一个请求的位置", "它不走到头 然后就折返了", "其它的跟循环扫描算法是一样的", "这样的话它就可以提高它的公平性", "然后在这基础上我们还会再有两种优化", "这就是N步扫描和双队列扫描算法", "N步扫描算法实际上", "想对付的问题是什么呢", "是说由于我在扫描算法里头", "我是考虑后面这些请求", "哪个离我最近", "如果说你总是在当前磁头", "所在位置的边上有请求", "在这个位置的请求就会优先响应", "但这种优先响应", "就会使另外一些请求", "得不到访问的机会", "这就是我们这里的磁头粘着现象", "这时候呢", "我们怎么来解决这个问题呢", "你比如说在这里刚才我们说的", "进程反复请求某一磁道的I/O操作", "它就会长时间的停到这儿", "对其它的后续的请求", "等待延时就会非常长", "为了减少这种某些情况速度很快", "在另外一些情况下性能很差这种情况", "有了N步扫描", "它的做法是什么呢", "它的做法是把磁盘请求", "分成N个子队列", "每次按照先进先出的顺序", "来处理所有的子队列", "也就说子队列我是按照先来后到的顺序", "但是在每一个队列内部我用扫描算法", "这就是我们这里的N步扫描算法", "那这种算法呢又有一个小变种", "就叫双队列扫描算法", "它和前面的做法的区别是在于", "我只分两个队列", "某种角度上讲", "你认为是N步扫描算法的一个简化", "这种简化完了之后呢", "我分成两个队列", "交替使用扫描算法处理每一个队列", "在处理一个队列的时候呢", "当前新到达的请求就放在另外一个", "没有进行处理那个队列里头", "用这种办法呢", "我就让这些请求有一个最长的等待时间", "也就是说当前处理的这些", "处理完了之后我再会去处理新的请求", "从这个角度来讲呢", "我的平均等待时间就会减少", "这是我们对磁盘调度的一个简要介绍"]}, {"name": "", "block_id": "f22be6543e95497fa3de8454e9cde02a", "text": ["下面我们来讨论文件缓存", "和打开文件管理", "文件缓存呢是指", "我们从磁盘上读数据到内存", "甚至于到CPU使用", "中间有多种缓存", "我们先看看 这在哪些地方", "都有可能有缓存", "首先呢我们是在磁盘上有数据", "然后磁盘上通过磁盘控制器", "来完成对磁盘上扇区的读写", "在这个磁盘控制器上头呢", "就有扇区的缓存", "基于这个再往上呢 是内存", "内存里头呢 我们有数据块的缓存", "同时还有一类虚拟磁盘", "用内存虚拟盘", "它用内存来虚拟一个逻辑的磁盘", "然后在这之上呢我们维护了", "每一个打开文件的打开文件表", "打开文件表里头的每一项呢", "对应着我这里的一个文件", "最后是到CPU", "在这里头我们看到 内存 磁盘控制器", "上头都有缓存", "在我们操作系统里讨论的缓存呢", "是在内存当中的数据块缓存", "我们从磁盘上读数据块到内存", "这地方的读呢", "通常情况下是按需进行的", "我有一个read", "在执行read操作的时候呢", "会把相应的一整块读到内存里来", "选择我所需要的", "给相应的进程拿去使用", "而在读的过程当中", "我也可以采取一定的预读机制", "我可以多读几块", "那么这时候呢我们认为", "数据块在使用之后会被缓存", "这种缓存的意思呢 在于说", "日后我可能这一块还会再用到", "如果出现这种情况", "那我就不用再去从磁盘上读了", "在写的时候呢", "也有可能这种写呢", "会被延迟到以后", "也就相当于 我先把它写到", "内存里的缓存里头", "然后后续再有修改的时候呢", "而我事先没有写", "那这样的话 我就可以把两个写", "合并到一起 来往下写", "当然这种你合并之后写呢", "有一种风险 就是可能在你", "前一个写没有进行", "第二个写也没进行的时候", "系统出了故障了", "那么你头一个", "本来认为它已经正常写进去的", "也就可能会丢掉了", "有了这个之后 那我们看", "这个缓存我们怎么来控制", "在这里呢有两种缓存机制", "一种呢是数据块缓存", "我读磁盘上的东西", "我放内存里 我标记这一块", "内存的东西是磁盘的缓存", "以后你要去读磁盘我先查这个地方", "还有一种缓存机制呢是页缓存", "从我们刚才这种讨论", "大家已经感觉到了", "在虚拟存储里头 我们会把", "物理内存不够用的地方", "放到外存里头", "实际上 数据块的缓存呢", "你可以理解为是我把磁盘上的东西", "在内存里做一个反向的缓存", "从这个角度来讲", "这两者之间 有很强的", "关联性和相似性", "所以我们可以把", "这两种机制统一到一起", "具体我们来看一下这两种机制", "首先是磁盘块缓存", "磁盘块缓存呢就是", "它和虚拟存储之间呢", "我们是相互隔离开的", "你可能会有虚拟页的对换", "也有可能进程有文件的读写", "这两个呢在虚拟页这个地方的时候", "它可能会是说", "我在要去置换的时候", "我看是否有相应的缓存", "因为在我们前面讲的", "页面置换算法里头", "有一种情况是 我会往外写", "或者说 从磁盘上读的时候", "我有一部分内容呢", "在内存里头还是有备份的", "对于这种情况 我可以直接从页缓存里", "拿到相应的结果来使用", "而对于读写文件呢", "我可能在内存里有磁盘块", "已经有缓存 我也可以从这里拿出来", "这样一来的话对于这两种情况", "它们在这个磁盘块的", "数据块的缓存这个地方呢", "就可以到合并到一起", "但是前面这地方页缓存多了一级", "然后这个数据块再往下", "到磁盘上文件系统", "这是页缓存 实际上相当于", "它们俩合并地方是在数据块这个地方", "而另一种机制是把它俩统一起来", "这时候大家还记得 我们在前面讲的", "虚拟页式存储吗", "那个地方我可以把虚拟页面", "映射到本地的外存文件当中", "这就是我们这里说的", "逻辑地址空间里的页面", "经过内核的虚拟存储管理机构", "把它映射到物理内存", "或者说把它映射到外存", "这两者之间呢", "它们都是可以存数据的", "所以它可以利用这种方式", "来扩展进程可用的逻辑地址空间", "这时候说我们除了", "把它放在对换区里头", "你也可以认为它是一个文件", "我们可以还对一些可执行文件", "我直接把它映射到", "你的可执行文件里头去", "这种机制呢 实际上就和我们", "这里文件数据块的", "页缓存机制是一致的", "那么这时候呢我可以把这个页面呢", "缓存到别的文件里头", "也就是我们这里一种情况", "有了这种做法之后", "我们就可能反过来提供一种机制", "就是把文件缓存到内存当中", "把你的文件读写呢", "转换成对内存的访问", "这样一来 就可以把", "这两者之间统一起来", "在这种情况下 你在文件访问的时候", "就会导致缺页和相应的", "页面状态的变化", "这是它运用页面缓存的好处", "但是它也会有一个问题", "就是页面置换算法", "我们有一个 说", "给每一个进程分配多少物理页面", "如果是全局置换算法的话", "给整个系统有多少物理页面", "如果说你再把这个", "和磁盘缓存搁在一起的话", "这两者之间的页面数 到底分配多少", "实际上你又多了一个", "需要动态调节的部分", "这时候你需要", "在虚拟存储和页缓存之间", "去协调各自物理内存分配情况", "有了这种机制之后呢", "我们会看到 进程的内存访问", "和文件读写 都会转换成", "我这儿的页缓存", "如果说有 直接在内存里头就行了", "如果没有 再转换下面", "到文件系统里去读写", "这是我们说有了文件系统之后", "我的缓存的做法", "当然你要想维护这一套做法呢", "那你所有打开的文件 在操作系统里", "都必须维护相关的数据结构", "来记录这些缓存的状态", "这就是我们这里的打开文件数据结构", "其中重要的一个内容呢是文件描述符", "打开文件表里的每一项", "就是一个文件描述符所对应的信息", "每一个打开的文件呢", "有一个文件描述符", "这里头呢包含的信息是", "相关的文件指针 文件操作的设置", "以及于对应的目录项的缓存", "这些信息呢 对应过来是", "每个进程 有一个进程的打开文件表", "而整个系统 有一个系统的打开文件表", "并且在这种情况下", "如果说你某一个文件卷", "已经有文件被打开", "那么这时候呢 有打开文件的文件卷", "你就不能被卸载", "这就是为什么在有些情况下", "我把系统里的某个文件卷卸载", "它会不成功的原因", "有了这个之后 我们来看", "前面说到的 文件系统的组织视图", "跟我们打开文件怎么对应起来呢", "在这里头 你打开某一个文件", "就对应着相应的目录项 文件控制块", "和文件的内容 需要在内存当中有缓存", "这一信息呢 在内存当中的记录", "就构成了我们这里的", "系统打开文件表", "这个系统打开文件表里", "有一些内容是 各个进程是不一样的", "那这些不一样的部分", "就构成了我们进程的打开文件表", "而进程打开文件表里呢 共同的部分", "会映射到系统的打开文件表里头", "这样的话两个进程共用的部分呢", "它就在打开文件表里头", "这就是我们这里说到的", "进程打开文件表 和系统打开文件表", "有了这个之后", "接下来我们看打开文件锁", "也就说 有多个进程", "共享同一个文件的时候", "那么这时候呢 对于它们的访问", "就需要协调", "操作系统能够提供一种机制", "就是文件锁", "这种机制呢 分成两种实现策略", "一种是强制 你在访问一个文件的时候", "它根据锁的保持状态和你的访问请求", "来判断是否允许你进行相应的访问", "或者是拒绝", "还有一种做法呢是劝告", "实际上在这儿呢", "它就是在操作系统", "提供相应的一些机制", "使得进程可以查询文件打开", "和锁定的状态", "由进程来决定", "我在这种状态下我怎么做", "一种说我不管你怎么样 我直接访问", "因为我对它的中心状态不关心", "或者说 这个中心状态对我没有影响", "如果有影响 那你就可以决定说", "我延迟一会儿之后", "等相应操作完成了", "我再来进行相应操作", "这样的话 就把打开文件", "访问协调的机制呢", "变成是应用进程自己来协调", "这是关于数据块缓存", "和打开文件维护的讨论"]}, {"name": "", "block_id": "b742a2bbe99242bb947eb5bb1f7f396c", "text": ["下面我们来讨论", "消息队列和共享内存", "这两种进程通讯机制", "首先是消息队列", "消息队列是由操作系统维护的", "以字节序列为基本单位的", "间接通讯机制", "也就是说它是一种间接通讯机制", "肯定是由操作系统维护的", "它通讯的基本单位是字节序列", "这是消息队列的特征", "在这个图示当中", "我们会看到若干个进程", "可以往内核的消息队列里发送消息", "然后另外的进程", "可以从这消息队列里读出消息", "消息是一个最基本的字节序列", "多个消息按先进先出顺序", "构成一个消息队列 标识相同", "实际上是我这个消息队列", "可以构成若干个子队列的特征", "与消息队列相关的", "系统调用有这样几个", "也就是说我消息队列需要有一个创建", "这就是依据你的标识", "来创建或者获取相应的消息队列", "然后有了消息队列之后", "我有两个操作 发送消息和接收消息", "对于消息队列来说 它后边有", "缓冲区的起始位置 缓冲区的大小", "以及我在写的时候它的标识", "而另外一个接收跟它是类似的", "前边的内容都一样", "这多了一个type", "详细的这些参数的含义", "大家可以下去查相关的手册", "还有一个是消息队列的控制", "这指什么意思呢", "我们进程创建和结束的时候", "它所占用的资源都会被释放掉", "进程从创建获取各种资源", "到结束的时候", "这些资源都会被释放掉", "但是消息队列", "是独立于创建它的进程的", "所以一个进程可以创建一个消息队列", "然后这个进程结束了", "但这个系队列", "还可以继续存在下去", "从而你在后续的创建的进程", "可以去读取消息队列的内容", "实现两个生命周期不同的", "进程之间的通讯", "所以在这需要有专门的系统调用", "来完成对消息队列的创建和删除", "接下来的第二种机制呢 是共享内存", "共享内存它是把同一段物理内存区域", "映射到多个进程的地址空间里的", "一种通讯机制", "某种角度上来说", "它应该是一种内存的共享机制", "但我们这里头是", "把它作为通讯来使用的", "这种机制在进程和线程里的情况", "是不一样的", "在线程里头由于同一个进程", "共享相同的地址空间", "如果说你的通讯双方", "是一个进程里的两个线程", "那么这时候呢", "这种共享内存是天然的", "你不需要额外的机制就已经可以了", "而如果是进程", "因为每一个进程有自己的地址空间", "所以在不同的进程之间", "要想做共享内存的话", "你必须显示的去设置一个共享内存段", "然后你才能实现内存的共享", "这种做法它的特点是快速方便", "因为我一个进程写进去", "另一个进程马上就能看得见", "也没有系统调用在这里", "进行用户和内核之间的切换", "它的不足是仅靠共享内存", "你没有办法实现完整的通讯", "你需要加同步机制", "以避免一个进程在写的过程当中", "还没有写完之前", "另一个进程从里头读", "这是共享内存和它相对应的", "共享内存的实现机制", "我们可以用这个图来描述", "两个进程的地址空间各自不同", "中间是物理内存", "我们把一块物理内存区域", "映射到两个进程", "怎么映射呢 就靠两边的页表项", "不同的页表项", "它是在进程地址空间里可以有相同", "或者不同的逻辑地址", "但是它们映射过来的时候", "这一页对应的", "物理内存的地址是相同的", "那这时候呢", "它们就映射到同一页里头了", "这时候在一个进程里写", "在另一个进程里我就可以读", "就可以看到相应内容", "从而实现这个通讯", "所以这种通讯呢 它的速度是最快的", "一头写进去 另一头马上就能看得到", "这种通讯呢", "它也没有系统调用的干预", "不需要数据复制 这也是它快的原因", "它的麻烦是不提供同步", "你需要用其他的机制", "来实现进程之间的", "对共享内存访问的协调", "与共享内存设置相关的", "系统调用有这样几个", "创建共享段", "把共享段映射到", "指定的进程地址空间当中", "取消共享段到进程地址空间的映射", "和共享段的控制", "这几个系统调用", "主要是完成共享关系的建立", "而正常的共享数据的访问", "只需要我们的读写指令就行了", "不需要专门的系统调用", "有了这几个映射关系之后", "我们就可以通过正常的读写指令", "完成两个进程之间的通讯了", "但是为了保证数据的完整性", "我们还需要采用信号量等", "其他的同步机制来协调", "不同进程对共享内存的访问冲突", "避免一个进程往里写的数据还没写完", "另一个进程从里读数据", "从而读到的数据是错误的", "有了这个协调机制之后", "我们就可以完成两个进程之间的", "最快速的信息交流了", "到这个地方为止呢", "我们就讲了四种进程之间的通讯机制", "信号、管道、消息队列和共享内存", "它们都有不同的适用场景", "也有不同的特征", "你比如说有的信息量存的比较少", "但是速度比较快", "有的信息量比较大", "但是前后的协调机制比较复杂", "希望大家下去之后通过实际的例子", "来尝试几种不同通讯机制", "看它们各有什么样的特征", "更有兴趣的同学可以在我们的ucore里", "对这些通讯机制进行实现和完善", "今天的课就上到这里", "下课"]}, {"name": "", "block_id": "d83012d46c7040f2ad37d59884a986b6", "text": ["接下来我们介绍进程控制块", "进程控制块是进程当中的重要信息", "它负责控制", "由操作系统控制和", "管理进程运行的过程", "那进程控制块到底是干什么的", "然后它如何用", "里头到底有些什么样的信息", "我们在这儿呢一一来进行讨论", "进程控制块是管理和控制进程", "运行所需的信息的集合", "那在这些信息里头呢它是有些啥呢", "进程的基本信息你比如说它的ID", "它执行的是哪一个程序", "以及它运行变化的过程", "那就是进程的状态", "那进程控制块呢是", "进程存在的唯一标志", "也就是说我任何一个进程", "只要它创建了它存在了", "它一定有一个", "跟它相对应的进程控制块", "那一个进程结束了", "那它进程控制块呢", "也就必然被操作系统回收", "好那这时候说", "我们这进程块怎么来用呢", "那在创建的时候", "生成该进程的进程控制块", "然后结束的时候", "回收它的进程控制块", "在中间使用的时候呢", "那对进程的所有操作都是", "通过进程控制块来实现的", "那具体进程控制块里都有些什么", "它们是如何组织的呢", "以及于我们在进程在", "执行过程当中它的状态", "到底怎么变化呢", "都和这个进程控制块是密切相关的", "下面我们先来说进程控制块的内容", "进程控制块里的内容呢有标识信息", "然后再一类呢", "就是我多个进程交替运行", "如果你不交替运行的话", "第二条你是不需要保存的", "好交替运行的时候交替的部分", "交替完了之后会被", "另外的进程使用的部分的内容呢", "你都必须保护下来", "那这就是处理机的现场保护", "然后再一些呢就是进程控制的信息", "那这是我们进程在内存当中的印象", "好我们加载的时候呢就是在", "内存当中形成这样一段存储区域", "存储相应的代码和其它的一些内容", "好我们在这里进程控制块里是什么", "就从这里抽出一部分信息", "来放到我的进程控制块里头", "实际上这一块呢", "也是存到内存里的某个位置", "内核当中的", "比如说关键的信息就是", "当前指令指针这个P", "指向的到底是哪个地方", "好第二个是说我在这里头", "函数调用和返回", "当时的栈顶在什么地方", "那这是至关重要的", "然后再有你比如说它的标识信息ID", "然后它的控制信息调度和这里的", "其它寄存器就是你现场保护的时候", "别的进程执行的时候要用到寄存器", "你在这儿都必须保存", "那具体说起来在这里头", "控制信息有些啥呢", "控制信息呢一个是以调度相关的", "那就包括调度的信息", "和它的进程的状态", "因为它依据状态来决定我如何调度", "然后进程之间的通讯信息", "任何一个进程它在执行过程当中", "你一定要跟外界打交道", "比如说我处理不同的数据", "读入不同的数据来进行处理", "如果没有这一条的话", "那这个程序的用处也就很小了", "好然后再一个是存储的信息", "我这个进程占用了哪些存储空间", "那对应的位置是什么样的", "你在用完之后", "你还必须还给操作系统", "好再就是进程占用的资源", "你比如说我打开的文件", "那这些你在结束的时候是要回收的", "以及于我的进程状态的变化体现为", "进程控制块所在的", "各种各样的链表里头", "或者说索引表里头", "对应的这些连接关系", "那在这儿都是通过", "相应的进程队列来实现的", "这是进程控制的信息", "好 那么进程控制块组织呢", "的有多种多样的方式", "你比如说表链表索引", "和各种各样的数据结构都可能会用到", "在我们这里头呢", "我们简单的说两种", "一种是链表", "那一个元素指向下一个元素", "下一个元素再指向下一个", "以同一类型的构成一个链表", "那比如说在这个地方", "那我们有就绪和", "等待两个进程状态的列表", "那这个列表分别", "在这里头实现的是就绪", "有三个这个等待的是三个", "那分别是他们组织成一个链表", "两个不同的链表", "然后第二种呢是说我们可以用索引", "把通过指针指向进程控制块的指针", "放到索引表里头", "那不同的状态的呢", "我构成不同的索引表", "这个刚才说的链表同样的", "我可以用类似的办法来", "组织成索引表", "那我们实际上在操作系统里头呢", "你原来在数据结构当中", "学到的各种各样的数据结构", "在这个地方", "都会在后续里头呢不断得到体现", "好那我们到这儿呢就说清楚了", "进程控制块它是干什么的", "它是如何来用", "以及于里头到底", "都有一些什么样的信息", "那我们这地方介绍呢还都很初步", "那下面通过程序里", "实现里内容的来看", "对进程控制块里头到底准确的", "来说哪个系统里都有一些什么"]}, {"name": "", "block_id": "1efd4dbf8f3b410dad942e88ab896bec", "text": ["下面我们来讨论", "文件描述符这个基本的概念", "文件描述符是指打开的文件", "它在内存当中所维护的相关信息", "首先我们来讨论一下打开文件的过程", "我在读写数据之前", "我必须打开文件", "这是我们通常情况下", "你写的程序里头的文件访问的模式", "打开然后进行读 或者写操作", "完成之后 一个关闭", "我就不再对这个文件进行操作了", "针对于这种模式呢", "在操作系统内核当中", "维护了打开文件的相关信息", "也就是说它会跟踪进程打开的文件", "所谓的跟踪就是在内核当中", "维护了一个打开文件表", "这个文件表里的每一项", "对应一个打开的文件", "这时候我给它一个标识", "就是文件描述符", "也就是说文件描述符", "是打开文件的一个标识", "为什么我不直接用文件的标识呢", "原因在于打开文件的数目和", "你的文件系统里的文件数目", "是有数量级的差别的", "这样的话我可以给它一个", "更简单的标识来方便我们的访问", "文件描述符是操作系统", "在打开文件表中维护的", "打开文件的状态和信息", "这里有些什么样的信息呢", "首先第一个是文件指针", "我们在读写文件的时候", "最后一次读写的位置", "每个进程都维护自己的打开文件指针", "也就相当于我有一个文件", "有多个进程对它进行读写", "在读的时候你的这个指针", "每个进程只是跟自己的指针相关联", "另外的一个进程读写相同的文件", "这时候你的文件指针", "并不随着它的读写而发生改变", "这就是我们这里说的", "每个进程分别维护自己的打开文件指针", "除了文件指针之外", "再有一个是文件打开计数", "这里指的是当前这个", "被打开的文件打开的次数", "记录这个次数的意思是在于", "最后一个进程关闭文件的时候", "那么就可以将这个文件", "从打开文件表当中去除了", "这是打开文件计数", "同时还有就是文件在磁盘上的位置", "这时候我们会把一部分", "磁盘上的文件的内容缓存到内存当中", "所以这时候", "我要记录文件在磁盘上的位置", "你下次再读的时候", "有缓存的这些内容", "我就可以利用内存当中", "缓存的数据让你进行访问", "再有是访问权限", "每个进程访问文件的时候", "它是以什么样的方式来进行访问", "你比如说只读 可读可写", "为了能够通过文件系统", "来实现对文件的访问", "我们有必要来讨论一下", "文件从用户和系统的角度来讲", "它是个什么样的", "这就是我们这里说到的", "文件的用户视图和系统视图", "用户视图是指", "我们用户进程看到的文件是什么样", "这里头呢 文件是持久的数据结构", "这是你应用进程", "我需要读写文件里的数据的时候", "这些数据是有结构的", "这是我们这里想看到的", "但是从系统的角度来讲", "它并不关心这个事", "所以系统提供了一个文件的访问接口", "在这里头呢", "文件变成了一个字节序列了", "当然对这一点的理解", "不同的系统会有一些差别", "在Unix 系统Linux系统 这一类的系统里", "它认为文件内容是字节的序列", "操作系统并不关心", "存储在磁盘上的数据这些数据的格式", "这是你应用进程需要关心的", "这就是我们这里的系统视图", "也就是说它把文件", "视为是数据块的集合", "说到数据块呢 这有两个", "我们访问的数据块和磁盘的扇区", "有关系但是也有区别", "数据块是逻辑的存储单位", "可能由多个扇区组成", "而扇区是物理的存储单元", "数据块的大小和扇区的大小", "可能不一样", "通常情况下是", "几个扇区构成一个数据块", "特别是对于容量比较大的", "这些磁盘来说是这样的", "有了用户的视角和系统的视角", "那这时候它们之间的转换怎么来做呢", "我们先来看一个文件读写的例子", "进程读文件的时候", "它是怎么在做呢", "首先读取你对应的这个内容", "所在的那个数据块", "整块读出来 也就是说磁盘的访问", "它具有这样一个特征", "它的最小访问单位只能是块", "我不能去对块当中的单独的字节", "进行读或者是写", "也就是说你想读出一个字节", "也必须把整块读出来", "你想写一个字节", "也必须把整块重新写", "那这样一来的话", "我在这个地方就是", "读出字节所在的数据块", "然后把其中需要的内容返回给进程", "这是你的读操作", "而进程的写文件操作呢", "它是先读取相应的数据块", "也就是说你要写的那个位置所对应的", "那一块的内容全部读出来", "然后修改相应块当中的对应的内容", "修改完毕之后 把整块写回去", "这是你的写操作 对于这种情况呢", "我们在这里头从用户视图到系统视图", "就有一个转换", "这个转换过程当中的", "一个重要的特征是文件系统当中的操作", "它的基本操作单位是数据块", "有了这个之后", "我们在这里就会有这样一个特征", "你即使只读一个字节", "也需要把整块读出来", "你比如说我这里一个字节", "而一块呢 是4K 那这时候呢", "也就相当于我为了", "读其中千分之零点几的数据", "读写的量实际上是它的上千倍", "所以在这里头呢", "读写数据的时候我们一种优化", "就是一块的内容", "我是不是有可能", "把它充分的利用起来", "在具体讨论内容的时候", "我们还有一个问题需要在这来讨论", "就是进程对文件的访问模式", "也就是说操作系统", "在实现文件系统的时候", "它需要了解用户进程", "是如何访问文件的", "那么在这里头呢", "有这样三种方式", "第一种是顺序访问", "按文件的字节序列这个顺序", "依次进行读写操作", "我们现在用到的大多数文件访问", "都是顺序访问", "而第二种是随机访问", "我访问的位置并不是顺序的", "从中间读", "这种做法呢", "在实际的进程访问当中并不常用", "但是仍然很重要", "比如说像我们在这里的虚拟存储当中", "把内存页存储到对换文件当中", "这时候它的访问就是随机的", "它对系统的性能的影响很大", "第三个是索引访问", "依据数据特征", "来找文件当中的相应位置的数据", "这种做法通常情况下", "在我们操作系统里", "并不完整的提供索引访问机制", "一种做法是在上边建数据库", "数据库提供完善的索引访问方式", "实际上某种角度上来讲", "我们可以认为操作系统里的文件系统", "是一个小型的数据库", "这是索引访问文件的一个示例", "说我要想找文件里的某一个记录", "这时我怎么找呢", "我需要先找着", "这个记录对应的位置在哪", "这时候形成一个索引", "一种我把它整个读出来", "然后再挑我想要的这个", "这时候它的效率会比较低", "所以在这呢", "基于索引的访问的话", "就是我在这里加了一个索引", "事先把相应的内容做了一种抽象", "然后这时候我再来访问的时候", "我先访问索引文件里的内容", "找到它对应的位置", "这时候再去读它相应的记录的内容", "这样的话就可以提高它的读写效率", "这是索引访问的做法", "对于文件的内部呢", "我们说从操作系统的角度来讲", "它并不关心它的结构", "在实际的系统当中", "我们可以把它视为这样几种结构", "一种是无结构的", "它就是一个单词 或者说字节的序列", "第二种是简单的记录结构", "我把它分成若干列", "每一列是其中的一个内容", "这种列的大小或者记录的大小", "可以有固定长度的", "也可以是可变长度的", "再有一种就是复杂结构的", "我在这里定义复杂的结构", "通常情况下这些复杂的结构", "都是由你应用程序来识别", "而从操作系统层面来讲", "这些结构并不是很关心", "但是为什么我们在这里会来讨论", "它的内部结构呢", "就是你到底是可执行文件", "还是文本文件", "在操作系统接口这一层面上", "它提供某种程度的支持和识别", "接下来是文件的共享和访问控制", "多用户系统里头", "文件的共享就变得很必要了", "你比如说系统里很多文件", "你不可以每个用户保存一份", "通过共享可以节约磁盘的存储空间", "在这里共享之后就带来一个问题", "我的访问如何来控制", "访问控制是每个用户", "它到底可以访问哪些文件", "可以以什么样的方式来访问", "这是访问权限", "在我们现在的系统里", "通常情况下的访问权限有这样几种", "读 写 执行 删除和看到它的列表", "这些基本的权限呢", "对应到每一个用户", "这就是我们的文件访问控制列表 ACL", "对于每一个文件 每一个用户", "它有什么样的权限", "在Unix系统里它的做法是这样的", "用户分成当前的用户", "用户所在的组和系统里的所有人", "也就是分成三个范围", "然后每一个文件的访问权限", "分成读 写 执行这样三种权限", "如果在这种情况下", "你要想把所有的文件权限全部列清楚", "这时候就构成一个访问矩阵了", "三种类型的用户", "然后它有三种权限组合到一起", "每一个文件有一个自己的选择", "那这样我给出整个系统当中的", "每一个文件的访问权限", "为了让这件事情做起来方便", "我们需要识别用户", "我必须识别用户是谁", "我才能决定它有什么样的访问权限", "然后为了让这件事情做起来效率更高", "我们可以把用户分组 提供组标识", "那这样的话", "我可以给一组人设相同的权限", "我只需要判断这个用户", "是否在这个组就行了", "关于访问权限", "我们在这里就只做一个简单讨论", "深入的讨论在不同的操作系统当中", "都有很多的内容", "接下来一个问题是说", "共享所导致的语义一致性", "当多个进程同时访问共享文件的时候", "它们如何来协调", "这里的协调", "我们同前边的同步算法很相似", "我需要协调我写到里头的内容", "你读的内容大家是不是一致的", "由于磁盘和网络延时的缘故", "我们在文件系统里", "对这个问题是弱化处理的", "也就是说它的设计很简单", "在Unix系统里简单到什么程度呢", "对于文件的读写", "一个用户写进去的内容", "其他的用户立即可见", "然后共享文件呢", "允许多个用户同时读和写", "基本上是说在这里", "它没有协调的这些控制", "这样一来的话", "你的内容读写是不是完整", "就需要靠应用程序自己来把握", "那也就相当于我把这个一致性的问题", "甩给应用进程自己去处理了", "还有两种做法呢", "一个是会话语义", "写入的内容只有当文件被关闭的时候", "其它用户才可见 这样一来的话", "你相当于改的内容必须写完整了", "其他的进程才能看得到", "这样一来它们之间要协调的事情", "就变得会简单一些", "但是它的效率会低一些", "还有一种是读写锁", "操作系统在这里呢", "提供几种基本的互斥访问锁", "由应用进程自己来选择", "我需要什么样的同步互斥", "来保证我内容的一致性", "这是一致性的问题"]}, {"name": "", "block_id": "2658baef1ad0460095befde047419f08", "text": ["下面我们来介绍软件同步方法", "基于软件的同步方法呢", "它是在两个进程之间", "通过共享变量的访问", "来实现线程之间的同步", "那这一类方法呢", "我们给它的大致模式先给它描述", "假定有两个线程 T0和T1", "然后每一个线程呢", "它的实现代码都是这样一种格局", "进入区 临界区 退出区", "然后我们在这里控制的地方呢", "是在进入区和退出区里头", "通过一些共享变量的修改", "来同步它们之间的行为", "那我们在这里的所有的方法呢", "都是要讨论在进入区里头", "我要对哪些共享的变量", "进行什么样的设置和判断", "那这些方法呢跟我们前面讨论到的", "生活当中同步问题呢是一致的", "我们跟那儿呢做一个类比性的讨论", "首先第一个尝试 说", "我在这里呢", "在两个线程之间共享一个变量", "这个变量呢表示允许谁进入临界区", "那这里是允许进入", "临界区的线程的ID", "好 那这时候我们说", "线程Ti实现代码呢是这样的", "它先判断当前这个turn的值", "到底是不是i", "如果不是 也就相当于我本身是i", "允许另外一个线程进入临界区", "i不允许进入临界区", "那这时候呢它就一直等待", "等待另一个线程把它改成i", "好 如果 这样的话就是", "在它自己等待它变成是它之后", "它能进去 进去之后呢", "执行临界区的代码", "执行完毕之后退出的时候呢", "在退出区呢 它把turn改成j", "也就说另一个线程ID", "那我们看这种情况", "能满足我们的要求吗", "如果说turn的值是i", "那么这时候呢线程Ti", "进入一个判断是可以的", "OK 它就进去了", "好 如果不是那就它一直等着", "那这时候说如果这个地方", "是j来访问那它就进不去", "那这时候我们看到", "i和j之间访问临界区的", "关系是啥样的", "开始的时候假定它等于i", "那么这时候呢i能进去", "j能进去吗 j进不去", "好 i进去之后它改成j", "好 这时候如果i再来进的话", "它进不去了 j也能进去", "这时候我们就会发现一种现象", "它们俩是交替进入临界区", "这是很好的一种做法", "但如果说某一个线程", "想连续两次进入临界区", "那这时候它就会有麻烦", "所以这种做法呢", "它能够满足我们说的忙则等待", "也就说我在这里头", "任何一个线程进到里头去的时候", "不会有第二个同时在里头", "但是它不满足空闲则入", "也就相当于如果说这里是空闲的", "但是这时候编号不是你", "那你进不去了", "好 那我们对这种做法呢", "进行进一步的修改", "那这是第二种做法", "我们在前面呢", "设置一个变量turn不够用", "那我们这儿呢现在设置两个变量", "也就相当于一个数组", "描述每个线程它是否是在临界区", "这种做法和刚才那个地方", "有什么不一样呢", "这就相当于我是用两个来表示", "我尝试着解决两个线程", "需要交替进入的问题", "好 那这时候呢", "线程Ti的实现代码我们这样来做", "先判断另外一个线程它的flag是1", "如果它不是", "也就相当于它没在临界区里头", "那我就把自己的标识改成1", "那这时候我在临界区", "然后进入临界区", "出来的时候", "我把自己这个标识呢改成0", "那这种做法呢", "和我们前面的第一种尝试", "想想看有什么区别", "线程Ti想进入临界区", "它做判断", "假设另一个没有在临界区", "那它判断是通过的", "OK 好 它这时候呢", "把自己的标识改了然后进去", "如果它再来一遍可以吗", "它再来一遍同样的做法仍然没问题", "一个线程连续进入是可以的", "好 如果说它交替进入呢", "那也没问题", "好像改善了我们前面", "第一种尝试里头的麻烦", "但是它有什么问题吗", "还记得我们在前面讲", "采购当中那个同步", "说两个先判断 后设置", "两个同时判断之后会出现什么", "同时设置", "那同时设置之后呢", "两个线程就同时进入到", "临界区里头去了", "那这时候这是它的毛病", "它就不能满足忙则等待", "好 那这种做法不行了", "之后怎么办呢", "我们把前面含义做一下改动", "也就说前面我们就像", "我们在采购那个同步里头", "我们是先贴标签还是后贴标签", "刚才那种做法呢", "相当于是后贴标签", "那这时候呢我把这个flag含义改了", "不表示我在临界区", "而表示我想进入临界区", "那这时候呢相当于我是先贴标签", "这是它的实现代码", "先贴标签后做判断", "这时候我们说 前面的采购同步里头", "先贴标签后做判断会出现什么问题", "两个都有可能判断完了之后", "都觉得自己进不去", "OK 那就都进不去了", "那这是它的问题", "它能够满足不能同时进", "但是不能满足如果空闲我可以进去", "这就是空闲则入", "好 这种做法呢也不行", "也就相当于我把标签贴在前头", "贴在后头都不行", "好 那这时候呢", "我把这两个合在一起", "这就是我们这里的Peterson算法", "这是两个进程之间", "能够完成同步的算法", "它怎么做的呢", "turn表示当前谁进入临界区", "而flag表示我请求进入临界区", "好 这时候我们说", "进入区的代码是先设置标志", "相当于这时候设置的标志有两个", "一个是我想进入", "第二个是turn的值", "然后我在后面做一个判断", "那这时候想想看", "这和我们前面先设置标志", "后做判断有什么区别", "那这地方它俩同时", "设置了一个变量 turn", "这是问题的关键", "我把这一步设置完了之后呢", "我后面的判断", "就能够区别出来它们俩", "好 我们具体看一下", "如果说另一个线程j", "它没有申请进入", "那我这儿直接能进去没问题", "因为这两个条件里头", "有一个不成立它就进来了", "好 假定说另一个也申请了", "它也变成true", "好 那这时候会什么呢", "会有这样一个turn在这儿等着", "因为这个变量是", "往存储单元里写数据", "两个线程同时往里写", "或者并发往里写", "那总是有一前一后", "好 不管是哪一个", "因为在总线上仲裁之后", "我是有一前一后的", "在这里呢", "假定我在这儿", "我写的是j", "如果我是最后一个写的", "会什么样的情况", "另一个flag是true", "然后我的标志呢", "turn的标志是按我最后写的", "那我判断相当于", "如果两个同时想进入的话", "后设置turn这个标志的", "那这个条件就成立", "而先写的后面这个条件不成立", "好 那这样的话", "就是先写turn这个标志的能进去", "而后写的就会在这儿等着", "那等到在退出区里头我把flag改了", "好 那么这个条件呢", "前面这个就不成立了", "好 那这是后写标志turn", "也就能进去了", "好 那这一个呢", "我们说跟我们前面讲", "采购同步一样的", "把它们所有的情况", "罗列出来进行分析", "写标志 判断它们", "所有可能的顺序一一进行分析", "我们说Peterson算法呢", "是可以完成", "我们的两个进程之间同步", "好 那在这种情况下我们说", "要是更多的进程怎么办", "我们先把这个两个进程的做法呢", "换一种形式来写", "这就是Dekkers算法", "它的做法是什么呢", "跟标志 跟我们前面的几乎一样的", "但是这个进入区的判断呢", "相对来说复杂一些", "那实际上也是先写", "然后后面去判断", "判断完了之后", "那看如果另一个也想进入", "实际上它就把自己改为false", "然后开始等待 前面这个", "这种做法呢", "退出去的做法跟那儿是一样的", "这种做法呢", "它可以很方便的扩展到多个线程", "而扩展到多个线程的做法呢", "就是我们这个图呢给出的图示", "我在这里有一个turn这个变量", "这是共享的", "然后是每一个线程 若干个", "我把它排成一个环", "每一个里头有一个flag的标志", "好 那我在进入的时候呢", "我先填这个flag标志说我想进入", "然后去看turn标志", "如果有多个想写", "那这个时候呢它总是会有最后一个", "好 那么在这种情况下", "这是当前正在访问临界区的那一个线程", "好 我要做什么呢", "进入区我就从这儿往后一直到i", "这是个环", "也可能会在另外一个位置", "就从它起头 到i这个地方", "这一段里是不是有其它线程", "也跟我一样的 同时想进入", "如果有 让他们先访问", "访问完了之后", "这个turn会一直往后蹿", "蹿到我这儿", "那这时候我进去", "那这就是我们这里说的", "进入区的做法", "而退出区等我用完了之后", "后面有可能", "也有其他在等着的", "我顺序的把标志", "给到下一个想进入的", "如果都没有转一圈之后", "我把自己留这儿就行了", "好 这是N个进程的软件同步方法", "好 那我们看到", "这几种方法搁到一起之后", "我们发现这个", "基于软件的同步方法它很复杂", "两个进程之间需要多个共享数据项", "我才能够完成这个同步", "同时这是一个盲等待", "也就说我在进入区里头", "我必须频繁地来", "查询共享变量的状态", "那这是呢软件同步方法", "所面临的问题", "好 经过这几个算法的介绍呢", "我们知道通过软件方法", "是可以实现多个进程之间的同步的", "但是这个方法比较复杂", "里头有错之后也不好查找", "如果说你是多个线程", "多个临界区", "那么这时候这个问题会变得更复杂"]}, {"name": "", "block_id": "4430532dad0d4e0fb1bedfc858474a7f", "text": ["接下来我们介绍连续内存分配", "我们说 在分配内存空间的时候", "我们首先第一个", "在没有其它的技术支持的情况下", "分配给一个进程的地址空间必须是连续的", "为了提高利用效率", "那我希望分的位置有适度的选择", "这些动态分配算法", "实际上就是你在去选择的做法", "而选择完之后", "你用每一个进程可能用的时间长短不一样", "有的进程先结束", "有的进程后结束", "这个时候 有可能先结束的会留出一些空", "后面一个在分配的时候又会再去找", "这个过程的执行", "就会在中间留下一些碎片", "这些碎片对于我们后续的分配是会有影响的", "我们就从如何去找你要用的空闲分区", "和如何来处理不能利用的这些", "小的空闲分区的两个角度来看", "连续内存分配算法", "连续内存分配 是指给进程分配一块", "不小于指定大小的", "物理连续的一块内存区域", "这个地方是一个图示", "说我进程不断的分配回收", "分配了三个 进程二就释放掉了", "这个时候是我内存分配时候的状态", "每一个进程的地址空间里头", "我们可能存放的是代码 数据", "堆栈 这些内容", "那在这些中间", "我们就会有一些区域没办法利用了", "比如说像这里头", "这有一块 这有一小块", "中间如果你要分配四块的话", "这小块也没法用了", "对于这些没法利用的区域", "我们就称之为是碎片", "这些碎片它是没办法利用的", "这个没办法利用 是相对而言的", "如果说你要得小块", "其中这块还是可以利用的", "但是有一些你是无论如何用不起来的", "这些碎片 我们把它分成两种情况", "一个是叫外碎片", "外碎片是两块之间的这一块", "实际上它也是一个小的空闲块", "只是由于它过小", "而其它进程申请的区域的大小都大于它", "而导致这块没法利用", "另一种情况是内碎片", "内碎片是分配给进程的区域内部的", "一些没法利用的区域", "什么情况下会出现这种（情况）呢", "如果说我分配的时候", "并不是说我可以准确地分配你所指定的大小", "比如说 你想分配510字节", "但是实际上我们在分配的时候", "只能是以512字节这种", "2的整数幂为单位的大小", "那剩下的几个字节你就没办法利用了", "像这些我们称之为叫内碎片", "对于我这来讲", "P1和P3上边剩的这段就是这种情况", "那是由于它要取整所导致的", "那我们在分配的时候", "希望尽可能减少这种碎片的出现", "从而使得我在利用的时候", "比如说这种情况", "我想分配一个六块的", "那么这两个在这里头是没办法利用的", "如果它两个是在一起的", "这个事就是行的", "我们来看动态分区分配", "动态分区分配实际上是说", "我在分配的时候", "我可以指定大小", "并且这个大小是用户指定的时候可变的", "那我们分配出来结果", "称之为叫一个分区", "也可能叫内重块 也可能叫块", "分配出来的地址是连续的", "对于这边是一个例子", "第一个进程 分配", "第二个进程 接着来", "刚开始的时候我可以顺序地分配", "这事比较容易", "在用的过程当中", "某些进程就会结束", "那结束掉就还回来了", "对于这种情况", "现在我要想再分配的话", "我就必须知道我哪些内存区域", "已经分配给了进程", "哪些内存区域还是空闲的", "实际上在这时候", "我们操作系统就要", "维护这样两个数据结构", "一个是已分配的分区", "我们就需要知道", "哪些是已经分配出去的", "它分配给了谁", "第二个是空闲分区", "我需要知道空闲分区的位置和大小", "对于我不同的找法", "这两个数据结构的组织形式", "是会有一些变化的", "在不同组织形式下", "你在找分区或者说把分区释放的时候", "放回到分区列表里的时候", "它的开销是会不一样的", "这是我们在这需要考虑的问题", "对于找分区的不同", "我们在这就有这样几种", "动态分区的分配策略", "大家通常想要是说我要分配一块区域", "我给你指定大小", "这个个时候你去分你去找", "你可能会碰到一个我就找一个", "这就是我们这里的第一种情况 最先匹配", "你找着哪一个", "碰到哪一个就是那个", "我也可以是说我找最佳的", "叫最佳匹配", "它是什么意思", "我把所有这些空闲的我全看一遍", "看看这里头 哪一个是比我大", "但是又是大的最少那个", "如果说 你是这些空闲分区", "你是按地址顺序排的", "那你就把整个全部找一遍", "如果说我在这里", "是按照它的大小排的", "那我就是从小往上找", "找到第一个就行了", "这是你空闲分区排序办法的不同", "我找的时候开销是不一样的", "还一种是最差匹配", "我去找", "每次用的时候我用的是最大的", "用最大就相当于实际上我是按照由大到小排序", "我的第一个肯定就是它了", "这是几种基本分区的分配策略", "下面我们具体来看", "第一种 最先匹配策略", "在这里 它的思路很简单", "你要分配多少字节", "我就从空闲分区列表里", "去找第一个可以找着比它大的", "比如说在这里头我是按照地址顺序排的", "这个时候我在这我去找", "我这个黄颜色是我空闲的", "我这给了一个例子", "说我想找一个400字节的", "我上来看 这个地方是1K", "OK 它就是比我想要的大", "那就是它了", "分配完了之后变成什么呢", "分配完了之后", "一块被你申请的进程所占用", "我把它放到已分配分区的列表去", "并且注明它是哪一个进程占用的", "然后这个时候还剩一点", "剩一点我又把它描述成另外一个", "小个的空闲分区", "接着把它放到空闲分区列表里头去", "在这里头如果按照地址排的话", "那我就是在哪", "这个思路就是这样的", "那我们再看你在这里做的时候", "它实现办法是什么", "我的空闲分区是按照地址顺序排的", "然后分配的时候怎么做", "分配的时候从前往后找", "找第一个所谓的合适", "就是大于我指定的大小就可以了", "释放的时候 我在还回来的时候我放回去", "按照地址把它插到里面去了", "并且看它前后是否有临近的空闲分区", "这个时候我把它合并到一起", "这个时候找和合并的开销都是比较小的", "但是它在这里头", "因为我们每一次都是从头找", "这样的话你都在前面能找到的时候", "它就不会往后找", "所以这样一来", "它的另外一个好处是", "在高地址的区域里头", "它会留下一些比较大块的分区", "你在后续要申请大块的时候", "我是能找着的", "如果我大块都切成了小块", "那这你就找不着了", "这是它的优点", "它的缺点是说我会有外碎片", "我每一次切的时候", "如果大小不合适我都会切成俩", "这个时候就会留下一个小的空闲分区", "如果这个小个空闲分区多到一定程度", "这时候你在后面往下分配大块的时候", "它就得从前往后找", "也就相当于前面很长一段你找不到", "由于你找不到 你就只能往后找", "那这个时候往后找的这个过程", "开销就会越来越大", "也就相当于越往后", "你在前面搜索的时间就会越长", "这是第一种算法最先匹配", "它的好处和缺点", "那么第二种方法是最佳匹配", "也就是说它找到一个比它大", "并且是最小的空闲分区", "如果说在这里头", "像在这里这个例子", "我们要想分配400个字节", "那1K 2K 500字节", "这三个比较起来", "这个是比它大并且是大的最少的", "那我们在这来分配", "分配完的结果变成什么样子", "我前两个不动", "第三个把它切成两个", "留下一个小的100字节的空闲分区", "另外一个作为已分配的", "对它做相应的标识", "告诉它分配给了哪个进程", "那这个事就算搞定了", "我们看在这里头", "我需要维护的数据结构是什么样子的", "首先第一个", "空闲分区我怎么来排序", "因为我是找比它大最小的一个", "我找的时候是从小往大找", "所以我的空闲分区", "如果是从小往大排序", "我开始是比它小的", "第一个比它大的", "OK这就是我想要找的", "如果前面比它小的数目比较少", "我很快就能找着", "分配的时候 我是从前往后找", "释放的时候", "我就看 跟它临近的进行合并", "这个时候就有一个问题", "临近的话我就是需要去找它地址临近的", "并不是大小临近的", "正是因为这样一来", "按地址排序的 你合并的时候", "它的算法就会复杂一些", "花的时间就会长一些", "这种做法它的好处是我可以把较大的块", "如果说我分配块的尺度", "都是比较小的时候", "这个时候它的效果是比较好的", "如果说你分配大的", "那这个时候它后边剩的就会少了", "这个时候它会有什么好处呢", "避免大的分区被拆分", "因为你找的是比它大的最小的那个", "然后它可以减少外碎片的尺寸", "也就是说剩下那块", "一定是我能找的这一块里", "剩下的最小那块", "然后相对来说它比较简单", "缺点是说你剩的那块边角料是小了", "但剩的越小这块边角料它越没法利用", "所以它有外碎片", "并且是释放分区的时候它会比较复杂", "然后剩下那些小碎片基本上也就没用了", "这是最佳匹配", "然后还有一种做法我们是最差匹配", "它的做法我找最大的", "有可能是说我找最大", "也不满足我的要求", "这是找不到了", "那这里头我们找了一个最大的", "比如说在这里这个例子", "我要分配400字节", "那这个时候找哪个呢", "最大的这是2K", "我把它切成两块", "在这里 这块标记已分配", "剩下这一块还有1K多比这块还大", "它可以被利用的机会就会更多", "这是最差匹配它所带来的好处", "具体做法是", "这个地方空闲分区排序要怎么排", "这个时候由大到小排", "我每次找的时候", "只要第一个满足要求", "那就就是我要找的", "第一个不满足要求 我就没有了", "这时候分配的时候就是找最大的一个", "也是找第一个 找的速度是最快的", "然后释放的时候 我要去找它临近的", "由于我排序不是按地址排的", "你找临近就需要去顺序找了", "找着临近的 然后把它合在一起", "放回到空闲分区列表时候", "我还要去找放的位置", "因为你原来是按大小排序的", "现在你仍然需要按照原来大小的去排", "要不然下次找的时候就不对了", "这个时候它有什么好处", "如果说你的中等尺寸的分配比较多", "这个时候效果是比较好的", "因为我用掉那块不是很大", "然后剩的那块多的时候还能利用起来", "相当于我剩的小块就比较少了", "剩的那块我还可以找到用处", "实际上这个时候关键是", "剩的那块能给它找什么样的用处", "它的缺点是释放的过程比较慢", "因为释放之后的合并是要进行搜索的", "它排序跟我这个合并没有关系", "然后也会有外部碎片", "如果说你在这头由于我每次都是最大的", "你在后边你想分配大分区的时候", "这事就变的比较困难了", "这是我们在这里说到连续存储分配", "它的几种做法", "这几种做法主要出发点", "就是我那个空闲分区的列表", "它是按什么来排", "然后我们需要去考虑的是", "在分配的时候它的查找开销", "和在释放的时候它合并的开销", "和把这个合并完的结果", "放回到空闲分区列表里的时候", "找合适位置的开销"]}, {"name": "", "block_id": "ca80c4c040af42e3a3a6c09261008a46", "text": ["接下来我们介绍时钟置换算法", "和最不常用置换算法", "这两个算法呢实际上是对", "前面的FIFO和LRU呢做的一些简化", "时钟置换算法呢是对这个", "LRU考察的是过去一段时间", "而现在在这里头呢 它是把", "在FIFO完全不考虑过去的访问情况", "变成是在这里呢有一定的考虑", "但又不像LRU呢那样考虑的那么长", "所以这时候呢", "在它俩之间做了一个折中", "而最不常用算法呢实际上是从", "考察过去这个间隔的时间", "变成是考察过去的访问次数", "时钟置换算法呢", "它的基本思路呢很简单", "就是对页面的访问情况进行大致的统计", "因为我LRU呢统计过于详细过于细致", "以至于开销太大 那我只做粗略统计", "那所谓的粗略统计呢", "它只是统计过去一段时间这个页面", "是否被访问过 访问过我留下", "没访问过的我就按照进来的先后顺序", "或者说它按照现有的顺序来做排序了", "那它在这里头 为了做这件事情", "它首先对数据结构做了一些改动", "页表项里头增加了一个访问位", "这个访问位呢用来描述", "在过去一段时间里头 是否被访问过", "而过去一段时间呢", "是靠这个指针来约定的", "那这个指针怎么约定过去一段时间呢", "它把这些页面组织成一个环形链表", "然后这个指针呢", "是在环形链表上进行周期性的循环", "这也是我们这个时钟这个词的来历", "看上去呢像一个钟表", "好 那在这里少的时候", "它是去看访问过的留下", "没访问过的它就按照链表里的顺序", "进行顺序的置换了", "那这是它的数据结构", "它的算法怎么做的呢", "是访问页面的时候", "那你要在页表项里记录它的访问情况", "也就是说访问过 我把相应的访问位置1", "没访问的那我就不做处理", "好 再有一个呢就是缺页的时候", "缺页的时候", "它从指针的位置开始顺序查找", "查找在上一次扫过", "到现在这一次扫描的时候", "它是否被访问过", "如果没访问过那就是", "在过去这段时间里头没有访问", "对于这些呢 它就可以对它进行置换", "找到第一个作为它的置换", "所以这儿呢它也有FIFO的那种思路", "好 那这种做法呢", "它的特征是在LRU和FIFO之间做折中", "那所谓的折中是在于", "它对过去的访问情况有考虑", "做了统计", "所以它不像FIFO完全不考虑", "这里的访问情况", "然后再有一个呢", "它又不像LRU考虑的很详细", "FIFO里说 只是说在过去一段时间里头", "没有访问的那它就做置换了", "这个时候呢如果说你所有都没访问", "那它就退化成是FIFO了", "那具体说起来呢是这样的", "我们怎么来实现呢", "装入一个页面的时候", "那把它的访问位清0", "然后访问的时候呢把访问位置1", "那你在执行的过程当中访问了哪些页面", "你就把哪些页面的标志位置为1", "好 出现缺页的时候我怎么处理呢", "出现缺页的时候从当前的指针位置", "开始扫描环形链表 检查", "如果访问位为0", "那这一页呢是我可以置换的", "那我直接置换 好", "这个指针移到下一个地方就结束了", "好 如果说页面是访问过的", "那这个时候呢", "我就去把它的标志位改成0", "也就是说我从现在这个点开始", "进行一次新的计时", "好 并且把指针移向下一个页面", "如果下一个页面仍然是访问过的", "继续往后找", "一直到找到一个可以置换的页面", "找到一个访问位为0的", "按照头一条进行置换", "那这是呢它的处理的办法", "那我们用一个图示来说明这个过程", "那这是一个内存当中的物理页面", "它把它组织成一个环形", "然后在这儿呢加了一个指针", "开始的时候指向这儿了", "好 如果在这里头我们访问某一个页面", "在这儿 它把这访问位置1", "好 如果说已经置1的你再访问", "那这个1就不动就行了", "然后在我发生缺页的时候", "那这一页没在这里头那我怎么办呢", "就从这指针的位置开始扫描", "找访问位为0的 访问位为1的我清0", "那这个时候呢应该是找到这儿", "我们看 好 这儿清0 这儿清0", "然后到这儿清0 这地方清0", "找到这个地方它停下来", "好 这个页面呢", "是我们可以用来做置换的", "把它置换成新的页面", "这个缺页中断呢就算处理完了", "再次缺页的时候 它继续往后扫", "到这儿又找着一个再做替换", "它就周而复始的", "那这样的话我们就可以使程序", "在正常情况下可以访问", "缺页的时候我可以找到一页替换", "然后继续执行", "那这是时钟置换算法的大致的过程", "那我们下面用一个更详细的表格", "来说明它处理的情况", "这是我们前面例子里", "说到的一个访问序列", "然后我也给它分配了四个页面", "但在这里呢我页表项里头", "我记录了一下它的访问的情况", "好 那在这里起始的时候", "它们都没有访问过", "那访问第一个页面", "那这时候在内存里头访问的是c", "好 那这时候c的访问位是置1的", "好 再往后走 这回访问的是a", "那这个地方呢访问位置1", "再访问 下一步访问d", "这里d呢它置1 好 再访问b", "那到这上头b置1 再往下走", "访问e的时候那这里没有了", "那这个时候会出现缺页", "缺页的时候呢 那我缺页的处理是什么", "那个指针 这个蓝颜色", "表示当前指针所在的位置", "好 那从这儿开始扫描", "是1的改成0", "好 找到下一个 再是1 再继续改成0", "再是1再改成0", "全是1改了一圈之后", "回到最顶上它发现了一个不是1的", "那这时候我把它替换成我的缺页这个", "OK 这样的话我把它改成1", "改完之后的结果呢", "在这儿 a被替换成e了", "好 那这个时候呢", "我这个缺页中断就算处理完了", "好 再往下继续执行 访问b", "这个时候呢又改成1 再访问a", "那这个时候呢a不在里头又发生缺页", "缺页的时候我就要从这里继续找", "当前在这个b的位置", "这个b是1改成0", "那下一个就可以了 这时候", "它处理是先改0到这儿", "这是找到的一项改成1", "OK把c换成了a", "那处理完的结果呢在这儿", "c换成a", "好 那这时候呢执行到这儿继续往下走", "访问b b在里头", "把它的0改成1就行了", "好 再访问c那它又会出现缺页", "缺页之后呢", "在这个页表项里头进行扫描", "这个地方正好它就是0", "所以这项直接可以替换", "替换完了之后的结果呢在这儿", "好 它换成c", "那到这儿之后把这儿换成c", "好 我们在这里呢继续往下走", "这时候看到", "往d的时候这里仍然没有", "它还会再出现缺页", "那这个缺页呢我会再继续找", "这又是一圈全是1", "全部改成0又回到这儿", "第二步 第三步 第四步 回到这儿", "那应该是把e是我可以选择的", "把e换成d 这是换完之后的结果", "好 到这个地方呢", "我们就把这个时钟置换算法的", "基本流程说完了", "那在这里头呢", "我们考虑到的仅仅是它访问的情况", "如果说你访问的那一页", "你是被修改过的", "那么这时候呢它缺页中断的处理时间", "就会是当前这个时间的至少是2倍", "你需要把原来的内容写出去", "再把新的内容读进来", "那这个过程呢", "在缺页中断这段时间太长", "那我们需要对它做改进", "那这个地方就是改进的时钟算法", "它的基本思路呢是说对有修改的地方", "这些缺页的开销呢我把它减小", "它怎么减小呢 就是如果你有修改", "那我这时候跳过这一页我不做置换", "那在系统里呢它会定期的", "把这些修改过的呢写到外存里头去", "那在这儿呢", "我们这个细节不再仔细讨论", "好 它的做法是什么呢", "在页表项里头加上一个修改位", "然后在你做访问的时候进行修改", "那我们前面说有一个访问位", "是你在访问的时候它被置1", "那这里头又加了一个修改位", "那这时候我在访问的时候", "就有两位来做状态的变化", "你是读那只是改访问位", "修改位还是0", "如果说你是写 那这两位同时改", "好 缺页的时候呢", "我仍然是跟原来一样去找", "但这时候找的过程当中呢", "修改过的页面它是直接跳过的", "那具体说起来是这样的", "这是它指针扫描的时候", "它改状态位的方法", "如果两个都是0", "那这时候呢肯定是前一轮里头", "它没有访问过 那这时候我可以替换", "好 剩下的三种情况访问位为0", "修改位为1", "那这时候也就相当于", "我这里前一轮转过的时候", "修改过的地方你还没写出去", "那这时候我把它清0", "好 通常情况在这个过程里", "会启动往外存里写", "好 同时继续往下走", "那这两个情况呢", "访问位1 修改位为0", "那这时候呢 我把它改成0", "如果访问位两个都是1", "我把第一个改成1", "第二个继续留着", "那就会出现上面", "这个地方的这种情况", "好 在这儿也有一个示意图来说", "我们看在这儿多加了一位修改位", "那这个时候在那个指针扫描的时候", "会是什么样的呢", "把1改成0 两个1", "好 这找到一个", "这是我们可以替换的 两个都是0", "好 我把它改成我要的页面", "如果说在下一次再出现缺页的时候", "我从这儿继续往下找", "两个1的改过来", "那在这儿找到一个", "好 那我把它做替换", "好 那这样的话就是改进的时钟算法", "在这个算法里头呢", "它在缺页中断的时候", "对于修改过的页面", "它的处理呢速度会比原来快", "那你说在这里头 它快到底在哪呢", "一个是延迟之后", "后续有可能的改动的页面", "写出它可能会被合并和延时", "好 这个地方也是把刚才", "加了改进的时钟算法它的执行过程", "那跟刚才的时钟算法不一样的地方", "这地方加了两个标志位了", "那处理的过程也是在前面类似的", "这是对c的访问是只读的", "好 那这个地方只是改成10", "对a的访问是写的", "好 那这时候把0改成11了", "好 然后再是d那是改成10", "然后再是b 那是改成11", "再到e的时候它产生缺页了", "这时候我要去找一个页面", "可以来做替换的", "那怎么找呢 那做循环", "11的改成01", "10的改成00", "那改一圈之后回来应该是找到c", "我们看一下它执行过程", "11改成10  11改成10", "10改成00  10改成00", "好 这个地方01改成00", "好 最后找到这个地方", "那这一项是替换成1", "替换完的结果呢 是这儿", "好 那接下来再往下走", "那我们访问到这个地方是b", "我把b的标志改了", "在这个地方注意一下", "我这个地方加了两个星号", "实际上就相当于我在改标志的时候", "实际上这相应的内容", "并没有写到外存里头去", "需要系统里另外的部分呢", "来对这种情况做处理", "要不然的话这两者就不一样了", "好 继续往后走", "a是写00改成11", "再有b再访问 这已经改过来了", "所以这时候页表项里内容没有做变化", "好 然后再是c", "这时候又产生缺页", "看到结果是什么", "这地方直接d 这地方是00", "我直接可以替换d", "OK 替换完的结果就是在这儿换成c", "好 上边的指这儿", "实际上刚替换完之后", "接下来它又访问d 还是产生缺页", "那这时候会找到哪儿呢", "这地方不是 这地方不是", "改过一圈之后回过身来会在b这个地方", "01  00  00  00好再倒过来这改成00", "好 这时候找到b 替换", "那这是我们刚才说的时钟算法", "和改进的时钟算法", "那改进的地方就是对于写操作的页面", "它的置换会有一个稍微不一样的处理", "那接下来我们说最不常用算法", "这个算法也是对LRU的一种简化", "它所谓的简化呢就是它统计的依据", "不再是我们刚才说的时间", "时钟算法里修改或者是没修改的01状态", "它是在这里加了次数", "所以在这种情况下", "它的统计开销相对来说就会大一些", "那看一下它的具体怎么做的呢", "它是在这里每一个页面", "加一个访问计数", "我们刚才说的访问位呢", "某种程度上来讲", "你也可以认为它是一个计数", "只是说这个计数", "它计的范围是比较小的", "只有0 1两种状态", "而我可以设置一个多位的计数", "这时候多位计数的话那它就会加1", "加1的操作会复杂", "但这时候呢我可以统计的更精确", "好 缺页的时候呢", "我置换那个计数最小的那一页", "那也就是说", "过去一段时间你访问最少的", "我认为它是这个需要置换的", "当然这时候也有可能有这种情况", "就是一个页刚拿进来没访问几次", "又把它置换出去", "这是它存在的一个麻烦", "它的问题是开销大 并且呢", "计数值还没长的很大的时候", "可能频繁的是这些页面", "刚拿进来又拿出去", "所以它的做法呢", "后续有一个改进就是对这个", "已经计了数的这些值比较大的", "它会定期做衰减右移", "那这样的话它计数值会变小", "用这种办法来做", "实际上这个LRU和LFU之间区别在哪", "LRU考察的是过去的未访问的时间", "这地方考察的是访问的次数", "这两者到底有啥区别呢", "因为这个统计时间我要去维护那个栈", "统计次数相对来说好弄点", "我们也还是通过一个具体的例子来说", "这是我们刚才那个例子", "但是跟刚才那个不太一样的", "我们如果按原来那个序列的话", "它就太短了", "以至于LFU不足以显示它算法的特征", "那么在这儿呢给上边加了一个数值", "表示我多少次访问", "也就说原来我这一次访问的话是一次", "那我在这儿呢 统计了", "在这里访问过的它是有多少次", "好 我们在这里头呢", "这是实际分的四个页面", "假定初始的时候它的访问次数是这样", "那我们看执行的过程当中会是啥样的", "好 首先在访问的时候", "我要去修改每一个的计数", "比如说在这里头原来有6次", "那我在这一段时间里头呢", "它访问了7次", "好 那这样的话", "我就会把这个值6加7 13在这儿", "再往下走访问的时候a这里头有", "计数加上相应的值那这是加1", "好 在访问d的时候也是一样", "这地方2加14 16", "再访问b再继续往上加变成10了", "再访问e的时候这里没有了", "那就会产生缺页 那缺页怎么办", "我去找我当前这些计数里最小的那个", "那是a 好 我把a替换成e", "那并且这时候", "替换完之后你访问多次", "那计数加这里头", "继续往下到b这个地方又继续往上加", "那就会发现存在里头", "如果时间越长的话 这数会越加越大", "你加的越大你日后", "再被置换出去的机率也就会变小", "好 如果说你这时候访问的特征", "从一个区域变到另一个区域", "那么前一个区域里多次访问的页面", "有可能会保留很长的时间", "好 然后再访问a", "那这时候前面没有了 缺页", "好 这时候找你最小的是哪个", "b把它换掉", "那这时候呢它的访问次数清0之后", "先换出来把它当前访问次数加上", "好 再往下一步呢 又访问b", "那这时候又没有了", "好 它又要有缺页", "在这里找 哪一个c", "它只有13次 好 最小的置换掉", "那这个地方就换成20次了", "这是我这里b的情况", "好 再过来访问c", "那又是缺页 这里最小的是啥", "是16 把16置换掉", "那这时候有一个问题是说", "你这里写的数 好像你要想置换别的", "你这个数只能越写越大", "如果说你刚开始几次基本上会换一个", "好 那这时候说 再访问d的时候", "这里最小的是什么 18  e", "换掉之后", "这是执行到这个时候的状态的结果", "那到这儿呢 我们可以看到这个", "时钟算法和最不常用算法", "这两个算法呢", "都是对LRU的某种程度的简化", "那简化之后呢 这个开销会小", "但是它统计的精度也会下降", "那这时候实际上我们在这里", "做这个置换算法的时候", "就是需要在这种", "近似的程度和它的准确性之间做折中", "必须是简化到足够的程度", "以便于我们在每一次调指令的时候", "都有很多的存储访问", "都能在很快的时间里头来实现", "或者我用硬件", "可以很方便简单地来实现", "那像这种情况 LFU就比较难实现了", "那为什么我们还在这儿会讨论呢", "实际上这个存储的访问呢", "它不仅仅是有CPU到内存", "也有我读硬盘的这种存储访问的情况", "这时候呢它时间长一些", "像这些算法呢", "在那个地方就相对来说就可以用了", "好 那这是我们说的", "时钟算法和LFU最不常用算法的情况"]}, {"name": "", "block_id": "158ac45919f145bea4c768b88eaae8b2", "text": ["好 接下来我们讲交换和覆盖", "这两种做法呢实际上是", "我们在前面已经讨论到过的", "但是为了能更好地说明", "虚拟存储的作用和它的基本原理", "我们有必要把前面这两个呢", "再细化一下进行介绍", "覆盖技术是说我有一个进程", "要在内存当中运行 但是这个内存较小", "而我的程序比较大 那没法再给它运行", "我怎么做这个事 那它的做法呢是说", "我需要把程序依据它的逻辑结构", "把它划分成若干个功能相对独立的模块", "然后把那些相互之间", "没有调用关系的模块呢分成一组", "它们共享一块内存区域 这样的话", "我就可以让通过这种共享呢", "让整个进程占用的存储空间变小", "从而在一个小内存的系统上能运行", "那具体说起来呢 在这里面呢我们就是", "把程序的模块呢划分成必要的部分和可选部分", "必要部分通常是一些常用的功能", "而可选部分是些不常用 或者说在一些交替用的", "那这些常用的呢让它常驻内存", "而这些可选的部分呢 我只在它要用的时候", "我把它装入内存 那有了这种做法之后呢", "那是说这种不存在调用关系的", "我可以把它相互覆盖", "把它放到同一块内存区域里头来", "好 那这种做法我们具体看看它怎么做呢", "这地方呢给出来的是一个例子", "说我有一个程序 它呢分成了六个模块", "每个模块的大小呢在这儿有了标定", "基本上是20 30 40 50这几个尺寸", "然后它总共的大小呢是加在一起", "是190K 那现在呢假定说", "我在一个一台计算机系统上运行它", "它的物理内存不够190K", "那这时候你肯定没办法在上面运行了", "好 那这时候呢我希望通过", "我应用程序的处理使得可以让它能运行", "那我们怎么办呢 先把它分成", "按照相互独立的这几块", "按照相互之间调用关系我把它分组", "A和这些都有关系 它自己一组", "B呢它和C E F都没关系", "那我把C跟它分成一组", "好 这个D呢 它肯定是要单独一组", "因为这是一绺 好 那它和E和F是没有调用关系", "它们俩可以在一组 E和F呢也是一样的", "所以它们仨一组", "这时候我怎么给它分配存储空间呢", "是每一组里头我按它最大的来分配", "那这时候呢我们分配完了是这样一种", "A给20K B和C呢一个50 一个30我给50", "剩下这个E F D这三个呢分别是30 20 40 我给40", "我分了这样几块之后", "那这时候它运行的时候会是啥样子呢", "刚开始运行的时候A B和D在内存里头", "它们之间运行 好运行到一段时间之后", "那开始C调用的时候调用E", "那这时候我把B和D换出去", "然后把C和E拿进来", "这时候在执行中间这一段", "假定说你是在做数据处理", "好 那它是可以运行的", "好 等处理完了之后", "那最后我要把结果输出来这是用的F", "这时候F交换过来", "因为这个F呢我们这一绺的大小", "是以它们三块最大来弄的", "所以这F放进来呢肯定是没问题的", "好 用这种做法之后", "我总共占用的存储空间是多少", "40 50 20加在一起110 那它是可以运行的", "好 那这样以来的话如果说你的系统里", "只有110K的物理内存", "那这个大一点的程序就没有办法运行", "通过这种改造之后 使用覆盖技术", "我写出来的程序跟你的功能是一样的", "但是这时候它可以在110K的内存上运行", "好 通过这种办法呢我可以", "减少一个应用程序内存占用量", "从而可以在小的 小内存的系统上运行", "那这时候问这种做法需要了解这个关系", "我现在这个划法是最优的吗", "那实际上在这儿我们可以给出另一种划分办法", "那A是独立一个模块", "但是第二步呢我把B原来是和C放在一起", "这俩差挺远", "好 那这时候呢我把C B E和F放在一起", "这两块呢它尺寸比较接近", "好 那这时候我给它50K", "而把最后一个呢C和D它俩放在一起", "它俩都是30 这时候搁30", "把这尺寸接近的放在一起之后呢", "相互之间没有调用关系放在一起", "好 这时候它合在一起", "这几个加在一起是100 这个会更小", "那是不是它是最小的", "如果说你要严格去来讨论这个问题", "那是相当复杂的 所以在这儿呢", "这个给程序员的开销是很大的", "那我们说在实际的系统里头呢", "在我们的DOS操作系统上", "这是历史上用过的 里头有个Turbo Pascal", "那这是它的集成开发环境", "使用Pascal语言的", "好 那在这个环境里呢", "它提供了这种Overlay的覆盖技术", "那有了这个支持之后", "那实际上它这里面是有一堆库支持", "你在这里头呢这个模块的换入换出", "和模块之间的关系的这种指定", "好 那这时候说它的开发难度是会增加的", "因为我要确定人首先要用程序员", "来对模块进行划分 划分完了之后", "还要确定它们之间的覆盖关系", "那这时候呢 我的编程难度是增加的", "与此同时我的执行时间呢也会有所增加", "那这时候呢需要 原来我们执行的时候", "是你把190K一块读入内存", "然后你就开始执行了 后面就没有开销了", "好 而在这儿呢", "我不但要在刚开始的时候我读入一部分", "那后来呢", "我还会把另一部分再读进来", "那这种呢就会导致你的执行时间会增强", "那这种做法呢我们觉得它会有问题", "好 另一种做法交换技术", "这种做法呢是增加正在运行的程序", "或者说需要运行程序的空间", "这和我们前面说那个问题不太一样", "说 我原来呢是一个程序的内存空间就不够用了", "现在这儿呢 实际上讨论的是说", "我一个程序你肯定要够用的", "然后我只是当前这个程序呢", "由于多道的程序运行使得", "另一个应用程序占用了内存空间", "使得它的空间不够", "它并不讨论一个程序在所有内存空间里", "用的时候它仍然不够的情况", "好 那在这儿说 我们怎么做呢 你把那些", "如果说你多个进程 同时在内存里头", "我把那些另一些进程就把它暂停", "并且放到外存里去", "这样的话我的空间不就够用了吗", "当前正在运行的或者说你需要运行的进程", "它的地址空间就增大了", "那这时候呢需要注意一条", "它换入换出的基本单位是整个进程", "那这个单位呢导致了不像我们刚才的", "覆盖我是程序内部的事", "好 然后 这时候有两个基本操作 一个是换出", "我把一个进程的整个地址空间保存到外存里去", "跟它对应着呢是换入 我把某个进程", "在外存当中某个进程读到内存里头来让它能运行", "那这是以进程为单位的交换技术", "这种做法呢我们在前面也有这样一个示意图说", "我在这里头两个进程 一个进程在内存里头", "一个进程在外面 那现在说我要想让它运行", "它需要的空间大 我就把它换出来", "然后把它换进去 然后这样的话", "它的空间呢就能够运行了", "如果说这空间足够的时候呢", "一半它也能进行的 我就可以让它俩在内存里头", "这样你 你这个交替运行的时候", "它的速度就很快 但这时候呢空间不够", "好 这是交换", "我们使用交换技术可以把一些", "暂停执行的进程放到外存里头去", "但这时候呢也会有一些麻烦", "就是说首先第一个我们遇到麻烦", "是说我在什么时候来进行交换", "那这时候呢通常情况下我在内存不够的时候", "或者有不够可能性的时候", "比如说我一个正在执行的进程", "它的内存空间不够用了", "这时候我必须把另外一些暂停执行的", "并且在内存里的", "把它整个进程地址空间兑换到外存当中", "这时候我这个可以扩大", "另一种情况是说我有一个进程要执行", "现在内存里可用的空闲空间不够用", "好 那这时候我就把暂停的另外一些进程呢", "倒到外存里面去 这时候它可以来运行", "那这是时机", "再有一个是交换区域的大小", "也就是说我倒到外存里头去", "放在外存里头这些进程映象", "它要占多大空间呢", "需要把所有的暂停的用户进程", "全部保存到外存当中", "这时候呢它是需要占用一定的存储空间的", "还有一个问题是说 我换入的时候", "那你是否能放回到原处呢 如果说不放回到原处", "我原来的函数调用或者说有跳转 这些你怎么办", "那这个时候呢我们说它的做法是", "需要采用动态的地址映射的办法", "而这些前面关于交换和覆盖的这种技术准备", "都为我们的虚拟存储打下基础", "好 那我们对它做一个比较 对于覆盖来说", "它是在程序内部模块之间的", "跟程序外边没关系 好 这时候它是一个进程", "在物理空间里运行它就不够了", "好 那这时候说我们需要兑换的呢", "覆盖进行交换的呢是这个", "没有调用关系的模块之间", "程序员必须知道这种逻辑覆盖关系", "这是比较麻烦的", "而对于交换来说呢它是以进程整个地址空间", "为单位来进行交换的", "这时候呢我们不需要这个逻辑关系", "它只会发生在进程之间", "好 这一部分呢实际上可以由操作系统来做的", "那上边这一部分可不可以由操作系统来做呢", "那这事有难度 原因在于这地方这种逻辑关系", "你操作系统没有办法很准确掌握的", "好 那这样的话是说 我有没有可能以使用", "由操作系统来做同时呢", "我又是不是以整个进程为单位", "是一部分一部分的", "进程地址空间的一部分内容", "我把它导入到外存里头去", "这个时候有没有可能呢", "那这就是我们下面要说到的", "虚拟存储要来做的事情"]}, {"name": "", "block_id": "2abf404154224d6ca02ddbbd2be549fe", "text": ["我们接下来介绍", "局部置换算法它的一些特征", "那么在这里头呢", "我们前边已经介绍了", "五种局部置换算法", "这五种局部置换算法呢", "各有各的优缺点", "那么它们之间都有一些什么样的特征", "到底它们之间是一个什么样的关系呢", "我们在这用一部分时间做讨论", "第一个是Belady现象", "说的是随着分配给进程的", "物理页面的增加", "它的缺页率会少吗", "好 后边这个呢", "实际上是对几种算法之间它们的比较", "每一种算法呢", "它都会在一定的情况下", "和另一种算法体现出某种相似性", "Belady现象", "这里说的是说我们给每一个进程", "分配一定数目的物理页面", "那如果说它缺页次数比较多", "那这时候我会需要增加给它的页面数", "那增加完了之后", "这时候我们按照通常的理解", "它的缺页应该降低", "但实际上如果你的算法不好", "比如说像我们这里的FIFO", "在某些情况下 你增加页面之后", "它的缺页次数反而会增加", "这种现象就叫Belady", "那产生这种现象的原因是什么呢", "原因是这样的", "我们置换算法 你置换的话", "是标记它的某种特征", "然后依据这种特征对它进行置换", "那我们标记的这种特征", "和进程的内存访问的这种特征", "它是不一致的", "那也就是说每个进程", "是不是会有自己的访问特征呢", "你比如说我有一个排序程序", "那它的访问特征和另外一个", "我一个word的编辑程序 那这两种呢", "它的内存访问特征", "肯定是完全不一样的", "好 正是由于这种原因", "我们置换算法对它的预测呢", "和进程实际情况会不一致", "好 那这种预测不合理", "那就有可能出现这种情况", "那这时候是说", "是我所有的算法都这样吗", "这是我们需要考虑的 那我们在这呢", "还是先从FIFO说起", "我们刚才说FIFO是有Belady现象的", "我可以找到一个实例", "说你用FIFO算法", "那分配给它页数少的时候", "它会出现一个缺页次数", "分配增加之后", "缺页次数反而增加的这种情况", "那我们具体来看一下这个实例", "那在这里头呢 这个地方是个FIFO", "然后这是访问的序列", "然后我们在这呢 访问缺页状态", "在这跟我们前边的约定", "稍微有点不一样", "比如说我们在这里", "第一次访问我就认为它是缺页", "为啥会这样呢", "原因在于我们在前边", "统计局部置换算法的时候", "刚开始我的那一段我是不算的", "但是在这呢", "因为我分配给它三个物理页面", "下一次我分配给它四个", "如果这段不算的话", "这两个的比较性会不一样", "好 所以我们在这起头的这几个都算", "好 那这个是前三次我刚起头的时候", "那这个呢 怎么着都是一样的", "什么算法都是这样", "好 第四个 那这时候呢 加进来", "你的前三个是不在这的", "它会产生缺页 再往下一个", "这一个也不在 它还会是缺页", "然后还会是缺页", "然后到这5这也还会是缺页", "好 那到1这个地方呢", "没问题了 这个1在里头", "好 那这个时候呢", "它没有命中 然后2命中", "然后3缺页 4缺页 5缺页", "那这时候呢 总共有多少次呢", "总共是在这 缺页是9次", "我只有三次命中的", "那我们在这呢 这是个示例", "好 那我们再这呢 我们再看", "我分配给它4页的时候", "还是同样一个序列", "它的缺页次数会增加吗", "好 由于我们刚才说你分出的三次", "那前边这四次是肯定一样的", "好 那在这里头说", "你分配4页肯定比刚才好", "那从第一个来讲 这肯定是好", "因为刚才那个1拿出去了", "你就有缺页了", "好 这1没拿出去是不是好了呢", "1没拿出去 这确实是命中了", "但是这两次都是成功的", "好 接下来的日子就不好过了", "接下来之后5缺页 你把它拿出去", "好 然后在这呢 再来1", "你又把它拿出去", "然后2 又是缺页 3 4 5", "你会发现 在这个顺序当中", "我这访问的总共就五个", "你到了4页之后 还是有缺页", "到什么情况下不会缺页呢", "你把这五个全放在这 就肯定不会了", "那现在就是说对于4页的这种情况", "那到这实际上你可以基本上可以看到", "你刚才把哪一个拿出去之后", "我就要访问哪一个", "1 2 3 4 5 正好对着的", "那你说在任何一种情况下", "是不是你给出一个序列来之后", "我就可以针对着你拿出的情况", "构造出这个序列来呢", "这是我们在这里头", "那你说这么来的话", "我可以构造出来的话", "我是不是任何一个算法", "都能做到这样呢", "这是我们在这里需要讨论的", "好 从这呢 给出一个实例", "就是这个序列分3页和分4页", "它的情况是缺页增加的", "所以它是存在Belady现象的", "那如果说你在这里呢", "你证明它有 那我举出一个例子来就行了", "但是如果你想证明它没有", "你把所有的全枚举一遍吗", "这是不可能的 好 那在这呢", "我们说LRU它是没有Belady现象的", "那在这呢 也给出了一个实例", "说我这是分配三页 缺页十次", "然后我在这呢 再给它分配四页", "那数一遍之后呢", "它缺页八次 那这个没有", "那我仅靠这一个例子", "我是没有办法说明这一条的", "那有证明吗", "好 实际上在这里呢", "我们是可以有证明的", "说只要是你类似于", "我们前面那个栈的这种做法", "那从底下往上抽的话", "那这些算法呢", "它肯定都是没有Belady现象的", "这是我们说的 那再问一句", "我们的时钟和改进的时钟", "这两种折中之后有Belady现象吗", "LRU没有Belady现象", "和关于时钟和改进的时钟算法的", "Belady现象", "到底是个什么结论", "留给大家课后去思考", "这个在相关的参考书里", "可以找到它的证明", "那接下来我们说LRU  FIFO和时钟", "这三种算法它们之间的比较", "那实际上我们在前边已经说过了", "这两个是两个极端", "除了那个最优算法LRU是最好的实现", "然后FIFO是我们在这里给出来比较差的", "那这时候呢 它们有什么相关性呢", "实际上任何一个置换算法", "那它在做的时候呢", "都会有一个排序", "这个排序是什么样的", "这对于你有至关重要的影响", "这两者的区别在于", "LRU是因为是以最近一次访问的时间", "前边的访问的时间来做排序", "而FIFO是以加载的时候", "装入的时间为顺序来排序", "这是它排序的 它们俩之间的区别", "那仅从这个时间点上来说呢", "好像这个事比较好弄", "第二个是它的这个在执行的过程当中", "它是否要动态的调整", "那这时候FIFO的这个顺序进来的时候", "这个因素在后边就再也不会变了", "所以它没有调整 所以它的开销就小", "而LRU每一次访问", "我都要去维护我那个栈的顺序", "所以它的开销是很大的", "那这样一来的话", "就相当于我们说这两种算法是开销大", "它的性能好 这个开销少 它有问题", "然后说这两种算法它在一定情况下", "是可以相互转换的", "LRU它可以退化成FIFO", "在什么情况下呢 是这样的", "如果说你访问的页面是第一次", "也就只访问一次 然后就不再访问了", "对于这种情况这两个算法", "你在里用LRU是没有意义的", "原因在于它只用一次", "你用第一次的时候", "没有任何的历史你可以借鉴", "所以它俩是一样的", "而这时候它的顺序", "也是跟你加载的顺序是一样的", "所以这两个排序是一样的", "好 在这 这是一个实际的例子", "那你说这个例子是你构造出来的", "有几个页面", "我就顺序的访问比它多一个", "这样的话对于FIFO", "你就肯定是不行的了", "那在我们实际用到的程序里", "有啥样的是这种情况的", "这种情况也是存在的", "比如说我们在看视频", "视频信息的输出的时候", "你在读入相关的信息 那这个信息呢", "通常情况下我们播视频的时候", "它是从头到尾播一遍", "你很少有翻来覆去在那听的这种情况", "好 正是由于这种原因", "所以我们这种只放一遍的", "这种情况也是有的", "如果说在你的系统当中", "这种情况很常见", "你就有必要针对这个", "别把这个缓存的事做的很复杂", "这是LRU和FIFO之间的一些关系", "那这时候说LRU的性能好", "但是开销大 FIFO的开销小", "但是会有Belady 然后说Clock", "时钟算法实际上是它们俩之间的折中", "怎么做折中呢 我们看一下", "在这里访问页面的时候", "我们前面说一个需要调整顺序", "一个不调整顺序", "那调整顺序的开销大", "那不调整顺序这个呢", "我就啥事也没做", "那这个做法呢不好", "我们在这里取一个折中", "就是访问的时候 我会做标记", "比如说哪些页面访问过", "那这是比FIFO做的复杂的事", "那由于这件事情有硬件参与", "改页表里的页表项", "这件事情相对来说比较方便", "好 然后我不去调整它的顺序", "那这样的话", "我调整顺序的开销就没了", "然后说在这里头呢", "那我要想得到LRU的一些特征", "我怎么办呢 我缺页的时候", "那缺页的时候我们的时钟算法会去扫描", "实际上这个扫描你可以理解为", "它这里对这个顺序做了一定的调整", "实际上它怎么调整呢", "就是你扫描的过程当中", "有一些点它是直接蹦过的", "访问过的它是直接蹦过去了", "好 这种直接蹦过你可以理解为", "是把它的顺序是做了某种形式的调整", "好 那这样一来的话", "说时钟算法它和LRU是什么样的呢", "对于刚才说的没有访问过的页面", "这Clock算法 你LRU也已经退化成FIFO了", "你Clock也和它是一样的所以你可以说", "Clock和LRU是性能一样的好", "实际上它和FIFO", "它们三个是一样的", "因为我没有任何可以借用的信息了", "好 那在什么情况下", "它比FIFO做的好呢", "对于被访问过的页面", "Clock就比LRU要做的差", "但是比FIFO做的好", "因为在这里Clock它只记录了", "我是否访问过 访问过的我留下", "而对于LRU不但是访问过的", "我要做记录", "并且访问的顺序我还要做记录", "所以这样的话", "它的记录的信息比Clock要多", "这是我们对这三种算法", "它们之间的一个比较", "到这个地方为止", "我们就把局部置换算法呢", "全部讲完了 在这里头说", "这些主要的区别是在于", "我在这个固定页面的情况下", "我怎么来调整我要置换的", "这个页面到底是谁 我对它做排序", "我以什么样的指标来排序", "这种排序的情况下", "它们的开销是什么样的", "好 在开销我不可以接受的情况下", "我如何对它去做折中和简化"]}, {"name": "", "block_id": "dc61dd0b9dac403ba39628053b94cc7d", "text": ["好 我们接下来看看", "怎么来建立这个页的映射机制", "为了能够理解这个机制", "我们首先去了解一下我们整个这个", "X86 CPU里面怎么来完成", "基于页机制的一个地址映射的", "它的硬件操作过程怎么回事", "那可以看这幅图", "这里面假定已经建好了一个", "所谓的页目录表 页表", "这一块是它的物理内存", "对于一个地址 我们说一个虚拟地址", "它分了三块 分了三部分", "这实际上是一个典型的二级页表", "第一个是Offset这是32位的地址", "占了12位 那么中间的二级页表", "对应的页表项占了10位", "高的页目录项也占了10位", "那么高的这10位是用来去查找", "作为index查找这个页目录表里面的对应的项", "这叫PDE", "就是页目录的entry 在PDE记录什么信息", "PDE记录的是二级页表里面的起始地址", "可以放在这个地方", "所以说根据PDE里面的信息", "可以找到Page Table的起始地址", "同时根据第二级Table这里面的10位", "作为index来查这个Page Table对应的项", "称之为PTE", "这个PTE就是Page Table Entry", "它里面存的什么", "存的是你这个线性地址", "它所对应的一个页的起始地址", "这一个页大小多少", "其实由它的Offset可以算出来", "它12位 那意味着一个页的大小是4K", "那这里面PTE里面会存到", "这么一个页的起始地址", "它会按照4K地址来对齐", "那么这个作为Base Address", "来加上它Offset", "来形成最终的这个物理地址", "这就形成了物理地址", "这是说在X86里面完成的一个", "基于二级页表的一个地址映射关系", "那你可以看出来我们的硬件是", "这么来查找一个线性地址", "怎么转到一个物理地址", "那它为什么不是虚拟地址", "而称之为线性地址 大家想想", "因为我们前面说到了", "进入保护模式之后这个段机制是一定存在的", "即使这个00映射 我们说的对等映射存在", "你也不能说为此把段", "这个映射关系给取消掉", "这是它必须存在的一个很重要的原因", "也是为了上下兼容 所以这是线性地址", "那其实这个线性地址和", "我们说应用程序虚拟地址是一样的", "因为它是对等映射", "我们既然知道了这么一个映射关系", "我们来看一看 看一个实际的例子", "怎么能够把一个所谓的线性地址", "或者是虚拟地址转换成一个物理地址", "那我们需要建好这个页目录表", "需要建好这个页表 以及才能找到对应的页", "那么页目录表和页表它其实也是4K大小", "那么每一项每一个PTE", "或者PTE是32位的一项", "那意味着4K存1024项", "那我们需要把这里面的信息填对了", "才使得对于一个虚拟的地址", "这是一个虚拟地址 32位的虚拟地址", "0xC后面是1234567", "这随便举了一个例子", "它这个虚拟地址对应的物理地址多少", "可以算出来", "它实际上是根据这里面的", "PDE PTE来算的", "首先来看一下 它的高10位", "它的高10位其实是这里面", "你数这10项实际上这10项", "它其实代表的是304", "需要注意了一下这个304", "那意味着我们需要查", "1024项里面的第0x304项", "找到这个地方之后这里面会存一个信息", "这个信息比如说存的是0x233", "0x233它是按照4K来做一个偏移", "偏移了12位 向右偏移12位", "所以把它向左再偏移12位", "形成0x233000这么一个地址", "这个地址实际上是我们说", "它存的是Page Table的一个线性地址的基址", "找到这个Page Table之后", "我们的CPU会查中间10位", "中间10位实际上对应的是0x234", "234作为index", "找到PDE PDE存的什么", "存的是0x22333", "同样它也是按照4K对齐 右移了12位", "所以我们把它通过左移12位", "得到正确的你所对应的物理页的基址", "就是0x22333后面3个0正好是12位", "这是这个物理页的基址", "加上它的Offset Offset是它的低12位", "0x567 那么合在一起就形成了最终的物理地址", "就是0x22333加上567", "这就是它的物理地址", "所以说可以看到我们需要在lab2里面", "来完成对这两个表的建立", "从而可以实现正确的映射关系", "另外还要提醒一下 就是在这里面存的", "就比如说在页表项里面", "存放的地址内容是线性地址", "那这里面还有一点是", "第一个页目录的起始地址在哪儿", "这里面其实已经看到了", "它是一个特殊的寄存器 称之为CR3寄存器", "这个CR3寄存器来保存了", "页目录的表的起始地址", "那为什么只要一个CR3就够了呢", "因为它是二级页表 二级页表里面的", "页目录表这个4K的页目录表只有一个", "所以我们只需要一个CR3寄存器就够了", "好 我们前面已经把页表的映射机制", "给大家做了一个介绍", "接下来我们可以看看对于页表", "或者页目录表里面的一项", "到底包含了哪些关键信息 作为一个理解", "这里面列出来了页目录表项和页表项", "它的一个大致的属性的表示", "一共是32位 一个页表项", "和一个页目录表项是32位", "我们这里面除了关注它", "所谓的基址记录之外", "还需要关注里面的一些属性位", "因为基址 就是存放的无论是页的基址", "还是页表的基址", "物理页的基址 或者页表的基址都是20位", "还有剩下12位形成32位这么一项", "那么那12位其实很重要的信息", "就是低12位 低12位存了一些属性", "就你将来访问页的一些属性", "比如说这个页是否是只读的", "用R/W位来表示", "这个页是内核态访问的还是用户态能访问的", "那么有一个U/S 是user还是supervisor", "就是属于一般用户访问的", "还是超级用户访问的", "实际上就对应我们的用户态和内核态", "那么其实和我们前面说的", "段的安全保护机制有异曲同工之妙", "只是说基于段的保护机制它更加灵活", "它可以表示一个可大可小的一块区域", "到底是属于用户态还是内核态", "它的特权级是ring 0 ring 1", "ring 2 ring 3它有四级", "而对于页表而言 它就两级", "就是用户态和内核态 当然这也够了", "对我们前面讲到操作系统来说", "你只有两级是完全够的", "还有其它一些位我们讲内存管理的时候", "会再逐步展开", "它这些位可以有效的用来", "做内存的一些有效的管理", "那我们假定你建立好什么 建立好页表", "页目录表 都建好了", "这是我们ucore操作系统来建立的", "建好之后我们要使能页机制", "这和我们前面说的段机制是一样的", "保护模式一样的", "你需要对一个特定的寄存器", "这里面是CR0的一个PG寄存器", "它最高位 31位", "前面是最低位 最低位来enable保护模式", "那么我们最高位31位", "CR0的寄存器 31位 如果给它置1的话", "就代表启动了页机制", "这就是这个特殊的寄存器", "它是一个需要在内核态访问的一个寄存器", "好前面我给大家介绍一下CPU硬件的", "一个对内存的页表的机制建立的过程", "它的访问过程", "那我们操作系统怎么来使这个能正常运作", "我们ucore其实为此做了一系列的工作", "比如说我们前面说要分配页", "因为我们前面已经讲到了", "我们的内核以及ucore已经有一套", "基于连续内生存的一个", "内存分配的一套算法和机制", "从而可以说我们分配一个页", "分配一个4K来作为一个页目录的一个table", "然后再把这个里面的page给清掉", "清掉是为了做初始化", "然后你需要对除了这个页目录表之外", "还要建立对应的页表", "来对一定空间的内存来建立对应关系", "为此你需要在页目录表和页表里面", "填好相应的项", "那我们这里面建立的映射关系是什么", "0xC0000000到0xF8000000", "这块空间会映射到物理地址的", "0x00000000到0x38000000这么一个地址", "那这个其实是可以看出来", "它们的偏移值就是0xC0000000的偏移值", "虚拟地址比物理地址要多出来0xC0000000", "那实际上映射的是内核空间", "使得我们内核态的代码和数据", "都是在0xC0000000这个之上的一个空间", "那这个和我们在lab2时候", "你可以看到它在编译 链接", "形成最后的uCore代码的时候", "它链接时候用的起始地址就是0xC0000000", "这是对应起来的", "同时我们又建立了一个很奇怪的一个映射", "就是0x00000000-0x00100000虚拟地址", "映射到0x00000000-0x00100000这物理地址", "这是一个对等映射", "按道理说我们建好这个映射就OK了", "为什么还要建立一个对等映射", "且在enable了", "把这个CR0的31位给它置1之后", "enable了的页机制之后", "我们再次更新了GDT", "为什么要update GDT", "是由于我们的页机制已经起作用了", "页机制来完成从0xC0000000到0的映射", "就是0xC0000000是虚拟地址 0是物理地址", "这个映射靠页机制完成了", "那我们段机制只需要完成对等映射就OK", "就0-0映射就行了", "那我们说update GDT之后", "其实就是让我们段机制映射的关系", "从之前的不是那种对等映射变成对等映射", "但变成对等映射之后它又做了一次取消操作", "就刚才这里面会有一步", "就是完成从0到0x100000的映射", "这里面又取消了0到0x100000的映射", "这个映射是页机制的映射", "把它取消了 有点多余好像感觉", "做了一步又取消了 为什么", "大家思考一下 作为一个练习", "大家想一想怎么来解决", "那所有的这些代码", "是放在pmm.c里面来实现的", "这是ucore里面的一个文件", "专门属于管理页表机制的", "假设我们这个页表建立好了", "接下来我可能需要你再去完成", "再完成一个特定的内存的映射", "这时候你就可能需要去对", "这个PTE PDE来做一个处理", "甚至还会涉及说", "如果我们这个内存它属于", "另一块空间我们现在页表", "我们现在页表它没有对应到", "所以说我们需要干什么建立一个新的页表", "这就是我们的一个作业 我们练习", "你尝试着给你一个虚拟地址和物理地址", "你尝试着能不能分配一个对应的页表项", "使得虚拟地址能够正确的", "映射到对等的物理地址", "这就是我们说在页表里面来建立", "页的这个映射关系的这么一个练习", "作为我们这个lab2的一个主要的完成部分", "需要大家去完成", "好我们最后再看一下对于X86而言", "它确实比较全面", "既包含了段机制 也包含了页机制", "虽然我们这里面弱化了段机制这个映射关系", "但其实通过这个段和页一个组合", "我们可以形成一个更灵活的组织方式", "当然在现在操作系统里面主要", "还是用页机制来完成了整个的映射", "段机制它的作用更多的体现在安全管理上面", "那其实即使在安全管理上面", "段和页也有一定的重复", "在X86里面有一定的重复", "所以说可以看到我们会根据", "具体的运用情况来了解", "好 这是列出来在intel", "那个系统软件软件开发手册里面", "对应的章节", "它对页表机制有更深入的讲解", "站在硬件的角度", "怎么去便于软件开发人员", "去理解这个页机制", "可以看一看", "好那这就是这一讲的内容 谢谢大家"]}, {"name": "", "block_id": "5f7ff65b11c4489ba61b5cd20d5d2ce8", "text": ["各位同学大家好", "今天我们来讲非连续存储分配", "在前面我们讲到的连续内存分配中", "要给一个进程分配内存", "那必须分配物理地址", "连续的一块内存区域", "这给分配带来了很多的麻烦", "你比如说用户想要一块区域", "而在内存当中呢又没有", "满足这个大小的连续区域", "那这个分配就会失败", "基于这种现状 那提出了一种需求", "说我们是否可以不连续", "分配的内存空间不连续", "好 不连续呢 当然是说", "我可以找到它的机率会更高", "但这时候也会面临一些新的麻烦", "说我不连续之后我把哪些内容", "我是任意一个最小的单位", "一个字节就可以算成一个区域", "还是说我会受到一些限制", "那这个时候你这个分配到", "一个字节为一个单位太短了", "基于这种情况呢", "我们会选择不同的尺度来说", "我这个非连续内存分配我能每一块", "基本的块会有多大", "基于这种基本块大小的不同呢", "在我们这里有两种", "一种是段式 一种是页式", "那段式呢分的块比较大", "页式呢分的块比较小", "分的块小了之后呢", "我这两者之间的对应关系", "就会从逻辑地址到物理地址的", "对应关系就会变得比较复杂", "好 因为这个缘故", "所以我们这种对应关系呢", "就形成我们这里说到的页表", "好 还有一种方式是说", "我是不是可以", "把这两种方式结合起来", "那这就是我们这里的段页式", "首先呢我们来讲非连续内存分配的需求", "那在连续分配的缺点当中", "我们说你要求必须连续", "这一条很难达到", "好即使能达到", "在分配回收的过程当中", "里头也会有内碎片 外碎片", "好 如果说一个程序", "在执行的过程当中", "它需求的内存空间大小又有变化", "好 那这种变化呢就导致", "你很难进行动态的增加或者说减少", "这样最后的结果呢就是", "我们内存的利用效率比较低", "原因在于用户应用进程的需求", "你没有办法满足", "好 针对这种情况", "我们非连续内存分配", "那这时候要达到的目标呢", "就希望能够提高利用效率", "提高它的管理的灵活性", "具体说起来呢有这样几条", "第一个我希望分配的空间", "不再是有连续性的要求", "好 这样的话我找着你的", "要的大小的区域的机率呢就会提高", "第二个呢是说我们在用的过程当中", "每个进程它都要执行代码", "这些进程之间有很多代码是共同的", "那各个进程", "也会用到一些数据是共用的", "我们希望通过共享数据和代码", "实现减少内存的使用量", "也就是说我们在这里头", "两个应用进程都要用到同一个函数库", "那我把这个函数库的代码放到内存之后", "如果它们两个都能访问的话", "能够实现共享", "那这样的话我占用的内存区域", "不就变少了吗", "好 第三个是说我们希望能够变得灵活", "那我在这里头是不是分小了之后", "我想再要的时候我再给它加一块", "或者说其中某一块的大小的动态变化", "有了这些之后呢 我们就可以很方便的", "能够支持动态加载和动态链接", "好 这是这个目标已经说完了", "好像说起来这个目标很好", "但是这在实现的时候", "是会面临很多麻烦的", "首先第一个麻烦就是我们这里说到的", "虚拟地址到物理地址的转换", "那程序里头在实现的时候", "那它希望是说我给你一个地址", "然后告诉你", "你要告诉我", "它存在物理内存的什么地方", "这种转换呢如果它是连续的", "我只需要知道它的起头在哪", "剩下的问题就都在", "这一个进程的区域里了", "好 那如果现在不连续了", "那这时候这个转换呢", "就有可能是说你在哪一段逻辑地址", "你转换的区域在内存里的一个地方", "而逻辑地址的另一段", "你在这边是连续的", "到那边可能要转到另外一块区域里头去", "这两种区域的不同就会导致", "我在这里这个转换的过程会比较复杂", "好这种转换的复杂呢", "我们在实际实现的时候呢", "怎么来做呢 这里又有两种选择", "一种是用软件来实现", "比如说我要往内存里存数据", "像一个排序程序", "那由于我没有办法事先确定", "我要排序的数据的总量", "这时我给它分配", "多大的存储空间都有不合适的情况", "那我们会说在数据结构里学会有什么办法", "说我们在这里头可以先读一部分进来", "排完之后放到硬盘上去", "然后再读一部分进来", "排完之后放到硬盘上去", "那这时候呢", "最后我再把排好的再重新捋一遍", "那这就是数据结构里说到的外排序", "那这种办法呢也可以用到", "操作系统里的内存分配上来", "如果说你的代码空间存不下", "把所有的代码存内存里存不下的话", "那这时候我们可以说把其中的", "当前要执行的代码放到内存里头", "把另外一部分代码呢放到硬盘上去", "那这时候说这个倒怎么来做呢", "可以由软件来做", "也跟我们刚才说的", "数据外排序类似的办法", "那这种做法是", "我们通过你的操作系统软件", "或者说甚至于是应用软件来干这事", "另一种做法呢是硬件实现", "如果你要想用硬件来实现的话", "原因在于 我们现在", "做的地址转换过于频繁", "基本上是说你每执行一条指令", "都会去访问内存 那都要做成转换", "这时候用硬件来实现呢", "它的效果是比较好的 开销比较小", "而且这个转换相对来说", "它要计算的过程", "是比较简单的重复", "好 这样也适合于用硬件来实现", "好 那有了这个实现之后", "说还有一个啥问题呢", "还有一个问题是说", "我们在这里头", "要把这个进程分配的内存", "放到不连续的地方", "那我每一块大小有多大", "那简单来讲你可能会说", "要多大我给多大就完了", "那这时候是你连续的那样一块", "我分成小块之后", "我可以分成什么样的小块", "这时 我们前面连续分配里说到的", "内碎块 外碎块这些问题是否还存在", "好 这种分配的不同会导致", "这非连续内存分配的办法有很大的区别", "这里呢 我们有大致有两类办法", "一类叫做段式存储 一类叫做页式存储", "简单来说这两者区别就是", "段式存储分的块比较大", "它以一个段作为一个基本的单位", "那你在分配的时候", "这一个段的内容", "必须在物理内存里是连续的", "不同段之间呢是可以放到不同地方的", "这是段式 页式呢", "我就把它分成更小的块", "这个块的名字叫做页", "好 那你在分配的时候", "就是以页为单位来分配", "页与页之间呢是不连续的", "好 那由于这两者分配的情况的不同", "那实际上它在实现的时候", "会有很大的区别", "这些区别呢 会落实到我们后面讲到的", "段式存储管理和页式存储管理的实现细节", "好 有了这些描述之后", "那我们就可以来具体讨论说", "我的段式和页式到底是怎么实现的"]}, {"name": "", "block_id": "e23320e97ff4411a9832ff76ac8bd3d8", "text": ["接下来我们讲快表和多级页表", "那在刚才我们说", "快表是利用缓存的机制", "来减少对内存的访问", "而多级页表 是通过间接引用的方式", "来减少页表的长度", "那么它们具体怎么做的呢", "快表实际上就是把近期访问过的页表项", "缓存到CPU里头", "底下是我们在前面没有使用快表的时候", "正常情况下 你获取物理页号的过程", "逻辑页号在内存当中去查页表", "找到物理页号 然后得到物理地址", "那现在在这里缓存之后怎么办呢", "我在CPU里头 加上一组关联存储器", "关联存储器是什么呢", "关联存储器是说我这里有一个key", "我进来之后它可以并行的", "同时查所有的这些表项", "有匹配的 把匹配的找出来", "那你说这里", "原先在内存里访问一次你觉得费事", "到这里来你访问这么多次", "它就不费事吗", "实际上在这里头呢", "由于是在CPU里头", "它的速度会很快", "当然由于它的速度快 成本高 功耗大", "所以这个地方不能做的很大", "如果说匹配得上", "那这时候呢它直接得到它的物理页号", "也就相当于我逻辑页号作为key", "找到它的物理页号", "那我就得到你的物理页号", "这就不需要到内存当中访问了", "如果说在这里头你找的时候", "因为你这里容量很小", "肯定没有办法把整个页表", "全部装到这个CPU里头去", "好 那这些有不命中的", "那不命中的时候呢", "它就会从这儿", "你得再去找内存当中的页表", "这时候你只能是两次访问了", "好 找到这个页表之后呢", "我得到它的页帧号", "同时我把这个内容", "再缓存到CPU里的快表里头去", "下次再访问这一页里的数据的时候", "你就不必要再去访问内存了", "好 如果说我们在这里头", "99%的访问我都是在这个TLB里", "快表里命中的", "那只有一次1%", "是要到物理内存当中去查页表的", "这时我们的性能就能大幅度提高", "这是快表的基本原理", "好 接下来我们介绍多级页表", "多级页表是通过间接引用", "将页号分成若干级", "比如说在这里头", "我们原来的逻辑地址的格式", "是页号加页内偏移", "现在变成了三级页号", "P1 P2 P3 然后再加上页内偏移", "和它相对应的 我们的页表呢", "也会因此而形成一个树状结构", "比如说原来一张大的线性页表", "我把它切成若干段", "这切到段的个数呢", "和你最后一级页表的宽度是一致的", "然后它每一个子页表的起头呢", "作为上一级页表的物理页号", "填到上一级页表当中", "在第二级的页表的宽度", "和你第二级页号的宽度是一致的", "然后再一个 第二级页表的起头", "再作为第一级页表项的物理页号", "那这时候它的项数", "和你第一级页表的宽度是相一致的", "在这种情况下", "我们要访问相应的物理内存单元", "那怎么访问呢", "是从第一级查第二级 再查第三级", "那这时候我们整个访问次数就是K+1", "你这里是三级 那就是四次", "具体的访问过程是这样的", "第一级作为第一级页表的偏移", "找到第二级页表上的起始", "第二级页表项", "再作为在第二级页表当中的偏移", "加在一起找到第三级页表项的", "起始页号 物理页号", "然后这地方呢 这一页呢", "每一页这些页表都是和页相对齐的", "所以从这儿呢它就不再有页内偏移", "好 然后从这儿找到", "最后的 你要实际访问的", "那个内存单元的物理页号", "再加上最后一次物理内存的访问", "那通过这种方式", "我们可以有效地减少每一级页表的长度", "那如果说 你是所有的页表项都存在的话", "你用多级页表实际上对它的存储并没有减少", "但实际上 我们实际运行的进程呢", "多数并不会用到整个所有的页表", "所有的内存地址空间 逻辑地址空间", "在这种情况下", "我们可以通过各级页表当中的存在位", "把那些不存在的给省掉", "如果说我在第一级页表里头", "有一个下一块区域都不存在的话", "那么这样一来", "我节省出来的空间就会大幅度增加", "我使用的空间就会大幅度减少", "好 用这种方式呢", "实际上我们使用多级页表呢", "可以有效地的减少页表的大小", "下面我们通过一个简单的", "但是更具体的例子 二级页表", "我们看它是怎么做的", "这儿呢我们把20位的地址总线", "把它切成了三段", "0到10 1K", "10位作为页内偏移", "然后前面切成两个五位的页号", "第一级和第二级", "那在实际访问的时候是什么样", "这是这里头第一级", "那第一级页表的起头在哪呢", "它是写到固定寄存器里的", "在因特尔的CPU上", "有一个叫CR3的寄存器", "好 在这个寄存器里头存的起始位置", "加上你的第一级的页号", "作为它的索引 下标", "找到相应的页表项", "这是第二级页表的起始页号", "好 那第二级页表呢", "你找这个起始位置", "加上第二级的页表号", "把它俩找到你的实际的物理页号", "那这时候把偏移直接搬过来", "那就得到你的物理地址了", "有了这样一种做法呢", "我们就可以很方便地", "利用多级页表减少你整个页表的长度"]}, {"name": "", "block_id": "20f89a36ca3c401b9b393f1b2b4ed653", "text": ["我们再接下来看一下练习二", "练习二也是一个实践的过程", "我们希望大家能够通过", "我们硬件模拟器qemu 还有GDB", "能够执行和调试lab1中的软件", "这里面给出一些小的练习", "比如说我们能不能单步跟踪BIOS", "单步跟踪0x7C00处的设置断点", "然后把它整个执行过程代码给记录下来等等", "这是我们后续要去完成的实验", "这里面呢 我们可以看到", "这里也给出了提示", "我们在这里有一个叫做makelab1-mon", "这是一个什么呢", "那这条命令你可以看出来", "它这里面大致是干了两个事情", "第一个是让qemu把它执行的指令给记录下来", "把log信息给记录下来", "放到这个地方 q.log", "第二个是和我们的GDB结合", "结合来调试", "来可以调试正在执行的Bootloader", "需要注意 这里面还没有到uCore", "还在Bootloader阶段", "这个比较重要", "它是以前初始化的一些执行指令", "我们看看这里面有什么内容", "那这个呢都是GDB", "GDB能够识别的一些命令", "它第一个 比如说加载并kernel", "这是加载符号信息了", "这实际上是uCore的信息", "这里其实还没用到 第二个呢是", "第二条指令是与qemu进行连接", "通过这个TRP进行连接", "刚开始的时候", "BIOS是进入是8086的16位实模式方式", "那一直到0x7C00在BIOS这个阶段启动", "最后把Bootloader加载进去", "把控制权交给Bootloader", "那么Bootloader第一条指令", "就是在0X7C00处", "所以说 在这个地方", "我们设一个断点break", "break 0X7C00", "然后让这个系统继续运行", "那我们就可以看到", "它会在这个断点处停下来", "那我们可以把相应的这个指令给打印出来", "最后一条是x /2i $pc", "就是把这个 我们PC 就是我们EIP", "也就是指令的指针寄存器", "它存当前正在执行这个指令的地址", "那么X是显示的意思", "/2i是显示两条 i 是指令 是个含义", "那么我们可以看看执行下会是怎么一个结果", "比如说make lab1 mon", "它前两个窗口 一个是qemu", "这里面是qemu 可以看到已经启动起来了", "但是它断下来了 断在哪呢", "0X7C00处 我们这已经看到了", "那这里面 其实还可以显示更多条数信息", "比如说我们可以在x/10i $pc", "可以把当前的10条指令都显示出来", "那这些指令在哪呢", "大家想 这个指令在什么地方", "我们启动代码这个目录下存放", "就是Bootloader那 其实也可以看到", "在这边 从第16行开始 它这个指令", "和我们刚才看到的GDB里面的指令", "我把这个先关掉", "和我们看到GDB里面的指令是一样的", "可以看到其实我们现在", "已经断到了Bootloader起始的位置", "我们接下来可以让它继续运行", "那我们可以看到这个效果", "我们可以把这个显示在这儿", "让它一直位于顶端 OK", "那这时候它就一直会出现", "continuing一下 好", "你可以看到 这时候它跑的很快", "就是这里面", "它已经把我们uCore都加起来了", "可以进去运行了", "Ctrl+C断掉", "OK那现在就停下来了", "这就是一个很方便的调试Bootloader的方法", "包括后续的uCore也是一样 很类似", "好 那这是一些提示信息", "比如GDB里面怎么去单步调试", "那这是命令方式", "我们上次讲lab0所以给大家提示过", "怎么能够在ECLIPSE环境下", "来提升它调试 这个命令比较简单", "所以我们用GDB直接来调试了"]}, {"name": "", "block_id": "ca3bd9d8e6c94c5c9a51e17ea7c10168", "text": ["好 接下来我们讲一个", "连续内存分配的实例 伙伴系统", "伙伴系统实际上是一种", "我们刚才说的", "连续存储分配一种办法", "它在这里比较好地折中了", "分配和回收过程当中", "这种合并和分配块的位置 碎片的问题", "具体怎么做的呢", "我们在这会分成两部分", "一个是对它基本做法有个介绍", "第二个是说在我们uCore实验系统里", "它的伙伴系统是怎么实现的接口", "伙伴系统实际上是", "它是把整个你可以分配的分区的大小", "约定为必须是2的幂", "这样做之后 任何一块要分的时候", "只是把它从中间切开", "它不会以其它方式来切", "只是两个小块合在一起", "变成一个更大的", "在这里头如果说你在分配的时候", "你需要一块它的大小", "实际上可用的块", "如果它的大小比你需要大小的2倍还大的话", "我就把它切一半", "然后再跟你来做比较", "如果说在这里你比它1/2还大", "但是没到当前大小的话", "它就直接把这块给你", "具体说起来就是", "如果说它比你2倍还大", "那我就把它切半", "切半之后仍然比你2倍还大", "那这个时候我在继续切半", "一直切到某一个状态", "那再切你就比它大了", "而当前状态是比你的2倍小", "这个时候我把这块就分给你", "那这个时候我们形成内碎片", "最大可能是多少", "最大可能是你这个大小的1/2减1", "也就是说你正好需要1/2的时候", "我就可以把它分半", "你再多一个字节", "我有可能就给了你差不多一倍的大小", "这是Buddy System它的基本道理", "下面我们来看伴侣系统的实现", "首先我们来看在伴侣系统当中", "我们需要维护的数据结构", "在这里头我们空闲块", "维护的是一个二维数组", "这个二维数组第一维", "是空闲块的大小", "由小到大我排成第一维", "在相同大小这些空闲块里头", "我按照它的地址排序排成第二维", "这是我们这里的空闲块的二维数组", "然后在起头的时候", "整个系统里只有一块空闲块", "这是整个空闲内存区域", "在分配的时候是什么呢", "分配的时候我是由小到大去找", "比我需要大小更大的空闲块", "如果说在初始状态下", "我找到整个这是一块", "这个时候我就会有第二步", "找到之后我会看", "如果这块过大", "所谓过大是什么意思呢", "就是我需要大小的二倍比你给出这块还小", "我就把它切成一半", "变成2的u-1次幂", "然后再看 这个大小跟我需要块的大小", "是不是还比它大", "是不是比它2倍大", "如果比它2倍还大我就继续分", "分完之后变成两个空闲块", "把它放到空闲块列表里去", "二维数组里头", "然后这个时候一直到找到", "我需要大小是空闲块1/2还大", "但是又没它本身大的时候", "这个时候我就把这块分给它", "这是分配的过程", "然后在这 我们通过一组", "实际的例子来看分配流程", "假定我最开始的时候", "它的大小是的1M", "然后在这里头我们需要是100K", "100K的话1M切成一半512", "256 128 切到128的时候", "能够满足我的要求", "这个时候切完之后的情况", "切成一半 再切一半 然后再切一半", "128 然后这个时候它的大小", "比我需要100K要大", "但是比我需要的100K的2倍200K要小", "OK那我就把这块分配给它", "第二个分配请求是240K", "240K那我们从这里看", "比它大256K 256K是比它大", "但是比它2倍要小", "这个我们应该要分配到这", "分配下来的结果是这样的", "给它分配256K的空间", "第三个是给它分配64K", "64K我们看比128小", "那128的1/2是64正合适", "那这个时候我把它分了", "把128K分成两半 搁在那里去了", "再下一个是说我需要256", "那256我们在这里空闲的只有512比它大", "切成1/2", "这是分配之后的结果", "然后再往下我们是释放B", "释放完了之后", "按照我们原来连续分区的分配", "我有一个合并的问题", "我们说这块回来之后", "它没有办法跟64K合并", "因为合完之后的大小", "不是我们前面说正好是2倍", "也没办法放回到空闲分区的数组里去", "这个时候我就变成两个空闲分区", "然后我再释放A那128K还回去", "它也没有办法跟别人合并", "它是单独一个", "然后这个时候我申请一个75K", "75K仍然可以放到那儿", "这个时候换成75K 给了它128K", "这个时候我再看", "这个时候把C释放掉", "这个C释放掉的时候", "这个地方一个64", "和旁边64它两合起来的时候", "正好是原来128", "可以把它合在一起", "这个时候就变成128了", "128和这个能合吗", "不能合它不能构成2的幂", "即使的能构成2的幂 它也还会有问题", "然后这个时候我再释放E", "把这几个最后它们三个就会合在一起", "最后再还回D 整个过程结束", "那么这个时候它把整个合在一起", "在这个过程当中", "我们已经看到了它分配的时候情况", "我找一个比它大的 最小的空闲块", "然后看看是不是比它2倍大", "如果是 切半", "如果不是 OK就是它", "这样我们分配的过程就有了", "接下来我们把刚才说的", "合并的事再明确一下", "合并的时候我放到空闲块里头", "比如说我在这里分配任何一块", "合并的时候需要满足条件", "那满足条件是什么样呢", "大家看看 我在这里头", "如果这块还回去", "它可以和哪块合并", "和这块能合吗 大小不一样", "这是大小一样的 到底它和那块合", "我们在这里 第一个条件", "就是相邻的两块必须大小是一样的", "然后第二个 它必须是相邻的", "如果说你隔的话", "它是合不到一起的", "在这我们也没有移", "还有条件吗", "还有就是比如这三块", "如果这块和这块合那是不行的", "原因在于它俩的起始位置搁完之后", "这同属于上面两个分支", "这种直观意思表达", "实际上形式化表达出来就是", "相邻的两块 低的地址", "必须是2的整数次幂", "如果像这个地方", "它没办法是它的整数次幂了", "这个时候我们第三个条件就是", "低地址的空闲块起始地址", "必须是块大小的2倍的整数次幂", "有了这个之后", "那我们的伴侣系统就可以", "在实际系统当中来进行使用了", "目前在我们用到的Linux Unix", "都有Buddy System的实现", "它是用来做内核里的存储分配", "如果有同学想继续去了解它的实现", "在这有一些参考信息", "网上也有很详细一些实现", "大家可以去参考", "接下来我们说", "在我们用到uCore系统里头", "我的内存分配到底怎么做", "这个地方 把物理内存的管理", "提供了一个标准接口", "在这个接口里 实现了一组函数", "和相应的一些保存的信息", "第一个是管理算法的名字", "给了一个字符串做标识", "然后有一个初始化", "然后有一个检查", "这个基本上是辅助性的函数", "上来初始化的时候", "是我数据结构的起头", "检查是我在这个地方", "我函数写完了之后是不是好使", "我的一些测试就放在这个里头", "中间我们关心主要的函数是这两个", "是分配和回收", "当然在分配和回收分给一个进程之后", "我们在用的时候", "还得把它映射到进程的地址空间里", "所以会有上边这一个函数", "和底下这个函数", "底下这个函数是告诉你", "这个空闲分区里还有多大空间", "我们在这里要实现的时候", "实际上你就实现这两个函数就行了", "在我们uCore已经有Buddy System", "实现伴侣系统", "在这里实际上我们最后", "就把你函数写好之后", "只需要往这里一填", "把你函数名字填进去", "内核里的上层服务就可以", "用它来分配自己所需要存储空间了", "这个地方我们要填的", "从分配和回收的角度来讲", "主要填的是这两个函数", "具体的内容大家可以下去看代码", "好 到这个地方为止", "我们就说清楚了", "连续存储分配里头 它如何在做", "在这里要面临一些什么问题", "我们目前有一些什么样的解决方式", "这些解决方式都是从什么角度来考虑的", "今天的课就上到这里 下课"]}, {"name": "", "block_id": "f80d7edde9564a5db42065bc5d11f939", "text": ["我们刚才对内存管理的功能", "进行了一个基本的讨论", "接下来在讨论具体的内存管理算法之前", "我们有必要来讨论一下", "内存管理当中地址的生成", "我们说 从你写的程序里用到的符号", "到最后在总线上出现的物理地址", "这中间有一个转换的过程", "在具体说转换算法之前", "我们需要知道地址的生成过程", "和在生成过程当中并不是任何一个", "你想要访问的地址都是会允许你访问的", "这里还有一些安全的检查", "或者说合法性的检查在里头", "接下来我们看地址空间的定义", "我们在机器里总线上看到的地址", "是这里我们所说的 物理地址", "所有的物理地址空间所构成的空间", "叫做物理地址空间", "它是由硬件支持的", "通常情况下 比如说", "我们机器里说有多少位地址总线", "指的就是这里的物理地址总线的条数", "比如说32位的", "通常情况下就是32条地址线", "在我们这里它的编号是从0", "比如说32位 是0到4G减一", "那么这是从0开始一直到它最大编号", "这个编号在存储单元角度来讲是唯一的", "但是这种唯一", "实际上对于我们写程序来讲", "是不太容易来使用的", "因为我到底用哪个地址", "在程序写成之前 或者运行之前", "我可能是不知道的", "那么这样一来", "我们在这里用到第二个地址", "是逻辑地址", "逻辑地址是CPU运行的时候", "里边的进程看到的地址空间", "那通常情况下", "对应我们可执行文件里的那一段区域", "加载程序的时候", "你的程序加载到内存当中 它变成进程", "这个时候在你的可执行文件里的", "0到它最大值", "这个地方在相应地址空间里有一段区域", "这段区域就是我们进程的逻辑地址空间", "逻辑地址转换成物理地址", "就是我们后面会说到的方法", "那么这时我们这里访问到一条指令", "这条指令在执行的过程中", "它会访问相应的内存单元", "这些内存单元的地址从哪来", "就是从这 逻辑地址", "根据我们后面会说到方法", "转换成物理地址", "最后在总线上访问相应的存储单元", "我们在后边 一直说需要大家理解", "我到底用到逻辑地址", "物理地址分别是什么", "它们之间的转换过程是什么样子", "接下来我们看逻辑地址的生成", "大家在写程序的时候 通常情况下", "现在我们写程序都是用高级语言", "高级语言里头 这就是一个小例子", "一个程序 它有一个保留字", "prog到end", "这是它的开始和结束标志", "然后中间我调用了一个函数", "这个函数就是一个地址", "我们通常在写函数的时候", "里头你不会写 比如说0X多少多少", "作为你的函数的名字", "这个很不容易记", "我们会用一个符号来表示", "用符号之后 不同的函数之间", "这些符号之间", "它们就没有一个先后顺序的关系", "那你放到内存里头", "我可以把它放到任何一个位置", "这是我们在写程序源代码的时候", "你所希望见到状态", "然后这个源代码我们就会进行一次编译", "源代码里的这些语句", "我们的CPU是没办法直接认识", "我们为了让CPU能认识", "必须转化成CPU能认识的指令", "指令我们转换出来的第一步", "是把它转变成机器能认识的指令的汇编码", "这是汇编指令", "这样转换过来之后", "我们看到它会转变成函数调用", "jmp或者是call", "都是会有的", "然后后面仍然用的是符号名字", "这还只是汇编的源代码", "那我们通过编译之后得到汇编码", "然后我们会再对它进行一次汇编", "汇编之后实际上我们就变成了二进制代码了", "这个时候就是实实在在是机器能认识的指令", "这个时候里头的符号就不能再是", "我们前面讲的这些字符串了", "而必须是地址空间里的某一个位置", "比如这个地方就是75", "那75 这是从0", "假定这个长度是蹦到这个位置", "那么就是你在当前的位置蹦到75", "这个地方用到的就是编号", "这是一个编号实际上是", "在这里头我可能会用到别的符号", "别的地址", "比如我有一个函数调用", "从模块A调用模块B里的一个函数", "在这个调用过程中", "在你做汇编的时候", "另一个模块的位置你并不知道", "这时我需要再有一个链接的过程", "把多个模块和你用到的函数库", "搁在一起 把它排成一个线性的序列", "排了之后这个时候我就知道", "你跳转的另一个符号的位置在哪", "比如说我们在这里头你自己会移动", "模块之间也会有", "那这个时候我会告诉你", "这个地方蹦完之后", "我放的位置往后挪了", "前面是放的函数库", "所以我起头的位置往后挪了100", "那我这变成了175", "这个175实际上就是从0开始", "我只是在这一个文件内的", "如果说我的程序这个时候去运行", "那么它运行的时候放到什么地方", "不一定能正好放到0的位置", "那这个时候我在加载的时候", "还会再有一个重定位", "这个重定位是说我原先的0", "这是175", "现在我加载进来之后", "我把它放到1000的位置", "那这1000呢 从1000到1175", "这个时候我的跳转", "我原来蹦到175", "你蹦的位置就错了", "我要统一把这个要平移一遍", "这我就变成1175", "这是你在加载时候的", "由操作系统提供的", "重定位的功能要干的事情", "有了这个之后", "我们的程序在跑的时候", "它就变成是实实在在的地址了", "这是逻辑地址", "然后 我们在获取这个地址的时候", "可以在什么时候来做到", "刚才做的是直接加载的时候", "但实际上地址生成机会有这样几个情况", "第一个是编译", "假定我知道我最后要放的位置", "我在编译的时候就可以把这个地址写死", "如果是这种情况 你的起始地址发生变化", "你就必须重新编译了", "这种情况现在在什么地方出现", "像我们用到手机", "如果说你的手机是功能手机的话", "不是智能手机", "这个时候里面的程序通常情况是写死的", "不允许你买了手机之后", "自己再往里装地址本了", "或者说装软件之类的", "那么这个时候通常情况下", "在前面这些都是写死的", "还有一种情况是允许你加载到不同地方", "比如说像我们现在的智能手机", "那你就可以在买到这个手机之后", "我再往里加我的程序", "这个时候写程序的人就没办法知道", "你这个程序最后会加载到", "你的系统里的什么地方去", "如果是这种情况 我在加载的时候", "就必须做重定位", "也就是说我根据我装到内存位置里的不同", "我要把里头那些符号的名字或者跳转的地址", "把它重新捋一遍", "通常情况下在我们的可执行文件里头", "它前面有一个重定位表", "那这个重定项目表", "里头包含内容就是", "你在这个程序里头", "到底哪些地方需要去改的", "加载的时候把这个都改成绝对地址", "那你的程序就可以跑了", "这是我们刚才见的情况", "还有一种情况 是执行时生成", "这个相当于我们在前面用的", "一直就是相对地址", "那么到执行的时候", "执行到这条指令的时候", "我才可以去知道它确切访问的是什么地方", "这种情况出现在", "我们使用虚拟存储的系统里头", "也就是说我执行一条指令", "这条指令访问的位置 访问到那之后", "有可能你当时把这一块区域", "放到内存的某一个位置", "这个时候它有一个映射", "映射过去之后你找到相应的位置", "那这个时候只是在执行这条指令的时候", "才会做这种映射", "这样做就有一个什么样的好处", "我这个程序在执行的过程当中", "我就可以把它所在的位置", "在物理存储的位置 我可以挪", "而如果说是前面两种情况的话", "你不但要求你在地址空间是连续的", "同时在这里头 它运行起来之后", "你是不能再动它的", "比如说在这里头我加载的时候做了重定位", "我已经写了绝对地址了", "由于你存储空间不够", "或者说别的程序的存储空间不够", "你把它位置往后挪了一段", "你这么一挪完之后 你那些位置就不对了", "所以从灵活性的角度来讲", "我们在执行时候生成这个地址是最好的", "而前面几种它有一个好处是简单", "所以在这里 不同系统里这几种做法", "我们现在都是有采用的", "下面我们通过一个例子 图示", "来看一下地址的生成过程", "这是我们在前面已说到过的系统结构", "CPU 内存 I/O设备", "我们一条指令的执行", "比如说在这里头", "CPU当前正在执行一条指令", "这条指令是movl指令", "这条指令在执行的时候里头有地址", "这个地址在CPU里先看到了", "然后这个时候我的MMU", "它依据这边的页表", "来把你这边见到地址翻译成物理地址", "翻译成物理地址之后", "然后CPU里头有一个控制器", "这个控制器负责把你得到的物理地址", "和相关总线控制信号送到总线上去", "这个时候存储单元 存储芯片", "这个时候会识别总线上地址和控制信号", "依据你控制信号的 到底是读还是写", "总线上有一组相应的持续逻辑的交互", "如果是写 就会把这边CPU送过来的数据", "写到内存当中 指定的存储单元上", "如果读那就从指定的内存单元当中", "读出数据 放到数据总线上", "然后CPU拿回去", "这是它的一个交互过程", "在这个交互过程当中 CPU能干什么呢", "CPU能干的是", "地址转换过程它的影响", "实际上在每一次访问的时候", "它是不依赖于软件的", "是由硬件来完成这个转换的", "但这个转换的表", "我们是可以通过操作系统", "来建立这两者之间的关系", "这是我们后边会说到的页表的功劳", "接下来我们讨论", "在地址生成过程当中的地址检查", "这里是一个图示", "说明我们CPU在执行指令的时候", "它的地址处理过程 生成过程", "这是一条movl指令", "movl指令在CPU执行过程当中", "它会产生逻辑地址", "这个逻辑地址", "比如我访问的是数据段的数据", "那好 这时候数据段", "它有一个段基址和段的长度", "如果说你从数据段去访问的", "偏移量超过这个长度", "这个时候的这个访问应该是非法的", "对于这种情况 在每次访问的时候", "每一条指令在访问的时候", "它都会去检查你的段的长度和偏移量", "是不是有效的范围", "如果不是", "那么这个时候就走上面这一条", "告诉你内存访问异常", "这条指令执行失败", "进行相应的错误处理", "这个由操作系统来做", "另一种情况是说", "这里检查完的结果", "你访问的偏移量", "是在0和你的最大长度之间", "我认为这是合理的 是合法的", "这个时候它会和段基址加在一起", "得到你的物理地址", "比如说在这500 1000", "那就是1500", "从这访问到你对应进程的", "物理地址空间里去", "那在这个过程中我们说", "操作系统可以通过用指令来", "设置相应的长度和段基址", "这是会我们可以通过软件方法来", "影响到我这里做相应检查", "有了这个检查之后我们就有了", "从符号一直到你的逻辑地址", "逻辑地址在执行过程当中转变成物理地址", "并且在这个过程中有相应的检查机制", "这是我们在这里说到地址的生成和检查"]}, {"name": "", "block_id": "f9d44191eec1410689e4f929d765430a", "text": ["接下来我们介绍缺页异常", "那么缺页异常呢", "在我们前面讲页式存储管理里说", "缺页异常就是发现页表项当中这一页", "不在物理内存当中我就会产生缺页异常", "缺页异常把相应的内容读到内存里头来", "我再重新执行这条指令", "这是我们前面对缺页异常的描述", "那实际上在缺页异常里头呢", "还有很多要处理的内容", "我们现在先来介绍一下缺页异常的处理流程", "那在这儿我们现在有一个图来说明这个过程", "首先是我在CPU里头呢要访问一条指令", "比如说load M", "这条指令呢它会找m所对应的页表项", "找到这一项之后 如果这一项是有效的", "那这时候呢或者是驻留位是为1", "好 这时候它就直接去访问去了", "如果这一页是无效的", "那这时候就会产生缺页异常", "缺页异常呢就会导致操作系统的", "缺页异常服务例程的执行", "这个缺页异常服务例程它干什么呢", "它缺页之后那首先第一个它得找到", "对应着那一页在外存当中存在什么地方", "如果说有这一页之后找到了", "那这时候呢我把这一页读到内存里头来", "读到内存里头来就会带来一个问题", "我在内存里我到哪去找这一页", "我肯定要找空闲的页面", "如果找着那这时候呢我把这一页读进来", "并且回身要修改相应的页表项", "那页表项修改", "修改完了之后然后我再重新执行这条指令", "OK 这样以来的话 我这个缺页异常呢", "就算是 大致的流程就算处理完了", "但是在这个过程当中如果说", "这个你要找空闲页找不着", "那这时候怎么办呢", "那这时候我们还需要把这个流程", "再对这一段呢再做一个细化", "那也就是我们这边说的", "说我缺页异常我要在这里", "要去找空闲的物理页面", "如果能找着那这事没问题了", "直接蹦到我们刚才说的复制", "说的后面一步 如果没找着呢", "那这时候我就得把另外一页把它写出去", "我根据页面置换算法来找", "找一页我不常用的我把它替换出去", "假定说这一页的物理页帧号是F", "它对应的逻辑页号是Q", "好 我就找到这一项", "那么找到这一项之后我把它淘汰掉", "这时候我又有一个要判断的", "这个Q对应的这一项是否修改过", "如果修改过那你直接把它扔掉是不行的", "我还必须把这一页呢写到外存当中去", "给它找另外一个地方把它写那儿去", "然后写完了之后呢", "这一项我就可以拿回来用了", "那在这之前呢还有一个事", "要修改这个Q所对应的页表项的内容", "把这一项置为是无效", "以便于你下次再来访问的时候", "这一项我已经分配给别人了", "好 那如果说这写完了之后", "那这时候E 就是我们刚才说到这儿", "也就相当于我这儿有了一个空闲的页帧了", "我把相应的这个P对应的这一页", "把它装到这里头来 然后这是我们这里说的五这一步", "修改P对应着的页表项的驻留位", "表示这一页我已经把它对到这儿来了", "好 然后这里的6对应这一步", "我重新执行产生缺页异常的这一条指令", "整个这个处理流程就算处理完了", "那么有了这些介绍之后呢", "我们说对这个缺页异常呢有一个了解", "但是如果说你和实际的操作系统代码当中", "缺页异常处理相比较这个流程仍然是非常简化", "那实际代码里头比这处理又要复杂一些", "这个希望大家再去看实际代码来逐步", "把这个过程细化和加以理解", "好 那接下来我们还有一个问题是说", "我们刚才把在外存里找的那一页", "外存那个地方我怎么去找它呢", "那这个时候我的外存保存这一页放在哪", "我必须很方便地找", "在我们现在的操作系统里呢有两种搞法", "一种搞法呢是说", "我直接做一个分区叫兑换区", "这在Linux Unix都是这么干的", "另一个呢 我是可以用一个文件来存这些东西", "在文件里头我采用特殊的格式", "来映射这些页面", "因为在这头我通常都是固定大小的页面", "所以它的文件可以针对这种做法来做优化", "好 这是我往哪放的事", "这时候是不是所有东西", "全放这里头呢也不是这样", "因为我们在外存当中的这些", "进程地址空间里的内容", "有一些是我可以放到这里头兑换区里头的", "而另外一些呢你比如说像我们这里说到", "可能选择另外这样两种 一种是代码", "我本来代码是在可执行文件里头的", "那如果说你生生给它另整一个地方", "去把它复制过去保存这是没必要的", "所以这时候代码是直接指向你的可执行文件", "而还有一些就是共享库 这些库呢 实际上", "也是它有相应的目标文件来存放", "这时候呢 你也没必要把它复制到这里头来", "因为这两项内容呢我们都是不去修改的", "好 其它的数据段 堆栈段那这些呢", "你都可以放到你的兑换区里头", "和兑换空间里头", "好 最后一个问题我们来讨论", "虚拟页式存储管理的性能", "我们如何来评价", "虚拟页式存储管理的性能呢", "在这呢我们定义了一个指标", "叫做有效存储访问时间", "这个有效存储访问时间呢", "如果说你是在页式存储管理里头没有虚拟的话", "那么它就是访存的时间", "因为我所有的内容都在内存里头", "我直接读就可以 读内存的时间是固定的", "大家是一致的 但是有了虚拟之后", "那我们就只能有一部分是", "直接从内存当中访问的", "而另外一部分呢我是从硬盘上读的", "那从硬盘上读呢 要涉及到缺页异常的处理时间", "那这时候根据你缺页率", "缺页率E减P那是你的内存访问", "而概率P呢你是从硬盘上访问", "这俩加到一起平均下来就是", "你的存储访问的有效访问时间", "那下面我们用一个例子来说", "假定我访问内存的时间是10个纳秒", "而一次访问磁盘的时间是5个毫秒", "而在这里头缺页率设置为P", "那缺页里头有一些需要做过修改的", "页修改概率为Q 那这时候", "我的有效存储访问时间是多少呢", "在这儿这个表达 10纳秒乘以1减缺页率P", "那这时候存储在内存里情况的访问", "然后剩下的是会在磁盘上的访问", "我们在这儿缺页异常处理时间", "主要是你磁盘访问时间", "而代码执行时间我们在这儿忽略不计了", "好 那在这里头呢 基本上是说5个毫秒", "是10个纳秒的50万倍", "50万倍乘在这里头来", "然后这边呢缺页率是概率P", "然后在这里头呢它是乘1", "还要加上一项什么呢", "对于修改过的我是两个5毫秒", "那这时候再加上一个Q", "这个P乘Q是你这个缺页情况下再加上页修改", "这俩搁在一起那最后是我们的有效时间", "如果你想让这个最后这个", "有效存储访问时间和这个10纳秒不相上下", "或者稍微大一点的话", "那么这个时候你的缺页率这个P必须足够小", "以至于可以把这个50万倍基本上给抵消了", "那这样以来的话我这个地方有效时间", "才会可以和原来的存储访问相一致", "那这是我们说虚拟页式存储管理的性能", "那到这个地方呢", "我们关于虚拟存储管理的概念就讲完了", "那我们在这里还有一个问题没有涉及", "就是我们在这里说我缺页中断", "中断完了之后我要用页面置换算法", "来选择一个页面来 用来存我先要加进来东西", "那这个地方如何选择呢", "这是我们下一次要讨论页面置换算法的内容", "好 那今天的课就上到这里 下课"]}, {"name": "", "block_id": "8e696de63dc04ecda4c1367760b88384", "text": ["好 接下来我们介绍中断异常和系统调用", "那在这里呢 我们会说中断异常和系统调用", "它到底是用来干什么 解决什么问题", "然后这几个的应用场景", "或者说他们之间有些什么样的区别和联系", "它在用处的时候 它们之间会有一些差异", "但是也有很多会共同的东西", "再一个就是说我们需要来说明", "中断异常和系统调用它的实现机制", "首先我们说在上前边的内容里头已经说过", "操作系统 计算机系统启来了之后", "它会加载操作系统的内核", "然后就把控制权转给操作系统内核了", "在这前面这一段呢 是可以信任的", "但是在操作系统内核之上呢", "实际上我们还有很多的应用程序", "这些应用程序我们没有办法", "对它做到完全的信任", "而这应用程序要使用操作系统内核提供的服务", "那这时候怎么办呢", "实际上我们就需要解决一个操作系统内核", "和外界打交道的问题", "那我们说操作系统内核是可以信赖的", "我可以在里做对计算机系统里的任何内容的控制", "可以执行它的特权指令 这种信任呢", "并不是它跟外界完全的隔离", "它还需要为上边的应用程序提供服务", "也就是说我可以信任的内核", "它必须对外界提供某种访问的接口", "或者打交道的通道 然后再一个呢", "我们除了会是跟应用程序打交道之外", "我们在程序或者计算机系统", "在运行过程当中会有各种各样的问题", "比如说我在外设", "你在跟他做交互的时候你敲键盘", "我并不能确认 你会在什么时间", "准确的一个什么时间点去敲键盘", "你敲了键盘之后 可能我的系统正在干别的事", "这时候我没办法给你做出响应", "那这样的话就会让你感觉", "这个计算机系统很不好用", "所以为了能够让计算机系统", "能够对外界做出适当的反映", "我们需要提出中断机制", "也就是说当外设与系统有交互的时候", "我需要怎么来处理", "还有一种情况呢", "是说我的应用程序在执行过程当中", "比如说我做除法 除了一个零", "那这时候是要出问题呢", "而是否会除零呢", "我只有执行到那一步的时候我才知道", "好 等到这个时候你再知道的话", "那我已经没办法往下做了", "所以总会有一些意外情况", "我在事先写程序的时候我是没办法预料到的", "对于这种意外的情况", "我们怎么来处理 所以在我们这里呢", "通常的做法是说应用程序提供你所需要的功能", "那里头的异常呢 这种意外的情况呢", "把它控制权转给操作系统", "由操作系统来处理它", "这是我们这里说到的应用程序执行当中意外", "有异常来做处理 那还有一种情况呢", "是说我们要解决用户程序如何来解决系统的服务", "就好象说我们提供给银行对外提供服务", "银行为了保证安全 所以它有很多的防护", "这个防护又和对外提供服务这是有矛盾的", "为了方便用户来使用银行的服务", "你必须提供灵活的访问接口", "但是这种灵活的接口 又不能影响到银行的安全", "操作系统内核也是一样的", "我们需要来通过系统调用来提供一个接口", "让应用程序既方便的使用内核提供的服务", "又不至于用户的行为对我内核的安全产生影响", "那也就是说使用服务呢 我们有很多种方式", "那在这里头呢 用内核提供服务", "和我们通常写程序的时候用函数库", "来提供服务有啥区别 那这是我们在这里呢", "你在选择用系统调用 还是用函数库的时候", "需要做出的判断", "好 有了刚才这些问题我们来看", "用下边这个图来看一下", "内核和外界之间打交道的地方", "这是我们内核 然后我们在里呢", "提供了相应的一些内核服务 这些内核服务", "首先会是说跟外界的硬件打交道", "比如说我敲了键盘 那我在敲下一个键的时候", "可能里头会有一个缓冲区", "缓冲区的大小是有限制的", "那存多了 前边的内容就会丢", "好 那我在这里呢 有数据之后", "我就必须告诉操作系统", "那你在这里面及时把我的数据读走", "否则的话", "后边来的数据就会丢了 那这时候呢", "有一条通道 那这就是我们这里的中断", "好中断 通知内核 内核通过驱动", "来与你的设备进行数据的交互", "比如说键盘我是读进去 磁盘的话", "即是会有读有写 然后还有一种情况是说", "应用程序在执行的过程当中", "好 正常执行 那跟内核没关系", "好 执行到某一个位置的时候", "比如说某条指令做除法 除了个零", "或者说一条存储访问指令", "访问到某一个存储单元", "但这个存储单元是不允许你访问的", "就好比说储户你想说银行里有你的钱", "你就想直接去开银行的保险柜", "把你的钱取出来 那这是不行的", "对于这种情况呢", "我们在这里跟操作系统是类似的", "它会提供一个异常机制", "那我们把这些情况都认为", "是你代码执行过程当中的出错", "有些错误呢 实际上是我们事先有预计的", "好 那这时候呢 把空闲交到内核", "内核可能做出的处理呢", "要么说我把你遇到的问题解决掉", "比如说你访问到的某一个存储单元", "原来的存储单元不存在", "好 那我把原来的存储单元的内容放到内存里头", "OK 对于虚拟存储来讲", "这时候你就可以执行了", "而另外一些问题 比如说像是除零之类的", "那你这时候除零 我就没有办法继续下去", "这时候我就会把应用程序", "所占这些资源还给操作系统", "那这是我们异常 那最主要的一类呢", "是正常情况下的使用", "应用程序会使用到函数库", "那这时候跟内核不打交道", "但是内核 应用程序或者函数库", "会间接的通过系统调用接口", "使用到操作系统内核的服务", "比如说我要读写文件", "那我应用程序不能直接访问磁盘设备", "它怎么办呢 发出操作系统", "提供了一个磁盘读写的一个系统调用接口", "好 那应用程序通过调用这个", "读写接口所提供的这个函数", "好 那这时候进到内核里头来", "内核把相应的数据读出来", "还给应用程序 那这个流程就结束了", "所以从这我们可以看到", "操作系统内核和外界打交道基本上就是中断", "异常和系统调用这三个接口", "这是我们在这里说到这三条", "从这三条我们就可以看到", "中断 异常和系统调用他们之间", "到底有什么样的定义", "系统调用是应用程序", "主动向操作系统发出的服务请求", "而异常呢 是非法指令或者其他原因", "导致的指令执行失败之后的处理请求", "那这种处理请求呢 可能会是说我终止程序", "也可能会是说解决你遇到的问题", "然后重新执行这条指令 而中断呢", "是硬件设备对操作系统提出的处理请求", "比如说我缓冲区里有数据", "需要内核把它读走", "或者说我缓冲区里的数据已经全部用完", "需要内核补充新的数据", "那这里我们说到的中断异常和系统调用", "那这三者之间的区别到底怎么来描述呢", "我们可以从这样几条来区别", "第一个是它的源头 那在这呢", "我们标出了系统调用的触发条件", "中断的起头和异常的起头", "这三个分别对应着我们这里的来源不同", "外设 应用程序 实际上这个异常", "在这个图里描述是适宜性的", "我在执行内核代码的时候", "也可能由于代码的执行出现问题", "这时候呢 也可能是内部出现的", "然后第二个呢 是他们的响应方式不一样", "那这三个箭头分别对应着系统 调用", "中断和异常的响应方式 那系统调用呢", "通常情况下我们会是同步的或者异步的", "也就是说应用程序发出系统调用请求", "然后它就在那等着了", "一直到你算完内核服务完成之后给它结果", "那也可能是异步的", "说我们在这里系统调用发出了之后", "你内核在处理时候", "处理的过程当中", "我就切换过去干别的事情过去了", "然后等到其他条件准备之后", "你这才会回来 而中断的它是异步的", "也就是说你上边应用程序", "该怎么做处理怎么做处理", "我不会感知到中断的存在", "那中断只是在应用程序暂停执行", "处理完中断所需要的服务之后", "继续恢复你应用程序的执行", "就跟没有这件事情一样", "而异常是跟你的这个当前指令有关的", "这个是同步的 也就是说必须处理完", "当前这条异常所产生的指令所导致的问题", "我才可以继续下去 那当然他们之间的处理呢", "会都在内核里头来做", "但他们的处理也会有一些区别", "中断会持续的进行", "而系统调用它会是用户提出之后会处理", "等待然后再继续 而异常呢", "是会处理当前所出现的问题", "那具体说起来 中断的处理", "那这个中断实际上我们把它理解为", "系统调用异常和中断这三种情况的总称", "对于硬件上的处理呢", "这主要是在硬件中那个地方", "在CPU做初始化的时候", "它其中就有一项工作 要对中断使能", "也就是说在许可外界打扰CPU的执行之前", "CPU是不会对外界的任何中断请求发出响应的", "那只有我CPU把相应的准备工作做完", "外界来一个请求之后 我知道怎么处理了", "我才会允许这种处理", "如果我不知道怎么处理的话", "你给我一个请求 我也不知道怎么办", "所以在这 在初始化的时候", "它有一个中断使能 使能之后", "我才能够进行中断的处理", "第二个是说这个事件产生了", "产生了之后通常是一个电平的上升沿", "或者说是一个高电平", "那CPU会记录下这件事情", "也就是说我有一个中断标志", "表示出现了一个中断", "然后这时候我需要知道中断", "到底是由什么设备产生的", "需要知道中断源的编号", "这一部分工作是由硬件来做的", "好 硬件做完这一部分工作之后", "剩下的事情就是由内核的软件来做", "那在这里头呢", "也就是说这几个进来都到了这个中断向量表", "中断向量表如果是中断", "那它直接绕到这边的中断服务例程", "驱动程序里来做出响应", "如果是异常 它直接转到异常服务例程来做处理", "如果说是系统调用 由于系统调用的量很大", "那我们在这儿 系统调用之后", "系统调用它之后总共占用一个中断编号", "然后它自己的不同的系统调用的功能呢", "是用系统调用表来表示的", "好 在这呢 根据你系统调用表里的", "功能的选择不同", "我去选择不同的系统调用实现", "那么在这个过程里头呢", "我为了不影响程序的正常执行", "我前边有一个保护现场和恢复现场", "而在这里头呢 要做系统调用的交互", "我还需要知道系统调用产生之前", "我准备的上下文的信息 比如说你到底让我干啥", "那这一部分工作呢 是会和你的编译有关系", "然后中间这一部分到底如何实现", "那这个是由操作系统来做的", "然后如果是中断的话", "那么你在执行的过程当中", "需要清除这个中断标志", "这个也是由你的中断服务例程来完成的", "好 我们说中断可以满足应用程序", "外部设备 或者程序执行异常的服务请求", "那这时候可能会出现一种情况", "我正在处理一个请求的时候", "有来了一个请求这时候我怎么办", "那我们说在操作系统的里头呢", "它是硬件的中断 它是允许被打断的", "也就是说我正在处理一个中断的时候", "可以允许你再出现其他的中断", "如果两个中断源不同 那这时候呢", "我可以通过优先级的高低", "让一个往后推一段", "或者说让一个暂停下来", "那使得我可以同时在做", "交替在做处理 然后在中断服务例程里头", "并不是说我任何一个时刻都可以做任何一个处理", "它会在一定的时间里呢", "禁止中断请求 比如说我电源有问题", "那可能其他的问题就变得不重要了", "这时候我在做电源的处理的时候", "我就会禁止掉其他中断", "然后中断服务请求会一直保持到CPU做出响应", "然后对于异常呢 我也可以被打断", "你比如说我在程序执行当中出现了异常", "这时候正在做异常的处理", "比如说我在这里头虚拟存储里头", "它访问到的存储单元的数据不存在", "我正在从硬盘上倒数据进来", "倒的过程当中 它会用到磁盘I/O", "这时候也会再有磁盘设备的中断", "这时候是允许它可以做嵌套的", "然后对于异常服务的嵌套呢", "这是我们说到的 异常服务和缺页", "这两个在异常服务里头还会再出现异常", "也就是说我执行中断", "执行异常处理例程里头", "有一段存储访问它是缺页的", "那这时候两个异常也是可以嵌套到一起"]}, {"name": "", "block_id": "2f124ea897504ca0a4da19f2e2190219", "text": ["下面我们来讨论磁盘缓存", "磁盘缓存是放在内存里的", "磁盘数据的缓存", "那这些缓存呢 是为了避免", "对同一块磁盘扇区里的内容", "进行反复引用时候的多次磁盘访问", "我们先说什么是缓存", "缓存实际上是数据传输过程当中", "双方速度差异比较大的时候", "我在中间为了匹配速度", "引入的一个中间层", "我们这里磁盘缓存呢", "就是把磁盘扇区的内容", "在内存当中做一个缓存区", "如果内存里有", "我就可以直接用内存里的缓存数据了", "在这儿我们可以看到这种做法", "和我们前面讲的虚拟存储很类似", "虚拟存储是用磁盘空间", "来存内存里存不下的这些数据", "而现在这个磁盘缓存是倒过来", "所以从这个角度来讲呢", "它们俩有很多地方是相似的", "但是它们也有很多地方是不一样的", "比如说内存和磁盘缓存", "磁盘的访问频度呢", "它是要远低于虚拟存储的访问频率的", "由于访问频率比较低", "这个算法我就会做的", "比虚拟存储会复杂", "磁盘缓存的置换算法到底怎么来做", "也就是说我到底该", "把哪些磁盘块的内容在内存里做缓存", "哪些不做", "在具体讨论", "一种磁盘缓存置换算法之前", "我们先讨论一下单缓存和双缓存", "这里单缓存和双缓存呢", "指的是这个缓存区", "到底是一个还是两个", "首先我们来看单缓存", "它的做法是什么呢", "设了一个缓存区", "然后有两头", "一头是CPU 一头是设备", "设备往这缓存区里写数据的时候呢", "由于我只有单缓存", "这时候CPU这头呢是不能操作的", "等CPU这一头能够从缓存区里", "读数据的时候", "设备这一头是不能往里写的", "大家还记得吗", "我们前面讨论到的生产者 消费者问题", "就是跟这儿是很类似的", "由于在这里我任何一个时刻", "只有一个可以对这个缓存区进行操作", "它的速度就很受限制", "如果说你两边交互频繁的话", "那这时候就有我们这里的双缓存", "它是设置两个缓存区", "在一个缓存区", "由一头在进行操作的时候", "比如说这里头I/O设备", "往缓存区1里头写数据", "那么这时候缓存区2呢", "就可以由CPU来从里读数据", "这两个是可以同时进行的", "因为它俩在不同的缓存区里头", "一旦是我写完了 这回也读空了", "它两头做一个切换", "我们两头又都可以继续进行了", "这样的话它的交换速度就会更快", "有了这个讨论之后 我们来看", "磁盘缓存的访问频率置换算法", "在这里设计这个算法", "要解决的问题是在于", "在磁盘访问的时候", "我有可能访问某一个扇区里的数据", "我频繁的访问", "这个频繁的访问如果说我们用LFU的话", "那这个计数就会很快速的增加到很大", "这时候你再往后用LFU它就不能反映", "当前你进行引用的真实情况", "我怎么来做呢", "它的思路是这样", "对于密集访问的这一段", "我不对它进行引用计数", "基本上说起来就是", "在短周期之内我用LRU", "在长周期里我用LFU", "这样的话我就可以在短周期里头", "靠特殊的栈的处理", "来描述我的访问顺序", "然后在长的时间尺度里", "我用LFU来进行访问次数的计数", "具体怎么做呢 我们来看", "这是访问频率置换算法的示意图", "首先这是LRU里的那个特殊的栈", "这是栈底 这是栈顶", "和前面的LRU不同的地方是在于", "我把这个栈分成了三段", "第一段叫新区域", "第二段叫中间区域", "然后第三段叫旧区域", "分三段的目的呢", "是为了这三段我做不同的处理", "具体这种不同的处理在什么地方呢", "每一次访问的时候", "访问某一块数据块", "那我把这一块放到这个栈顶", "这是LRU的要求", "然后我又附着上两个", "如果说你这个引用的这一块", "是在新区域里头", "它往前移的时候", "它的计数是不变的", "这就是我们真正的LRU", "如果说不是在这新区域里头", "是在中间区域或者是旧区域里头", "那么引用的时候", "不但挪过去并且把计数要加一", "那么这样一来我们就可以实现", "在新区域里头不加一", "避免了你这密集访问所带来的", "引用计数的快速增加", "而在中间区域和旧区域里头我加一", "那这是我们LFU的要求", "有了这两个之后呢", "我新加入的这些块", "我直接把它放到栈顶", "这是LRU的要求", "并且把它引用计数置为1", "然后说我淘汰的时候怎么办呢", "原来淘汰说我在这里栈底的", "现在它是在旧区域里去找计数最小的", "这是LFU的要求", "但是和LFU的区别是在于", "我不在整个栈里去找计数最小的", "有可能这个密集访问", "和中间这种新加进来的它的计数很小", "这样一来的话就定义这个中间区域", "就是为了避免", "我的计数刚进来用了没多长时间", "它正是我们频繁要使用的", "但是由于计数比较小", "你把它置换出去的这种情况", "我只是在旧区域里头", "我才按照计数大小来选", "使得这个中间区域呢", "变成是一个过渡的", "有了这样一种做法之后", "我们就把原来在虚拟存储里的算法", "改造成一个更复杂", "可以用来做磁盘缓存置换算法的", "这个访问频率置换算法", "这是磁盘缓存置换算法", "那到这儿我们就讲完了", "I/O子系统里的磁盘缓存", "我们把刚才讲过的内容总结一下", "我们在这节课里呢", "首先对I/O访问的特征进行了一个介绍", "我们有多种不同的设备", "然后这些设备的访问方式呢", "各有各的特点", "针对块设备 字符设备", "和网络设备这三种不同情况", "我们进行不同的处理", "然后数据传输我们可以分成", "轮询方式 中断方式 DMA方式", "这几种方式", "是我们在I/O子系统里常用的", "然后接下来我们介绍了", "我们常用的一种设备", "磁盘设备里头的优化", "这里面优化又分成两个", "一个是我对I/O请求", "到底我哪个先去访问", "这是磁盘调度讨论的问题", "第二个是磁盘缓存", "我把磁盘上的数据", "哪些放到内存里做缓存", "也给了一个算法", "I/O设备有很多种", "其它各种各样的设备", "也有针对各自的特点进行的一些优化", "只是由于时间的缘故", "我们在这儿没有做深入的讨论了", "那到这个地方呢", "我们这学期的课就讲完了", "好 谢谢大家", "我们这节课就上到这里 下课"]}, {"name": "", "block_id": "bb121ac5ad1b463f9099b2892175b476", "text": ["接下来我们看一下lab2的", "这个实验指导书", "来对lab2要完成的工作", "做一个初步的了解", "那lab2主要是完成物理内存管理", "当然是建立在lab1基础之上的", "意味着如果你lab1没有完成", "那你没法开展lab2的工作", "这是它们是一个就是有相互依赖关系的", "之后的实验也都具有同样的特点", "那这个实验的目的是什么呢", "这个实验目的是结合我们原理课的讲解", "更深入的理解段页式内存的", "地址的转换方式", "以及如何建立页表", "建立页表之前其实还有一个", "连续地址空间的这个物理内存管理", "这一块呢", "也是需要在lab2中有更深入体会", "大家可以看一下就是在lab2中", "如何通过我们一系列的", "操作来完成这些工作的", "其实大家很关注就是要完成几个练习", "lab2提供三个基本练习和两个扩展练习", "我们一个一个来逐一给大家做个讲解", "首先这个练习0呢实际上", "就是重复lab1的工作", "把lab1做的那些你修改的", "那些代码填到lab2中来", "你可以通过一些工具", "比如说diff和patch来自动的merge", "如果merge合并的时候呢 出了点问题的话", "就可能要手动来做更新", "也可以用图形化的工具来手动合并", "比如说我们这里面提供的meld等等", "这是第一步", "因为你要把lab1的工作", "能够让它正常工作了", "才能进一步完成lab2的后续的一些工作", "这个实际上是一个基本的", "第二步就是说怎么去来完成", "对这个物理内存空间的", "分配的一个算法实现", "那在原理课中我们讲了好几种不同的", "连续物理内存空间的分配算法", "包括first-fit best-fit worst-fit等", "这里面我们考虑", "在操作系统里面怎么来实现", "那看起来在原理课里面讲的", "first-fit是相当简单的", "那如果要具体实现在我们的", "ucore操作系统里面", "我们设计实现一个新的一种框架", "在基于物理内存管理框架之下呢", "我们可以实现不同的这个内存分配算法", "那么first-fit是我们要求大家去完成的", "首先你们就要去了解", "我们说的物理内存pmm manager", "这么一个程序里面", "它到底是怎么来组织的", "这也是需要根据源码来看一下", "那在这个lab2源代码里面", "我们可以看到两个文件", "default_ pmm.h和default_ pmm.c", "那这里面很重要的pmm_ manager", "在这个框架里面", "我们设定好了一个", "连续物理内存分配算法的", "一个最主要的一些函数的实现", "这里面列出来了", "我们重点实现的是分配 释放", "当然你要能够完成正确的分配 释放", "你还需要有一定初始化的工作", "为什么初始化", "首先要把我们说在ucore启动之后", "要把我们计算机物理内存有效感知", "然后知道哪些是空闲的", "哪些可以去为后续做malloc  free", "动态内存分配", "这个需要在前面init_ memmap", "这一块来完成", "最后这个是完成一个检查", "这个检查是说", "我们知道想判断一下你的实现是否对", "我们会有check 这么一个函数", "这个是得到当前", "剩余多少页的这么一个函数", "就是返回当前的free pages", "这个形成了我们pmm_ manager", "看起来比较简单", "这是基于函数指针的方式来实现的", "那我们需要把我们的first-fit", "这个代码填到这里面", "这里面有详细的信息", "这里面到底要怎么做", "你的代码应该怎么去完成相应的工作", "它的步骤是什么 这里面都列出来了", "我建议大家在实现之前呢", "把这一块代码仔细阅读一下", "仔细阅读一下", "来理解你应该怎么来填写", "那到底你填在什么地方", "这个也是需要注意的", "在我们这个源代码里面呢", "我们可以通过", "如下这个命令来查找", "你需要填写的地方", "我们已经标注出来", "大写的LAB2这个位置呢", "实际上就是你要填写的地方", "我们每个练习里面都包含这个信息", "就是可以看到在练习一里面呢", "它在这个地方需要你去填写", "如果是在后续的练习 练习二和练习三", "那么在这个地方要填写", "这里面也知道", "比如你要完成first-fit这个算法呢", "这需要对default_ pmm.c", "这个文件呢做相应的填充", "来实现你的那些", "刚才说那些函数指针里面对应的函数", "从而可以完成正确的", "分配内存和释放内存", "以及初始化内存的工作", "那这里面可以看到", "其实这些函数 列出来了一些", "但这些并不是一个正确的first-fit实现", "它也许可以工作", "但其实它没有达到", "first-fit它所要求的功能", "所以说我们需要去对此进行修改", "来完成这个对这个以页为单位的", "内存的动态分配", "这个内存是连续物理内存", "这是第一部分的内容", "那我们还希望你通过", "完成这个实验之后", "能够在你的实验报告中说明", "你设计过程中", "到底有没有进一步改进空间", "其实first-fit这个实现呢", "有多种实验方式", "你可以有一些技巧", "来使得它更加高效", "甚至说你还可以去跟worst-fit", "或者是best-fit进行比较", "当然前提是你需要去实现", "看看在你的操作系统里面", "这些算法到底哪个好", "哪个差一些 这是练习一的工作", "练习二的工作主要是完成页表的", "一个更深入的理解", "通过设置页表和对应的列表项来建立", "对于某一个虚拟地址和物理地址", "一个对应关系", "所以说练习二呢 它需要去修改", "修改跟页表相关的一些位置信息", "那我们前面已经看到你修改练习二", "主要集中在pmm.c 350行这个地方", "我们查一下pmm.c", "大约的位置在这儿", "这里面是要完成一个获取页表项(page table entry)", "这么一个函数的实现", "这里面讲到两点", "或者这个页表项已经建立好了", "那么你只需查找对应的这个逻辑地址", "我们称之为虚拟地址和逻辑地址", "它所对应页表项是哪一项", "把它取回来就OK了", "如果说这里面没有这一项", "对应的逻辑地址或者是线性地址", "它没有页表项对应", "那你就需要创建一个页表项", "你怎么去实现对页表项的创建", "这需要去修改相关的一些函数", "来完成对应的功能", "那我们这里其实也列的比较详细", "你到底要完成哪些步骤", "这个是肯定是错的", "但是它的注释也一样", "你需要仔细的阅读这一块的注释", "以及这里面一些要求", "这实际上给很多帮助", "你要为了完成这个功能", "你可以用我们这里面", "ucore里面已有一些函数", "到底用哪些函数", "哪些宏 可以帮助你来完成这些功能", "这是练习二要求的", "我们还可以通过understand来", "其实还可以更深入看一看", "整体的架构它怎么实现的", "这一点需要大家掌握", "就是这个get_ pte这个函数", "到底是怎么调这个函数来的", "怎么一步步过来的", "那从最开始的kern_init一直到pmm_init", "再最后获得PTE", "那我们其实在understand里面", "也很好可以看到这个过程", "在kern_init其实是", "整个内核初始化的总控函数", "我们前面还没有涉及到", "物理内存这些管理之后", "其实比如说之前中断控制器的初始化", "中断向量表初始化等等", "都在这儿来完成了", "这次呢新增加了pmm初始化", "那我们可以看看这个函数在这儿", "它的一个函数量关系比较复杂", "那可以看出来这是kern_init比较小", "调到了pmm_init", "然后呢最后它还会去一层一层的去", "我们看看在哪", "比如说在这儿", "check_ pgdir这么一个函数", "这个函数会进一步", "调get_ page获取某一个页", "这里面呢会调get_ pte", "这里面就可以看出来", "它有不同的调用关系", "get_ pte有好几个函数对它进行有调用", "我们双击一下这个呢", "可以在这儿重新看一下以get_ pte为准", "来看一下它被谁调用了", "那可以看出来 这里列出来了", "被这些函数所调用", "通过理解这些函数的实现能够知道", "这些函数在什么情况下", "为什么调用get_ pte", "从而可以更好地有助于完成get_ pte", "这个函数里面的需要完成的功能", "另一方面我们还希望大家在实验报告中", "能够说明如下一些问题", "比如说如果你访问一个虚拟地址", "或者一个线性地址", "然后呢按道理来说应该有一个对应的", "物理地址和它对应", "如果说这个物理地址没有对应", "也意味着你的页表项或者没有", "或者是建错了 会出现页访问异常", "这时候出现什么情况 OK", "第二个呢", "如果说出现了页访问异常那么", "我们ucore呢它应该有一个", "对应的缺页的服务例程", "中断服务例程来完成对这个", "页访问异常的进一步处理", "但是如果说这个缺页服务例程", "缺页中断服务例程", "进一步又出现了页访问异常", "那会出现什么现象 请大家思考一下", "这是练习二这一块的工作", "那练习三呢 其实是练习二的一个", "反操作或者逆操作 前面是建立", "建立对应的页表项", "从而把这个映射关系建立好", "这里面是说如果要释放一个映射关系", "把这个页给释放掉", "那么就意味着不存在了", "我们应该让它这个页表", "这个映射关系也取消 怎么做", "这里面你如果说", "对这个get_ pte有一定了解之后", "相信你来完成所谓page_ remove_ pte", "也一样可以比较好的完成相应的工作", "同样 用同样的方法", "可以用前面说到的415行是练习三", "在这里面完成这个page_ remove_ pte的", "一个大致实现", "这里面讲函数到底要干什么", "然后还讲到它大致一个实现步骤", "这里是重点需要你去填写的", "当然提醒一下你实现完之后", "把这个注释给去掉", "否则这个代码是无法", "被编译到执行码里面去的", "好 那我们完成了这个函数实现之后呢", "我们希望你能够在实验报告中", "回答如下一些问题", "第一个是关于数据结构", "page的全局变量它是什么", "它其实是一个数组", "这个数组每一项与页表中的", "页目录项或者是", "页表项有没有对应关系", "如果有这个关系那关系是啥 这是一个", "第二我们前面已经讲到在lab2中", "我们完成的虚拟地址到物理地址映射", "是有一个偏移", "就是虚地址是0xC0000000", "会映射到物理地址0", "这是一个非对等映射", "如果我们要完成对等映射也意味着", "虚拟地址的0也就是物理地址0", "如果要完成这件事情怎么做", "我们希望大家能够去尝试一下", "也同时能够在实验报告中做一个说明", "当然你如果不完成这个编程", "也是没有问题的", "我们完成的要求的编程是", "练习一二三里面明确指出的", "要修改或者扩展的几个函数", "好 接下来我们再看一下扩展练习两个", "第一个是buddy system", "第二个是slub分配算法", "那这两个分配算法呢", "在我们今年呢", "通用操作系统里面是存在的", "这两个都在Linux里面有对应的实现", "那我们可以考虑能不能在我们ucore中", "实现buddy system和slub分配算法", "一个可以给大家提示一点是说", "其实在我们早期的这个同学实验中呢", "已经完成了对这个", "buddy system和slub分配算法的一个实现", "所以说希望大家", "在有兴趣有时间的情况下", "可以尝试一下这挑战中的一个或两个", "好 那我就把练习", "给大家做一个简单介绍", "那为了能够更好的完成", "更好的完成这个练习呢", "我希望大家能够把后续这个", "lab2实验执行流程能够去读一下", "从而可以在整体上知道", "lab2是怎么完成的", "读完这个文档之后", "就是lab2的实验指导书之后呢", "还需要大家能够", "去结合代码去静态的分析", "或者说是动态的调试来看我们这个", "lab2大致的一个执行过程", "和对文档描述是否一致", "从而可以对如何感知物理内存", "这个在原理课中是没有涉及到的", "如何以页为单位来管理内存", "实现段页式机制", "那么这部分在原理课中", "也很少涉及到这么详细的细节", "这是需要大家通过理解原理", "分析代码 调试代码", "完成我们的练习", "从而可以有一个更好的一个", "更深入的一个理解", "那这是最后的实验报告", "要求指出了我们要", "把我们代码提交到git server上去", "然后我们这个实验报告呢", "是markdown格式", "也需要大家提交到我们", "对应的git server的帐号", "所对应的git repo里面去", "注意有lab2的注释你去写的时候", "还要将your code", "替换为你的学号", "这一点希望大家能够稍微", "在提交代码之前注意一下", "这里面附录A B C D", "是有一些相关的一些讲解", "A B C是和物理内存相关", "以及虚拟地址 物理地址的", "一个对应关系做了一个介绍", "自映射呢是一个更高级的机制", "它描述了如何通过", "虚拟地址的一个访问", "快速把这个页表给打印出来", "它还有其它一些功能", "在这里面如果有感兴趣的同学", "可以深入去分析一下", "这个附录D所描述的内容", "好 我们其实可以看看", "如果说lab2你如果完成了", "正确完成了相应的工作", "我们可以执行一下", "可以看到在这里面呢", "lab2已经正确完成了这个内存的分配", "建立好了相应的页表", "然后在enable了", "这个段机制和页机制之后", "所有的系统还依然能够", "正确完成相应的工作", "包括lab1里面的中断实现", "你看还在正确地一步步地", "产生相应的执行", "希望大家能够", "更好地更顺利地完成这个实验", "在这里面你也许", "会碰到一些意想不到一些困难", "希望大家能够及时到我们说的", "piazza那个问答平台去提问", "我们的助教随时解答", "大家碰到的一些问题", "好 谢谢大家"]}, {"name": "", "block_id": "4f5ae406fb5040cc8db13e57d776c332", "text": ["接下来我们讨论段式存储管理", "那在段式存储管理里头", "我们会来说明", "段的地址空间是如何来组织的", "然后在段式存储管理当中", "我的内存访问是如何进行的", "那在段式存储管理当中", "我们把进程的地址空间", "看成由若干个段组成的", "每一个段 在这里", "是给出了一些实例", "你比如说我的程序", "有主程序有子模块", "那各个子模块我可以看成是", "相对独立的一个段", "主代码呢我看成是一个段", "然后我的公共库", "可以看成是另外一个段", "这几个呢都是代码", "同时还有一些堆", "初始化的数据 堆栈", "符号表 这样一些数据段", "好 那在这里头", "我们把它看成是一个", "组织成一个段地址空间的话", "实际这时我们希望是能够达到", "把进程的地址空间能够", "以更精细 更灵活的方式", "把它分离开", "分离开之后呢", "我可以实现更好的共享", "好 有了上面关于段地址空间的描述", "这时候呢我们就可以", "把逻辑地址空间", "转换成一个不连续的二维结构", "那在这里头呢我们看到", "我们把代码分成了几个部分", "两个部分 数据 堆栈", "堆 那这几个部分呢", "各个部分内部呢", "它是需要连续的", "我会用它的偏移呢来进行访问", "但各个部分之间 我们很少有跨越", "从一个段访问另一个段的这种情况", "以一个段的基址", "去访问另一个段的这种情况", "好 有了这个讨论之后", "我们就可以把段地址空间的逻辑视图", "转换成一个这样的结构", "那到物理地址空间里头呢", "它就可以是不连续的", "那由于各个段之间我们是相对可以", "把它很好地分离开 那这个里头呢", "这种不连续呢", "对我们的访问带来的影响", "是相对来说比较小的", "好 有了这种概念之后", "那么这时候我们来看", "我的访问过程是什么样的", "首先有了这一段之后", "我们可以把它理解为段呢实际上是", "每个段是什么", "每个段是访问方式和存储数据", "存储的到底是什么数据", "到底用什么样的方式在访问", "这个相对一致的一段地址空间", "好 这一段呢我要求它是连续的", "好 有了这个之后", "那我们说如果每一个段呢", "对应到一块连续的内存块", "然后若干个段组成了", "进程的逻辑地址空间", "有了这个之后", "我们再来看段的访问是什么", "我就会把逻辑地址", "分成一个二元组", "段号和段内偏移", "那原来的地址", "我们是一个连续的若干位", "好 现在呢 在段式地址空间里呢", "我们把它分成两段 段号和段内偏移", "转化过来之后呢", "我们看到的逻辑结构呢", "变成是段号和段内偏移", "这个时候分开之后", "那我再访问的时候", "我必须把它转换成原来的地址", "好 有了这种地址的划分之后", "那它的访问过程会变成什么样子呢", "好 这是进程的地址空间", "这是物理的地址空间", "然后程序在CPU上执行", "它要访问一个存储单元的时候", "首先是它的逻辑地址", "在段地址空间里头", "我们把它分成两段", "段号和段内偏移", "这个首先用段号", "我们去查进程的段表", "那若干个段", "所有的段在这里都有一项", "每一项对应一个段描述符", "这里基本内容是", "段的起始地址和它的长度", "那这里的内容呢", "我们是可以用操作系统的软件", "来对它进行控制的", "也就是说我在这里头", "每个段在什么位置呢", "它的相关信息我是由", "操作系统可以控制的", "好 有了这里头", "我可以得到段的长度之后", "那硬件在里做什么呢", "存储管理单元MMU", "它就会把这个长度和你的偏移", "取出来两个做比较", "看看是不是越界", "如果越界 那这时候", "就会出异常", "如果说", "你的偏移是小于它的长度的", "那这是一个合法的访问", "然后在MMU里头呢再利用段基址和", "你的偏移两个加到一起", "就可以找到你实际要访问的内容了", "有了这个访问之后", "那我们基于段的这种机制", "就可以工作起来了"]}, {"name": "", "block_id": "9ca9b0148d344836a61cc4d947ef5a14", "text": ["好 在刚才的描述当中", "我们说清楚了计算机在启动的时候", "它从什么地方去读第一条指令", "从磁盘上的什么地方去读第一块数据", "那接下来 我们会把刚才这个过程做进一步的细化", "也就是说系统启动的时候的流程", "按照我们刚才说的流程", "应该说我加电之后去读BIOS", "BIOS去读你的加载程序", "加载程序去读内核映像", "这个过程实际上我们又可以把它细化下去", "因为我在加载程序的时候", "我BIOS里头起来", "我们说直接去读bootloader", "但实际上这个过程它并不能直接进行", "比如说我们在最早的时候", "系统里只有一个分区", "上来之后我就直接到分区里找文件系统了", "但是对于我们现在来说", "所有的计算机", "或者大多数的计算机里头都不止一个分区", "可能会有几个分区", "每个分区上会装不同的系统", "那这个时候就在前边加上一个主引导记录", "这个主引导记录是说", "我要从哪个文件系统里", "去读我的这个加载程序", "好 有了主引导记录之后", "然后我就进到当前哪个分区里头", "分区里头又有一个分区的引导扇区", "这个活动分区的引导扇区", "再来加载我们刚才说到的加载程序", "这个过程当中实际上我们就需要知道中间", "这几个部分它的格式是什么样子", "如果你不知道这个格式的话", "那你写出来的程序", "最终存到磁盘上", "机器是不能够从里头认识的", "那我们具体说起来呢", "有这样几个过程", "首先我们在前面已经说过", "CPU加电完成它的初始化", "到一个确定的状态去读第一条指令", "我们需要知道CPU初始化之后", "它的代码段段寄存器", "和当前指令指针寄存器这两个的内容", "算出来它的第一条指令在内存当中的什么地方", "有了这个之后 说我们在这里头呢", "这是它计算的依据", "因为它是实模式", "所以是CS和IP都是16位的", "CS左移四位加在一起算出我的位置", "这个时候 我放到内存当中的BIOS的位置", "只能是在最底下的一兆", "原因在于这时候它是20位的地址", "有了这个之后我们就直接进到BIOS里执行", "BIOS里 我们刚才说", "它是从磁盘上去读你的加载程序", "那实际上在这里头它还有很多的事情要做", "首先第一个是硬件自检", "也就是说我们有可能加电起来之后", "你的内存出错 那整个后边就没法做", "这时候问大家", "你见到过你的计算机如果内存出错了", "你的显示器肯定是不工作的", "那这时候我怎么知道出这个问题了", "我们说在计算机系统里头", "它的加电自检", "它上来之后是看最关键的这几个部分是不是在工作", "如果说检测到", "这就相当于在自检的时候你需要知道", "关键的内存 显卡这几部分是否存在", "或者说干脆你的机器里就没有显卡", "如果存在的话 它的工作状态是什么样子", "把这些设备完成每一个", "这些关键性的接口卡里头", "它自己也有自己的初始化程序", "这些初始化程序完成之后", "那我就认为关键的设备是可以的了", "然后这时候 我们再来执行系统的初始化", "BIOS的初始化 这时候它是干什么呢", "我们说我们现在的系统", "很多都是可以即插即用的", "那如果说我想从一个USB接口的光驱里启动", "那你怎么启得来", "那这时候呢 在这个BIOS里的自检", "现在是能够做到系统的自检", "把这些检测并且配置你的这些即插即用的设备", "这些工作做完之后", "我就知道我现在的系统里到底都连了哪些硬件", "好 我们说在BIOS里有一个系统配置表", "这个配置表就是我们这里所说的", "ESCD 就是扩展系统配置数据", "那用这个数据 我就能知道", "我当前系统里都有些什么样的设备", "每次加电之后有可能你会插上新的卡", "或者说拔掉已有的卡", "这个数据是会变得", "每次加电的时候都必须做", "做完之后说我就把控制权", "转到我们从外部读进来的数据里头", "读进来的代码里", "那这就是按我们在BIOS里指定的顺序", "从软盘 硬盘或者光盘或者你指定的其他设备上", "读进你的第一块扇区", "读进来之后 那这时候", "我们说在我们现在说的这个过程里头", "有多个分区", "好 这时我就有一个主引导记录", "在这个主引导记录里头", "我们需要知道的内容是它的格式", "那说在里头呢", "我们说它有512字节", "但是在这 你只能说我可以用到的是446", "那其他部分是什么", "原因在于我在这里头", "我还有后边有多个分区的时候", "这些分区的状态是什么样的", "你也要存到这512字节里头", "所以这样的话", "你就只有446个字节的内容来执行你的启动代码", "在这启动代码里我需要干啥呢", "需要知道我这些分区表是不是正确的", "如果说你的分区表是错的", "那这时候我的程序是没法正常加载的", "然后还要加载并跳转到", "你的活动分区的引导记录上去", "第二个是你的分区表", "然后我们对于所有的引导扇区", "都有一个结束标志", "这个结束标是55AA", "有了这个之后 它才认为这是一个合法的主引导记录", "那有了这个之后", "它就会跳到你活动分区的引导扇区上去", "那在这仍然是一样的", "它也有一个它需要了解的格式", "那在这里头 就开始有文件卷的信息", "这个结束标志跟刚才那个主引导记录是一样的", "好 在这基础上呢", "说它有启动代码", "那启动代码就是一条跳转指令", "那这个跳转指令跟我们刚才说到的有什么区别呢", "那这地方它就跟平台相关了 你的CPU不同", "这个地方这条指令肯定也是不一样的", "然后空下的其他地方呢", "再是我的启动代码", "这个地方的启动代码就需要认识你的格式说", "我这个加载程序不是存在在512字节里头的", "存在别处 它在哪", "那就靠你这里的代码来约定说我放在哪", "而这里的代码实际上是我们存在硬盘上的", "或者说你的软盘上的", "这个时候我是可以改动的", "那改动完了之后", "我就可以把我的加载程序放在任意的地方", "只要我在这标识出来我上哪去认识它就可以", "好 接下来我们说加载程序的细化", "那在这里头呢", "我们说加载程序它首先不是直接去加载你的内核", "而是去从文件系统当中", "这时候加载程序我是能够认识文件系统的格式的", "从里头读一个启动配置文件", "这个启动配置文件", "在不同的操作系统里它是会不一样的", "你比如说Windows和Linux都有自己的格式", "这样的话它Windows和Linux", "都有自己的加载程序的格式", "依据这个选择你启动的这种参数", "比如说我是在正常启动", "还是说我是在安全模式启动", "还是说我是在一个调试状态下启动我的系统", "那这些区别都会读出来之后", "它导致我在加载内核的时候的一些内核会不一样", "或者说我加载的时候的参数会不一样", "好 依据配置去加载内核", "那么到这 我们把这个过程描述清楚了", "说到这是不是会说", "是说的足够详细吗", "如果说我要来写实际程序", "知道这些是不是就足够了", "那我可以告诉大家", "我这的介绍仍然是很粗的", "如果说你要想写实际的程序", "那么我们需要知道CPU的手册", "它在加电的时候", "处于什么样的状态 BIOS里的规范", "我在从磁盘上什么地方读的第一条", "它的格式是什么样子", "那到这呢 你还需要知道", "我的内核编译的时候", "它的一些相应的信息", "那我们说在计算机启动的过程当中", "我们有很多需要考虑的因素", "这种考虑的因素又有很多细节", "和我们实际的硬件环境", "或者说周围的情况密切相关", "那是不是我们需要在每一种硬件平台上", "我都要制定一个自己的启动流程呢", "那实际上不是这样的", "我们在实际的工业界", "它制定的一组相应的标准", "BIOS就是我们现在广泛使用的", "在PC机上的启动流程标准", "那在这里头 它是主板上的一段程序", "那它可以完成系统的启动", "但是从它最早出现的时候", "是70年代后期", "那在这应该是几十年的变化过程当中", "它已经有了许多的发展", "这呢 我们列出了几种它的变化", "刚才说到那个主引导记录这一部分", "这一部分实际上相当于是说最早的BIOS", "它是从主板上加电自检之后", "进到你的磁盘上的唯一的一个分区上", "去加载它的引导记录去了", "那有了多分区磁盘之后", "就相当于我一个系统有多个磁盘 有多个分区", "那这时候我就需要选择从哪个分区启动", "由于这种需求呢", "在上边加了一个主引导记录", "这个主引导记录呢", "告诉你我从这几个分区里的选择了", "其中的活动分区来进行启动", "那这也有了我们这里的第一个", "然后从这里头我们也可以看到", "当时谁在里头呢", "主引导记录里头我只能描述最多四个分区", "每个占16个字节", "我全部有512个字节", "你四个分区用到了64", "那再多了的话不行了", "而我们现在用到计算机很多的分区会大于四个", "那这时候怎么办呢", "这时候就有了这里说的GPT", "全局唯一标识分区表", "这个分区表 可以在我的分区表里", "描述更多的分区结构", "有了这个之后 我就不会受那四个的限制", "所以这是BIOS的两个发展", "然后PXE实际上是网络启动的一个标准", "也就是说我的机器启来了之后", "我想通过局域网或者说其他的网络", "连到服务器上 去从服务器上", "下载我的内核镜像来执行", "那这时候怎么办呢", "就是这是它的标准", "那如果从这个角度来讲", "你要从网络启动", "好 这时候就你的BIOS里加网络协议栈", "那从这个角度来讲的话", "这个BIOS的功能也会越做越复杂", "甚至于在一些系统里头", "那它就是一个小的操作系统", "好 那在这个变化的过程当中呢", "从我们刚才讲解注意到", "BIOS它可以有一些局部的修改", "来完善对后续的支持", "但这种支持总是会受到前边的制约", "比如说在我们的主引导记录里头", "为了支持多分区", "那我就把中间那地方加成了磁盘上的主引导记录", "然后再加上活动分区里头的这个引导记录", "多了两层 实际上多这两层呢", "它的意义并不是特别的必要", "如果说我设计一个全新的话", "那这件事情我是不需要这么做的", "正是由于这种原因", "那我们又定义了一种新的这个启动规范", "那就是UEFI 统一可扩展固件接口", "这个接口 它想达到的目标是在所有平台上", "一致的提供操作系统的启动服务", "为了做到这一点呢", "实际上它这个标准呢", "应该是从90年代就开始出它的第一个版本", "一直到现在呢", "都在不断的演变的过程当中", "在上这课之前呢", "我查了一下它的最新状态", "它的最后一次修改我能看到的是2015年的1月份", "好 在这里它会增加什么呢", "那我在这举一个例子", "说我们要想从磁盘上启动", "我只要能拿到一张新的磁盘塞到你的机器里", "这台机器剩下的事情我就都可以控制", "那这样的话 我这个系统", "对于一些关键性的服务器", "我允许这样做是有麻烦的", "好 针对这种麻烦", "在这个UEFI规范里头呢", "就定一个可信启动流程", "在这个流程里头呢", "BIOS起来以后", "它在读磁盘上的引导记录的时候", "那它是会对这个引导记录的可信性进行一个检查", "也就是说它会让里头有一个签名", "你只有我满足我签名的这些引导记录我才会读进来", "才会把控制权交给你", "使得我在整个的启动流程当中", "可信的这些介质上的这些代码", "可以在我的系统当中运行", "从而提高了从启动的阶段", "减少了这种安全的风险", "那我们说 这个修改的过程", "还会再继续下去", "随着这个周边环境的变化", "在这个规范里头加新的内容", "慢慢的 也会希望这个规范能够有更广泛的适用范围"]}, {"name": "", "block_id": "3746851beaf34d6c88570bc03877a97c", "text": ["各位同学大家好", "今天我给大家介绍第四个实验", "就是关于内核线程的管理", "那我们这次课程呢", "主要包含以下几部分", "总体介绍 关键数据结构和执行流程", "首先我们看一下总体介绍", "总体介绍包含三个部分", "又包含三个小部分", "目标 练习和整个这个", "实验流程的一个概述", "那目标是什么呢", "我们前面已经完成了", "从lab1到lab3的一个实验", "那么在前面的实验中", "我们重点解决了什么呢", "重点解决是内存管理相关的", "一系列的一些关键的知识", "包括物理内存管理", "以及虚拟内存管理", "那在这个过程中呢", "我们已经掌握了", "就是关于内存的一部分的一些知识", "接下来呢我们要看一下", "对于我们CPU而言", "我们怎么能够充分利用CPU", "让CPU来执行多个", "不同的线程或者进程", "在这里面我们首先关注是线程", "因为相对来说在内核里面", "创建一个线程比在用户态", "创建进程要容易一些", "我们先从这个线程入手", "这也和我们大致原理课内容", "正好有点相反", "我们原理课一般是", "从进程开始讲起的", "但是没有关系", "因为它们很多部分", "都是有相同的地方", "大家再回忆一下", "原理课中讲过一些知识", "原理课我们讲一个线程", "或者进程在这里面我们不做区别", "那他有一个生命周期", "从最开始这个启动", "到最后的结束", "那么创建线程线程处于就绪态", "然后占用CPU执行", "然后由于某种事件的原因", "导致它的等待", "在这个整个过程最后还要退出", "那么这是", "我们说是一个线程一个生命周期", "那怎么去有效管理生命周期呢", "这就需要在我们操作系统里面", "有一个专门数据结构", "我们称之为TCB", "线程控制块", "当然我们可以叫PCB", "就是进程控制块", "在这里面我们一样不做区分", "在本次实验中呢", "我们重点讲的是线程", "所以我们可以在以后", "都用TCB来进行一个表述", "那第二方面呢我们希望去了解", "这个线程执行一个过程", "怎么去执行它", "怎么去调度它", "那我们可以看到", "对于一个线程而言它需要管理的", "除了它的代码段 数据段之外呢", "还有一个执行的流程", "我们需要知道它在", "某一个时刻执行到什么地方", "这也就是说对于这个线程执行过程呢", "我们希望有效管理措施", "可以使得单线程和多线程", "都能够在我们系统里面", "能够正常的工作", "对于单线程而言", "我们可能涉及不到调度", "但是对于多线程而言", "我们就会碰到到底在什么时候", "应该让这个线程去占用CPU执行", "因为存在多个线程", "抢一个CPU的情况", "所以说呢", "在这里面我们希望让大家能够了解到", "大致一个线程怎么去创建", "以及他怎么去执行", "甚至说还进一步去考虑", "两个线程或者多线程怎么去切换", "来分时的占用CPU来执行的一个过程", "这是说我们这个lab4重点要考虑的内容", "为此呢你可以看到我们需要", "去对TCB做一个比较全面的理解和分析", "那么充分利用TCB里面的一些信息", "来完成对这个线程的有效的管理", "好 那这时候我们讲完这个", "关于这个线程目标这一块", "我们接下来看一看", "我们这个实验要完成的练习", "练习有三个", "第一个就是你要知道怎么去初始化", "创建一个进程控制块", "或者线程控制块", "这个不做区分", "第二个呢 我们会讲怎么为这个", "内核的线程分配资源", "有了控制块之后呢", "它是用来管理", "管理很多元数据", "管理这个比如说这个线程", "占用空间占用堆栈等等", "那这些信息怎么能够", "怎么能够在创建线程的时候", "给它分配好相应", "他所需要能够正常运行需要这个资源", "第三个呢要理解一个就是相对来说", "和我们硬件相关的一个细节", "就是怎么去切换的", "当有两个进程存在的时候", "那我们怎么去能够", "完成进程和线程的切换", "这是我们说希望", "大家通过练习能够掌握的", "当然我们在后续的讲解中", "对这里面一些关键点和难点呢", "给大家做一个介绍", "以便于大家能够", "比较方便的开展相应的练习", "那如果说你完成了这个练习", "那么可以看到我们最终会创建出", "创建出一个内核线程", "它可以完成一个最简单的", "hello world一个显示", "别小看这个hello world", "虽然感觉只是打一个字符串", "但其实我们为此做出了很多的工作", "包括从lab1建立中断机制", "跟外设打交道", "lab2管理物理内存", "lab3管理虚拟内存", "有了前三步基础之后呢", "我们才能够去创建一个进程或者线程", "那么接下来我们看一下", "整个一个实验运行一个流程", "首先我们需要去能够", "对他的关键数据结构进行一个处理", "关键数据结构包含两部分", "一个是说我们要有TCB", "就是线程控制块", "第二个呢 当存在多个线程的时候呢", "我们需要把这些线程", "有效的管理起来", "一堆线程管理起来", "那么需要有一个list", "这个线程控制块一个列表", "那我们可以用list结构呢", "来对它进行有效的管理", "有了这两部分之后呢", "我们就可以说我们一个对线程", "关键数据结构呢就可以建好了", "第二部分呢就是要去怎么去操作了", "那么对于操作而言呢", "我们首先要完成相应的初始化", "在前面的lab1到lab3", "完成了包括中断物理内存", "和虚拟内存的初始化工作", "这时候我们打下一个基础", "那在这个实验中我们还要", "进一步要去初始化什么呢", "我们内核线程本身初始化", "还有怎么去创建相应的", "一些关键的一些资源", "就是为这个线程要去分配一些资源", "然后还要能够去实现线程的切换", "只要把这几部分", "初始化工作做完之后呢", "你才能够有效去让一个线程", "能够正确切换和运行", "好 最后一步呢就是说", "我们能够让我们前面创建好", "这个线程能够切换去", "让它去执行", "从而可以打印出我们", "刚才说到这个字符串的信息", "可见为了完成这个工作", "确实要完成大量前期", "一些初始化的工作", "当然我们在后面会", "逐一给大家讲解其中的一些关键点"]}, {"name": "", "block_id": "e4d7b39409ad4ef399eedecf65ed686f", "text": ["今天我们来介绍同步互斥", "同步互斥是操作系统当中", "协调进程之间动作", "和相互关系的一种机制", "那在这里头呢", "我们通过生活当中的例子", "先来说明同步互斥", "到底是个什么样的问题", "我们有一些什么样的办法来解决它", "然后呢是在计算机系统当中", "我们给出三类不同的做法", "我们下面会一一来介绍它", "首先我们来介绍同步互斥的背景", "那就是说为什么我们要做这件事情", "那在以前我们在写程序的时候呢", "我写一个独立的程序", "这个程序呢它不需要", "和其它的进程共享状态和资源", "那在这种情况下它的确定性", "和可重现呢是可以保证的", "也就说你只要是", "输入的状态是一致的", "那么它输出的结果呢", "一定就是相同的", "然后我第一遍执行", "和第二遍执行它的结果是一样的", "但是由于我们在实际的程序当中呢", "如果说你在这里头", "以这种方式来做的话", "那我们这个程序的功效呢", "就很有限了", "通常情况下", "我们写好一个程序之后呢", "是希望它在每一次做的时候呢", "它对不同的数据进行处理", "那这时候我们", "在中间的过程当中 执行的时候", "这个顺序就不是很重要", "而我们在操作系统当中呢", "有了多进程之后", "这时候会有多个", "并发的进程交替执行", "这种交替执行呢", "会导致进程之间有资源共享", "比如说大家都要占用CPU", "那我是时分的", "大家都要占用内存", "那我是把一块区域分配给你", "把另一块区域分配给另外一个进程", "正是由于这种资源的共享", "这种不确定性和", "不可重现呢就会产生", "那如果说在这里头你的程序的结果", "对这种不确定性 或者说", "这种不一致性是没有依赖的", "那我们在这里变化这一部分呢", "不影响到你的结果", "那这时候我们程序", "应该也算是正确的", "但是一些时候呢", "这种状态的不一致呢", "会导致你运行结果的不一致", "甚至于有些情况下这种不一致呢", "就是我们希望它出现的", "比如说我两个进程之间在通讯", "那根据通讯对方回过来信息的不同", "我这边处理是不一样的", "而这种在通讯的过程当中两者之间", "保证它可重现的这事是不行的", "那在这种情况下", "我们要想保证一个进程执行的", "正确性的难度就增加了", "好 这时候会出现一类", "什么样的错误呢", "就是我们有一些错误它是间歇性的", "也就说你第一遍执行", "那外界的环境跟现在不一样", "那也许没错", "到另一次执行的时候呢", "它可能就出错了", "实际上这是我们在", "实际写程序当中呢", "经常碰这种情况", "你自己在那儿测试的时候", "你的程序都一切正常", "交给用户用的时候情况就变了", "那你说我在这里严格测试之后", "为啥会不一样呢", "实际上这里头你所说的严格", "总会有一些依赖的环境", "跟你在测试的时候", "和真实系统运行的时候 是不一样的", "好 那你说这样一来的话", "这件事情带来这么多麻烦", "我们不这样做不就行了吗", "但是进程的并发执行呢", "又给我们带来很多的好处", "这些好处呢", "导致于我们非常希望这样做", "也就是说进程要与", "计算机系统当中的其它进程", "或者是设备要进行协作", "那这种协作呢", "可以带来这样一些好处", "第一个是说共享资源", "你比如说有多个用户", "想使用一台机器", "那他们之间呢", "这台计算机资源呢", "就是大家共享的", "好 那这样的话", "我们可以节约成本", "然后说你的钱存到银行里头", "但你并不一定什么时间在什么地方", "那这个银行帐号的余额呢", "我可以在多台取款机上操作", "那这时候我就可以", "就近存取我的现金", "那这会是给你带来好处的", "然后说我们在嵌入式系统里头", "你比如说机器人", "那上头呢它有多种设备", "比如说 我们的手臂和手", "之间的控制机构", "它们之间要协调", "因为只有在这种情况", "你协调到一起", "你才能够完成一个复杂的动作", "比如说机器人的", "直立行走或者说跑步", "那这些呢都需要多个机构来协调的", "这些共享呢", "是我们这里必须要做的", "然后第二个好处呢", "它是可以提高速度", "比如说我们在这里头", "我们在前面讲进程的时候说", "CPU是管计算", "设备是跟外界做交互的", "这两个实际上它们是可以", "在时间重叠上可以一起工作的", "那它是并行", "如果说你在算的时候", "I/O设备你不能让它工作", "那这时候呢I/O设备就只能闲着", "而你在做I/O的时候", "CPU没有相应的数据", "它也没办法做", "好这样的话", "这两个效率就降低了", "那我们希望呢", "这两个能很合理进行安排", "以便于它们俩可以同时工作", "那这样的话", "程序运行的速度就提高了", "再有一个呢是说", "我如果说系统里有多个处理机", "我把一个程序切成若干个模块", "这些模块呢可以作为独立的程序", "跑到不同的处理机上", "那这时候它可以并行执行", "也可以提高它的速度", "这是提高速度两种做法", "然后还有一种呢", "我们可以把程序模块化", "我用多个进程来", "完成一个综合的功能", "比如说我们在这里头说到编译", "以编译的过程为例", "编译呢 我们可以把它分成", "源代码模块的编译", "然后库的编译 和最后的链接", "这样几个部分", "那这几个部分呢", "我们把它写成独立的程序", "那这样的话它们组合到一起", "进行复用和扩展呢也会比原来方便", "所以基于这样的理由呢", "我们需要让多个进程并发执行", "好 那我们刚才说", "并发执行有状态的变化", "这些状态变化可能影响到", "我程序执行的结果", "那在这儿呢我们就举一个例子", "看看到底它会有什么样的影响", "这些影响我们怎么来控制它", "在这儿举的例子是说", "我们在操作系统里", "有一个进程创建的系统调用fork", "这个创建进程的系统调用呢", "它要给每一个新创建进程呢", "分配一个进程ID 一个标识", "那这个标识的分配呢", "在我们系统里头呢", "就会是对应过来这样一行代码", "在操作系统内核里头", "fork的实现代码里头", "也能找到这样一行", "说我一个进程的ID", "那是系统里呢有一个全局变量", "这个变量呢叫nextpid", "好 我把它赋值并且加1", "也就是说把当前的值", "赋给你新分配的这个进程", "然后把它的值呢加1", "这样的话下一次再来分配的时候", "我就是接下来这个值了", "那这个代码呢", "我们在实现的时候呢", "机器在编译的时候", "就会把它转换成这样几条汇编指令", "在源代码里就一行", "那这翻译成的这四条指令", "你拿过来执行呢应该也是没问题的", "它是把你这个全局变量里的ID", "读到一个寄存器里头", "然后再把这个寄存器", "赋值到你这个进程", "自己的进程控制块里的变量", "newpid", "然后把它这个寄存器值加1", "然后再把加1之后的结果呢", "重回到你原来的nextpid", "好 这个过程就结束了", "那正常情况下执行呢", "这也是没有问题的", "好 我们希望它", "预期的结果呢是这样的", "假定我开始的时候对pid是100", "一个进程调用fork", "它由100变成101", "然后第二个进程再调用fork", "那它分配到101", "然后把当前值呢变成102", "好 那这是我们期望的结果", "好 那在这个过程当中我们看一下", "如果说我的执行顺序", "在一种特定的顺序下", "这个预期的结果能出现吗", "这就是我们这里说到的", "一种可能的错误", "好 假定说我有两个进程 A和B", "那它在运行的时候呢", "调用fork之前呢", "它自己有自己的一个", "局部变量 new_pid", "这里面也有一个", "它俩的名字是一样的", "好 整个系统里呢有一个nextpid", "那 当前值它是100", "好 那我们这时候呢调用fork", "我们重点关注是刚才那条", "分配进程标识的代码", "它所对应的汇编代码的执行顺序", "好 我们首先呢是这四条汇编语句", "那应该是说在中间", "它会可能出现切换", "先上来之后读nextpid", "然后这个时候呢发生了一次切换", "到进程B再去读这个pid", "好 那这两条执行完了之后", "我们看到你newpid就已经变成了100", "而进程B呢也变成了100", "那这时候实际上我们就", "已经发现它有问题了", "它俩是相同的值", "那你给两个不同新创建进程", "分配了一个相同标识", "那这时候会有麻烦的", "好 我们看 好 然后这时候呢", "再执行加1写回去 这地方变成101", "好 然后这回切换回来", "到右边的进程", "再加1赋值", "那这地方还是101", "这个赋值就被赋值了两遍", "并且是相同的值", "好 那么这时候大家看", "在这个过程当中", "出现了什么一情况", "两个进程的分配的ID是一样的", "并且新创建的变化完了之后", "ID它不是创建了两个进程", "我应该加2 这地方它只加了1", "好 那这时候出现", "这种情况的原因是什么", "原因就是在于", "我们正常假设这四条是一块执行的", "读出来 赋值 然后加1写回去", "这边呢读出来赋值做了", "加1写回去这件事情中间被切断了", "好 切断之后", "这两头的加1就变成是相同的了", "写回去也就变成相同的了", "好 那这个时候呢", "我们这个状态就出结果了", "好 这时候出现这种的问题的", "原因在什么地方", "就是读出加1这个操作", "它并没有是一个整体在进行操作", "这就是我们这里说的原子操作", "原子操作是指一次", "不存在任何中断或失败的操作", "如果出现了中间的失败", "中断那这时候是不行的", "在生活当中的原子操作是什么呢", "你比如说我到银行里去", "存款或者取款", "那你是有一个假设的", "说我把钱给到窗口里头", "那么这时候呢我的存折上的钱", "金额是要发生变化的", "这两个一起发生", "那储户没有任何意见", "好 如果这两个分开", "你存进去钱了", "但是你的存折上的", "金额没有发生变化", "要么你不同意", "要么银行不同意", "好 那这是我们", "这里说的原子操作", "那要求要么成功执行", "要么没有操作", "不会出现部分执行的状态", "这是我们在这里头呢", "如果说我们刚才", "pid加1的这个操作", "它是个原子", "那我们这儿就没问题了", "现在的问题是我们把它分成两段", "中间做了个切换", "这是我们要面临的挑战", "所以我们今天讨论", "同步互斥问题的时候", "就是要在操作系统里头", "提供一种同步机制", "既允许并发执行", "以便于我能做到资源共享", "和提高速度", "同时我要让一些操作呢", "是原子操作", "因为你不是原子操作之后", "所带来的麻烦就会很大", "那这是我们在这里的需求", "接下来我们会来说", "我们有一些什么样的办法", "来解决这个问题"]}, {"name": "", "block_id": "07827843d0304cc49c8917ead3523e9f", "text": ["好 那我们接下来", "再稍微具体一点", "看一下uCore文件系统一个架构", "那么这一块呢", "比刚才要更深入一些", "从两个角度 一个是从控制流的角度", "一个从数据结构的角度来看uCore", "文件系统一个架构", "首先我们看一下这个控制流", "就是说 用户访问文件的时候呢", "它从应用程序开始发出请求", "到最后从硬盘中读", "或者写相应的数据", "这个过程从上而下", "看看这个访问是怎么一步步来完成的", "那第一个 是通用文件系统的访问接口", "那么这个是包含两部分", "一部分是给我们应用程序", "提供了一些API", "这些API呢是放在一个", "简单一个C库里面", "那这C库呢会访问相应的系统调用", "从而可以获得uCore操作系统", "关于文件这一块的一个服务", "那对应的这个函数可以看出来", "我们调用 比如说在这里面", "提供了write 就是写文件这么一个操作", "那么write呢 会最终调这个", "关于write的sys_call", "使得我们内核通过sys_write", "来完成接下来的这个服务请求", "这是第一个层面", "就是站在用户的角度看待", "这个层面的一个调用过程", "那第二个呢一旦说在操作系统里面", "我们的sys_call这个level", "得到了一个请求 说", "要完成一个文件的写操作", "那接下来的控制就会", "交给我们什么呢 VFS", "文件系统的抽象层", "就是虚拟文件系统这一块", "虚拟文件系统呢它包含了很多部分", "包括了文件的接口 目录的接口", "inode的接口以及文件系统的接口", "整体一个抽象", "那么这个呢 屏蔽了底层", "具体文件系统和设备的一些差异性", "可以看出来刚才这个sys_write", "会进一步向下调用", "会访问什么呢 sysfile_write", "file_write以及vop_write", "需要注意的是 从file_write到vop_write", "其实形成一个转换", "这个转换是从文件 面向用户这个文件", "转成了面向具体硬盘里面的操作的一个inode", "这是一个转换", "当VFS把用户发出的针对文件的写操作", "转变对一个inode写操作之后呢", "这个inode本身", "还是一个站在虚拟文件系统上面", "一个抽象的inode", "它会进一步转变成什么呢", "一个具体文件系统", "在这里面我们是以一个", "simple file system来举的例子", "一个具体的文件系统呢", "它的一个inode情况", "通过inode来完成后续的", "针对磁盘的一个读写", "那可以看到 刚才的vop_write呢", "会进一步变成fs的write", "就是simple file system 的write", "这个write会再通过wbuf (write_buffer)", "这么一个操作", "来向我们设备发出请求", "比方说做一个写操作", "那么它的数据内容", "是从我们应用程序", "刚才那个高层的", "write的buffer里传到这里面来", "然后把这个buffer内容", "会写到我们的device中去", "Simple file system", "它发出一个写请求之后呢", "最后会通过一个外设的访问接口", "来完成对外设的一个访问", "这个外设呢 和我们刚才说那个", "具体的硬盘呢还是不一样的", "它是在硬盘之上建立成抽象", "而这个抽象我们称之为I/O设备接口", "这个接口也是由", "我们VFS来进行管理的", "可以看到当Simple file system", "发出wbuf这个操作之后呢", "会把这个操作转变成一个", "针对device的一个操作", "这个device操作呢有很多类", "我们刚才已经看到有面向串口的", "有面向屏幕的 也有面向硬盘的", "还有甚至空设备 有不同类型的设备", "我们最终选择是disk", "我们前面已经设定好了", "SFS它的数据是位于", "我们disk 0这个磁盘上的", "所以 当发出这个dop_io的时候", "最终会调disk 0的I/O", "使得它可以向disk 0发出写请求", "这层I/O设备接口呢", "是一个抽象的接口", "它里面可以包含不同类型的设备", "最终disk 0会访问什么呢", "会访问一个驱动", "这个驱动是硬盘驱动", "通过硬盘驱动来完成实际的", "往这个硬盘数据的一个读写", "可以看出来 刚才这个disk 0的I/O", "会转变成一个IDE的write", "因为我们前面知道", "最开始是一个write操作", "那么这个I/O既可以支持读", "也可以支持写", "我们会变成一个IDE的write之后呢", "完成把应有程序提供的数据", "最终写到我们硬盘扇区里面去", "就是这个ide_write_secs", "IDE硬盘它的扇区", "这是一个整个的执行过程", "那么前面呢我们看到一个", "从上到下的控制流的一个访问", "针对write的一个操作", "接下来我们可以看看", "在内核中数据结构整体一个布局", "那么也是从高层逐步往下来展开", "给大家做一个讲解", "我们知道 我们的应用", "其实是以进程的方式", "在操作系统管理之下运行的", "所以在我们进程控制块里扩展了一部分", "跟文件相关的一些数据结构", "比如说我们的proc_struct", "它包含了一个files_struct", "而这个files_struct实际上是一个数组", "在这数组里面 很重要一点", "它打开了哪些文件", "它有一个opened file array", "根据打开文件 可以进一步找到", "这个文件所对应inode", "可以看出来 这一块区域", "是和我们进程紧密相连的", "应该说 是属于我们", "进程控制块的一部分", "但光有这部分还不够", "我们还需要进一步去", "和我们系统级inode进行联系", "所以可以看着这个struct file呢", "会有一个信息会到一个inode里面去", "而这个inode信息是属于VFS", "可以看出来在 VFS管理之下", "它有很多这些 对应的数据结构", "我们这里面关注哪个呢 in_info", "这个in其实是inode一个简称", "这个VFS这一层的inode", "它会进一步表述具体的inode怎么回事", "你可以看出来 这是一个union结构", "比较有意思 这个union结构呢", "其实说它包含了不同类型的inode", "我们在这里面 具体而言", "是一个SFS的一个inode", "就是simple file system的一个inode", "这个结构也是在内存中的", "这个在内存中inode结构呢", "包含了更进一步的", "跟硬盘相关的SFS的信息", "也很重要数据就是sfs_disk_inode", "那么这个inode信息", "其实就是在硬盘中存储的内容", "所以说 这一块内容", "其实和我们硬盘中的一块区域中", "专门来存储inode的数据块呢", "它里面的内容是一致的", "那么这个sfs_disk_inode", "它的成员变量中有很多丰富的信息", "比如说这里面type 表明这个inode", "它的类型是文件 目录", "还是其它什么东西", "第二个呢它这个direct和indirect", "表明了它所存储的数据", "所在数据块的位置", "有了这个信息之后", "我们就可以很容易找到这个inode", "所对应文件的内容", "或者目录内容在什么地方", "关于simple file system这个结构里面", "有很多的内容", "是和我们硬盘中的", "数据结构是直接对应的", "当然我们在具体访问的时候", "需要把部分的内容", "也会取到内存中来做进一步的操作", "从上到下可以看出来这整个的过程", "从进程开始 到uCore kernel里面", "system level的数据结构", "VFS再进一步引申到我们具体的SFS", "那么SFS又分两块", "一块是内存中一些管理信息", "还有一部分是从硬盘中", "读取的一些管理信息和数据信息", "形成了整个的 跟文件系统相关的", "数据结构一个关系图"]}, {"name": "", "block_id": "d7bfb04a07b74de7b9eb7bc82d861301", "text": ["今天我们来介绍I/O子系统", "I/O子系统是我们计算机操作系统当中", "负责与外设打交道的部分", "那么在这里呢", "我们首先会来介绍", "I/O子系统里头它的I/O特征", "这里主要是说我们在系统里头", "可以连接的设备是有很多种的", "速度有很大的差异", "那么这些各种设备的访问特征", "直接影响到我们", "用什么样的方式来跟设备进行交互", "在了解它的特征之后", "我们会来介绍", "I/O的结构和它的数据传输", "最后两个部分是", "我们在这里举了一个实际的例子 磁盘", "对于磁盘的I/O来说", "我们会又涉及到两个问题", "一个是磁盘的调度", "这里指的是说我们在磁盘访问的时候", "由于磁头有机械的移动", "所以这个时间是会很长", "所以在这里头呢我们需要", "有相应的一些算法来提高它的性能", "这就是我们这里的磁盘调度", "另外一个呢是磁盘缓存", "也就是说我们把磁盘上的数据", "读到内存当中来使用", "写回去的数据还需要写回到磁盘里头", "这读和写呢", "我们可以在内存里头加缓存", "从而提高它的访问效率", "如何来控制这个磁盘缓存", "也是我们这里要讨论的问题", "首先我们对I/O设备的接口", "进行一个分类", "在这里头我们大致的分类有这样三类", "字符设备 块设备和网络设备", "这三类设备呢", "各有一些各自的特点", "字符设备通常情况下它的速度很慢", "比如说在这里举的例子是", "串口 键盘和鼠标", "而块设备呢通常是我们的存储设备", "比如说磁盘 磁带和光驱", "而网络设备呢", "是计算机系统与外界打交道的", "最重要的手段", "你比如说在这里头", "我们的以太网 802.11无线网 蓝牙等等", "这些都算是网络设备", "那么这三种不同的设备呢", "它的访问是具有不同的特征的", "首先第一个字符设备", "所谓字符设备呢", "它的访问是以字节为基本的访问单位", "然后是顺序访问的", "比如说像我们的键盘你敲一个键之后", "每次你只能敲一个", "如果两个在一块的话它是组合的", "对于计算机系统来说它也是一个", "那这个输入是", "一个字节一个字节来进行输出的", "像串口它也是两个方向", "每个方向也是", "一个字节一个字节为单位往外输出的", "这时候呢", "它的访问通常由get put", "这样两个I/O的命令", "在这里我们通常把它封装成一个文件", "用文件访问的接口和语义", "来对这些字符设备进行访问", "这是第一类", "第二类呢是块设备", "块设备它最主要的特征是", "底下的访问是以基本的数据块", "为最小访问单位的", "也就是说读写是以一个数据块为单位", "这种访问呢是比较均匀的", "它的数据量也是比较大的", "那我们在访问的时候呢", "通常情况下可以使用文件的接口", "我们实际上在前面的文件系统里", "就是这样在讨论的", "为了提高性能也可以使用原始的I/O接口", "也就是说我直接对磁盘上的扇区", "进行读写控制", "我们也说到第三种方式", "我可以把磁盘映射到内存当中", "用内存映射文件", "来对磁盘上的数据进行访问", "第三种呢是网络设备", "网络设备它的最主要特征呢", "是它的交互是比较复杂的", "我们有一门专门的网络原理课程", "来讨论这一协议", "这个地方就是以格式化的报文交换", "是它最主要的特征", "为了应对这种特征呢", "它的I/O命令是专门的网络报文收发接口", "send/receive", "然后我们多种不同的网络协议呢", "是封装在这个网络接口下面的", "以使用不同的协议", "跟不同的对象进行交互", "这是我们在这儿呢", "对设备访问的特征有一个大致的描述", "有了这些描述之后", "我们更主要的问题是会来讨论", "CPU与设备之间的交互", "那这种交互关系呢", "也就是我们这里说的同步和异步I/O", "这张图给出了我们用户的进程", "与设备进行I/O操作的时候", "它的一个大致的结构", "用户发出I/O请求", "然后这个请求会送到", "操作系统内核当中的设备驱动", "设备驱动呢会把它转换成硬件的控制", "控制你的硬件进行相应的操作", "硬件操作完成之后呢", "它会产生中断", "由内核当中的中断处理例程进行响应", "最后送到设备驱动 然后回到用户态", "这是进行I/O的一个过程", "这个过程实际上", "我们说到的第一种方式是阻塞I/O", "也就是说我发出请求到数据回来", "中间我进程是要处于等待状态的", "一直到有数据回来", "这种特征对应过来的", "收和发分别是这样的", "你在读数据的时候", "我把命令发出去之后", "进程进入等待状态", "一直到完成数据的读出", "而如果说是写数据", "那么是我发出写请求之后", "进程进入等待状态", "一直到设备完成数据的写入处理", "也就是说如果是磁盘的话", "它真实写到磁盘扇区了", "那这时候我才结束", "这个过程到我们这张图里", "就变成是用户的请求", "首先通过系统调用到设备驱动", "设备驱动会把用户请求转换成", "实际的硬件控制命令", "下来的时候是绕过中间的中断处理的", "中断只是在返回的时候有处理", "直接控制硬件进行相应的操作", "操作结束之后呢", "它会产生中断请求", "然后转到设备驱动", "最后通过系统调用的返回 到用户态", "用户得到相应的结果", "这是第一种方式", "在这种方式里头呢", "进程是需要等待的", "等待一定会读到数据", "或者一定会把数据完成写", "第二种方式是非阻塞I/O", "也就是说进程在执行的过程当中", "我把命令发出去之后我就不等待", "这种不等待呢", "转换过来是对于读写操作", "把系统调用发出命令之后立即返回", "返回的值是你进行成功传送的字节数", "读或者写的字节数", "这时候你在读写的过程当中呢", "有可能什么也没读到 什么也没写进去", "返回的值是零 这种情况呢", "我们还是在这张图里表示出来", "那就是写", "然后它就直接返回了", "这是第二种方式", "第二种方式 它可能读写不成功", "或者说读写的数据量", "跟我想写出去的数据量不一致", "于是我们就有了第三种方式", "异步I/O", "异步I/O是把同步和异步两者结合起来", "它在读数据的时候是", "我把我要做的事情标记好", "把缓冲区设好", "那这样的话告诉内核然后它就返回了", "操作系统内核在完成相应的数据处理", "并且把读到的数据放到缓存区之后", "它会通知用户", "而写呢是反过来", "我标记好我的数据在什么地方", "操作系统完成写到实际的设备上之后", "它会通知用户", "这个过程在这张图里表现出来是这样的", "我先通过系统调用", "把我要写的数据告诉设备驱动", "然后设备驱动控制硬件设备进行操作", "控制完成之后", "我不会去等它结果我直接就返回了", "而设备操作完成之后它会通过中断", "这时候返回出相应的结果", "在这个阶段", "驱动里头是会需要等待的", "而我的应用程序这一段", "是可以干别的事情的", "这是我们说到的三种I/O操作的方式"]}, {"name": "", "block_id": "51a508d40a7f4f9683b5c88be635058b", "text": ["好 那我们来看一下", "这个底层支撑是怎么来完成的", "第一个是定时器", "定时器主要是用来干什么呢", "让进程睡眠 进入等待状态", "为此我们有一个do_sleep函数", "这个函数就可以让进程睡眠", "并进入等待状态", "它做什么事情呢", "添加一个timer", "我们称之为定时器", "这个细节后面会讲到", "一旦添加timer之后呢", "我们会让这个进程进入等待状态", "完成schedule 这样它就切换出去", "然后让其它新的进程去执行", "紧接着呢 我们的时钟", "会产生时钟中断", "产生时钟中断之后呢", "我们会遍历这个timer 的list", "这是一个timer_list", "挂了很多的timer", "我们刚才添加的timer", "会添加到这个timer_list里面去", "然后看看是否有哪一个定时器", "这里面会有个时间 一个限制", "这个时间限制是否到期", "如果到期之后呢 它就会唤醒进程A", "使得我们进程A", "从刚才的等待状态变到就绪状态", "这就是定时器的大致的工作过程", "我们看细节", "定时器的数据结构的定义", "它里面包含什么呢", "什么时候到期", "什么时候这个时钟就结束了", "然后哪一个进程", "当前是跟这个timer绑定在一起的", "然后这个timer连到list里面", "它这个link 双向链表", "这是一个list_entry", "那么这个结构就形成了", "我们说定时器一个数据结构", "那么 timer_list呢", "是把所有的timer挂在一起", "便于我们这个时钟中断", "这个处理例程呢能够对此进行判断", "看哪个timer到期了", "然后我们再看它这个执行过程", "站在进程或者线程角度来看", "进程或者线程", "它只要调用以下几个函数", "比如说sys_sleep等等", "最终会调到do_sleep", "我们刚才说的", "就是内核提供的一个函数", "那么do_sleep呢会创建一个timer", "就 add_timer", "然后给timer做初始化", "并让当前这个进程进入等待状态", "完成一次schedule", "切换到新的一个进程去执行", "这就是说 当一个进程", "如果说它想睡眠", "它要做的一个大致的过程", "是这么一回事", "那如果说时钟中断产生之后呢", "我们可以看到", "只要时钟中断一产生", "我们的中断服务例程", "就会接受这个处理", "比如说Trap_dispatch", "在我们这个trap.C函数里面", "就会进一步去查询这个timer", "所对应那个timer_list", "总的timer_list里面", "是否有哪个timer到期了", "如果有哪个timer到期了", "它们会把跟这个timer相关的", "那个进程给唤醒 wake up_proc", "这是我们在进程管理之后", "用到的一个很常见的函数", "它会把它这个状态", "从等待状态变到就绪状态", "然后把这个timer给delete掉", "从这个list里取出来 没有用了", "同时再调了一个", "sched_class_proc_tick", "大家想想 这个里面还有印象吗", "在lab6里面这个函数很重要", "它完成了什么呢", "它完成了跟时间相关的参数的调整", "比如说我们现在说 有一个时间片", "那么每一个timer", "有可能导致时间片的递减", "从而可以使得其它进程有机会", "在某个进程用完时间片之后呢", "有机会被调用去执行", "那这就是说在定时器里面", "这个timer_list里很重要一个处理过程", "那么第二个这个底层支撑机制呢", "是屏蔽中断", "我们为什么屏蔽中断 大家想一想", "屏蔽中断最主要的目标", "是要保证互斥性", "在这个屏蔽中断之后呢", "我们就不可能对它进行调度了", "这对调度器产生的影响", "这是我们说这个", "屏蔽中断最重要一个目标", "屏蔽中断完成了一个", "互斥的一个保护", "使得当前在屏蔽中断状态下的", "这个内核线程呢", "它不会被调度或者被打断", "那怎么来屏蔽中断", "那么这个和我们硬件相关", "我们有个Eflags寄存器", "这个寄存器里面有一个bit", "很重要的一个bit", "叫做 Interrupt Enable Flag", "那么这个flag那么如果自乘1", "表明当前是允许中断的", "如果自乘0表明是什么呢", "表明是当前不允许中断", "所以我们专门有两条指令", "COI和STI 这两条指令呢", "能够完成屏蔽中断和使能中断", "也就说对这个flag产生的影响", "我们的ucore利用了这种机制", "通过这两条指令来实现", "一个临界区一个代码的一个保护", "使得在这里面执行的代码呢", "它不会被我们操作系统所打断", "在这里面Local_intr_save", "对应的就是什么呢", "对应这里面的COI指令", "而Local_intr_restore呢", "对应的是STI指令", "它们除了完成对这个中断使能flag", "的一个enable和disable之外呢", "还对当前这个标记寄存器", "做了一定的保存和恢复", "这是它们完成的大致的一个功能", "那么第三个这个底层支撑呢", "是等待队列", "为什么要有等待队列", "它和我们刚才说的时钟睡眠的队列", "就timer_list是类似的", "它主要是由于某一些资源", "得不到满足之后呢", "它也需要等待", "所以呢通过这个等待队列", "使得进程可以进入等待状态", "当某个事件 或者某个资源", "得到满足之后呢", "它可以从等待当中恢复出来", "为此 我们设计了一个", "等待项和等待队列", "这两个关键的数据结构", "我们可以看一看", "这里面等待项包含什么呢", "第一个proc 就是当前哪一个进程", "和这个等待项是对应的", "第二个呢 它的这个wakeup_flag", "就是它被唤醒 或者它等待", "到底等待什么原因", "有可能有几种", "我们前面说到的 比如说", "由于信号量没有得到满足 它会等待", "由于子进程还在运行", "它需要等待子进程结束", "那么它也需要等待", "那么这就是等待的一些flag", "第三个呢有一个等待队列", "也就说你这个等待的项", "会挂到这个等待队列里面去", "第四是wait_link 那么就是说", "它在这里面就是完成了", "对这个等待队列里面链表的", "一个建立过程", "那么这几项合在一起", "形成了我们说的wait这个等待项", "等待列表呢 其实就是一个", "等待项形成的双向链表", "用的是我们通常用到list_entry", "我们看它的操作", "如果说 现在的进程", "想进入一个等待状态", "它会做什么事情呢", "这里面举的例子", "是以信号量的P操作为例", "就是对应函数叫down函数", "来做这个等待一个过程", "可以看着 这里面很多其它一些", "高层函数呢会调这个down函数", "这个down函数最终会", "调一个很关键的函数", "让进程进入等待队列", "一个函数叫wait_corrent_set", "那么这个函数呢", "会完成什么事情", "它会产生一个等待项", "然后对这个等待项进行初始化", "叫wait_init", "同时把这个等待项呢", "挂到这个等待队列里面去", "叫wait_queue_add", "最后还会把这个进程", "从运行状态变到等待状态", "这里面跟以前讲的不太一样", "以前经常是运行态变到就绪态", "这里面说的是从", "运行状态变到等待状态", "同时完成schedule", "这是说让进程进入等待队列里面", "跟等待项和等待队列相关的", "一系列的操作", "第二个也会唤醒", "我们说 当一个进程", "它需要的资源得到满足之后", "它会被唤醒", "那么唤醒最主要的一个函数", "是wakeup_wait", "跟这个等待队列相关", "它也是一样 可以看着", "由于一系列的一些高层函数呢", "会调 比如说信号量这个V操作", "这里面对应是up函数", "这个up函数呢", "会进一步调wakeup_wait", "就是唤醒当前等待在", "这个信号量上这个进程", "那么wakeup_wait呢", "它首先会把那个等待项", "从等待队列里面取出来", "并进一步调wakeup_proc", "完成对这个进程的唤醒工作", "所谓wakeup_proc", "很明显就是跟我们前面讲的", "进程管理相关", "它会把这个进程的状态", "从等待状态变到就绪态", "然后呢就进一步去执行了", "那么既然进到就绪态呢", "那就意味着它可以参与到这个", "调度器的调度管理中来"]}, {"name": "", "block_id": "c3ec1fe6ccf148b9868ad8365de7d3b5", "text": ["那各位同学大家好", "那我们今天给大家介绍一下", "lab3的实验内容", "那lab3是有关虚拟内存管理", "大家在学完原理课的", "虚拟内存管理之后呢", "可以通过这个lab3实验呢", "能够对虚拟内存管理的", "关键的一些知识点", "它的一些基本概念和", "它的一些处理机制等等", "有更深入的理解", "那我们希望通过lab3呢", "大家能够把这两者之间呢", "建立一个对应关系", "那我们这次课呢", "主要讲以下部分内容", "第一部分是有关", "我们这次实验它的目标", "我们希望通过学习完原理课之后呢", "我们再做实验要达到一个", "什么样一个目标", "这是我们第一个要讲的工作", "第二个是回顾一下lab1和lab2", "为什么要回顾呢", "是在于我们的lab3呢", "其实在建立在lab1和lab2基础之上的", "它用到了中断 用到了页表机制", "来实现我们这个lab3", "然后呢我们会介绍一下这个lab3", "大致的一个整体设计框架", "以及这里面用到的一些", "关键数据结构 功能和大致处理流程", "尤其是针对两个关键的部分", "一个是页访问异常的处理", "一个是页换入换出机制的一个处理", "这两块呢重点给大家阐述一下", "通过这些阐述呢能够使得大家", "可以更容易的去理解", "和完成这次实验的内容", "好 我们看一下这个目标", "那么目标是什么呢", "我们说 第一呢其实是", "把你lab1和lab2再回顾一下", "知道lab1和lab2到底完成了什么事情", "因为在这里面我们前面已经提到了lab1", "它完成了一个很重要的一个机制", "是中断处理机制", "而我们在lab3里面用到这个页异常呢", "也其实它这个处理过程也是建立在", "这个中断处理机制之上的", "所以说呢这两者有个必然的联系", "这是一个 第二个就是实验二", "实验二我们是完成了什么", "完成了一个物理内存的管理", "建立了基于页机制的这个映射关系", "而我们这个lab3虚存管理呢", "也是充分利用了这个页机制的", "这个映射的关系", "来完成了虚存的管理", "所以说这两个呢", "其实你首先你在完成lab3之前呢", "你需要对lab1和lab2", "你完成lab1和lab2做一个理解", "做一个回顾 我们可以说lab1和lab2是", "打下了一个很好的基础", "如果有同学能够顺利", "或者说经过自己的努力完成了lab1 lab2", "我可以说后面的实验相对来说", "要容易很多 要平坦很多", "不像我们前面说lab1 lab2", "它要了解大量的硬件细节", "尤其是80386这个保护模式", "但是一旦大家突破这个瓶颈", "那我想后面的这个完成lab3", "以及后续这些实验呢", "就应该要轻松和容易很多", "那我们lab3要完成什么事情", "lab3其实我们最终目标是", "希望要提供一个比实际物理内存空间", "要更大的一个虚拟内存空间", "也意味着你的物理空间", "可能只有比如说4兆", "那其实我们虚拟出来了8兆使用", "这其实给我们应用程序", "提供了一个很好的使用空间", "当然在这里面我们还没碰到应用程序", "要到lab5去才碰到 但是这里面呢", "我们其实提前做好这些准备了", "要达到这个目标我们需要", "刚才说到了要借助于这个", "中断和页表机制 来完成什么呢", "专门针对缺页错就是说页处理异常", "这种机制的一个处理", "那么这是建立在", "我们中断这个机制之上的", "同时呢我们还要去完成什么呢", "完成一个FIFO页面的一个替换算法", "我们在讲原理课的时候", "讲了多种替换算法", "那么这里面我们只是", "挑了一个最简单的FIFO", "先进先出这个页面置换算法", "来实现所谓的把一些不常用的页", "把不常用的一些页给换出去", "把最常用的页换进来", "当然这个常用不常用取决于", "你的算法的设计和实现了", "你为了能够换入换出", "你要想到你换入和换出", "是要和我们什么呢", "和我们的硬盘打交道", "所以说你还需要提供一个", "对硬盘的一个处理", "对硬盘进行读和写", "这个呢就是我们说大致总体目标", "希望通过这几个结合呢", "来实现所谓虚存管理的", "一个基本的一个框架", "那实验目标呢是虚存管理", "这一块主要是希望提供一个", "比实际物理内存更大的", "虚拟内存空间", "这是我们和我们原理课的原理和", "相应概念是一致的 那怎么做呢", "这里面要完成两块主要的练习", "第一块练习呢是完成这个", "给未映射的地址", "映射上物理页这么一个工作", "这主要是说", "当一旦产生这个缺页异常之后", "我们通过对do_pgfault", "关于这个缺页的这个中断处理例程", "最主要的一个函数的设计和实现呢", "来完成给未映射的页面映射上物理页", "这一块呢需要考虑一些细节", "到时候我们会在后面", "还会进一步讲解 这是第一个", "第二个练习", "第二个练习是完成页替换算法", "这个页替换算法比较简单", "是FIFO 算法本身简单", "但是你需要把这个算法呢", "能够和我们整个ucore 融为一体", "这为此需要和好几个部分有交互", "第一个比如说跟swap分区的", "swap in / swap out这个相应的处理", "完成跟硬盘打交道", "以及要去识别相应页表里面", "的一些相关的一些改动等等", "这都是练习一 练习二要完成的工作", "在完成练习一 练习二之前", "你需要把之前的那个lab1和lab2", "要把它的代码填进去", "因为我们lab3是基于这个lab1和lab2的", "这是我们说这个练习这一块"]}, {"name": "", "block_id": "c1857a4b11d640bcbb6adf3c63e0f0a2", "text": ["今天我们开始介绍进程和线程", "进程和线程呢实际上讨论的是", "操作系统在让一个程序", "执行的过程当中", "这个执行的过程", "我们是如何在维护的", "那今天呢我们首先来讲进程", "在实际的操作系统当中", "我们有一组工具", "可以让你知道一个程序", "它执行的状态是什么样的", "比如说这个执行的是哪一个程序", "然后它目前占用内存是多少", "然后CPU的使用时间是多少", "那这地方都是它的相关信息", "那这时候有一个问题", "程序和程序的执行", "也就是我们这里说的", "进程它到底是什么样的关系", "那我们首先呢对进程给一个定义", "进程是一个具有一定功能的程序", "在一个数据集上的一次动态的执行", "那我们说程序肯定是具有功能的", "那我们在这里进程多加的两个属性", "是数据和动态执行", "有了这个程序", "加上数据和动态执行之后呢", "就变成我们的进程", "那这是我们在前面讲的时候", "我写的程序那这是它的源代码", "然后源代码我们经过编译之后呢", "变成目标文件", "这时候有我们前面讲的地址的转换", "然后在加载的时候呢", "把它放到内存里头", "我们把一个程序", "放到内存里的目标是什么", "就是为了让它对数据进行处理", "让它能够执行", "那这就是我们这里头数据和执行", "那进程呢就是讨论这个", "程序在对数据进行处理的时候", "这个处理过程", "操作系统是如何维护的", "那我们换个角度来看一下", "进程和程序之间的变化的内容", "这是我们的源代码", "你写出来的静态的程序", "好这个程序在被加到内存当中的", "我们首先以一种形式", "把它的代码放在这里头", "然后在这上面又加了一段", "这就是我们的 堆 栈 和数据 数据段", "这些内容呢实际上是为了", "让我这程序在执行的", "过程当中进行维护的", "比如说我这里有函数调用", "那函数调用和返回的地址呢", "就必须写到我的堆栈里头", "以便于我知道", "进到一个函数里头是从哪过去的", "回来的时候我要回到什么地方去", "那这是呢", "这个进程在和程序", "相比较而言我们加的内容", "那进程到底有些什么样的组成呢", "简单的来说进程包括", "程序执行的所有状态", "那具体说起来呢", "包括这样一些代码数据", "这是我们在前面提到过的", "但更多的呢是我们这里", "现在执行过程当中状态", "你比如状态寄存器通用寄存器", "和进程所占用的资源", "这些内容呢最后会构成", "我们在进程里一个", "很重要的组成部分叫进程控制块", "好这些内容呢搁到一起", "由于操作系统提供了进程概念", "好那我们进程在这里呢", "就体现出这样一些特征", "一种呢是动态性", "那说我的一个程序它在执行的过程当中", "有从创建到结束这个过程", "第二个呢是并发性", "那么我们通常所说的程序执行", "它只是一个指令指针在执行", "那我们有了操作系统之后", "这时候可以交替执行多个程序", "这个多个程序呢它可以在", "操作系统的调度下占用CPU来执行", "这种交替性呢就可以体现出", "我们在宏观上的一种并发性", "再有一个呢是独立性", "不同的进程呢我们希望", "它们之间的工作呢相互不影响", "这是它的独立性", "但是另外一个呢", "它还有一个特征叫制约性", "也就是说我两个或者多个进程", "在同一个操作系统下运行的时候", "它们就会由于共享数据", "或者说资源进程之间的通讯和", "同步产生相互之间制约", "这时候我们就需要有一个", "需要仔细把握的地方就是在于", "进程的独立性和制约性", "它们俩之间我怎么来权衡", "我们希望一个程序的执行是独立的", "但是我们同时也希望一个程序", "在执行过程中能够跟外界打交道", "这样的话我才能用同一个程序", "对不同的数据进行处理", "好那下边呢我们通过", "这样一个图示来说程序进程", "和我们在原来的CPU上执行的程序", "它怎么就体现出上面这几个特征来", "那我们这地方看到这条线索呢", "你可以理解为进程CPU", "在执行指令的时候的情况", "执行进程A的指令", "然后切换到进程B", "执行进程B的指令", "这个切换呢有一段进程切换的代码", "交替切换到最后然后再绕回来", "这时候我们看到", "物理的CPU上的指令指针", "它还是任何一个时刻", "只执行一条指令", "好这有一个执行的顺序", "那在操作系统管理下", "我们把这个切换代码", "作为一个独立的部分来看待", "我们可以观察", "各个进程内部它自己的执行状态", "好这时候呢我们就把", "一个CPU里头物理的指令指针", "转变成了四个并发执行的进程", "的指令指针", "A B C D", "应用程序在做的时候", "只观察你所关心的进程A B或者C D里头", "它的执行的情况", "那这是一个 啊 这是体现出四个", "好这种特征我们从时间轴上", "可以看到一种什么样的特征", "就是ABCD四个进程", "在时间轴上它们是交替运行的", "宏观上它是并发执行的", "好 有了这些讨论之后", "我们需要来强调一下", "进程和程序之间的联系", "和它们之间的区别", "它们之间的联系是什么呢", "进程是处于运行状态下的", "程序的抽象", "和程序是相关的", "好程序呢是一个静态的文件", "你比如说你的源代码", "或者说可执行文件", "而进程呢是执行中的程序", "除了程序之外它还有它的执行状态", "然后进程同一个程序的", "多次执行对应着不同的进程", "那我们不同的程序呢", "它的代码肯定是不一样的", "比如说在这里头我同一个命令", "IS多次执行它对应的是不同的进程", "那进程执行呢除了我们的程序之外", "还需要其它的一些资源", "比如说我们在这里头内存和CPU", "内存负责保存代码和数据", "CPU呢是用来执行指令的", "这是它们之间联系", "它们之间的区别呢", "我们刚才说了一静一动", "程序是有序代码的集合", "而进程呢是程序的执行", "它有用户态和内核态的切换", "然后进程是暂时的", "程序是永久的", "程序我可以放到一个文件系统里头", "那它就可以长期保存", "而进程呢它总是有一个开始", "一个结束", "一个变化的过程", "这个结束了", "那这个进程也就不存在了", "而进程和程序", "它们的组成呢是不一样的", "进程除了你的程序", "还包括数据和控制信息", "进程控制块", "好 那到现在呢", "我们就对进程的大致的情况呢", "有一个基本的介绍"]}, {"name": "", "block_id": "6e69c3db3ee54abeb7850ca227958a95", "text": ["今天我们通过一个实例", "来介绍系统调用的使用和实现", "在这里我们通常从应用程序的写法上来说这个事", "我们说我想写一个程序", "能够把一个文件的内容复制出来", "写到另一个文件里头改一个名字", "这个地方是我把这件事情展开之后", "我写程序会是什么样的", "首先我会在屏幕上输出一个提示", "要求用户输入", "你要读的那个文件的名字", "然后等待键盘输入", "接下来 我会提示用户", "在屏幕上给出提示说让他输入输出文件的名字", "等待并接受键盘的输入", "等到这两个信息都有了", "然后说我们就试图去打开相应的文件", "首先去打开输入文件", "如果输入文件在你的文件系统当中有", "那这是成立的 如果说文件不存在", "这个时候肯定出错了因为我要复制的源没有了", "接下来说我去看看创建输出文件", "如果说你有这个文件", "这个时候我会把原来东西覆盖掉", "这是不对的 这个时候如果文件存在", "这个时候我出错退出 这几步都做完了之后", "那我就确认我的输入文件是存在的", "输出文件是没有的", "然后开始循环从文件当中读数据写到输出文件", "从输入文件当中读数据", "从输出文件当中把数据写到输出文件中", "那为什么会在这做循环", "有可能这个文件很小我一次就搞完了", "如果这个文很大我可能会循环若干次", "等所有这些都做完", "那么这个时候我关闭输出文件和输入文件", "然后屏幕上提示我整个事情做完", "整个程序正常退出 那这是我想写的程序", "对于这个程序来说", "我会用到哪些系统调用", "我们会有键盘的输入 有屏幕的输出", "有文件的输入和输出", "实际上在操作系统内核里", "他这个实现键盘 屏幕和文件", "都视为是文件系统里的", "只是说键盘和屏幕作为特殊的文件来使用", "那么在这里头涉及到的系统调用是", "open close还有一个应该是create", "然后再有一个write read", "有了这几个系统调用之后", "那么我这件事情在上边", "用我的函数库里内容就可以完成", "具体怎么来做 我们看到要想在应用程序写", "那应用程序会使用到一个库函数read", "这和我们用到其他函数是一样的", "在我们ucore有这样一个头文件", "告诉你他格式什么样子", "然后这里头你需要知道这里的参数是什么意思", "你读写的文件 你读出来的数据放在什么地方", "缓冲区域头指针", "然后这个缓冲区域并不是无限大的", "他的最大长度你不能超过这个长度", "然后我从里头读数据往里放", "那我实际读出来的时候", "有可能比这短", "因为我实际文件里可能没有这么多数据", "如果说我实际数据比这个缓冲区大怎么办", "这个时候最多读出来是缓冲区长度", "因为在多就缓冲区溢出了", "然后读完之后返回值 这个地方有个返回值", "返回值是你的长度 你在使用的时候怎么做", "你打开文件 把这三个参数填上去", "返回来的时候", "返回的结果就是你实际的程度", "这是你在用的时候", "对于我们系统的实现来讲", "在编译程序的时候", "你的应用程序用到相应的库函数", "这个库里头在编译系统调用的内容的时候", "他就会前面准参数", "实际上这段都会往堆占压占", "压占完之后最后有函数调用", "而这个函数调用最后都转到我有一个", "你说这不是系统调用 是的", "这是一个函数调用", "这个函数调用所有的系统调用", "他都是通过一个宏展开形成相应的函数", "实际上在这里有一段汇编", "大家注意这段汇编有可能你现在还不能完全看懂", "那你需要值得这个int", "是我们前面说到系统调用的指令", "后面i实际上是你系统调用的中段向量编号", "后面num实际就是系统调用read系统调用编号", "然后后面是相应的参数", "这些填完之后", "实际上最后你在的执行应用程序", "执行到这个地方 到这里来的时候", "他就会转成系统调用进到内核里去", "接下来我们操作系统里是如何实现系统调用read", "首先我们刚才说在用户态一个int进到内核里来之后", "这实际上是一个软中段", "所有这些都会到你最开始一段汇编程序叫alltraps", "在这里会获取到中段所需要的", "相关信息组成的数据结构", "这个时候实际上TF数据结构", "那么在这里头我们注意到其中有一条", "是其中的中段向量", "那么在这里是系统调用对应中段向量", "然后依据这个那么在trap函数里头", "他就会转到我们系统调用这个函数里头", "在这个函数里头他会读其中的EAX", "实际上就是你的系统调用编号", "这个系统调用编号会看到他是等于read", "等于这个实际上相当于这个时候", "我们知道进来是系统调用", "并且这个系统调用调用是哪个功能", "我们还缺什么", "我们还缺他参数", "这些参数就会转到相应的系统调用实现里头", "这个实现里负责去堆占里头SP", "获取相应我们当时填进堆占里头那三个参数", "这个文件 缓冲区 头指针", "然后缓冲区长度 有了这三个之后", "实际上这个时候就相当于", "已经从用户态转到内核态", "如果说我是一个函数调用的话", "这个时候就已经转过来", "我在继续做相应函数实现就可以了", "这个时候我们就看到最后他到sysfile read", "这个函数里头去完成相应的文件读取功能", "这个文件读取就是直接操作底下的驱动程序", "在往下 等到他最后返回的时候", "ok 那这个时候我们到这trapret", "在这里头我们去看这类代码最后会有ireturn", "这个return会把相应的返回值的长度", "读到内容长度返回给用户态", "整个实现就全部完成", "那接下来我们会去看看实际的系统里的代码是什么样子的"]}, {"name": "", "block_id": "9331ddacfb33471994ef1a2348b63688", "text": ["各位同学大家好", "今天我们来开始讲第八讲虚拟存储", "那么跟虚拟存储相关内容呢我们会分成两讲", "一讲呢是虚拟存储的概念", "另一讲呢是虚拟存储当中的置换算法", "今天呢我们先来讲虚拟存储的概念", "在前面呢我们讲过了物理内存的管理", "在那个地方呢我们有分区 非连续分区", "这两种办法呢是讲我们在物理内存当中", "如何去找到一块可以给进程使用的内存空间", "那么在今天呢我们来开始讲虚拟存储", "虚拟存储和前面讲的非连续内存分配呢", "是它的一个延续 非连续内存分配", "是说我在内存里找存储空间", "让它可以不连续 而虚拟存储呢", "是在这个非连续存储内存分配的基础上", "可以把一部分内容放到外存里的做法", "那这种做法呢可以让我们的应用程序", "有更大的空间可以来使用", "那具体说起来怎么做呢", "那在这里头我们就会讲到", "我们为啥会要把数据放到外存里头去", "因为在外存里访问呢它是会比内存慢的", "这样会带来一系列的问题", "那说我们在这里呢这样做之后", "可以让你内存的空间更大", "那如何来做呢我们这里会有到覆盖 交换", "这两个做法呢在前面的介绍我们已经提到过", "那更主要的一部分呢", "是我们这里说到的虚拟存储", "虚拟存储呢又涉及这样几个方面", "第一个说我可以把数据放到外存里头", "那如果说你的访问是完全随机的", "那这时候你放到外存里头之后", "你的访问它的性能肯定是要下降的", "好 那实际上呢我们在这里呢", "程序的执行它有一定的特征", "这就是我们这里的局部性原理", "有了局部性原理之后呢", "相当于我们程序在访问的时候", "它要么是指令的顺序执行 要么它是跳转", "跳转多数时候呢又是一个循环", "跳回到你原来访问过的某一个位置", "基于这样一些存储访问的特征呢", "我们可以说使用虚拟存储呢", "它的性能不至于比原来下降很多", "但是我可以得到更大的存储空间", "好 然后再说我们如何来做这件事情", "这就是我们说到的虚拟存储的概念", "然后说我们在页式存储之上", "加上把一部分的页放到外存", "这就是虚拟页式存储", "再有一个就是说我们在这里", "由于你把这个数据放到外存里", "那么你在指令执行的时候有可能你访问的", "某一个数据就在外存里", "好 那这个时候就有我们的缺页异常", "那缺页异常实际上我们前面讲中断的时候呢", "也已经涉及到过一些", "它是指令执行过程当中出现的问题", "好 那对于缺页来讲它的处理是什么样的", "这个是我们这次课里头呢要来介绍的内容", "那首先呢我们来看虚拟存储", "为什么我们要做这件事情", "那做任何一件事情它都是需要有需求推动的", "那我们说在这里呢", "现在对存储的容量的需求呢是越来越大的", "那我们看到这是以电脑游戏为例", "在早的时候的电脑游戏呢", "通常情况下我存在一张软盘是几十K", "几百K的这样一个尺度", "那这时候呢我们常见的警察抓小偷之类的", "然后到接下来呢我们希望这个游戏更好", "这种图象质量更高 好 那这种交互性更强", "那这时候我们游戏占的空间就变成几兆", "好 在这种情况下", "那就跟原来比就是10倍的增加了", "好 再往后我们要想更大场面的", "你比如说这是足球的互动游戏", "那在这里头呢这些人物 它的这个角色增加", "并且可以有很强的交互性", "每一个动作又有3D的动画之类", "这搁在一起之后", "我们这个游戏变成几十兆 上百兆了", "好 这种情况下 这只是一个例子", "说明我们应用程序随着时间推进", "它对存储的需要量是", "远大于存储容量的发展速度的", "那在这里头呢我们说有了这种需求之后", "我们对于存储来讲", "我们就要从技术上来解决问题", "那具体技术解决的办法呢", "我们有这样几条要求 第一条是容量", "那容量我们希望它越来越大", "第二个呢是我们希望速度它越来越快", "然后第三个呢 我们希望价格是越来越便宜的", "但是这几个目标呢实际上是相互制约的", "和计算机内部的其它部分呢相比较而言呢", "它是占的成本是不能太高的", "基本上在这个发展过程当中这一部分", "占的在计算机系统里头成本", "是大致相对稳定的一个比例", "好 那这是理想的情况", "这个理想的情况那我们是做不到的", "好 那这时候呢我们就会", "在现实当中来做这种折中", "好 现实当中折中是什么呢", "我们就会把存储放成这样一个层次结构", "那最快的是我们CPU里面的寄存器", "然后最慢的是我们外部设备里的磁盘和磁带", "好 中间 居于中间状态呢就是我们的内存", "那这几个呢它们的速度最快的是纳秒级别的", "最慢的是秒级别的 中间差100万倍 百万数量级", "然后它们的容量呢是几K 几兆 几十兆", "到最后呢 现在应该是我们到几个T这种尺度", "为什么这个比例我不可以都放这上头来呢", "原因在于 增加这些快速的部分的容量", "那它的价格就上去了", "好 那这时候说我们要想增加它的容量", "那我就是底下这几个 成本比较低的", "那这时候呢成本比较低的这几个呢", "速度又降下来了", "所以实际上这时候它组成一个层次结构", "让整个系统处于一种均衡的繁忙状态", "是我们想达到的最终的合理状态", "好 有了这些需求之后", "和内部存储介质的多种多样之后", "那我们在操作系统里对存储空间的管理呢", "就变得比较复杂了", "那我们希望管理出来操作系统抽象出来的", "进程地址空间呢是一个规范的", "布局合理的一个地址空间", "而在我们实际系统里头呢", "那它的存储介质是多种多样的", "那如果说直接让用户来应对", "这些存储介质的使用的话", "那么这时候你写出来程序", "它的通用性就会很受限制", "然后它编程的难度也会很高", "所以在中间呢我们用操作系统来做这种抽象", "这种映射关系由操作系统自动来做", "用户见到的空间就是上面的抽象的地址空间", "如果是这样一种结局的话", "那我们现在这个应用程序开发的环境就非常好了", "好 为了做到这一条", "那这就是我们在计算机操作系统当中的", "存储管理所需要 想达到的目标", "好 这种需求呢", "我们出现的原因是由于内存不够用", "而内存不够用呢也是随着", "我们在操作系统里头它多道程序", "多进程 多线程 这样一些", "并发性提高的情况下所导致的问题", "那解决办法呢我们有这样几种", "一种呢是覆盖 用户自己来导你的程序", "比如说我的代码都放到内存里不够了", "那我就会说我把它代码分成若干模块", "我们明确它们之间调用关系", "好 相互之间不存在调用关系的", "那好 那这些呢我就可以", "把它附庸到一块区域里头来", "但你附庸之后就得要你用户自己", "来确定我在什么时候把一个模块加进去", "什么时候把另一个模块加进去", "这个你的应用开发难度会提高的", "第二种是兑换 说我们在这里", "用操作系统来干这件事情", "但是这时候呢因为我兑换的单位", "是一个进程的整个地址空间", "那这个时候它的开销是比较大的", "但是尽管说开销比较大", "在早的时候我不能做到", "非连续物理内存分配的时候", "这种办法仍然是有效的", "好 那这个是一个", "而我们今天要说的呢是虚拟存储", "那我们和前面的交换这种", "自动比较起来又往哪走了一步呢", "它仍然是自动的", "但是它的空间和容量是会更大 也会更自动", "那这是我们想要达到的目标", "那有了这个目标之后下面我们就", "具体来讨论我们是如何来实现这个目标的"]}, {"name": "", "block_id": "ea19f406608e4985a8b76c2b10ceec1f", "text": ["下面我们来讨论银行家算法", "银行家算法是一种死锁避免的方法", "它指的是说", "我们以银行贷款分配的策略为基础", "通过判断系统是否处于安全状态", "来确定我这一次的资源分配是否同意", "这里借用的银行贷款分配策略是这样的", "客户在申请贷款的时候", "那你必须告诉银行", "你最大的资金申请量是多少", "并且保证在你的项目执行完毕之后", "能及时归还贷款", "对于我们操作系统里的", "银行家算法也是有类似的要求的", "从银行这个角度来说", "它只要保证用户贷款的数量", "不超过银行的最大值", "那么这银行就应该尽可能的", "满足客户的需求", "也就是说银行手里头没钱不行", "有钱不把它借给客户", "实际上它的利用效率也是很低的", "那这个比喻呢", "我们可以这样来进行对应", "银行家对应着我们这是操作系统", "银行家要来判断", "我借出去这笔钱行是不行", "安全不安全", "操作系统需要来判断", "我这个资源分配出去是否安全", "那银行家借的是资金", "这是它的资源", "对于我们操作系统来说", "我的CPU内存", "这是我的资源", "银行家应对的是客户", "而操作系统应对的", "是申请资源的线程或者是进程", "具体怎么做呢", "首先它要对系统的状态", "有一系列的记录", "你比如说在我们这里头", "假定系统里的线程数目是N", "然后资源的种类是M", "这时候呢 它们有一个矩阵", "M乘N的矩阵", "表示每一个线程", "它需要申请的每一类资源的总数", "那有了这个数字之后呢", "这里的一行", "那肯定是小于我系统里", "所拥有的所有资源的总量", "这是一个最基本的限制", "第二个是说我系统里的剩余资源", "这地方是一个长度为M的向量", "也就相当于系统里有M总资源", "每一种资源当前还剩多少", "再有一个是分配矩阵", "这里描述是已经分配给", "每一个线程的各类资源的数目", "以便能够知道它和总量之间", "到底是个什么样的关系", "已经分配出去", "不能大于每个进程", "在起头的时候生成的总量", "再有一个就是还有一个未来需要的量", "这也是一个M乘N的矩阵", "每一个线程它还需要M类的资源里的", "每一种各需要多少 那从这", "这几个向量和矩阵之间", "有这样一个关系", "最大的和未来需求的", "和已经分配的它们构成一个等式", "未来需要的等于最大的", "减去你已经分配的", "这是银行家算法在运行过程当中", "需要维护的信息", "也就是说它需要知道", "我现在总共有多少资源", "哪些已经分配出去了", "哪些还是空闲的", "这是它必须掌握的 否则的话", "它没有办法判断到底是否处于安全", "然后在这里就有一个安全的判断算法", "这里头呢 它的做法是说", "我们把现在可用的资源复制一下", "作为我当前进行判断的一个工作场所", "然后就看在这个状态下", "是不是我可以满足", "当前已经分配过资源的这些线程", "它的总的需求", "如果能满足", "表示我当前这种状态下", "可以把所有已经分配出去的资源", "最后在用户用完之后能够回收回来", "如果不是这样的话", "它就是不安全的 那在这呢", "每一个线程有一个状态", "false表示当前还没有运行完", "如何来判断当前是否安全呢", "它就是在所有这些线程里头去查找", "我未来需要的资源的总量", "是否小于我当前有的这些资源总量", "并且当前这个线程是没有执行完的", "如果能找到这种情况", "那实际上就说明我当前的可用资源", "是可以满足某一个线程的", "未来的所有需要的", "那这时候呢", "我能把它的资源给回收回来", "如果你找了一圈之后没有找到", "那这时候呢", "就相当于是不安全了", "如果找到那这时候呢", "我就会把资源放回到可用资源里", "就是放回到work里", "同时把它的状态改为true", "也就是说这个线程结束了", "然后我再回到这来继续找", "到最后所有的都满足", "或者说有一个不满足", "但是我找不着剩余的资源", "可以满足某一个线程未来的需要", "那这是最后一步", "是否所有的线程", "都已经变成完成状态", "如果不是 它就是不安全的", "如果是那这时候它就是安全的", "这是银行家算法里头最核心的部分", "基本的思路就是我当前的剩余资源", "可以满足某一个线程的未来需要", "并且这种迭代循环到最后", "能够满足所有的线程的需要", "也就相当于我找到了一个安全序列", "有了这个基本的判断之后", "我们的银行家算法说起来就简单了", "每一次请求的时候", "我来判断这个请求是否安全", "首先第一个判断", "这个请求的资源量", "和最大的需求量比较", "它是不是比它小", "需要的资源量和你当前申请的资源量", "如果说你现在就已经超了", "那肯定这就已经报错了", "那我就拒绝分配给你相应的资源", "如果满足我需求的量", "还没有到我声称的最大量", "那这时候呢", "就进入第二步判断", "看我现在可用的资源是不是够你用的", "如果不够用线程必须等待", "如果说够用", "再来判断我现在这个是不是安全", "怎么来判断呢", "假定你把当前的用户申请允许了", "把资源分配给它了", "然后看我是不是能找到一个安全序列", "假定你已经把用户的请求分配完毕了", "这三个矩阵或者是向量", "它的状态发生变化", "然后我们调用前边的", "安全状态判断算法", "来对它进行判断", "判断完的结果有两个", "一个是安全的", "一个是不安全的", "如果安全的 那我同意分配", "并且把资源分配给相应用户", "如果不安全那这时候", "我前边就已经拒绝", "或者说到这我也再拒绝", "这是银行家算法", "那这个算法到底怎么来用呢", "我们下边通过一个例子来说明", "最主要的部分就是", "判断这个状态是否安全", "假定给一个初始状态", "这是我系统里的总的资源数目", "R1、R2、R3", "分别是9、3、6", "它的资源总数", "这是四个线程", "它们所声称的资源需求总量", "每一个的总量都小于我这个", "比如最大是9", "R1没有大于9的", "如果说这时候就有一个", "那你直接告诉它这事是不行的", "这是我已经分配出去", "到当前这个状态的", "这两个矩阵相减就是未来它需要的", "这时候我也可以告诉你我当前剩余的", "那这个状态是否安全呢", "我们需要判断的就是未来需要的量", "和我当前所剩余的这些资源比较而言", "是不是我可以找到一个序列", "最后把所有的资源全部收回", "我们对照了一下", "第一次你可以找谁", "1、2、3、4", "最后一个资源只有这一个", "T2是我正好所有的都满足的", "因为它只要R3", "我这里R3有 OK", "这事行了", "假定我把T2的需求满足分配", "给它一个R3资源 这时候呢", "我就可以把这里", "它用到的资源就都给收回来了", "那么这时候我这就变成6、2、3", "我分配完之后的状态是这样的", "原来这两个的状态就都清零了", "我这的状态变成6、2、3", "然后这时候说我是安全的吗", "实际上我们看下去", "我这的剩余资源可以满足", "剩下的三个线程任何一个", "当前执行都是可以的", "那这样的话", "我又可以把它们的都给回收回来", "再来 这样的话", "我们就看到最后剩一个", "这肯定满足", "所以我们说这个状态是安全的", "那我们再换一个例子来看", "在这地方同样是当前资源总数", "各个线程需要的资源总量", "以及与我已经分配出去的状态", "和未来各个线程需要的资源量", "和我当前的状态", "用户再想分配一个变成这种状态", "T1请求R1和R3各一个资源", "变成现在这种状态了", "那这种状态是安全的吗", "我们说如果你敢这么分配", "分配完了之后", "剩余的资源就已经没有办法满足", "这四个线程当中的任意一个", "未来的需要了", "这个可以满足剩下的R2", "都是不满足的了", "两个就不行", "然后R3的话", "那这两个不行", "所以最后你就没有办法找到一个", "当前资源够某一个线程未来所有的需要", "所以这个状态是不安全的", "如果说T1请求R1和R3资源数个数为一的话", "那么这个请求呢", "你是不能同意的", "同意了你这个系统就是不安全的了"]}, {"name": "", "block_id": "da1e3764a86f47b59f552501e9fee64d", "text": ["刚才我们通过一个", "生活当中的同步例子", "说明了同步所会遇到的问题", "和可能的解决方案", "那么下面呢我们就把在计算机当中", "同步问题的解决方案呢", "给一个规范的描述", "这就是我们这里说到的临界区", "临界区是指进程访问", "临界资源的一段", "需要互斥执行的代码", "在我们这里头呢", "这是我们要保护的代码", "在这段代码里头呢", "任何时刻只允许一个进程", "在这段区域里头执行", "为了做到这一点", "我们在临界区之前呢", "有一个进入区", "那在这里头呢", "需要去检查进程", "进入临界区的条件是否成立", "如果成立 那就进入", "那进入之前呢需要设置一个标志", "这个标志说当前进程", "正在访问临界区", "好 那有了这个进入区", "条件检查成立之后", "那我就会使用", "使用结束之后呢有一个退出区", "退出区的主要功能呢", "就是清除你所设的", "进程正在访问临界区的标志", "还有一个部分呢叫剩余区", "这一部分呢", "就跟我们同步互斥没关系的代码", "那这是我们在这里对", "临界区的标准的", "访问模式一个约定", "有了这个约定之后", "我们来描述一下临界区的访问规则", "在刚才前面例子当中我们说", "我们任何时候临界区的资源", "我需要是互斥的访问", "那也就说如果有一个在访问", "另外一个进程不能再访问", "如果说没有进程访问", "那这时候呢 你就可以进去", "好 在这里头我们把这些呢", "描述这样几条规则", "一条呢叫空闲则入", "也就说没有进程在临界区时", "任何进程可以进入", "你不能像我们前面举的", "生活当中例子", "谁都进不去这是不对的", "第二个叫忙则等待", "如果已经有进程在临界区了", "其它进程均不能进入临界区", "那如果说这一条不满足的话", "就会有两个进程", "同时进到临界区里头", "比如说我们面包买重的情况", "还有一个规则是有限等待", "也就是说在等待区里的进程", "不能无限制的等待下去", "好 那这时候呢", "我需要对等待的时间有一个约定", "最后一条叫让权等待", "也就说不能进入临界区的进程", "需要释放CPU进入等待状态", "而不是说像我们在前面例子当中", "我需要频繁去查", "当然这一条呢", "它是需要有相应的一些支持", "所以在这里呢它是可选的", "有了这几条临界区的访问规则", "那么下面呢我们就来看", "临界区的访问的实现方法", "那在这里呢我们介绍三类", "一类呢是禁用中断", "那禁止中断之后", "那其他的进程就没有办法", "对当前进程的执行呢", "进行任何的打扰了", "那这时候呢", "我当前进程对临界区资源的访问", "也就不会有任何问题", "但这时候他对", "系统的中断的响应会有影响", "因为你禁止之后", "中断就没办法响应", "然后是第二类办法呢", "是用软件的办法", "也就说在硬件还没有支持的时候", "那这时候呢我们先尝试用", "共享变量协调的方式来做这件事情", "那这时候呢它是比较复杂的", "第三类办法呢", "我们是借用操作系统的支持", "来对应用提供同步的服务", "那在这里头呢由于引入管理者", "那么我们在这里就不像软件的办法", "完全是大家", "对等协调的方式来完成的", "那这几种办法", "它的衡量标准是什么呢", "那我们在做比较的时候", "是比较它的性能", "和它的并发的级别", "也就说到底我是", "允许什么样的并发执行", "接下来我们说禁用中断", "禁用中断呢", "顾名思义它就是", "禁止硬件中断的响应", "那也就相当于", "我把中断使能给关掉了", "那这时候就没有中断", "那也就没有了时钟中断", "也就没有了上下文切换", "好 这时候呢也就没有了并发执行", "所以在这种情况下", "整个系统呢是由当前进程独占", "硬件的响应处理 被延迟到", "你中断启用之后", "那这时候对于紧急的事情呢", "它没有办法做响应", "好 那在这种做法里头呢", "我们现在的计算机系统呢", "都有相应的一些指令", "来实现禁用中断", "下面呢是我们基于中断禁用", "所给出的临界区域访问代码", "在这段代码里头呢", "通常情况下我们用一个宏", "来实现把当前的CPU的状态", "保存到存储单元当中", "同时把中断禁止掉", "因为如果说你不保存的话", "等你中断恢复之后", "那么整个系统状态呢会发生变化", "然后是临界区的访问", "访问结束之后我是恢复系统的状态", "并且使能中断", "那这时候对应过来呢", "进入区就是我们这里的关中断", "而退出区呢", "就是我们这里的使能中断", "好 这种办法呢它有很大的局限性", "也就说关中断之后", "进程就没有办法停止了", "如果这时候你的进程执行出了问题", "那整个系统就没有办法回来了", "还有一个问题是", "它可能导致其它进程处于饥饿状态", "也就说它们没有得到执行的机会", "再有一个呢是 我们在这里头", "它的执行时间可能会很长", "从而呢使得", "我中断要求及时响应这一条", "没有得到支持", "好 所以在这里头呢", "匝的使用必须很小心谨慎的来用", "那在我们的计算机系统里呢", "通常情况下只是在", "不能不用它的时候我才会去用它"]}, {"name": "", "block_id": "f4ae8dadf98b4e0c9937295f81df1873", "text": ["好 那我们前面已经", "把这个空间建立完毕", "那接下来干什么", "我们希望我们的这个进程", "用户进程能够去到用户态去执行", "为此我们需要做个小练习", "来完成trapframe一个设置", "大家再回顾一下trapframe在哪见着呢", "其实在我们lab1", "lab1就已经涉及到了有一个", "trapframe完成了中断的一个", "打断的一个状态的保存", "就放在什么地方呢", "trapframe里面", "那为什么要用这个trapframe呢", "因为我们希望通过这个设置", "来完成一个特权级的一个转变", "从kernel空间切换到用户空间", "去执行我们的程序", "从而实现所谓的用户进程的一个执行", "那这个过程建立在前面的基础之上", "把这一步建好之后呢", "就可以让这个用户进程去执行了", "这是我们的练习", "那为此我们需要了解一下", "怎么从特权态0到特权态3", "这么一个切换", "其实这个过程呢", "在我们讲特权级的时候呢有提及", "但这里面我们再回顾一下", "那时候讲的时候第一个是说", "我们有一个ring0一个栈空间", "然后呢我们为了能够到ring3去", "我们做什么事情", "在这里面构造一个", "中断打断时候这个", "硬件保存的栈信息", "这一块", "正常情况下在内核态里面", "产生一个中断之后呢", "它会在它这个内核堆栈里面", "保存这个信息", "当然你完全可以自己", "构造出这么一个信息出来", "因为我们希望根据这个信息呢", "来使得在执行iret这条指令之后呢", "能够回到用户态去", "但这里面还不行", "为此我们要对它", "这个堆栈要做进一步的修改", "SS和CS呢重新设置", "从特权级0变成特权级3", "而且它的地址ESP还有EIP", "这个地址一个是堆栈的offset", "一个是执行地址的offset", "那么要重新设置", "从而可以使得这个区域呢", "正好是说模拟的一个", "当从ring3产生中断之后", "回到ring0的时候", "硬件保存的信息", "有了这个信息", "如果我们再执行ret的时候呢", "就会跳到ring3去了", "当然这个前提是我们前面已经", "建好了所谓这个中断门", "这是我们在lab1里面要掌握的内容", "那区别是什么呢", "lab1呢是从ring0里面产生中断", "依然回到ring0", "我们这里面是要从ring0里面", "要跳到ring3去执行", "lab1的challenge其实要完成这个事情", "直到lab5呢我们必须要完成这个事情", "才能实现用户进程在用户空间执行", "其实我们关注的是怎么能够去", "构造出一个合理一个trapframe", "使得在接下来执行ret之后呢", "能够跳到用户空间去执行", "那我们再小结一下可以看出来", "为了能够完成ring0到ring3这个跳转", "我们的进程 创建这个进程", "用户进程 它有两个栈", "一个是内核的stack kernel stack", "一个是用户的stack", "这样才能确保在用户态的时候", "它用的是用户stack", "在内核态的时候呢是用内核stack", "它可以通过系统调用", "来完成到内核的一个执行过程", "在一开始", "我们创建这个进程的时候呢", "还需要通过特殊的机制", "构造一个trapframe", "使得它能够跳到 这个", "用户进程的第一条指令去执行", "那这个过程", "需要大家通过练习来完成"]}, {"name": "", "block_id": "dd5492927c66446d94e8950d8543210a", "text": ["接下来我们介绍虚拟页式存储", "那么在前面呢我们已经说过了", "虚拟存储它的基本概念是什么样的", "它的基本思路是啥样的", "那我们把它置换的", "交换的这个单位设置为页之后", "就变成我们这里的虚拟页式存储", "那它的基本思路很简单", "就是在页式存储管理的基础上", "增加一个请求调页和页面置换算法", "那这类的做法呢它具体做起来的时候呢", "我们在怎么做呢 它思路是这样的", "首先在程序加载的时候它只加载一部分页面", "那这个和我们前面的", "页式存储管理不一样地方", "页式存储管理呢它加载的时候", "是把所有的都加载到内存当中", "只是它可以实现存储的不连续", "你可以找到相应的页面 有空闲页面就足够了", "那你这样一来的话", "在执行的过程当中它就会出现缺页异常", "那在原来的页式管理里头呢", "它也会出现异常但不会出现", "这里所说的这个缺页", "因为我这个进程地址空间里头任何一个页面", "都有对应的一个物理页面存在", "好 这是跟原来不一样的", "好 如果出现这种情况那怎么处理呢", "操作系统里头要加一个缺页异常的处理", "将相对应的在外存当中页面呢调到内存当中来", "并且把相应的页表项进行修改", "修改完毕之后以便于我可以重新执行这条指令", "那这样的话这条指令就能继续下去了", "那随着这个执行的过程呢 那我在内存里呢", "只有一部分内存进程的地址空间内容", "在内存 但是整个进程它是可以一直这样", "良好的运行下去 那关键的问题", "就在这个地方有个缺异常的处理服务例程", "那这是我们在虚拟页式存储当中的地址转换", "如果大家看这张表的话", "这和我们前面页式存储的地址转换", "是完全一样的 说 这是逻辑地址空间", "这是物理地址空间", "然后我在某一条指令访问的时候", "有一个操作数是页号加页内偏移", "然后页号加页内偏移呢通过这边转换之后", "到页表 页表找到相应的页表项", "如果说是页式存储管理", "这里对应的页表项", "一定会是有一个物理页号 页帧号", "然后找了页帧号呢把它的页内偏移加过来", "这就能找到相应的物理内存单元的内容了", "好 如果说在前面加上虚拟怎么办呢", "加上虚拟之后这个地方呢", "你在这个地方就会在页表里加一个", "多加标志位 这个标志位呢会表示", "我对应的这一页是否在物理内存里头", "如果不在这条路就走不下去了", "好 这条路走不下去之后呢", "执行到这儿呢它就会产生缺页异常", "然后 这个缺页异常呢 就会由操作系统来接管", "操作系统要做的事情呢是找页把它写好", "然后把这个位变成有效", "OK 这一件事情就算过去了", "这是在虚拟页式存储管理当中的地址转换", "我们看到变化呢 从整张图上看变化很小", "但实际上这些小点的变化呢会导致很多的修改", "好 那这时候一种修改呢是在页表项里头", "原来的我们页表项是从以逻辑页号为序号", "找到的呢就是物理页帧号", "有了这个物理页帧号之后", "我就能转换出相应的物理地址来了", "但是在虚拟页式之后", "虚拟呢我们就会加上一些标志位", "这是在虚拟存储管理里头", "需要用到的几个标志位", "分别的含义是什么呢", "首先第一个有一个叫驻留位", "它是表示该页面是否在内存当中", "那如果说是一 表示在内存当中这时候呢", "对应过来一定可以找到它的页帧号", "那可以转换成实实在在的物理内存单元的地址", "好 如果它是零 表示这一页呢在外存里头", "那这时候就会导致缺页", "那导致缺页之后呢", "就会来修改这些标志位", "好 这是第一个标志", "第二个标志是修改位", "表示这一页在物理内存当中有的这一页", "这必须是驻留位有效的情况下", "好这一页如果被修改过", "那这时候呢它会有什么变化呢", "如果说我想把这一页淘汰放到外存里头去", "那么这时候我必须把内存当中修改的内容", "写回到外存当中", "如果说这个地方没有修改过", "那这时候呢对应在外存单元里头有相应的内容", "那这时候我在替换的时候", "置换的时候我只需要把这一页作废就行了", "这是修改位 然后还有一个呢是访问位", "表示这一页在过去一段时间里头", "是否被访问过", "因为我们在虚拟页式存储管理里头", "它需要有一个置换算法把不常用的页面", "置换到外存当中去", "那么哪些常用哪些不常用呢", "就是靠这个访问位来进行统计", "访问位访问过它是一 没访问过它是零", "那这样的话它就在一定程度上", "近似统计出来这一页是否被经常访问", "一表示经常访问 零表示不经常访问", "还有一个呢保护位", "这个保护位是用来表示这一页允许访问的方式", "你比如说 只读 可读 可写 可执行等等", "这样一些信息 好 那有了前面地址转换", "和页表上的修改这件事情从道理上来说", "我的虚拟页式存储管理就算说清楚了", "那么下面我们先通过一个例子", "来说明一下这个过程", "假定我有一个16位的逻辑地址", "然后这个时候呢它的逻辑地址空间呢是64K", "然后物理内存我只有32K", "页面大小是4K 好 这时候我划分出来的情况呢", "这是逻辑地址空间 这是物理地址空间", "好 那么这时候说我在这里做映射怎么做呢", "我哪些映射到物理内存里头来的", "我在这里有相应的编号 没有映射过来的", "我的简化表是这里写的是X", "好 然后这样以来的话", "它们就建立一张表 对应过来这里写的是几7", "对应到物理单元的帧号是7", "好 那这样的话我这里的8个物理页面", "和16个逻辑页面之间", "有一半有对应关系 这是在页表项里有的", "好 那么这时候呢这里的X", "隐含着你的页表项里头的驻留位是零", "然后这个7呢隐含着你的驻留位是1", "那这个对应过来是驻留位的表示", "好 那么在这种情况下我们看我执行一条指令", "MOV把指定存储单元内容移到寄存器里头去", "好 那这时候说我在这边看对应的这一页", "在这个地方对应过来到这个地方 好 它是有的", "那这一条它是正常能访问过来", "好 我们再来一条指令", "我这个MOV 32到这个地方就是x", "不存在 好 这时候会产生什么情况", "这地方就是缺页", "缺页之后我就需要把现在在内存里某一页去掉", "然后把它对应内容写到内存里头", "并且改这一项", "OK我后面事情就可以做了", "以我们现在最常用的X86 32的", "CPU的页表结构来作为实例", "那么在32位的X86系统当中呢", "它有12位的页内偏移", "然后有2个10位的二级页表项", "这样的话是32位地址", "然后物理地址呢也是32位的", "那20位呢是物理页帧号", "好 然后这时候呢 它使用一个二级页表", "那这是它页表结构", "然后页表项的起始地址呢是CR3", "CPU里一个寄存器指出来", "然后从这儿呢", "我一个页表项占4字节 那一页由于是32位的", "好 那占4个字节呢 那么这4K为一页", "那这时候呢这12位是4K 4K为一页", "一页里头有1024项 1024个页表项", "那么正好对应着我这里的10位", "好 那这是第一级 然后第二级 这是它的页表", "那我们的地址转换怎么过来呢", "先是一级页表项里头的页号到这儿", "作为它的偏移找到相应的页表项", "一级页表项 好 这个页表项里头它有一个", "第二级页表项的物理页号", "好 然后这个时候呢", "再加上你第二级的页号 好 那从这儿呢", "第二级页表项里头呢", "以它页号作为偏移找到相应的页表项", "那这时候就是你实实在在要访问的", "物理页面的物理帧号", "好 那这个帧号呢 和你的偏移搁在一起", "把页内偏移加在一起这得到你的物理地址", "那么这是在这个结构当中它的页表的结构", "这和我们前面讲到的页式存储呢", "是完全一样的 那它变化地方在哪呢", "变化地方是页表项里头的东西", "那这地方是X86 32在以4K为页面大小的时候", "它的页表项的定义格式 那我们在这里关心的", "这是20位的物理页帧号", "这个没有什么变化", "我们需要关心后面这一段的标志", "那我们刚才在逻辑示意当中呢", "已经看到有几个标志", "在这儿呢实际上看到的标志更多", "那需要这几个是能对上的驻留位 可写位", "这是相当于权限 好 在这里头", "我们可能在前面没注意到就是用户态标志U", "实际上这表示我这个页表项", "是否可以在用户态访问", "那在内核地址空间呢", "只能有内核的状态的时候才能访问", "那这是一个权限的控制", "好 然后访问位 修改位", "然后跟我们前面不一样的地方有几个", "一个是保留位 那在这里头呢这标志位没用完", "它总会留有一些保留", "原因在于我们如果在32位的X86系统当中", "这个页表项是好用的", "但实际上呢我们在实际的系统当中", "它的物理地址空间呢 它是在不断变化的", "好 你比如说我32位的系统", "它最大的物理内存地址空间呢是4个G", "实际上我们现在用到的一些32位的系统", "它已经不是这个4个G了", "大于4个G怎么办 好 那这个时候", "相应的页表项就得跟着这个在变", "那这些呢都是为了后续的这些改动", "留有空间的 如果说你去看", "实际的因特尔的手册", "那么这里页表项结构呢有很多种", "那么它们很多是兼容的", "但是这些变化都从这儿出来的", "然后还有两个是这个地方", "就是缓存是否有效 是否写通", "实际上这里说的呢是在内存和CPU之间", "有一个高速缓存", "这个缓存呢我在读写数据的时候", "会把写出的数据先写到缓存里头", "然后高速缓存再慢慢地把它写到内存里头", "那如果说我要有一些时效性的操作", "比如说对I/O端口的操作", "那这种缓存是会影响我的语意的", "好 那这儿是有这个标志来做控制", "然后再有一些呢我在读的时候", "是否高速缓存有效", "如果说你前面读了一次 那这时候呢", "我后面再读的时候我可以直接", "从高速缓存里得到这个数据", "但实际上呢如果说这个数据它是时时在变的", "好 你第一次I/O端口里读到的数据", "第二次再读的时候你必须要从I/O端口里", "实实在在去读 那么这时候呢", "这些标志位都会影响到它的行为", "所以从这儿来看呢", "我们看到这个基本的原理里的虚拟页式存储", "和我们实际系统当中的还是会有一些差别", "这些差别转换到我们实际的", "实验系统代码里头代码里头", "这些差别就会导致我们代码会有很大的变化"]}, {"name": "", "block_id": "7383355005af41ff9a648fcf1bffbe98", "text": ["下面我们来介绍调度准则", "也就说在我们处理机调度里头", "我们调度的策略", "和调度算法好坏的一个比较指标", "那首先呢是调度策略", "调度策略呢是用来确定", "我如何从就绪队列当中", "选择下一个执行进程", "那这种选择呢", "到底选择哪一个", "实际上跟我们选择的", "调度目标是有关系的", "好 那这里我们具体说起来", "有些什么问题呢", "具体说起来就是挑选哪一个", "第二个 挑选的时候", "我用什么样的一个准则", "来进行挑选", "好 调度策略确定下来之后呢", "那调度策略的实现", "就是我们这里的调度算法", "然后我们在这里呢", "需要约定一个目标", "说我到底这两个调度算法", "或者是调度策略哪个比哪个好", "在前面我们讲过存储管理", "里头有置换算法", "那个置换算法的标准很清楚", "说到底哪个置换算法好呢", "最后 对一个序列来讲", "它的缺页次数最少 这就是好的", "如果说是在一类的", "测试用例里头", "它平均的缺页次数少 那就是好的", "但是对于调度策略来说呢", "这件事情就没有这么简单了", "那为了具体说明 我们的调度算法", "用什么来作为它的考核指标", "我们在这儿呢 有必要介绍一下", "处理机的使用模式", "也就是说我们通常情况下", "进程占用CPU来执行", "它通常处于", "这样两种模式之间来回切换", "一个是用CPU算", "这叫CPU计算", "另一个呢 我在CPU指挥下", "我要进行I/O操作", "这时候要跟外设打交道", "在外设打交道时候呢", "CPU通常情况下处于等待状态", "通常情况下呢", "我们的应用程序", "在这两种状态之间做交替执行", "那这种过程呢", "我们可以用这样一个图式来表现出来", "CPU计算 I/O操作", "CPU计算 I/O操作", "这几个序列是交替进行的", "那从这种交替里头", "我们能发现些什么规律呢", "这些规律对我们的调度算法有影响吗", "那我们对这里的这个执行的过程", "做这样一些统计", "统计出这样一个结果", "说我们关心它每一次CPU执行的时间", "这是这儿的横轴", "然后根据每一次时间长短呢", "对所有的CPU执行时间呢做一个统计", "纵向是某一个长度的执行时间", "它总的执行次数", "那这时候呢我们就得到这样一条曲线", "从这儿呢我们可以看到每一次执行呢", "通常情况下它的时间都很短", "比如说在这里看到的", "就是8毫秒以内", "好 那更长的时间呢", "如果说你给它分配更长的时间片", "那这时候呢 我们这件事情就没必要了", "所以这个呢可以用来说", "我们每一次执行的时间到底分配多长", "这是会有依据的", "好 那这时候说", "我们一个要决定下一个给谁", "那肯定是要给到", "下一个就绪的进程", "但是就绪进程如果有多个的话", "我们怎么来判断", "那这是第一个问题", "第二个是说", "如果在这里有时间片机制", "也就是我对时间有要求的话", "那进程如果说你的时间片分短了", "比如说在这里头", "我分的时间很短", "那大多数操作", "都没有执行到一个阶段的时候", "你把它暂停下来", "好 这样你恢复回来的时候", "有些事情没法做了", "好 这时候呢我可能被迫放弃CPU", "这时候对进程的执行是不利的", "所以我们在这儿要选一个", "合适的时间尺度", "来作为我们这里时间片的基本单位", "好 有了这个介绍之后", "我们再来看", "我们关心的调度算法的目标", "我会用什么样的一些指标来度量", "我这个调度算法好与坏", "首先第一个是CPU的使用率", "也就说你不同的调度算法在进程执行等待I/O的时候", "我是不是能够及时的找到另一个进程来占用CPU来执行", "如果能那这样的话", "我总的CPU的繁忙的时间", "的比例就会提高", "那最理想这是到100%", "好 这是系统关心的一个目标", "还有一个呢是吞吐力", "在单位时间内我完成的进程数目", "这是从系统利用效率的角度", "来讲我关心的两个指标", "而从用户的角度来讲呢", "我们可能关心的是另外一些指标", "比如说周转时间", "从我提交作业到最后算出结果", "这中间有多长时间", "这是周转时间用户关心的", "换个角度来说呢", "他可能会关心我的等待时间", "这里的等待时间是指", "我进程在就绪队列的时间", "因为处于我们进程状态里的", "那个等待状态的时间", "那是必须等的", "因为你等I/O操作没结束", "想干别的干不了", "那我们能缩短的", "是在处于就绪状态的这个时间", "如果说我一个进程", "从等待状态到了就绪", "马上就能占用CPU来执行的话", "那我的这个周转时间肯定就会短", "好 然后对于交互性应用来说", "我还关心它的响应时间", "从我提交请求到系统给出响应", "这中间需要多长时间", "比如说我敲键盘 玩游戏", "那这时候它不能及时响应我的操作", "这是影响用户体验的", "好 那在这里头我们说", "到底这些指标搁到一起", "好像他们都是矛盾的", "我们怎么来做 好", "这里头呢就有一个", "我到底关心哪项指标是我的重点", "通常情况下用户只是说", "我希望更快的服务", "到底怎么算快", "那在这儿呢", "我们给出这样一些描述", "那在不同的情况下", "我们对快的描述是不一样的", "比如说我在传文件的时候", "带宽高 那这时候是快", "对应到我们调度算法里头呢", "我在单位时间里", "能执行更多的进程 这叫快", "而在另一些情况下", "如果说我是在玩游戏的时候", "那我希望它的响应速度好", "那就延时低", "对于调度算法呢", "它就是有低的响应延迟", "也就是说响应时间很短 很快", "那在这里头呢", "这两个因素实际上是相互独立的", "延时低并不一定意味着高带宽", "高带宽并不一定意味着低延时", "它们俩是相互独立的", "好 我们在这儿呢用一个类比", "来说明它们之间的关系", "低延时是指说我想喝水", "那这时候呢", "那杯水我能很快的有水", "我就能喝上了", "所以这时候呢是从", "我提出这个请求", "到有水这个时间段", "而如果说我是想把一个游泳池灌满", "那这时候呢", "开始有水的时间我并不关心", "我关心的是最后灌满水的时间", "这时候实际上需要的是", "你这个水管子流量必须大", "好 这是吞吐量和响应延时这两个指标", "它们之间的对快的这个描述", "好 依据这些描述", "我们就可以把", "处理机调度策略的目标", "分成这样几个方面", "一个呢是响应时间目标", "我们希望快的响应", "也就说减少响应时间", "及时处理用户的输入请求", "尽快地把输出反馈给用户", "那同时呢 我们希望这种响应的时间", "它的抖动必须很小", "原因在于 如果说", "你在某一些情况下响应时间很短", "在另外一些情况下响应时间很长", "那实际上这时候用户体验", "它是很不稳定的", "所以在这儿 可预测的响应时间", "比高差异的低响应时间更重要", "好 这是从这个角度来讲呢", "我们改善了它的响应时间", "那这时候呢", "用户的交互体验就会好", "如果说你操作了", "机器没有及时给出响应", "那这时候呢用户很可能就会说", "我就把机器", "认为它有故障了就会把它重启", "好 所以在这个地方呢", "响应时间是操作系统的一个", "重要的调度算法要达到目标", "这就是它这里的计算延时", "另一个目标呢是吞吐量目标", "也就说我们希望增加系统的吞吐量", "那增加系统吞吐量呢", "可以从两个角度来提出解决的方案", "一个呢是减少开销", "比如说我们上下文切换的时候", "它的速度是不是能更快", "第二个是提高系统的利用效率", "你比如说CPU的利用率", "I/O设备的利用率", "如果让这两者都达到100%", "那你的效率是最高的", "同时减少等待时间", "这个减少等待时间", "用户和系统的目标呢是一致的", "减少等待时间可以提高它的响应性能", "也可以提高它的吞吐量的性能", "好 那也就说我们在这里呢", "要在有用户交互的情况下", "应该保证系统的吞吐力", "否则的话 那我们这个系统呢", "它就没办法正常使用了", "好 这时候说", "吞吐量呢是系统的计算带宽", "也就相当于我在单位时间里头", "能够尽可能执行更多的进程", "这是我们想要达到的目标", "还有一个目标呢是公平性", "也就说我们的系统它是不是公平的", "什么是公平呢", "我保证每一个进程占用相同的CPU时间", "这是一种描述", "这样就公平了吗 那不一定", "如果说一个用户执行了更多的进程", "那这时候每个进程的时间相同", "各个用户之间它是不同的", "好 那这时候说", "我们换一种提法", "让每一个进程的等待时间相同", "所以在不同的时间 不同场合", "它对公平性的度量是不一样的", "好 所以在这里头我们说公平性", "实际上你为了增加它的公平性", "我在很多时候", "会增加它的平均响应时间", "也就是我会有一定的开销", "来保证它是公平的", "好 这是我们关于调度算法的度量指标", "和一个调度算法怎么算好", "给出来的相应的描述"]}, {"name": "", "block_id": "b5e0695d06fd4db9a02572d38afd33c1", "text": ["接下来我们介绍虚拟存储当中的局部性原理", "那我们在这里说虚拟存储是想", "把原来放到内存里的这个进程地址空间的信息", "把其中的一部分放到外存当中来", "那要把它放到外存当中来呢", "实际上这时候呢需要有一系列的准备工作", "那我们首先看一下", "我们在这里头如何把这个放到外存里头来", "我们想达到的目标具体准确的描述出来", "这是我们虚拟存储希望达到的效果", "进程地址空间实际的物理内存和外存", "这两个搁在一起呢", "来存放地址空间的内容", "这一些呢放在内存一些放到外存里头", "中间呢是由操作系统来干这件事情", "那我们把这个目标具体的描述出来呢", "就有这样两条 第一条是说", "我们只让一部分程序加载到内存当中来", "这时候呢就可以让程序运行", "那这是跟以前不一样的", "以前我们说要想一个程序运行", "我必须把整个进程加到地址空间当中", "那这时候才能开始运行 只加一部分让它", "怎么能让它运行起来", "那这时候呢需要我们做的是说要操作系统", "自动的来完成我需要加载哪一部分", "而不需要程序员的参与", "而在我们前面用的覆盖技术呢", "这是需要程序员来参与的", "另一个呢是说我们可以把一部分", "内存空间当中的信息放到外存当中去", "内存和外存之间做一个交换", "这样做的目的是让正在运行的进程", "能够有更多的空闲空间", "而这一条也是需要由操作系统来做", "它在内外存之间进行交换", "需要讨论的问题是说我到底要把哪些东西放出去", "实际上这时候我们前面说的第一个", "我到底要把哪些东西放进来", "这是我用到的放进来", "这个地方我把哪个东西放出去呢", "实际上是说我需要把不常用的放到外存当中去", "这就是我们后面会说到的置换算法", "那在具体讨论之前呢", "我们需要来讨论程序访问的一些特征", "这就是我们这里说到的局部性原理", "所谓局部性原理呢是指程序在执行的过程当中", "在一个较短的时间里头", "它所执行的指令和指令操作数的地址", "分别局限于在一定区域里头", "因为通常情况下我们指令是存在代码段里的", "指令所访问的操作数呢通常是存在数据段里的", "这两个呢各是一个地方", "那这两个各自一个地方呢", "分别局限在一定区域里头", "这怎么说呢 这种特征呢体现在以下几个方面", "第一个呢叫时间局部性", "也就是说我一条指令的连续两次执行", "我一个数据的连续两次访问 通常情况下", "它们都集中在一段较短的时间里头", "正是因为有了这种较短的时间所以我可以把", "放到内存里的这一段内容 它会频繁的访问", "如果没这一条的话可能出现一种什么样的情况", "就是你刚放进来内存里的这个信息", "下一步要访问另一个你刚拿出去的", "如果出现这种极端情况的话", "你这个虚拟存储就性能大幅度下降了", "好这是时间局部性", "另一个呢是说空间局部性", "空间局部性是指我相邻的几条指令", "或者说我访问的相邻的几个数据", "访问区域呢是局限在一个较小的区域里头", "也就是说我相邻的访问的两条指令", "相邻访问的两个数据", "比如说我们在对数据进行排序的时候", "那我会有循环", "那这个循环呢就是你要访问这几条指令", "而我排序的相邻这些数据呢", "那就是你这儿要访问的数据", "它们呢通常情况下是局限在一个较小的区域里头", "再有一条呢是叫分支局部性", "分支局部性是指什么呢 说我有一条跳转指令", "这跳转指令的两次执行呢很多时候", "它是会跳转到同一个地址的", "这种情况在实际的例子中会是什么样的", "比如说我有一个循环 循环一千次", "那进到这个循环体里头", "到那个循环的跳转指令的地方", "判断小于你的循环次数", "它就蹦回到开头 那这样的话", "你从这条指令上来看", "前面只要没到你的循环次数", "那前面都是蹦到开头", "那这样的话只有最后一次是例外", "好 那这种呢我们称之为叫分支局部性", "有了这几条之后我们就可以认为", "我们所运行的程序它具有它所执行的指令", "所访问的数据有很好的这种集中特征", "它们会集中在一个局部的区域里头", "那这样的话如果我们能够判断清楚", "它局限在的那个区域到底是哪些", "我们可以对它做很好的预测的话", "那这时候我们就可以把这些内容放到内存里头来", "而把那些不常用的放到外存当中", "而这种经常用的放到内存里头之后", "那我们的计算的程序执行的性能", "就不会有大幅度下降 这也是由于这一条", "我们局部性原理 那从理论上呢保证了", "我们虚拟存储它是可能实现的", "它具有可行性 并且呢", "它实现完了之后应该能有很好的这个效果", "好 那具体呢我们通过一个例子来说明", "说这个局部性到底体现在什么地方", "同时这种局部性", "也跟我们写的程序特征是有关系的", "在这儿给一个例子", "说我在这里呢4K为一个页面", "然后我给一个进程呢 这仅仅是个示例", "分配一个页面这是用来放数据的", "好 那这里头我约定一个二维数组", "那1024乘1024 假定你的int是整数呢", "是占四个字节为一个整数", "好 那这时候呢我在这个页面", "再被这个数组呢进行清零", "我们看它访问的次数会是啥样的", "好 清零呢 我来写我这程序的时候呢", "这是一种写法 两个循环", "二维数组第一维第二维", "那需要大家注意的是我第一维呢", "在里头这个循环是用的第一个下标", "在外头这个循环是用的第二个下标", "而还有一种另外的写法 我把它反过来", "i j i j 这样的话在里头那个小循环里头", "那我是先循环的第二位", "那如果说我们在实际的存储当中", "它的存储顺序和你这两个循环", "实际上它在访问的时候", "它的位置的分布呢是很不相同的", "那我们具体看一下这两个到底会有什么样的情况", "那这是呢我们看到的刚才那个", "二维数组它在存储空间当中的情况", "这里呢每一行代表一页", "你比如说每个元素我占四个字节", "1024个刚才说的4K 4K我占一页", "我们用来存数据的呢 分配的页面是", "物理页面是一个 那这样的话我每使用一行", "蹦到下一行的时候我就会产生缺页", "那对应着我们刚才前面的两种清零的办法", "那第一种办法呢 我是从第一个元素", "然后它并不是在这一页里的第二个", "而是第二页里的第一个", "一直到最后一页的第一个", "然后再是 这样循环下来的", "我们看它 它的访问顺序 第一页一直到1023", "然后又是第0页到1023", "这样的话我每一次相邻的一次访问", "我都会切到下一页 那这种切换呢会导致一次缺页", "那这样总共缺页次数是什么", "就是1024乘1024 而我们的第二种做法呢", "它的访问方式是先把这一行全部清零", "然后再把第二行全部清零", "如果说 你意识到背后是虚拟存储", "那么这时候呢这地方的缺页次数", "就变成了1024次", "如果说你认为这些数据全在内存里头", "那么这两种做法", "我们在内存里头任何一个单元在访问的时候", "它都是使用的时间是一样的", "那这两种算法是没有区别的", "好 如果说我们在这里头考虑到物理内存的量小", "那么这时候呢这两种做法", "它的区别呢就是巨大的", "所以在这儿呢不同的程序", "如果说你背后利用了虚拟存储", "那你在这里头呢需要很小心的", "去使用你的编程方法 以便于提高它的局部性", "这个提高它的局部性", "也有利于提高你的程序的这个性能", "好 基于这样一种做法呢", "我们说在这里头它可以很好的有局部性的特征", "那接下来我们会说基于这种局部性的特征", "我们怎么来实现我们的虚拟存储系统"]}, {"name": "", "block_id": "9d80e6426e744a6b9e77af19685cf4ee", "text": ["好 我们先来看第一部分的内容", "就是关于这个关键的数据结构", "这里面前面已经提到有线程控制块", "和线程控制块的一个列表", "那我们前面讲到这个线程控制块", "这个名词很简单", "thread control block", "感觉就是一个很典型数据结构", "但这个数据结构里面", "包含着什么信息呢", "可以看到有很多的", "它的一些成员变量在里面", "那这成员变量里面虽然多", "但没关系大家可以逐一", "把它进行区分出来", "首先看看 第一个它的ID", "我们说作为一个线程来说", "它有它自己的ID", "所以我们有一个PID", "来代表它的一个身份", "就跟我们身份证是一样的", "唯一的一个ID", "同时呢它就要有一个名字", "你有身份证之外", "你自己还有一个名字也是一样", "更好的表述这个线程", "那么这一块是跟它的一个", "身份标识相关的一部分信息", "这是第一部分信息", "那第二部分信息是什么呢", "第二部分信息是关于它的一个", "运行时候跟调度相关的", "一些管理控制一些信息", "比如说它当天是属于什么状态", "是属于就绪态 运行态还是等待状态", "那这里面有一个state来表明", "当前运行状态是动态变化的信息", "需要注意", "随着这个线程的运行呢", "它这个状态会发生变化", "第二个呢 它是否需要调度", "以及在某些细节上面", "有runs flags等信息", "都是跟我们说跟他动态运行相关", "一些信息在这里面有表述", "OK 这是第二部分", "动态运行相关的一部分信息", "第三部分呢", "第三部分是跟内存管理相关", "就是我们说", "线程也要占一定的空间", "那么它到底需要哪些内存资源", "这一点在这里面有个表述", "可以看到这里面有一个kstack", "就是内核里面的一个堆栈", "这里面大家需要注意", "因为我们这是一个内核线程", "所以它有个内核的堆栈", "那我们后续讲lab5的时候", "会讲到用户进程", "那么用户进程其实也有个内核堆栈", "那我们后面会进一步做阐述", "第二个CR3", "CR3在这里面没太用上", "因为我们在这里面呢", "其实既然是线程", "我们讲过线程的原理", "它会用所谓进程的一个页表来共享", "共享这个地址空间", "对于我们内核线程而言", "它对应那个进程是什么呢", "其实大家可以想象到", "其实就是我们ucore操作系统", "我们ucore操作系统在开始的时候", "比如说在我们lab1和lab2", "会完成一个什么呢", "会完成一个页表的建立过程", "那那个建立的页表呢", "就会被我们线程所使用", "所以它共用了我们的ucore", "OS一个页表", "第三个mm这个结构", "那么这个结构也是一样的", "其实这个结构呢", "我们还会进一步展开", "这是用来管理线程或者进程", "它所需要的这个内存空间的", "当然我们前面讲到对于线程而言", "这一块其实不用太多区分", "但是讲到进程时候", "我们会知道进程有它合法内存空间", "所以说在mm里面管理了什么", "mm管理了一个进程", "它所需要合法内存空间", "这个每一个合法内存空间内存块", "我们用一个vma来表示", "所以说呢有一系列的内存块", "合法的内存块用vma表示内存块", "来构成了整个这个进程", "或者线程内存空间", "但是对于我们内核线程而言", "这一块信息也是不需要的", "因为它都在我们统一的ucore管理之下", "所有的内存空间它都可以看得到", "所以说在这里面可以看到这些vma", "都属于同一个进程的", "mm这个结构来进行管理", "还有呢就是它这个list", "它有一个list", "就所有的vma本身形成一个list", "它的头会放在这儿", "叫做mmap_list这是形成一个", "就是对内存空间的一个管理", "对于lab4而言这一块可以忽略掉", "好 我们再看看下一块", "这一块呢 相对来说复杂一点", "而且跟我们硬件是紧密相关的", "一个叫context一个叫trapframe", "那么context就我们通常说的", "所谓的进程或者线程的上下文", "什么叫上下文", "就在于我们说一个进程在运行的时候", "它当前说处的状态就是一个上下文", "这个听起来感觉好像是比较抽象", "我们会给大家展开看看什么是上下文", "对于我们ucore操作系统而言", "它运行在80386这个环境之下", "它所谓上下文是什么呢", "看就这些东西", "看起来大家都很熟悉", "其实就是一堆寄存器", "从eip、esp一直到通用的ebx、ecx等等", "那么这构成了一个上下文", "那我们说要切换上下文", "就是切换这些寄存器内容", "这是很重要就是说代表了", "当前的这个线程", "或者进程它运行的一个状态", "这个state", "需要注意这个state更detail", "更详细一个state和刚才说到", "那个运行的属于ready态还是就绪态", "那个state相比呢那更抽象更高层次", "这个是很具体", "比如运行到什么地方", "放在什么地方eip这个地方来保存着", "它会把这个信息保存下来", "这是说的context", "第二个呢 我们称之为 trapframe", "trapframe大家想一想", "好像在哪好像依稀见过", "如果大家对我们的实验还有印象的话", "大家想想我们在lab1的时候", "已经碰到了中断", "那其实中断里面就用到了trapframe", "只是我们对当时trapframe", "没有做深入的分析", "到了这里面呢我们会对trapframe", "做一个比较详细一个解释", "因为它已经涉及到了", "我们怎么去能够让这个线程", "或者进程能够正确的运行", "我们需要对它进行一些设置", "在创建进程的时候对它做相应的设置", "那trapframe也是一个", "比较复杂的数据结构", "我们分几个部分来讲解", "第一部分你可以看找eip cs", "还有e_flags", "还有一个err erro code", "这几块呢就是说", "我们前面解释过在中断产生的时候", "或者中断或者异常产生的时候呢", "我们的硬件会把这些信息", "放到内核堆栈里面去", "OK 所以说这里面其实是", "放在内核堆栈里面一部分", "跟trap frame相关的一些信息", "保存了当前被打断时候一些信息", "第二部分是什么呢", "第二部分是esp和ss为什么有这个信息", "这个信息其实也是和我们硬件相关的", "也是硬件来负责放到我们堆栈里面的", "但是什么情况下有这个呢", "什么情况没这个呢大家回忆一下", "我们讲lab1的时候也提到过", "如果要实现特权级的切换", "比如从特权级3切到", "特权级0那么这时候呢", "它会把这个esp和ss", "也会压入到这个栈里面去", "所以说这一块记录的是", "当发生特权级变换之后", "我们硬件要去压栈的一些信息", "这样会确保将来能够", "顺利回到ring3里面去", "从ring0回到ring3", "那么这时候实际上为了我们说lab5", "实现用户级的进程做好一个准备工作", "还有一块信息", "这块信息比较多", "可以看到这里面我们说", "段寄存器的信息", "以及这里面是通用寄存器的信息", "这个信息和我们刚才讲的context有点类似", "没错 这是寄存器的信息", "这是段寄存器的信息", "那么这两个信息呢", "是我们软件来保存的", "因为当前你打断了", "某一个执行流程之后", "我们硬件会保存这两部分信息", "由于你后续的执行", "比如说我们在处理", "中断服务例程的时候", "你还会破坏相应的段寄存器", "或者通用寄存器", "所以把它这些", "所有寄存器都给保存起来", "以便于后续能够恢复", "那trapframe是什么呢", "trapframe其实就是保存了前一个", "被打断的进程或者线程它当前一个状态", "被打断需要注意", "这里面被打断被谁打断", "被我们中断（包括trap）或者异常打断", "这就是trapframe一些信息", "好 我们再回到我们线程控制块", "可以看到我们最后一部分", "最后一部分是一些list", "这个list记录什么信息呢", "一个是记录它的父进程的信息", "就是谁创建了线程", "在这里面有一个parents", "第二个呢是两个link", "这两个link实际上构成了", "我们所谓的线程控制块的链表", "这是一个双向链表这是一个link", "如果你有N个线程的话", "它们按照这种顺序可以链起来", "当然我发现如果是采取这种方式的话", "当你线程比较多的情况下", "那你查找某个线程的时候", "所花的开销会比较大", "为此呢我们还专门建一个", "基于哈希值一个list", "那我们相对来说它查找对应的线程", "对应什么查找呢", "对应pid的查找它会比较快一些"]}, {"name": "", "block_id": "7219838f7cdd4df386994ae5dd7414ab", "text": ["那前面我们给大家介绍了", "关于一个具体的simple file system", "一个大致的情况", "在这个simple file system之上呢", "我们还有一层Virtual file system", "那它呢起什么作用 大家可以看一看", "可以看出来VFS呢", "是在simple FS之上", "但是在我们应用之下", "这么一个中间位置", "那么它起到什么作用呢", "其实它起到一个承上启下的作用", "向下呢 它除了可以", "管理simple file system呢", "也可以管理不同的device", "甚至其它类型文件系统", "这是它的一个特点", "向上它提供了一层统一的接口", "给我们的应用程序来使用", "那我们应用程序不用关注", "底下到底是哪些具体的文件系统", "是设备文件系统还是simple file system", "还是其它一些file system", "不用care（关心）", "那它只需采取统一的一个接口", "比如说open read write close", "这么些基本函数呢", "就可以访问不同类型的文件系统", "那为了能够完成这样的功能呢", "我们其实需要在VFS这一层", "建立和我们进程的一个联系", "同时能够把抽象的", "file directory和inode", "和我们具体的文件系统进行对接", "这就是VFS它最主要的一个功能", "我们再具体看一下", "从大家最能理解的file这个结构入手", "那么file就代表一个文件", "那么它呢 是站在应用角度", "能够看到的一些信息", "比如说这个文件", "是只读还是可读写的", "它当前已经打开了", "还是关闭了等等", "这一系列信息呢", "其实我们的应用程序是需要知道的", "但是光有这些信息还是不够的", "我们还需要去了解", "怎么去进一步地对这个文件", "进行相应的操作", "可以看到 比如说", "从进程角度而言", "它需要记录它到底打开了哪些文件", "为此会有一个 关于文件的一个list", "在这个list里面呢 会有一些信息", "比如说举个例子 fd这个信息", "fd代表了当应用程序", "执行open之后 返回一个整型", "但这个整型其实就是一个index", "在哪体现呢 在这个fd_array", "那么这个index呢", "可以访问这个数组", "从而可以找到", "进一步的文件的信息", "另一方面呢 我们可以看到", "在file里面有一个成员变量是inode", "也意味着我们可以通过file", "找到它所对应的inode", "有了inode之后", "我们就可以进一步去完成", "对具体文件系统一个映射", "可以看着 在这里面", "inode还有不同的特点", "比如说它可以是一个sfs", "也可以是一个device", "在这里面根据它的type可以做区分", "这都在inode的成员变量里面", "在inode里面呢", "除了它的类型信息之外", "还有一些跟它使用情况", "相关的一些信息", "比如说Reference count", "就是引用计数", "还有open count 打开的计数", "所以引用计数是代表的是", "我们操作系统或者我们应用程序", "对当前这个inode做了一个访问", "我们需要记录一下", "因为只有当所有这些上层的应用", "不对inode进行访问之后", "我们才可以把这个inode进行回收", "这是一方面", "另一方面呢你打开一个文件", "那也意味着这个文件所对应的inode", "需要有一个加1的操作", "来记录当前到底有多少个打开的操作", "针对这个inode", "这是这两个信息", "这两个信息很重要", "因为它表示了", "关于inode资源的使用情况", "这是关于这两块一个介绍", "再接下来是跟inode相关的操作", "一部分是跟文件系统相关", "一个是跟inode本身相关", "我们首先看一下", "这个inode所属的文件系统", "具有什么样特征", "可以看出来一个inode", "其实它有一个成员变量叫做in_fs", "那么这个in_fs决定了", "这个inode到底属于哪个文件系统", "可以出来这是一个fs的一个结构", "那这个fs呢是属于VFS的", "我们刚才讲的sfs_fs是不一样的", "那个是一个具体的", "simple file system的一个描述", "而这是一个抽象的VFS的", "一个system的描述", "可以看出来 在这里面", "它很重要的一点是", "它包含了对不同类型", "文件系统的一个表示", "这里面又出现了sfs_fs", "以及还有一些具体的", "这里面没有展现出来的", "比如device_fs等等", "那么有了这些成员变量之后呢", "我们再结合一些函数指针", "就可以有效在VFS这个层面", "统一地对不同类型文件系统进行处理", "第二个是关于inode本身一些操作", "那么这里面列出了关于inode一系列的", "统一的一层函数调用一些接口", "比如说open close read write", "这是大家经常看到的", "以及得到目录这个目录项所需要的", "叫做get directory entry这么一个操作", "这一些操作呢", "就是一个统一的interface", "至于这底下具体实现", "是和我们具体文件系统相关的", "我们大家还可以回忆一下", "我们前面讲SFS的时候给大家提过", "SFS呢 会设定它那个inode", "所对应的具体的操作", "比如sfs_open sfs_ close等等", "有了这个接口 我们就完成了", "对具体文件系统的一个隔离", "同时向上提供了一层统一的接口", "方便了应用程序", "对文件的访问和操作"]}, {"name": "", "block_id": "e3a9fea73c14428ca793b28b2fd617d8", "text": ["下面我们继续来讨论置换算法", "那首先我们讨论的", "是时间片轮转算法", "在时间片轮转算法里头呢", "我们首先要约定一个", "进程调度的基本时间单位", "就这里的时间片", "它是处理机资源分配的基本单位", "每个进程上来之后执行一个时间片", "那我们用下面这个图示", "来说明时间片轮转算法", "它的基本工作原理", "这头呢是CPU", "然后这是它的就绪队列", "中间会时间片结束的时候", "会有时钟中断导致后续的处理", "那具体处理是这样的", "时间片结束的时候", "那按照先来先服务算法", "切换到下一个就绪进程", "那这里的下一个就绪进程", "是排到这里的第一位", "好 结束的这个呢", "是排到它的队的最后", "好 这样一来的话", "就是如果有n个进程", "那每个进程呢占一个时间片", "那这就是每隔n-1个时间片", "进程占用一个时间片来执行", "那在这个周期性的轮转当中", "每一个进程呢分到了1/n的时间", "这是时间片轮转算法的基本思路", "下面我们通过一个例子", "来说明它的运行过程", "那这地方呢假定时间片的长度是20", "然后现在有四个进程", "它们分别的执行时间在这里", "下面我看一下 它的执行过程", "我们用下面这个图来表示", "首先每个进程执行20个时间单位", "那在这里头呢 P2呢只有8个", "那执行到这儿呢", "20到28 它就结束了", "好 第一圈执行下来之后呢", "进程二就结束了", "好 接着来第二圈", "那么这时候呢只有三个1 3 4", "第二圈结束的时候呢 我们看到", "P4又已经全部执行完毕了", "那它也退出 整个进程结束", "现在还剩P1和P3", "好 再接着往下来", "到这个时候呢", "P1也执行完了P3执行", "最后还剩一个P3", "好 这是它整个执行过程的", "CPU的占用情况", "那我们来看看它的等待时间特征", "这是四个进程", "在执行过程当中的等待时间", "我们以其中的一个为例", "比如说P1 它执行了几次呢", "第一次 第二次 第三次", "分三个时间片它就执行完了", "那么中间等待的时间是什么呢", "起头它是第一个所以没有等待时间", "然后第二的话就是20到68", "然后第三次是从88到112", "那这地方就是68-20", "112-88 好 那这个地方呢", "这是它的等待时间", "那我们算一下", "它的平均等待时间 是66.25", "那我们看到", "这是一个时间片轮转算法", "它的运行过程", "那我们看到中间等待的时间呢", "相对来说比较长的", "好 那这时候说", "我们时间片到底设置为多长合适呢", "那我们说在这里头呢", "时间片轮转算法由于它靠时钟中断", "强行把正在执行的进程结束掉了", "所以它在这儿呢", "有额外的上下文切换的开销", "不像我们前面的一些算法", "它只在进程到等待状态的时候", "它才会有进程切换", "那我们说在这里头", "我们把时间片设多大合适呢", "那先看两个极端的情况", "时间片很大", "大到可以任何一个进程", "都在一个时间片内能完成", "那这时候它的算法变成什么样了", "变成一个先来先服务了", "也就是说来了之后", "按照来的顺序去就绪队列里排", "一次执行肯定结束", "那这就变成了先来先服务", "而这时候呢它的等待时间呢", "就跟我们先来先服务是一样的。", "好 那这是很长 不太合适", "而对于时间片短", "那你比如说我们在这里极端的情况", "我大量一半以上的时间是在做切换", "执行的时间只是按其中的一半", "那么这时候呢", "这个上下文切换", "它是有很大的开销的", "好 这些开销呢", "会影响到系统的吞吐量", "所以我们这儿呢", "时间片大了对进程的响应时间不好", "小了对系统的开销不好", "那这时候我们要选择一个合适的尺度", "目前呢对这个问题呢", "只有一些经验值在这里来设", "你比如说在这里头我们现在系统", "通常情况下呢", "它是10毫秒左右一个时间片", "这个时间片呢", "上下文切换的开销呢是在百分之一左右", "好 这是关于时间片的问题", "那我们说在这里头", "我们想看一下它的这个等待时间", "到底是什么样的情况", "我们还是以刚才的那个例子来说", "那我们把它对照", "先来先服务和时间片轮转算法", "这两个算法它的等待时间", "那我们先假定呢", "上下文切换的时间呢为零 忽略不计", "好 那这时候我看", "每一个做法它的平均等待时间", "这地方最后的这两个呢", "先来先服务算法到达情况影响很大", "所以我们在这儿取两个极端的情况", "一个是最差 一个是最好", "实际上最好的呢", "就相当于是短进程优先", "好 最差的呢相当于长进程优先", "那中间呢这几个是我取不同的时间片", "我们看一下算出来的结果", "那这是它的平均等待时间", "我们看到最好和最差的情况", "都是先来先服务的", "所以你到达的序列", "对它的实际情况抖动很大", "好 而对于时间片轮转呢", "那么这时候呢", "它基本上是在它们的中间", "这是这两种算法的比较", "好 那接下来说", "每一个进程占用CPU", "执行多长时间这件事情定下来了", "然后我们排队的事情也定下来了", "但这时候 它仍然没有办法", "用一个算法满足我们应用的所有需求", "好 那这时候 我们就想到", "是不是可以把这算法组合到一起", "实际上我们刚才的时间片轮转算法", "已经是把先来先服务", "和时间片划分的这种做法", "两个结合到一起", "好 那在这儿呢", "第一个做法呢就是多级队列调度算法", "它把就绪队列分成若干个子队列", "每个子队列是相互独立的", "比如说我们在这里头", "前台 那是交互的应用", "那这时候我要求时间片短", "那后台呢 是计算时间比较长的", "那这时候呢我可能用先来先服务算法", "好 这两个交替到一起", "我用一个时间片算法", "好 然后说我各个队列之间", "可以有自己的调度算法", "这我们前台 用时间片轮转", "后台 用先来先服务", "然后队列之间怎么办", "那队列之间 既可以说我固定优先级", "前台想想是该优先", "好 后台呢有空的时候我再来处理", "好 这时候就可能有什么", "我们前面讨论到的", "你按照这个来的话", "它就会导致饥饿", "就是后台的这些长进程它的优先级低", "而且运算时间很长", "前台的交互进程的短进程", "数量很大的话", "那么它就会出现饥饿", "好 那说我换种办法", "用时间片轮转 那在这里呢", "每个队列分得一定的时间配额", "保证它总的时间占一定比例", "好 那你比如说这里头", "前台占80% 后台占20%", "前台有作业的时候呢", "它可以很好的得到及时的响应", "后台呢也不至于完全处于饥饿的状态", "在刚才的多极队列里头呢", "各个队列之间呢是没有交互的", "那进一步往前改进呢", "就是多级反馈队列", "那么多级反馈队列呢", "是队列之间可以相互移动", "也就说我一个进程", "在执行一段时间可以在队列A", "执行一段时间之后", "可以把它放到队列B里头", "那这种做法呢 它会变得更灵活", "比如说我们在这里头一种做法", "时间片的大小", "我可以在不同队列之间做调整", "那优先级越高的", "那它时间片越小", "优先级越低的呢它时间片越大", "好 然后在这里头", "如果说你执行的时间越长", "我把你的优先级调的更低", "那这地方我们用这样一个图示来表示", "我这个地方分了N个优先级", "由高到低", "然后时间片q呢", "t0是基本的时间单位", "优先级越低 那它就会倍增", "好 那这时候每一个进程", "上来之后在优先级最高的一级", "好 如果说它一个时间片用完", "它还没有执行完 那它就降级", "好 这样一来的话", "我们这个算法就得到这样一个特征", "CPU密集型的进程", "那它的优先级会逐步降低", "并且时间片会分的很大", "好 这样的话", "它切换的这个开销呢相对来说变小", "而对于I/O密集型的进程", "那这时候呢它会停留在高优先级上", "因为每一次它算的时间都很短", "它的时间片没用完", "好 这样一来的话", "我们有可能在这里", "形成一个很好的多级反馈队列的算法", "好 在这个算法之上呢", "我们又有一类公平共享调度算法", "那它强调的是资源访问的公平", "把用户和进程分组", "一些用户呢比另一些用户重要", "那这样的话 它分的时间会更大", "然后不重要的这些用户呢", "不能让它垄断资源", "也就的说按用户的优先级来做这件事情", "那实际上我们在这儿", "用这个图示来描述", "系统资源我在调度器控制下", "分成若干组", "每一组占用的时间", "在执行的过程当中", "我是进行相应统计的", "好 这样一来的话我们就可以", "没有使用完的资源那就按比例分", "好 那在这里头呢", "如果说我的资源没用到", "我所约定的份额", "那这时候我优先获得相应的使用权", "这些时候呢的问题是说", "这个算法到底怎么来实现", "它的开销是什么样子", "我在这儿就不做仔细介绍了", "有兴趣同学可以下去进一步去看", "好 到这儿呢我们就说清楚了", "六种经典的 或者叫传统的调度算法", "每一种算法呢它各有特点", "对于先来先服务呢", "这个算法是很简单 但它不公平", "平均等待时间变动很大", "然后改进的一种办法是进程优先", "那这时候它不公平", "但是有一个特征是平均周转时间最小", "然后它有的毛病是", "需要预测未来的执行时间", "然后可能导致饥饿", "好 而高响应比优先呢", "实际上它考虑的是我的等待时间", "然后在这里呢", "它是基于短进程优先来改进的", "只是换了一下它排队的指标", "然后时间片轮转算法 它是公平的", "然后平均等待时间呢性能会比较差", "但它的交互性会很好", "然后多级反馈队列呢提供一套机制", "使得我多种算法可以集成到一起", "实际上我们现在", "在实际系统里用到的算法呢", "基本上是这种综合的算法", "只是综合的方式呢", "各个系统不一样", "而公平共享算法呢", "它强调的是", "公平是它第一个要衡量的指标", "好 那么刚才我们讨论清楚了", "这个传统的调度算法当中", "各自的特点和基本的做法", "那么我们对于实际系统里头", "我们还是以ucore为例", "介绍一下它的调度算法", "是怎么在系统里工作的", "首先呢我们看一下它的调度队列", "那在调度队列这个数据结构里头", "我们看到它有相应的指针结构", "来描述我就绪队列的排法", "然后每一个进程的相关的", "时间片的信息 在这里有描述", "好 这样一来的话", "就可以通过它把所有的进程串到一起", "放到各自的队列当中", "从而形成调度算法所需要的调度信息", "然后再一个就是说", "我们这里调度和进程状态之间的关联", "我们前面讲了三进程状态模型", "和我们调度之间的关系", "而我们的ucore呢更简单", "只有两种基本的状态", "创建和退出 这两个状态呢", "相对来说执行的时间很少", "那主要的是可执行和等待状态", "那在这里头呢", "我们相应的状态转变", "分别在这几个相应的函数", "你比如说创建结束之后", "放在就绪队列里", "我们前面已经说过", "在proc_init里头", "好 那在这里头呢", "会有这样几个函数", "会导致运行状态的进程变到等待状态", "好 等待事件出现的时候", "它会回到运行状态", "然后exit 它会出来", "那在这些状态里头呢", "会和我们的进程切换联络到一起", "我们看一下它的切换的过程", "这是我们进程执行过程当中的", "内核和用户态之间的交互", "我们如果说只有一个进程的话", "在用户态执行", "那可能会出现中断或者系统调用", "这时候切换到内核", "这两个的切换呢对于我们来说", "在我们这个层面上来讲是一致的", "好 切换过去之后", "它保护中断的现场", "然后处理中断", "正常情况下处理完之后", "它回到用户态继续执行了 对吗", "好 现在我们在这儿呢", "在中间加了一个调度", "也就说我处理完了之后", "并不是直接恢复最后的现场", "而是在这里呢加了一个调度", "调度之后呢我就可以到另外的进程", "好 另外的进程呢最后会回到这儿来", "那这时候我们看一下整个的过程", "首先 是在执行的过程当中", "出现系统调用", "或者说中断 或者说异常", "这时候呢它切到内核", "那切过来的时候呢", "它会保存中断的现场", "保存完之后 那我进行中断处理", "因为这是要求时间的", "那 处理完之后呢", "正常情况下我就恢复用户态的现场", "然后就回去了", "但是现在调度之后", "调度的结果 如果说你是", "仍然是执行这个进程", "那跟原来一样", "好 如果说你是执行其它进程", "那么就切到另一个进程了", "而假定另一个进程", "实际上刚才也是执行到这个地方", "然后做的切换", "那到这儿来的时候呢", "它就会回到恢复中断现场", "那到这儿呢 确实是恢复中断现场", "恢复完之后它怎么办", "它就回到用户态去了", "就到这儿", "好 到用户态继续执行", "那在这里执行的过程当中呢", "它还会再出现中断", "比如说我时间片用完", "这时候再出现中断", "中断怎么办", "跟刚才这地方是一样的", "它进到内核态", "好 这时候呢保存中断现场", "进行中断处理 然后进行调度", "调度完了之后", "如果说切回上一回执行的那个进程", "怎么办", "切回去 好 这时候对于这个进程来说", "你可以理解为它处理完中断现场", "然后恢复用户态的现场", "然后回到用户态继续执行", "那整个这个切换的过程就完成了", "好 然后调度实际在哪", "就是由内核态返回到用户态", "之前那个时刻", "那我做这个调度，", "调度完之后到别的了", "回来的时候我再恢复", "然后回到用户态", "这样的话 既不影响到中断的及时处理", "也可以让各个进程之间", "能够交替运行", "好 那这个过程呢", "希望大家下去之后", "通过实际的ucore代码阅读", "来理解这个过程的执行情况", "好 那如果说我们在这里", "要加自己的调度算法 我怎么加呢", "在ucore里呢定义了一个调度类", "在这里头呢", "约定了调度算法对外提供的接口", "比如说我们在这里头", "调度算法会什么", "我有一个进程变成就绪状态", "我如何把它加到就绪队列里头", "我要选择下一个进程占用CPU来运行", "我选择哪个进程", "那这时候呢 对应着两个函数", "一个是入队 一个是出队", "有了这两个函数之后", "我就知道不同的调度算法", "就可以按照自己的调度方法", "由等待状态变成就绪状态的进程", "放到就绪队列里头", "也可以从里头选择出", "下一个要执行的进程", "来从这个就绪队列里头取出来", "好 那除此之外还有几个函数", "一个是pick_next", "就是我选择下一个进程", "然后还有一个呢 就是proc_tick", "tick实际上相当于", "我们在这里呢会支持时钟中断", "时钟中断的时候", "在不同的调度算法呢", "你的计数 或者说对优先级的修改", "是不一致的 好 那在这儿有这个", "再加上一个初始化 OK", "我整个调度算法的内容呢", "都可以从这儿和我的系统接起来了", "好 那这样一来的话", "我的系统其它部分", "不需要了解你的调度算法的细则", "我只要这个接口能接上", "那你的调度算法", "就可以在我这个系统里面工作了", "好 每个人呢只需要实现这几个函数", "你就可以把你自己的调度算法呢实现出来了", "并且和系统对接起来", "好 那实际上", "我们系统里怎么用这些东西呢", "那这就是我们ucore调度框架", "那我们说在用户态", "前面讲进程控制的时候", "已经说过了这样一些函数", "这些函数都和进程控制相关", "然后这地方是调度", "其中一部分是直接到这儿来", "重要的都是从schedule过来", "好 这个地方接的", "就是我们刚才说的", "调度类接口里的那些接口函数", "好 你的实现的函数呢", "通过填这个数据结构的函数指针", "那把你的调度算法接到这里头来", "那上面的系统调用和用户态", "通过这一边连到这儿来", "那这样的话系统应用", "就依据你的调度算法再进行调度", "这是ucore的调度框架", "那在实验当中呢", "要求大家去实现一种", "简单的调度算法 叫stride"]}, {"name": "", "block_id": "d7d982c83c0b4e80b1eaa3c02dd088d9", "text": ["下面我们来讨论线程的实现", "那在这里头呢", "线程的实现方式呢有这样几种", "在最早的时候", "实际上在我们的操作系统里呢", "并没有多线程的支持", "那用户提出了这种需求", "那我们首先可以做的方式呢", "是用户自己来写函数库", "在用户态来实现一个进程", "内部的并发性的提高", "那这就是我们这里说到的用户线程", "在用户空间里通过函数库的形式", "来支持线程的创建删除和切换", "那 这是我们在几种提供", "用户库的方式提供的线程实现", "那在用户线程支持", "有了一定基础之后", "那这个功能呢", "也会做到操作系统内核里头", "这种做法呢类似于", "我们在网络里头做法", "网络最开始也不是", "写在操作系统里头的", "那只是用了一段时间之后呢", "它才变成操作系统内部的一个模块", "好 那在操作系统内核", "实现线程支持呢", "它会更自然效果会更好", "那我们现在的操作系统呢", "基本上都支持内核态的线程", "好 在这两种基础之上呢", "在SOLARIS里头呢又进行了一种", "新的尝试 叫轻权进程", "那也就是说在用户态实现的线程", "和内核态实现的线程", "它俩各有各自的优缺点", "那在SOLARIS里头呢", "希望把这两种结合起来", "就出现了这种轻权进程", "那下面我们具体来看", "这三种做法它都是怎么来做", "用户线程是指说我们在通过一个", "用户库来完成线程的管理", "这包括线程的", "创建 中止 同步和调度", "那在这个图里呢我们描述了", "系统里的线程库里", "实现的基本方法", "在操作系统内核里头呢", "仍然只有进程控制块来描述", "处理机的调度的情况", "然后在这里头呢", "操作系统并不感知", "应用态有多线程的支持", "而多线程的支持呢", "是用户的函数库支持的多线程", "在应用程序内部", "通过构造相应的线程控制块", "来空置一个进程内部", "多个线程的交替执行和同步", "好 那用这种方式呢", "我们可以很好的支持多线程", "那它也有自己的好处", "比如说这里它有一些什么样的特征", "不依赖操作系统内核", "不依赖操作系统内核呢", "也就相当于内核", "不感知用户线程的存在", "那这也是最早", "为啥会做这件事情的缘故", "就是用于不支持线程的", "多进程操作系统", "好 那有了这个之后呢", "那用户你就会多一些事情", "在用户态实现线程", "这时候用户要自己来", "维护线程控制块", "要自己有一个相应的线程库", "那 有了这一条之后", "它还会带来好处就是", "用户态里的线程之间的", "切换它速度非常快", "没有用户到内核的切换", "然后用户也可以自己", "来写自己的调度算法", "因为我对应用", "我应用的开发者更了解", "这个多线程如何切换", "如何调度 它的性能会更好", "当然这种做法也有它的问题", "它的问题是什么", "由于线程发起系统调用而堵塞", "那这时候呢", "整个进程就进入等待状态了", "因为对于内核来讲", "并不知道你上面是多线程", "一个线程堵塞的时候", "把另一个线程继续运行下去", "要做到这一点的话", "必须有内核的支持", "好 然后不支持", "基于线程的处理机抢占", "这里指的是什么意思呢", "这里指的是说", "我们多进程系统里头", "通过抢占的方式", "让一个进程停下来", "然后让另一个进程继续运行", "那如果说我们是基于线程", "来做这件事情", "那这样的话我操作系统", "就没有办法让一个线程停下来", "然后这一个进程内部的", "另一个线程来运行", "那这种的必须由", "当前的线程主动放弃", "我才可以做这种切换", "好 那再有一个", "就是分配CPU的时间", "对于操作系统来说", "这个分配是由", "操作系统内核来控制的", "所以它是以", "进程为单位来进行分配", "如果你里头有多个线程", "那这多个线程", "每个线程分配到的时间呢", "相对来说就会变少"]}, {"name": "", "block_id": "bc5c727fd750472ebc78f978cbd44d43", "text": ["下面我们来讨论进程通讯", "进程通讯也称之为进程间通讯", "它是进程之间", "进行信息交流和同步的机制", "那我们在这里头呢", "任何一个进程之间通讯机制", "它都会提供两个基本的操作", "一个是发送 一个是接收", "不同的进程通讯机制后边的参数", "和内容会有一些不一样", "进程通讯的流程是这样的", "如果里头有第三方参与的话", "通讯的三方之间建立相应的通讯链路", "然后通讯收发操作 交换信息", "这是它的基本流程", "不同通讯机制", "进程间的链路的特征是不一样的", "比如说我们考虑到的", "有物理的链路 有逻辑的链路", "那物理的链路呢", "是你到底通过共享内存进行的", "还是说是通过其他的方式", "而逻辑的就是相当于", "我这条链路的一些属性设置会不一样", "首先我们来看进程间通讯的方式", "这里头呢 分成两种", "一种是间接通讯 另一种是直接通讯", "我们首先来看间接通讯它是在怎么做", "建成通讯呢 实际上是依赖于", "操作系统内核完成的进程间的通讯", "首先它在通讯进程和内核之间", "建立相应的机构 能够支持这种通讯", "比如说建立消息队列", "然后一个进程可以把信息", "发送到内核的消息队列上", "然后另一个进程从这里读出来", "从而实现进程A和B之间的通讯", "这个通讯过程", "它的生命周期甚至可以不一样", "比如说A发信息的时候B还没有创建", "而B接收数据的时候A可能已经关闭了", "这种方式是间接通讯", "而另一种方式呢 是直接通讯", "直接通讯是在两个进程之间", "建立一个通讯信道", "这就是我们这里的共享信道", "然后这个时候呢", "因为它俩直接进行交流", "两个进程必须同时存在才能够进行通讯", "发方向共享信道里发送数据", "收方从共享信道里读取数据", "这是两种基本的通讯方式", "下边我们具体来讨论这两种方式", "第一个直接通讯", "要进行直接通讯首先我们需要解决的", "一个问题是命名问题", "你到底和谁在进行通讯", "所以在它的收发基本操作里头", "都会有相应的一个参数", "描述发送出去的数据给谁", "也就是接收方", "接收的时候我要描述从哪接收数据", "那这时候是发送方的信息", "这是直接通讯里头我需要做的事情", "然后再有一个就是直接通讯的时候", "通讯链路的一些属性", "这条通信链路呢", "通常情况下是自动建立起来的", "然后在这里呢", "两个通讯进程之间恰好能对应一条链路", "每一对进程之间呢", "也只有一条相应的链路存在", "这是指同一类通讯介质", "这个通讯链路呢", "可能是单向的 也可以是双向的", "间接通讯是通过操作系统", "维护的消息队列来实现的进程间通讯", "在这时候通讯的时候", "我们首先需要描述的一个是消息队列", "在内核里可能维护了多个消息队列", "你要通讯的到底是哪一个", "这跟我们直接通讯里", "描述通讯对方的ID是一样的", "这个地方每一个消息队列", "有一个唯一的标识", "那你关心的就直接是和内核之间通讯", "某种角度上讲", "你可以理解为间接通讯", "是进程和内核之间的一种通讯机制", "然后只有共享了相同消息队列的进程", "它们之间才能够实现通讯", "也正是由于这一条", "我们可以通过操作系统内核的安全机制", "实现两个进程之间通讯的保密性", "这时候的通讯链路有些什么样的特征呢", "它是这样的 只有共享了消息队列的进程", "它才可以建立这条链路", "建立不了链路", "它们俩也就通讯不起来了", "这是第一个 然后这条链路呢", "可以是单向的 也可以是双向的", "这时候消息队列", "和进程之间的对应关系", "就变成是多对多了", "一个消息队列可以与多个进程相关联", "每一个进程也可以和", "多个消息队列进行共享", "间接通讯的通讯流程是这样的", "创建消息队列肯定是", "先运行的进程去创建", "然后是与消息队列之间的消息的收发", "最后我这个消息队列还需要撤销", "要不然的话", "在内核当中可能会有多个", "没有人再去用的消息队列", "它的收发跟我们前边的直接通讯", "不一样的地方是", "这时候描述的是消息队列", "发方并不关心收方到底是谁", "它关心的是消息队列是谁", "接收也是一样的", "通讯的过程当中", "还有一个属性是我们关心的", "那就是阻塞与非阻塞", "有的时候也称之为同步和异步通讯", "在阻塞通讯里头呢", "我每一次通讯都必须保证它成功", "这是它阻塞通讯的基本特征", "分成发送和接收我们来讨论", "阻塞发送呢是指", "发送者在发出消息之后进入等待", "直到接收者成功接收", "也就是说我发消息这一方一定要等到", "接收方成功接收到了我这边才结束", "而阻塞接收呢", "是指接收方在请求接收消息之后", "它就进入等待", "直到成功收到一条消息", "如果说我收不到消息的话", "那么这时候呢 我会一直在这等着", "这是阻塞通讯 还有相对应的呢", "是非阻塞通讯", "发送的时候是发出消息之后", "我立即就可以进行其他的做了", "我不管收方是否收到", "而非阻塞接收呢 是指我去接收", "如果说这时候没有消息发送", "在这个请求之后我收不到任何消息", "它和阻塞通讯相反", "它不会等着一定要收到一条消息", "它才返回", "这两种通讯方式呢", "阻塞通讯和非阻塞通讯", "它们各有各的适用场合", "应用进程在进行通讯的时候呢", "需要选择哪种是你适合的", "那接下来我们还有一个", "需要讨论的是通讯链路的缓冲特征", "也就是说我们在收发消息的时候", "在这个链路上", "是否有可能对信息进行缓存", "这里就分成三种情况", "一种是零容量", "也就是说发出去的数据", "必须有接收方接收", "否则的话这个中间就进行不下去了", "这时候呢", "没有接收方的时候它就会等待", "而有限容量是指", "通讯链路上有缓冲队列", "在它满了之后 发送方必须等待", "而无限容量呢", "发送方任何时候都可以发", "发出去的数据在链路上缓存", "收方呢 在任何时候再来进行接收", "这是我们关于进程通讯的一个简要介绍", "下边我们会来具体说明几种通讯机制"]}, {"name": "", "block_id": "e69445f98a7c4ca68a7f0c430bb6799f", "text": ["那我们现在结合一下", "就是实际操作来看一下", "实验4所需要关注的一些细节", "那实验4内核线程管理", "要完成的练习呢不多", "主要是能够知道", "怎么去分配一个进程控制块", "以及怎么能够去", "调度 执行一个内核线程", "那在这里面呢有三个练习", "练习1 练习2 练习3", "其实应对的呢", "应对的就是主要是在哪呢", "在这个代码里面的这个地方", "就是proc.c", "proc.c里面呢有两个函数需要关注", "一个是叫做proc_init这么一个函数", "它会设置idle_proc", "并进一步去创建init_proc", "就第0号线程和第1号线程", "然后呢第二个是do_fork", "这个函数会完成具体的", "特别是针对init_proc", "一个它的内部线程控制块", "一个初始化工作", "然后呢当把这些初始化完毕之后", "我们可以看到在我们的总控程序", "就是ucore里面总控函数", "code_init里面呢", "会去进一步去调这个cpu_idle", "cpu_idle就是去查找", "当前这个idle_proc", "它是不是need reschedule", "其实我们前面已经做过介绍", "初始化是need reschedule是等于1的", "如果等于1表明它可以被切换掉", "换下一个线程去执行", "那么会调schedule", "schedule也就是说会把", "我们刚才说的那个线程那个队列", "线程控制块的队列呢", "找出对应的一个", "处于ready态一个线程去执行它", "当然这里面我们细节不用看（lab6会详细分析）", "大致可以看着在这里面函数proc_run", "proc_run它可以调switch_to", "我们后面讲到过的", "关于怎么去把它的内核的栈", "它的页表相关的页目录表的基址寄存器", "以及它的context做一个切换", "做完这个之后在switch_to", "需要注意switch_to这里面是在", "汇编程序里面来实现的", "那switch to会完成", "两个内核线程的切换", "我们看switch_to怎么来完成的", "那么switch_to在这个", "汇编程序switch.S里面", "可以看着跟我们刚才讲是类似的", "就是它取得了这个关于", "idle_proc它的context", "然后把它所有寄存器信息", "保存在context里面", "这是这一部分完成的工作", "OK 接下来呢是恢复init_proc", "这个线程它的相关的context", "最后一步是push eip之后", "通过ret跳转可以回到", "我们说在context里面", "保存那个eip的地址", "那是什么呢", "可以看一下在这个地址在哪", "实际上这个地址就是forkret", "forkret会进一步调用forkrets", "那它是在trapentry.S里面", "有forkrets这个入口地址", "你可以看着当我们说通过switch", "现在已经切换到我们的", "init_proc开始执行的", "那么init_proc执行", "还没到到它的入口地址", "怎么到呢", "可以看到在这里面forkrets", "再jump到trapret", "这里面是干什么事情", "这一部分是实际上是", "恢复被中断一个过程", "会被中断或者异常", "打断的过程在这儿恢复的", "当然这里面其实没有这个被打断过", "因为它第一次执行", "那这些信息从哪来呢", "我们在开始做init_proc初始化的时候", "在它的TCB里面", "就线程控制块里面把这些信息填好了", "这些信息是在trapframe里面", "把这些信息恢复之后", "会调动iret", "当iret返回之后", "它会跳到哪去呢", "跳到kernel thread entry", "这个信息是存在trapframe里面的", "那kernel thread entry会进一步", "call(调用)ebx里面代表的地址", "这个地址在哪", "其实我们说是在这个地方", "在kernel thread初始化的时候呢", "会把这个fn在这儿复制", "这就是ebx", "所以说在这里面call ebx", "其实就是call fn", "从而可以完成实际的", "init_proc它的一个执行", "那我们看看它在哪执行的呢", "我们再找一找", "在proc_init中 它会执行一个init main", "这就是那个fn", "这里面可以看着", "我们说打印出来信息就在这儿", "这和我们实际执行它", "这个结果是一样的", "那么他在哪执行呢", "其实在这儿可以看出来", "我们如果正常执行", "可以看到 OK 显示了那段信息", "这个信息就是来于init_proc来完成的", "从而可以看出来", "如果你完成了前面正确的初始化工作", "最后就可以得出这么一个", "显示一个hello world", "一个简单的内核thread"]}, {"name": "", "block_id": "6aacf8cb19ca44b3a0706c751c82c8d3", "text": ["下面我们来讨论I/O结构", "在I/O结构当中呢", "我们先从硬件的结构说起", "在我们计算机系统当中", "我们的CPU为了跟外界相连", "实际上在我们的主板上", "它是分成了两段", "一段是和高速的这些内存 显卡", "相连的部分", "这时候它的速度通常是若干个G", "连的是内存显卡", "然后还有一个部分是南桥", "它负责跟我们这里的", "各种各样的设备相连", "比如说像这里的PCI总线", "然后你的磁盘", "网络都是通过这底下连的", "在我们的基本原理里是说", "CPU通过总线来连内存和I/O设备", "那到这个地方", "我们就细化成北桥连高速设备", "南桥连I/O设备", "这时候在这种结构下我们还需要", "进一步来细化CPU到底", "如何来识别每一个设备", "它们的连接关系是什么样子的", "在这儿呢", "首先我们在这里头是CPU和I/O设备", "设备上面呢有设备控制器", "设备控制器的功能", "是提供CPU和设备之间的接口", "那在这里头就是总线接口", "然后有相应的一组寄存器", "可以进行数据的交互和", "状态和控制的交互", "也可以把它映射到内存当中", "给一段内存区域", "然后对于这段内存区域的访问", "对应过来就是我们的I/O设备的访问", "这就是我们这里说到的I/O地址", "I/O地址通过总线连到我们的CPU上", "总线和实际设备之间有总线适配器", "在这里头我们映射过来", "可能是内存地址", "也可能是I/O空间的端口", "那我们可以对I/O端口", "有相应的I/O指令", "如果是内存", "那我们直接是访问存储", "就对应着对I/O设备的访问", "这是从CPU到设备", "反过来还有一个从设备到CPU的通道", "这就是我们的中断控制器", "设备产生中断之后", "在中断控制器进行汇总然后送给CPU", "CPU就能对外部设备的事件做出响应", "这就是我们在这里CPU和设备之间的", "通讯的三种方式", "轮询那就不用中断控制器", "CPU直接访问I/O端口", "或者说访问设备所对应的内存地址空间", "我也可以采用中断方式", "那就是外部设备有事件要通知CPU", "就要通过中断到CPU", "如果说在这里头", "还有一种方式是说", "我外部设备需要把数据", "直接放到内存当中", "你可以通过CPU读然后放到内存", "在DMA控制器的控制下", "把数据从I/O设备直接到内存单元", "这是CPU和设备之间的连接关系", "那下面我们进一步来讨论一下", "I/O指令和内存映射I/O", "I/O指令它是通过I/O端口", "来访问设备寄存器", "实际上也就是相当于我们通过端口号", "来区别我访问的是哪个设备", "以及于哪个设备上的哪一项功能", "然后CPU上执行out in两个指令", "来完成对端口的读写", "这些读写不仅仅是数据的访问", "也还对应着相应的设备控制", "比如说我们有一些控制", "就是直接对指定的端口发出写信号", "那这个写信号来控制设备的操作", "而写的内容有的时候反倒是不重要的", "另一种呢是内存映射I/O", "它是把设备的寄存器或者存储队列", "或者说存储区域", "映射到内存的物理地址空间", "然后通过load /store", "这种存储访问命令来实现I/O操作", "在这地方呢", "它的地址到底是在哪呢", "实际上是在MMU来设置", "或者说通过硬件的跳线", "来完成相应地址的映射", "有了这些讨论之后", "那我们就可以给出", "操作系统当中I/O子系统的结构", "那我们从下往上来讨论", "最底下是我们各种各样的设备", "比如说存储的SCSI设备", "和这边的ATAPI设备", "然后还有其它的你比如说鼠标 键盘", "然后每一个设备之上", "都对应着有一个设备控制器", "那不同的设备它的控制器是不一样的", "然后在这之上呢", "对应着我们就是开始是软件", "操作系统里第一层是设备驱动", "每一个设备", "每一类设备对应着有自己的驱动", "在这上头呢是我们的I/O子系统", "它用来处理各种设备共同的一些内容", "比如说我们的I/O请求", "转换成驱动的I/O请求", "这是一种细化", "然后我也会缓存", "设备给出来的一些结果", "你比如说我要访问某一个磁盘上的", "某一个扇区的数据", "那我前面已经做过一次操作了", "I/O子系统负责缓存", "并且你第二次来访问的时候", "我直接给你结果", "然后上边是我们内核的其它部分内容", "文件系统 那这些都是依赖于I/O子系统", "来完成相应数据读写的", "在这种结构下我们来看一个", "完整的I/O请求的生命周期", "跟我们刚才那张图呢", "在这地方又有一些细化", "这地方的驱动我把它分成两段", "设备驱动和底下的中断处理例程", "那我们来看一个用户", "进行I/O请求它的过程", "用户发出I/O请求 这是时间顺序", "到这个系统调用返回", "我得到相应的数据", "或者说我输出数据完成", "操作系统里头的I/O子系统", "它会做什么事呢", "首先判断一下你要进行这个操作", "是否有现成的结果", "比如说你的磁盘数据的读操作", "如果有 那我在这儿呢", "直接把我已经缓存的结果给应用", "我这个操作就结束了", "它实际上没有对实际的设备", "进行任何的操作", "如果说这个数据没有", "它会给驱动发出I/O请求", "那这时候我就要去读", "指定的区域里的数据了", "设备驱动再把这些I/O请求", "转换成设备的控制命令", "这个设备控制命令呢", "直接给硬件进行控制硬件操作", "那么这时候设备驱动处于等待状态", "等这边处理结束之后", "它会产生中断", "中断回来我们的中断处理例程", "会对它做出响应", "这时候响应就是保存相应的结果", "并且把结果通知上面的设备驱动层", "设备驱动层负责来区分", "返回的结果和哪个请求是相对应的", "然后把这个结果", "给到相应的I/O子系统当中", "再把它送给用户的进程", "整个一个I/O请求的", "完整过程就实现了", "这是我们说到的I/O结构"]}, {"name": "", "block_id": "7aafd33d0eac428d82d512bdcad3b3eb", "text": ["下面我们来讨论目录 文件别名", "和具体的文件系统", "文件多到一定数目之后", "我们要想对它进行有效的管理", "这时候我们就必须引入分层的结构", "也就说把若干个文件", "以目录的形式组织起来", "比如说在这里头", "给出的是文件系统里的", "一种组织方式", "圆圈表示我们基本的 普通的文件", "在这里这些方块的 就是目录", "它是一种特殊的文件", "这个特殊的文件里存的内容呢", "是用来表示其它文件的信息", "所以它是特殊的", "文件内容是文件的索引表", "一条索引呢 就是文件名", "和指向文件的指针", "有了这个之后", "我们就可以把所有的文件", "组织成一个树状结构", "这时候我们如何来标识", "一个特定的文件呢", "每一个文件呢 在我们这里呢", "对应过来是一条", "从根目录开始的一条路径", "第一级 根目录", "然后找着它的下一级目录的名字", "这是我们第一级根目录里的目录项", "到第二级目录的时候呢", "它又有它的目录项", "根据你这个文件的路径", "一直找到最后文件的内容", "有这种方式之后", "我们就可以以路径的形式", "来标识每一个文件", "这样的话方便用户的访问", "这里所谓的方便呢 是指", "我方便用户的记忆和分类", "我们再换一个 这个地方呢", "实际上是从program/p/list", "最后找着我的这个文件 名字叫list", "用这种方式组织之后", "我们在目录上的操作", "就跟其它的文件有一些不一样的地方", "在目录里典型的操作呢", "是说我会有去检索", "我找我需要那个文件", "然后我创建一个新的文件的时候", "因为我在文件系统里", "存了一个新的文件", "那么这时候我必须增加相应的目录项", "这也会在目录里头呢 有相应的操作", "然后我删除一个文件", "也会需要你在相应的目录里呢", "把对应的目录项删掉", "然后我会去列目录", "看看这个目录里", "到底有哪些文件和子目录", "我会对文件重命名", "你改文件的名字", "那这时候目录项里的", "相应的文件属性 文件名", "你也需要去进行相应的修改", "再有一个是遍历路径", "也就相当于我想找某一个文件", "是从根目录一级一级找下去", "最后找那个文件", "这是在目录上的典型操作", "这些操作呢 对于操作系统来说", "它都是封装到内核里头的", "只能由内核来对目录进行修改", "这样的话 就可以保证", "这种目录的映射的完整性", "用户进行这个操作的时候他需要改", "这个改动怎么来做呢", "通过系统调用", "用户来通过系统调用", "来对目录进行相应的操作", "这是目录", "目录的实现呢 是描述我目录里的", "这些文件的列表", "我怎么来组织", "最简单一种做法呢", "是把它组织成一个线性的表", "这时候的问题是说如果这个表很大", "那这时候检索 或者说增删", "它的时间会很长", "但是它的好处是我编程比较简单", "然后另一种做法呢", "我是把目录里这些文件呢", "组织成一个哈希表", "先做哈希 然后再进行后续的操作", "这种做法呢 由于哈希的缘故", "它可以减少搜索的时间", "也会有另外一个问题 就是两个文件名", "它做哈希之后", "可能哈希结果是一致的", "这时候会产生冲突", "那么冲突呢 我需要在哈希表里", "有相应的解决", "这样做之后呢", "我目录表里的每一项呢", "它的长度是固定的", "接下来我们说文件别名", "也就说我有一个文件", "我想给它起两个或者多个名字的时候", "我怎么办", "首先我们在这儿看这个例子", "在这里头呢我有一个文件", "这有它的路径 count", "这两个最后指到是同一个实体", "我们这种做法的缘故呢", "是为了方便共享 减少存储空间", "文件系统中我怎么来表示它", "在这里头呢 这是另外一个例子", "这三个说的 实际上最后都是同一个", "它的实现办法呢 我们这有两种", "一种叫硬链接", "也就说 多个文件的目录项", "最后都指向同一个文件", "比如说在这里头", "我们知道这一个和这一个", "另一种做法叫软链接", "它的做法呢 是以快捷方式", "来指向其它文件", "它的文件描述出来", "仍然是各自独立的", "只是说链接文件里头呢", "它存的是另一个文件的 完整的路径", "它以这种方式来实现文件别名", "第一种方式呢 就会涉及到一个问题", "如果说我一个删除操作", "我到什么时候", "实实在在把这个文件删除掉", "它就会是 我只要删到最后一个", "指向它的文件名的时候", "我才会把这个文件实体删掉", "而软链接呢 我删除的时候呢", "删除别名和删除其它的文件是一样的", "删除别名 实际上文件不受任何影响", "删除文件之后呢 你原来的别名", "它指向的文件就是不存在了", "这是文件别名", "还有一个问题呢", "是文件目录中的循环", "我可以指向下一级子目录", "那我的子目录可不可以", "指回到它的父目录呢", "这时候 如果你这样指的话", "就会构成循环", "比如说在这里头 你要找某一个文件", "它的子目录的子目录", "我把它指向一个循环之后", "这条路径就可以无限制的循环下去了", "这种情况怎么处理呢", "我们处理办法呢有这样几种", "一种是 我加链接的时候", "我只能是文件 不允许目录的链接", "这是一种做法", "还有一种做法呢是说", "我在这里头增加链接的时候", "我用检测算法来检测", "这跟我们死锁检测差不太多", "我可以用银行家算法", "但这时候呢你的检测开销会比较大", "所以在实际的做法里头呢", "通常情况下 我是限制", "你可以检索下去的长度", "超过这个长度", "我就不再给你往下检索了", "这样的话也就减少了", "这种由于循环所带来的问题", "有了这个之后", "那我们来看 接下来是", "我如何找一个文件", "这就是我们这里的名字解析", "在很多地方呢有名字解析的问题", "这里说名字解析是把一个逻辑的名字", "转换成它的物理资源", "比如说我们这里的文件", "对于文件系统里的名字解析呢", "就是我给你一个路径", "然后你告诉我", "这个路径所对应的文件存在哪", "把它的内容读出来", "它的实际做法呢就是遍历文件目录", "从根目录开始", "一直找到你要找那个文件为止", "这是文件名的解析", "在这儿给一个例子", "说我这儿有一个路径", "最后文件名是ls", "我怎么来找呢", "首先我找这个文件分区的根目录", "根目录里头的位置", "在文件系统当中是固定的", "从这儿呢我读出根目录的数据块", "里头每一个子目录", "和它的根目录里的文件对应着一项", "我在这里呢", "找着我要找bin这一项", "这一项会指向下一级目录的数据块", "我再去找着下一个 bin", "这个目录所对应的文件头", "那在这里呢读取它的数据块", "也就相当于这里头就是", "bin这个目录里", "所有文件和子目录的列表", "在那里去找 是不是ls这一项", "找到这一项之后", "我再来看", "就可以读取到", "我这个ls这个文件的内容了", "那为了方便这种查找呢", "我们就提出一种概念", "叫做当前工作目录", "它指每一个进程", "给它设定一个缺省的目录", "它的名字解析", "就从这个目录开始往下解析", "这样做的好处是在于", "如果说我这个进程", "经常就在这一个目录里进行操作的话", "它就没有必要每次都从根目录往下找", "只有在你要找切换了", "你的当前工作目录之后", "你才会从根目录里找一遍", "这样的话就会提高效率", "这时候路径就有一种相对路径", "也就说基于当前目录所进行的查找", "这是当前工作目录 和相对路径", "文件系统呢", "在我们计算机系统起来之后", "它有个根文件系统", "通常我们访问这些数据呢", "所在文件系统必须挂接到系统当中", "才能够被访问", "比如说我们在这里", "这是一个未挂接的文件系统", "系统起来的时候呢", "它有一个根文件系统", "未被挂接文件系统呢", "需要挂接到这个根文件系统当中", "才能进行访问", "所谓挂接是指什么意思呢", "就是我把这个文件系统", "它根目录对应到", "根文件系统里某一个目录", "比如说我在这里user", "这个地方就是它的挂接点", "挂接上去之后", "我再去找这个文件系统里的某一个文件", "它的路径什么", "从整个系统的根开始 沿着这找", "找到你挂接点之下", "找到你这个文件系统的根", "从这个地方再往下找", "就可以找到 当前这个", "已挂接文件系统当中的", "任何一个文件了", "接下来我们说文件系统的种类", "我们最常用一种文件系统", "叫磁盘文件系统", "它是用磁盘作为存储介质", "在上面来存数据的", "这上头我们定义了各种各样的文件系统", "这时候会问", "为啥我会定义这么多种文件系统", "我有一种是不是就够用了", "不是这样的", "不同的文件系统由于存的数据不同", "它会做不同优化", "它使用场景的不同", "它也会做各自不同的优化", "比如说像我们的光盘", "它的文件系统呢", "它是一次性写入 多次读出", "而正常磁盘文件系统呢", "它是多次读入写出的 会有修改", "这样的话 它的优化角度是会不一样的", "不同的文件系统它的安全要求不同", "安全要求级别越高", "它的访问效率也会相对下降", "对于我要求安全级别不高的文件系统", "我可能就把安全机制减弱 甚至于取消", "这样我们就构成了很多种不同文件系统", "这是一类", "再有一类是数据库文件系统", "它可以基于文件特征", "来被寻址或者是被检索", "一个例子呢就是winFS", "再有一个呢是日志文件系统", "也就说我们对文件系统的修改", "这些我必须以原子的形式来进行", "因为我的数据很关键", "比如说我银行里的这些记录的修改", "这时候我们构成日志文件系统", "它是指文件系统上 所有修改", "它都会做相应的记录", "以避免我这个操作执行到半截", "所导致文件系统损坏", "由此导致数据丢失", "网络分布式文件系统", "这时候实际上相当于", "我们看到的是把文件存到远端的机器上", "这时候呢不同的网络访问方式", "构成了我们这里不同的文件系统", "再有一个呢是特殊文件系统", "比如说像我们前面讲到的", "进程间通讯当中用到的管道", "就是一类特殊的文件系统", "对于分布式文件系统", "我们还想多说两句", "也就说我们在这里为了进行共享", "前面的文件共享呢", "是在一个系统里多个进程之间", "分布式文件系统呢", "它是想通过网络来进行文件共享", "文件被存到远端的服务器上", "对于这种情况", "我们用户在访问远端文件系统的时候呢", "要通过挂接远端服务器上的文件", "这时候就会导致其中有网络通讯", "我们正常的标准的文件操作", "就会转换成网络上远程访问", "在这种情况下 我们在这里呢", "存在多种分布式文件系统的共享协议", "NFS CIFS", "这是Unix和windows常用的", "两种网络文件系统", "对于分布式文件系统", "我们会面临比原来更大一些麻烦", "你比如说对于安全", "在本地呢我只需要标识这个用户是谁", "我能标识清楚", "这个安全的管理就可以实施了", "而在网络环境上你想识别一个用户", "这时候它会变得更复杂", "所以在这种情况下", "我们用到的NFS", "实际上它是存在某些安全隐患的", "再有一个问题呢 是一致性问题", "加了网络之后 我读写的时候", "这个一致性就更难把握了", "出了错误之后", "我的错误处理呢也会比原来更复杂", "这都是广域网上的  或者网络上的", "分布式文件系统所面临的挑战", "到这儿呢 我们就对", "文件系统的基本概念呢", "有了一个大致的介绍"]}, {"name": "", "block_id": "1f28ba86d72a423bb27a90194c533924", "text": ["下面我们来讨论线程", "在刚才我们讨论进程的时候呢", "每个进程内部它的指令执行呢", "是有一个叫指令指针的寄存器来描述", "当前这个进程执行到什么地方", "但是在我们实际使用的时候呢", "一个进程内部我也可能会希望", "它有更好的并发性", "那这就是我们在这里", "引入线程的原因", "那在这儿我们先讨论", "引入线程我们通过一个实例来说", "为什么我们要在一个进程内部", "再进一步提高它的并发性", "好 然后说什么是一个线程", "在这儿呢我们给入这样一个例子", "说我有一个应用", "这个应用呢是播放音频的 MP3", "那它的功能呢包括这样几个方面", "一个呢是说我从音频文件里头", "读出相应的数据", "然后通常情况下", "我们的音频文件是压缩的", "然后我需要对数据进行解压", "解压之后呢", "我送到声卡去进行播放", "这是它要进行的三步", "这三步呢我们怎么来实现呢", "这个地方给出了一种", "用单进程的方式来实现的", "也就是说我在这个进程内部呢", "做了一个循环", "这个循环里头呢读数据", "解压然后播放一步一步来", "这个程序能很好的工作吗", "那你说我在这里头", "读磁盘足够速度快", "然后解压足够速度快", "那我解压完了之后给这边播放", "播放还没有播放完之前", "我下一部分的解压数据", "能跟得上的话", "这个程序是可以很好工作的", "但是如果说你细看下去的话", "这个程序会在什么地方有问题呢", "第一部分它需要", "频繁的进行IO操作", "进行读写", "而第二部分呢", "解压它主要是用CPU来算", "这两个部分呢是交替进行的", "实际上我们在系统里呢", "这两个部分是", "应该可以并发进行的", "但实际上在这儿呢这件事情", "做起来就比较困难了", "如果说我在负载比较重的时候", "或者说我的处理能力比较弱的时候", "那这时候呢", "播放声音的连贯性就会受到影响", "然后它资源的利用效率呢", "也会比较低", "好 因为这样的话", "我就没有办法干别的事情了", "因为要不然的话稍微慢一点", "好 最后我播出来的声音", "也就是说在声音上一次给的", "数据缓冲没播完之前", "如果说你下一波数据没过来的话", "那这地方声音它就会不连贯", "那说这样播不好", "那我们是不是可以把这个程序改成", "由多个进程来一块写呢", "好 那这时候说我把它改成", "三个进程来实现", "第一个进程是", "管读数据读到内存里头", "第二个进程呢是管解压缩", "第三个进程管播放", "那第一个读完数据的时候给第二个", "第二个解压的过程中", "由于操作系统的并发性", "我可以切换运行", "好 那这几个呢就可以", "在你读数据的等待阶段", "我就可以进行解压了", "好 这样的话说起来", "它们实际上可以并行", "但这时候呢", "又有一个问题说", "我在这个地方", "在做这件事情的时候", "它们之间如何来通讯", "如何来共享数据", "那我们在前面大家还记得", "我们在讨论进程的时候", "我们讨论进程控制块", "主要的一个目的是说让", "各个进程之间能很好进行隔离", "而现在呢我们这几个隔离", "不是它最主要的要求", "它们需要的要求是", "它们之间能更好共享数据", "而这个要求和我们最开始设计进程", "多进程的时候", "它的目标呢是有一定矛盾的", "好 那在这种情况下", "我们 它的开销也是相对较大的", "因为两个进程之间进行通讯", "通常情况下都通过", "系统调用要从内核里绕一圈", "那如果说这些都是在一个进程内部", "那这件事情就会好很多", "正是由于这种缘故", "我们希望在这里呢", "得到这样一种对进程进行改进", "在进程内部增加一类实体", "使得这一类实体呢", "在一个进程内部呢它可以并发执行", "有多个指令指针在执行", "同时呢它们之间共享的相同地址空间", "这样呢它们的信息交流呢", "会比原来更方便", "因为这时候隔离", "不是它们之间要解决的问题", "因为它是密切相关的一组执行流", "好 而正是由于这种需求", "就导致了我们线程的引入", "好 那这种思路目标我已经有了", "那我怎么来做呢", "这就是我们这里说的线程的概念", "线程是进程的一部分", "它描述指令执行流的状态", "好 那它在这里头我把进程当中的", "关于执行流的信息呢剥离出来", "构成我的线程", "但它仍然是进程的一部分", "这种剥离有什么样的好处呢", "剥离它就可以为并发", "在一个进程里头", "有多个线程啊提供可能", "好 那这样的话把指令执行流的", "最小单位变成是线程", "然后CPU调度呢变成是线程", "好 有了这两条之后", "那我在进程内部的并发呢", "就变为可能了", "好 有了这种变化之后", "我们原来的进程控制块", "会是啥变化呢", "好 原来的进程呢", "变成是资源分配的角色", "那这是我们的地址空间", "我们大家可以看到的", "在这里头跟我们原来比的话", "跟指令流相关东西就不放在进程里头了", "那这里头跟它相关什么", "就是堆栈", "每个指令流它有函数调用的时候", "它必须有自己独立的堆栈", "好 那这样我把它剥离出来", "变成是我们这里的线程的组成部分", "那线程呢是来负责处理机调度的对象", "好 那么在这儿呢 我有若干个线程", "我在这里有各自线程 有自己堆栈", "好 那把相关的关于执行流的状态", "的信息呢变成是线程控制块", "好 那这个线程控制块呢", "也从属于我们的进程控制块", "用指针指向它", "好 那这时候我就可以有多个指令指针", "多个堆栈", "和多个CPU里的寄存器的现场保护", "因为这个现场保护是和执行流相关的", "好 有了这样一个概念之后呢", "我们就可以在一个进程内部呢", "提高它的并发程度", "这个道理说完之后呢", "它大致想起来是可以的", "那这时候我们会做一些什么样的变化", "好 这是我们原来描述的进程的信息", "有代码数据 文件 寄存器 堆栈", "这是我们原来有的", "那在原来里头我只有一个指令指针", "所以这部分只有一份", "我改完之后变成什么样子呢", "这是多线程的进程 那在这里头呢", "代码数据打开文件", "仍然是和进程属性相关的", "它是进程的属性", "而跟执行流相关的", "我可以变成多份", "这时候呢寄存器堆栈", "变成是我们线程的属性", "线程是进程里的一部分 这时候", "这样做变化之后", "我就可以有多个线程在一个进程内存在了", "好 那有了这样做之后呢", "我们从道理上来讲我们多线程就可以", "很好的支持进程内部的并发", "好 这是我们说线程是进程减去资源共享", "剩下部分那就是我们执行流的信息", "好 那这样的话", "我们这样做完之后", "线程的引入有什么样好处呢", "一个进程内有多个线程", "线程之间呢可以并发执行", "线程之间呢", "可以共享地址空间和文件等资源", "这样共享会变得方便", "并发性会变得好", "那它有啥麻烦呢", "因为你在一个进程内部的多个指令流", "那这时候呢它们之间的隔离就没有了", "好 如果说一个线程行为有异常", "它改了另一个线程的相关信息", "那么这时候你的整个进程地址空间里的", "这些线程就都运行不了了", "好 这是呢但是说这种缺点呢是说", "我们不是重点关注的", "并且我认为各个线程之间", "是相互合作的", "所以它隔离的成分", "我们不要求那么长", "好 那有了这样之后我们来说", "现在我们在历史上这个变化的过程", "这个多线程思路是很好的", "那我们看一下这个思路", "它在历史上出来的时候", "它会是怎样一个变化的过程", "也就是说我们现在这些系统里", "是如何逐步来支持这个多线程的", "最早的计算机系统呢", "里头只有一个物理的", "指令指针寄存器", "那这就是我们最早的单进程系统", "比如说像我们的MS-DOS整个系统里", "只有一个指令指针流在跑", "也就相当于这时候", "我们关于进程管理这些机制呢", "这里头都没有", "好 然后我们说希望提高它的并发性", "好 这时候加了多进程系统", "那这时候呢我们传统的UNIX系统", "就是从这么做起来的", "这时候我们在进程切换", "和进程之间的资源隔离", "那都是在这个阶段给出来的", "那有了这个阶段之后", "我们想进一步提高", "这个一个进程内部的并发性", "就变成了我们现在的多线程系统", "那在一个进程", "同时有多线程和多进程", "那就是我们现在的", "这种系统里呢支持的情况", "实际上在这里头我们还有一类系统", "在现实的生活当中也是存在的", "这就是单进程多线程系统", "那这一些系统呢", "通常情况下是对于", "那些对并发执行要求高", "对信息共享要求高的", "但是对安全隔离", "要求低的这些系统里头", "比如说像我们的路由器里头", "路由器里头呢", "它是负责分组的转发", "路由表的查询", "这些是密切相关的", "但是它们之间呢", "需要很好的这个信息共享", "但是由于他们都是一家做的", "并且路由器里呢不支持", "你第三方往顶上加自己的程序", "好 那这时候呢它的隔离", "就做的比较弱", "好 那这样的话不做隔离的结果就是", "我这里只支持一个进程里头", "有很多的线程", "比如说像我们用到的PSOS操作系统", "它在路由器上用的它就有这种特征", "好 那有了这个之后 那我们来看", "进程和线程", "它们实际上什么样的关系呢", "进程是资源分配的单位", "线程是处理机调度的单位", "好 进程和线程呢", "一个是拥有完整的资源", "一个是只拥有跟执行流相关的资源", "那这样一来的话我们线程呢", "它所要保存信息就少了", "那在同一个进程里头", "它们相互之间切换的时候", "你需要保存的信息就少了", "这个时候它的速度就会快", "好 每一个原来说跟执行相关的", "这些进程状态", "现在都转成是线程的状态了", "所以线程有就绪 等待 执行", "运行几种基本的状态", "它们之间的状态的转换跟", "我们前面讲的进程呢是完全一致的", "好 有了这些之后", "那我们的线程呢", "就会有很好的特征", "那这时候它减少", "并发执行的时间和空间开销", "时间开销呢是指说创建终止切换", "它的时间都会比原来少", "这里所说的创建终止切换", "是指在一个进程内部的线程的创建", "如果说你创建一个", "新的进程里的新线程", "那和原来的进程创建呢", "开销是相当的", "甚至于有可能会多一点", "好 然后说我在这里头呢", "它们之间的共享呢", "会比原来更方便", "好 那到这个地方呢", "我们就说清楚了线程的基本概念", "那下面我们会去说如何来实现它"]}, {"name": "", "block_id": "edc844bfe81c499085b138ebbdeca008", "text": ["下面我们来讨论负载控制", "那在我们前面掌握的局部置换算法", "和全局置换算法呢", "都涉及到一个问题", "说我这一个系统里到底有多少个", "并发执行的进程在一起执行", "对于系统来说它的效率是最高的", "那这实际上呢就是我们这里说到的", "抖动和负载控制", "那首先第一个什么是抖动", "抖动是指说我系统里头的", "进程数目太多", "那每个进程的分配到的页面呢", "就减少了 减少到一定程度", "它不能包括它的工作集", "那这时候呢它就会花大量的时间", "去进行缺页处理", "那这个缺页处理增大到一定程度", "在我这个CPU的执行时间里头呢", "就占到比较大的比例了", "好 那这时候最后的结果就是", "你的进程的运行速度变慢", "那对于这种情况呢我们怎么来处理呢", "在处理之前我们需要", "首先分析清楚它是什么原因", "那实际上在这个现象里头", "已经说的很清楚了", "就是驻留在内存里的数目太多", "那太少这个系统的并发性不好", "太多那你的效率降低", "那我们需要在这里找到一个折中点", "那这个折中点呢就是在于", "我需要去考虑我到底是多少合适", "同时还有一个问题就是", "每个进程的页面是多少合适", "那各个进程之间也有差异", "所以这件事情综合起来控制呢", "是比较复杂的", "对于我们操作系统来说呢", "我们希望达到的目标是在并发", "和缺页率之间呢达到一个平衡", "那说起来的话这个平衡比较清楚", "但实际上做起来呢 它是很难的", "那我们需要选择到底有多少个进程", "以及在每个进程", "又给它多少物理页面", "那在这儿呢", "这个问题的深入讨论", "我们时间很有限", "我们只能做一个初步的描述", "那所谓的初步描述就是", "控制这个并发进程数", "每个进程的页面多少呢", "就靠置换算法来确定", "那我们在这里呢", "首先第一个我控制每个工作集的大小", "好 我希望整个内存的总量", "是当前运行的各个进程的", "工作集的总和", "这时候呢 可以和我们前面说的", "这个并发性和CPU利用效率之间的", "这条曲线来说明", "到什么时候这两个是相等的呢", "到这个位置", "也就是说增加到一定程度", "你再增加的时候", "效率提高就会开始到达顶点了", "但是这个地方呢我们比较难考察", "那我们怎么来考察呢", "实际上我们利用第二条 我缺页之后", "有一个缺页出现的平均间隔", "然后还有一个呢是缺页处理的时间", "这两个构成一个比例", "如果说你这个间隔大于处理时间", "那这时候我的处理是来得及完成的", "就在这个点之前", "如果说我这个间隔", "小于你的处理时间", "那你基本上就满负荷的去做处理", "还忙不过来了 对于这种情况", "就已经到了这条线的底下了", "好 我们希望在这里头呢", "它是在这条线的前面", "如果做到这一点", "那这样的话我们选择这个区域", "就是负载均衡的一个平衡点", "那我们能找到的平衡点", "是在中间这段区域里头", "好 到这个地方呢我们说清楚了", "置换算法分成局部置换算法", "我们如何能够从最优的", "局部置换算法去对它做简化 做近似", "然后再讨论到全局置换算法", "全局置换算法里头也是由工作集", "到缺页率算法", "也是对它的一种近似和简化", "最终我们达到的目标是", "让整个系统处于均衡的繁忙状态", "也就是达到负载控制里头的终极目标", "好 今天的课就上到这里 下课"]}, {"name": "", "block_id": "601de1ce9d3241f6ada8900ee3127c35", "text": ["接下来我们讨论内核线程", "在刚才的讨论里头呢", "用户来实现自己的线程", "机制会有好处", "但是也有它的不足", "那把这件事情挪到内核里头来呢", "它会更适合一些", "好那这就是内核线程", "内核线程是由内核通过", "系统调用方式来实现的线程机制", "那在这里头呢也就相当于我支持", "通过一组系统调用来支持线程的", "创建中止和切换", "那这是呢这个图呢是很好的", "说明了内核线程它的基本原理", "也就是说原来我们", "在用户线程里头呢", "你的线程控制块是在用户态的", "由用户应用程序自己来维护", "现在把这东西都", "挪到内核态里头来了", "内核呢", "进程控制块里头有指针指向它", "自己的相应的线程的线程控制块", "好那这样它的创建删除和切换呢", "都是在这里头来进行", "因为你进程的控制和线程的控制", "这实际上很多东西是一样的", "那好我把它搁到一起之后", "进程的切换就没有了", "而所有的切换呢都变成是线程的", "那这样的话它把", "整个这个问题就统一起来", "从而使得严格意义上来讲", "进程是资源分配的单位", "线程是处理机调度的单位", "好那这样的话", "用内核线程来实现多线程机制", "它的有一些什么样的特征呢", "第一个由内核来维护PCB和TCB", "好那这样的话", "调度的方式会更好一些", "好那这时候我们看", "它执行系统调用的时候", "那也不会堵塞其它线程的正常运行", "好那这时候呢相对来讲", "线程的创建中止和切换", "开销会大一些", "因为原来通过函数库方式来实行", "同一个进程内部的线程切换", "它的速度会快于用内核实现的", "同一个进程内的线程切换", "那当然它也会有自己的好处是说", "我调度的单位就可以变成是线程了", "好那这时候呢多线程的进程", "它可以获得更多的CPU的时间", "当然这个呢", "是由你调度算法可以来指定了", "好有了内核线程之后", "那说SOLARIS一种尝试想", "实现更好的轻权进程", "在内核支持的用户线程", "也就相当于我们刚才讲", "用户态线程它的线程机制", "它可以更好的做针对应用的调度", "好那么这样的话", "如果把内核和用户态", "这两个线程各自优点", "结合起来就是这种方式", "一个进程里头有多个轻权进程", "每一个轻权进程对应一个内核线程", "好再往上的轻权进程内部呢", "你可以对应多个用户线程", "那这个图呢很好说明了", "轻权进程的工作机制", "说这是我底下的CPU", "然后我在这儿呢", "这是我的内核线程", "我在这里头呢有这种", "这种是永久绑定的线程", "那相当于我们是在内核支持线程", "因为在用户态跟它相对应的", "就只有一个线程", "好而在这里头呢", "未绑定的轻权进程呢", "在这儿呢我有两个轻权进程", "上面绑定了三个用户态线程", "这样的话它们之间切换呢", "可以由你用户态来", "给出一些相应的策略", "来使得我这个更好", "能够提高应用的效率", "当然这种做法呢", "在最后的实际系统里的", "情况呢有些不理想", "在SOLARIS早的时候", "给出了用户线程", "后来给出了内核线程", "再把这两个结合到一起", "到最后发现说这种机制过于复杂", "它所说的优点呢", "并没有切实的体现出来", "最后变成了", "单一的内核线程的支持", "好这是我们关于线程机制的", "实现机制的讨论", "好到这个地方呢", "我们就说清楚了", "进程和线程的概念", "和它的基本实现方法", "基于我们前面对", "用户线程内核线程", "和轻权进程的讨论", "那用户线程和内核线程之间呢", "存在这样几种相互对应的关系", "第一种我们完全", "用内核线程来实现", "那对于用户态来说呢", "它看到的就是内核线程", "好那这时候呢", "我们实际上可以理解为", "用户线程和内核线程", "是一一对应的关系", "好另一种做法呢是说", "我们对内核如果说", "只是在一个进程里", "只有一个线程的话", "那就是我们传统意义上多进程系统", "那在这儿呢用户态", "你可以实现自己的用户态线程", "那这种对应关系呢", "可以理解为多对一的情况", "而对于SOLARIS的实现办法", "轻权进程我们可以理解为", "这两者之间的对应关系呢", "是可以多对多的", "并且这种对应关系呢可以", "动态在执行过程中来进行变化", "好实际上对于这几种关系呢", "对于我们在实际操作系统", "当中的使用呢都是有过出现的", "那目前呢看下来", "最后的结论性的做法呢", "是这种做法是比较好的", "好到这个地方呢", "我们就说清楚了", "用户线程内核线程轻权进程", "它是如何来实现的", "它的基本原理是什么样子", "也就是说我们在这里头呢", "在一个进程内部它的并发性", "我如何可以提高", "提高的时候这各种各样的实验办法", "它有什么样的优点和缺点", "好那到现在为止呢", "我们今天讲到的进程线程的", "概念呢就介绍完了", "好今天的课就上到这里 下课"]}, {"name": "3.1.srt", "block_id": "96832d1d7f89441fb8ef3181c7fe5622", "text": ["各位同学 大家好", "我们现在开始来讲 第二讲", "这一讲主要内容是中断 异常和系统调用", "首先我们需要来了解一下", "计算机系统在加电的时候", "从什么地方去读第一条指令", "从磁盘上的什么地方", "去读的我操作系统内容", "在这里头就相当于我们在说", "计算机系统的启动过程", "这张图大家在前面的课程当中都已经见到过了", "说CPU是有计算能力", "它可以执行指令 内存它有存储能力", "我们在程序运行的过程当中", "代码数据是存在这个内存里的", "然后这个I/O设备可以跟外交有交互能力", "我们的键盘输入", "我们的磁盘输入输出 网络的输入输出", "都是作为I/O设备来跟系统打交道的", "但是在今天的课程里头", "我们会更进一步来讨论这样一个问题", "CPU在加电之后", "它执行的第一条指令在哪", "那说我们在CPU在加电", "电源稳定之后", "那这个时候它会对里头的寄存器做一个初始化", "到一个指定状态", "这个时候开始去执行第一条指令", "那这第一指令在哪", "它会在内存里头", "但是我们在前面讲的内存的时候", "说内存是用来存数据的", "里头一关掉电源之后", "再加电的时候里面就没内容了", "这个时候你去执行第一条指令", "这第一条指令从哪来呢", "我们这个时候会", "内存会分成RAM 随机访问存储", "还有一个ROM只读存储", "这两个部分 内存当中有一部分区域里头", "就是ROM它是只读存储", "也就是说加电之后", "里头还会有一些我们原来写入的一些内容", "这些内容我们的系统初始化代码", "就从那里开始执行", "具体说起来我们可以这样来看", "在计算机系统加电的时候", "我们在这里头1MB下面有一段", "这段就是我们的BIOS固件", "这部分它在加电的时候我们蹦到那去执行", "这个时候就有一个约定", "计算机系统CPU在初始化完成之后", "里头的代码段寄存器和当前指针", "这两个寄存器的值是多少", "因为这个值直接决定了我们从内存当中", "读数据时候的位置", "我们在系统CPU完成初始化之后", "它处于实模式下 在实模式下", "它的地址计算把段寄存器左移四位", "然后加上它的当前指令指针", "这两个加在一起作为", "我们当前访问第一条指定位置", "还有一条限制是说", "在加电的时候 它处于实模式", "这个时候地址总线", "并不是像我们现在用到通常系统是32位", "它只有20位的地址可用", "那在这20位地址里头", "我们用的区域就是2的二十次方", "这个时候就只有1M", "所以放的区域就只能放在最底下1M里头一小块", "这块代码它为了从磁盘上读数据", "那这个时候必须提供相应的服务", "如果没有这些服务", "你是没有办法访问到磁盘设备的", "为了做到这件事情", "在BIOS里头 它需要提供这样一些功能", "基本的输入输出", "然后系统的配置信息", "开机自检和系统启动程序", "这几个部分基本输入 输出", "它是完成能够我从磁盘上读数据", "从键盘上读用户的输入", "我可以在显示器上显示相应的输出", "这是它基本的输入 输出的功能", "然后系统的配置", "我们都知道系统在刚开始的时候", "你需要有配置", "我到底是从硬盘启动 从网络启动", "还是说从光盘启动", "那这些启动是在你加电的时候", "由你的BIOS的设置来完成", "依据这些设置系统执行它的启动程序", "我能从硬盘把我的加载程序和操作系统内容", "加载到系统当中来", "具体的过程 我们可以这样来看", "在BIOS里头 它启动起来的时候", "它的初始化完成之后", "它就会从磁盘上读引导散区", "这个引导散区是只有长度512字节", "更长的它没有这个能力在BIOS程序", "它不允许你能读更多内容", "读进来放到指定的位置", "然后跳转到其中的固定位置", "就是这里的7C00", "然后这个时候我们就把控制权", "转到从磁盘上读进来的程序", "在我们这里 这是我们这里的加载程序", "加载程序里头我们又可以做进一步的事情", "这加载程序能干什么呢", "它能将操作系统的代码读到内存里头来", "并且能把控制权交给操作系统", "来继续执行操作系统功能", "这个时候有个问题 说", "你既然能从磁盘上读数据", "那为啥我不是直接从BIOS里头", "直接把操作系统的内核映像读进来呢", "实际上这时候它是有这样一些问题", "首先我们磁盘上是有文件系统的", "文件系统是多种多样的", "我们在机器出厂的时候", "不可以说我直接限制死你", "你只能用某一种文件系统", "为了增加这种灵活性", "那我在BIOS又不可能加上认识", "所有文件系统代码", "那怎么办 我就在里有一个基本约定", "我不需要认识格式", "我也能从里头读到你的第一块", "读了这块之后 这块的加载程序里头", "我们会用加载程序来识别你磁盘上文件系统", "这时候我认识磁盘上文件系统之后", "我就可以读到我内核的镜像", "并且把它加载到内存当中来", "这就是我们这里看到", "用加载程序读到操作系统来", "有了这个过程之后", "我们再把相应的控制权转到", "读进来的操作系统内核代码上", "我们操作系统就可以开始运行的", "我们在BIOS还要提供一些什么样的功能", "基本的输入 输出功能", "比如说我们需要知道", "如何在屏幕上显示基本的信息", "然后我从磁盘上读写散区", "那我能知道我的内存有多大", "我能从键盘上读用户的输入", "当然在这里BIOS只能提供最简单", "最基本的输入 输出功能", "并且它的使用也受到很大的限制", "比如说在我们的因特尔的CPU上", "它受到一条限制", "就是你只能是在实模式下工作", "那如果说我们的操作系统是工作在保护模式下", "那这些就都不可以用了"]}, {"name": "", "block_id": "ae29a3ec324f4174aa0e76a5d1299aeb", "text": ["好 那我们看看接下来", "我们要完成的练习就是", "stride scheduling", "这是一个我们在原理课", "没有讲的一个算法", "这个算法呢", "来自于一篇比较有名的一个论文", "大家有兴趣的话可以看看这篇论文", "这边给出了一个相应的链接", "当然我们也通过简单的图示", "来给大家展示一下", "这个算法它大致的一个含义是什么", "假定我们现在有三个进程", "P1  P2  P3", "那么呢 每个进程有两个属性", "一个属性是什么呢 它的步长", "就是说它现在执行到了什么地方", "你可以把这个理解为一个跑道", "可以看出来", "这个stride有三个", "P1是100 P2是106", "P3是102", "也就意味着现在最落后的是谁 是P1", "那么跑的最快的是谁呢  P2", "因为它这个106最大的一个值", "这是一个参数", "就是当前的它的位置", "第二个呢", "pass 要代表它一次要前进的步数", "比如说P1它一次前进的步数是16", "P2一次前进的步数是7", "P3一次前进的步数是10", "那我们这个调度的", "算法的策略怎么来选择呢", "我们要选择当前", "步长最小的一个值的进程去执行它", "然后呢 它执行的长度是多少呢", "是这个当前的步长加上它这个pass", "所以说我们可以看到", "在这种情况下我们要选择哪个呢", "很明显 这个P1", "它这个当前的步长是最小的", "所以我们选择它", "然后呢 它会去走一段距离", "是stride加上pass", "我们叫做步进值", "一个是步长值", "一个是步进值 OK", "它到这个位置了", "好 我们接下来再看一看", "当前谁的步长是最小的呢", "P3现在是102", "所以说我们接下来呢", "我们的调度算法应该选择P3", "然后它执行的步长是什么呢", "10  102加上10等于112", "到这个位置", "好 再接下来是P2", "它走的步长会到113这个位置", "好 这三个进程都走了一轮之后呢", "我们接下来再判断", "第二轮的时候谁最小呢 P3最小", "所以在这个时候应该选择P3去执行", "这时候它已经变成122了", "再接下来很明显P2执行", "然后周而复始来完成这个", "所有进程的一个选择 让谁去执行", "那可以看出来", "这里面谁的步进值越小", "那么它被调度的次数会越多", "大家想想为什么", "这给大家留一个思考", "那这个算法呢 它具有两个特点", "它可以基于", "进程的优先级来进行调度", "那么这个优先级会和", "我们的步进长度成一个反比", "我们后面会讲到", "第二个呢", "它整个这个调度的选择是确定的", "每一次选择不是", "一个随机出现的一个值", "而是一个确定的值", "所以这个算法具有这两个优势", "我们希望大家采取一定的数据结构", "和一定的操作过程", "来完成对这个算法的一个实现", "这里面首先就要选择合适数据结构", "为什么呢", "因为我们基于数据结构", "要完成相应的插入 查找 删除操作", "而这个和我们", "这个数据结构紧密联系", "到底是取的list还是一个特殊的队列", "比如优先队列等等", "这些都影响到你后续的", "这个算法的实现", "那我们完成的步骤", "第一步就是选择完数据结构之后呢", "你就要去实现里面的", "很重要的初始化函数init", "从而可以完成对这个相应的队列", "数组 堆 等的初始化", "紧接着呢", "会基于这种数据结构", "来实现入队和出队这么两个函数", "这里面再次提醒一下", "这个入队出队是一个抽象的概念", "它并不代表说", "你处理的数据结构", "一定要是一个queue", "一个队列", "第二个呢 我们要实现什么呢", "就是选择操作", "就是到底选择哪一个来", "作为接下来占用CPU执行的进程", "这是pick_next要完成的工作", "假定我们选择了之后呢", "接下来还要干的一个事情", "是proc_tick", "proc_tick是要改变当前的", "一个调度的一个参数", "是否需要调度了", "proc_tick在哪改呢", "我们前面也讲到", "是在中断的", "关于时钟中断处理例程里面", "会对这做一定的设置", "如果认为当前进程用完了时间片", "因为它每一个时钟中断", "代表一个时间片的一小部分", "当比如说一百个时钟中断", "代表一个时间片的话", "那么用完了时间片", "那么就需要重新调度", "这时候就要设置一个调度的一个", "我们前面讲的", "设置一个调度的变量", "叫做need_resched", "把它置为1之后呢", "在接下来的某一个调度点", "就会完成对schedule这个函数的调用", "好 这前面几个函数执行完之后", "我们还要完成一个", "入队和出队的一个实现", "把这个实现了那我们就认为", "我们就把这个关于这个调度算法", "最关键的几个函数实现完毕", "最后还需要干的一个事情就是", "把它的这个调度类设置对", "就是在sched_init这个函数里面呢", "来设置一个default_sched_class", "设置好之后就意味着", "我们的schedule函数能够找到", "你所设计的这个特定的一个调度类", "针对你的这个Stride调度算法的调度类", "来完成具体的调度过程", "当你完成了上述的函数和相应的一个", "关于这个算法的", "调度类的一个设置之后呢", "我们可以通过执行如下这个命令", "make run-priority", "来检查你是否正确的实现了这个", "stride调度算法", "那我们接下来呢", "给大家做一些提示", "使大家可以比较方便的", "来完成这个实验", "首先第一点就在于", "你怎么选择一个合适的数据结构", "那么这个数据结构呢", "会有助于你完成针对", "stride这个调度算法的", "插入 删除和选择这么几个操作", "这里面可以用前面讲的list", "双向链表来完成", "也可以用一些更新的一些数据结构", "priority queue", "这代表是优先队列", "那么优先队列呢", "又可以用进一步的具体的叫做", "斜堆（skew heap）这么一个数据结构", "来完成相应的操作", "就是哪三个操作呢", "插入 删除 查找", "如果采取双向链表", "那么它的这个时间开销", "是和我们进程个数呈一个线性关系", "就O(n)这么一个关系", "那它的执行开销比较大", "如果我们采取一种新的数据结构", "比如说基于斜堆的优先队列的话", "那么它的这个执行开销", "就是查找 删除 插入", "会比基于双向链表这个开销呢", "要优化很多", "所以说我们这里可以", "采取基于斜堆的优先队列", "来完成这么一个数据结构一个组织", "那这里面很重要就在于一个比较", "因为它是一个堆结构", "这个比较函数呢", "大家可以看它怎么实现的", "有了这个斜堆这么一个结构之后呢", "我们就可以完成", "关于这个数据结构的初始化", "插入 移除这么一个操作", "那么通过比较呢", "能够很快找着当前", "最值得去执行的那个进程在哪", "它正好是这个堆顶很容易找着", "那么进一步我们会去修改", "关于进程控制块的这么一个结构", "增加一些相关的信息", "比如说它有一个针对", "斜堆的这么一个运行队列", "那么我们会把我们这个", "就绪进程呢挂到这个队列里面去", "第二个呢这里面有一个stride", "代表当前进程它这个步长值是多少", "还有是一个优先级", "这个优先级什么意思呢", "就是说你优先级越高", "证明你越有优先执行的权限", "它和我们刚才说那个步进值pass", "正好起一个反比", "优先级越高它的pass值越低", "而pass值越低呢", "也意味着它有", "更多的机会被调度去执行", "另外还需要整个队列一个结构", "我们还是一个run_queue", "但是这里面专门有一个", "特殊的 叫lab6的run_queue", "来完成对这个结构管理和记录", "当然这个结构跟前面不太一样", "在哪呢", "我们前面一般是用list", "list entry是一个双向链表", "这里面是skew_heap", "基于斜堆这么一个数据结构", "好 这里面还给大家一些提示就是", "这个pass和priority", "到底什么样一个关系", "我们这里面来设置就是pass", "等于一个BIG_VALUE / lab6_priority", "这个lab6的priority", "代表某一个进程它的优先级", "这个值可以设置成不一样的", "可以设置很大", "也可以设置很小", "那么BIG_VALUE就可以", "设置一个相当大的值", "就说有这些priority都不会大于这个BIG_VALUE", "使得这个BIG_VALUE除以这个priority", "会得到一个pass就是步进值", "那步进值越小它前进的越慢", "那我们调度时候呢", "就会更多的选择这种进程去执行", "这也是为什么这个pass和priority", "正好是起反比的作用", "第二个需要大家注意的是什么呢", "这个步长", "这个stride这个值呢", "随着它不停地累加 其实会溢出", "你怎么保证这个溢出", "不会影响到对这个值判断", "比如到底选择哪一个", "最小那个stride去执行", "这个我们是需要有一些特殊的考虑", "大家要想到这里面有一些约束条件", "比如说STRIDE_MAX减去STRIDE_MIN", "要小于PASS_MAX 这是一个约束条件", "第二个呢我们还做一个特定设置", "STRIDE和PASS是无符号整数", "大家可以关注一下我们数据结构", "可以看到都是unit32_t 32位无符号整型", "那么有了这个之后呢", "我们再做比较的时候", "是用的有符号值来比较", "那么这一种设计技巧呢", "使得我们可以避免出现溢出之后", "无法去做正确的判断", "到底这个stride", "谁大谁小这么一种情况", "在这里面大家有必要去", "深入理解一下这个stride", "的比较是怎么来完成的", "在它不停累加情况下", "依然能正确的判断出", "到底是谁的这个stride值最小", "好 那前面给大家做了简单介绍", "希望大家 能够基于这些介绍", "能够理解关于这个调度算法的", "一个支撑框架怎么来的", "第二 基于这个支撑框架知道", "我们ucore操作系统", "在什么时候可以完成", "对调度算法一个函数的执行 这是一个", "第三个希望大家能够", "参考Round Robin这个调度算法", "来完成对这个stride调度算法的实现"]}, {"name": "", "block_id": "53b7c6f4b8f148899040d70e4ff01b50", "text": ["那我们看接下来看练习三", "练习三呢 我们要看", "看Bootloader到底干什么事情", "那Bootloader它实际上", "就是完成了最基本一些功能", "比如说它能够把80386的保护模式给开启", "使得现在的软件进入了", "一个32位的寻址空间", "就是我们的寻址方式发生了改变", "为了能够做好这一步", "它还需要干如下几件事情", "开启A20", "初始化全局描述符表", "最后 要使能和进入保护模式", "这三步是它干的事情", "那这三步看起来好像有点复杂", "但实际情况怎么样呢", "我们可以拿个小的程序来看", "我们现在不用lab1", "我们知道 其实之前讲很多这些代码", "也是由一个一个小的Project", "一步步形成了这个lab", "就是每个lab呢 实际上", "由一系列小的Project来构成的", "当然我们这里面已经是直接给大家提供lab", "其实我们可以看一下 lab1是什么构成的", "我们第一个lab的构成", "是由一系列的Project构成的", "那么如果我们只关注Bootloader的话", "我们会发现其实Bootloader很小", "这个代码量很小", "因为它确实只有512个字节", "所以说你可以看到我们的Project1", "当时开发的Project1", "就是一个lab1最早的一个版本", "那么这个版本干什么呢", "就是完成一个Bootloader", "它能够显示一个字符串", "这是一段很小的代码", "那么这个汇编代码", "这是Bootloader很重要一段代码", "这段代码虽然是汇编", "但是它完成的功能", "我们刚才说到的三个功能", "打开A20 建立全局描述符表", "然后使能 进入保护模式 32位的保护模式", "都是在这个汇编里面完成的", "所以说我们会给大家做个简单介绍", "这个代码其实量挺小的", "也就大约几百行代码", "两三百行代码就完成了这个功能", "那有的同学可能感兴趣", "执行出来什么效果呢", "我们可以看看", "好 它其实又编译了这么几个文件", "一个.S 一个.C", "那么这个sign.c呢", "它是一个工具", "它不是Bootloader组成部分", "而是生成主引导扇区的一个辅助工具", "通过它 生成了一个合格的Bootloader主引导扇区", "然后这个bootblock", "就是我们需要去用到一个", "需要用到一个主引导扇区", "运行一下可以看到", "它大概干什么事情", "这里面很多细节看不出来", "我们只看到显示了一个字符串", "显示一个字符串 Hello world!!", "这是Bootloader完成了一个", "Hello World的一个事情", "但在打印Hello World到屏幕上之前呢", "它其实干了很多事情", "我们刚才说的进入保护模式的", "那几件事情都完成了", "然后最后才是显示了Hello World", "而且Hello World还通过几种方式", "并口 串口和CGA", "我们说的Monitor 显示器", "这三种外设来显示", "当然这里面 我们只看到两种", "怎么开启A20的", "如何初始化GDB", "如何使能并进入保护模式", "需要大家仔细阅读这个文件的第16行到第56行", "当执行完第56行代码的时候 ljmp", "这个ljmp指令之后", "整个CPU 计算机系统会进入32位保护模式", "大家需要去了解 它怎么来进入的", "那么这里面需要去读一下它相关的代码", "以及全局表述符表的信息", "这个需要大家去稍微理解一下", "这是练习三"]}, {"name": "2.1 前言和国内外现状", "block_id": "572f26f3b3d2429e82e928b5747fee50", "text": ["各位同学 大家好", "我是陈渝 清华大学计算机系的老师", "我和向勇老师负责给大家上操作系统这门课", "我主要负责操作系统实验这个环节", "为了完成实验我们需要做一些准备工作", "第一个要了解大致做哪些实验内容这是一个", "第二个你要知道为了完成实验", "你要搭好一个实验环境", "所以说我们这两部分内容", "分别给大家展开来做一个介绍", "先看实验内容这块", "实验内容包含了以下几个部分", "第一部分是关于前言部分", "我们了解一下为什么要上操作系统实验", "对于操作系统课而言其实主要包含了两部分内容", "一部分是操作系统原理 另一部分是操作系统实验", "原理主要介绍了操作系统很多基本的概念 算法", "基本的一些操作系统知识", "操作系统实验主要是讲解怎么用我们C语言", "或者在硬件环境或者模拟环境中", "能把操作系统给实现出来", "或者说能把操作系统改进完善", "使它能够正常工作", "这两者之间貌似差别比较大", "但是其实相互之间起了一个很重要互补作用", "为什么这么说呢 因为大家可以看一看", "很多原理上一些内容 相对来说比较分散比较独立", "但是这些分散独立的概念", "其实都是我们操作系统实验中", "重要的组成部分 这是一个", "第二个这一组成部分是有一个紧密的联系的", "而这个联系性只有通过做实验才能有更深入体会", "这是我们觉得为什么要去", "做操作系统实验的很重要的目标", "第二个很多操作系统概念上", "讲的一些基本的术语算法等等", "那么它和我们具体的操作系统实现", "什么样对应关系", "它们之间有什么样的联系", "这个也是通过上原理课做实验才能有更深刻的体会", "所以我们认为操作系统课程它是一个科学", "和工程相结合的一门课", "需要通过原理的学习 通过实验的实践", "才能更好更深入掌握操作系统基本的知识", "这是我们认为为什么要上", "操作系统实验的一个很重要的目标", "另一方面我们强调了", "因为操作系统都知道是一个软件", "它需要去编程", "那我们需要大家在实际编程中能深刻的体会到", "操作系统到底是怎么完成它的功能", "怎么来展现它具体的概念算法", "我们认为操作系统实验需要强调这个实验环节", "对于我们同学来完成这个实验需要注意几点", "第一个是需要注意 你要理解整个系统", "这个系统包含了软件硬件两方面知识", "因为操作系统只要控制硬件", "所以你要站在一个全局的角度来理解问题", "第二个循序渐进完善功能", "为什么这么说呢", "因为我们知道操作系统虽然是一个大型软件", "但是它也不是一天建成的", "它也是一点点像搭积木一样 形成了从一小块", "一个砖头两个砖头最后形成了一座房子", "那么这个搭积木的过程我们希望同学能够掌握", "知道怎么从零开始", "能够完成出一个完整的小型的OS", "这是我们希望同学能够去了解和掌握的", "第三个要懂得阅读代码和能够去改进它", "这点其实是我们做实验中有一个比较深入体会", "为什么这样说呢", "其实大家在完成后续的实验会发现", "这个实验你花了很大一部分时间是在阅读代码", "并不是在编程 而是在理解和阅读代码", "只有很好的通过阅读代码把操作系统的框架", "它的实验细节掌握之后", "你再去完成老师给你布置那些实验内容", "你会发觉还比较容易", "所以你发现你完成代码量并不大", "但是你为此要把这个代码读懂", "花的时间是很多", "特别是它和我们一般的应用程序是有很大的区别", "它需要有很多跟我们硬件打交道", "它的编写方式 它的处理方式", "都和我们通常应用程序有很大区别 这是一方面", "另一方面当你能够掌握这个基本OS功能之后", "我们还可以对它进行扩展 做一些创新性实验", "这也是很鼓励一些觉得自己能力还不错", "你还需要进一步挑战", "你可以去在这方面有充分余地去发挥你的能力", "看看你能不能在这个操作系统之上完成新的功能", "来增强操作系统能力", "我们后面会跟大家做介绍", "我们同学这方面做的工作", "第二方面我们看看国外发展的情况", "首先是MIT我们清华大学在操作系统教学改革上面", "充分借鉴了MIT这些教学思路", "他们很强调超系统课工程实践能力", "所以他们设计了两个OS", "一个叫XV6一个JOS希望同学能够阅读XV6", "然后来改进完善JOS这么一个操作系统", "这是他们的一个思路 哈佛也是一样有OS161", "以及后面的哥伦比亚 伯克利 斯坦福等等", "他们都有各自的操作系统实践的环节", "强调学生在理解原理的同时", "能够通过实验来加强对操作系统", "一些具体细节的掌握和理解", "从而对操作系统有个更全面和深入的体会", "在国内也是一样 我们是基于国外的一些先进的一些经验", "比如JOS XV6 OS16以及Linux", "来设计一个小型的OS叫ucore", "我们现在做的实验就是阅读ucore", "然后对ucore进行改进和扩展", "这是一方面 其他比方说像北大", "国防科大等等 他们有不同思路", "有的是基于一个小型的OS 比如说像北大", "我们了解到他是基于MIT一些实验环节", "像国防科大 浙大等等", "他们更强调一些基于Linux来做相应的实现", "相对而言Linux更加复杂功能更强大", "掌握它花的代价相对要大一些", "还有上海交大 南开 基于国外的", "Minix Nachos等等 来做相关的实验", "当然这些信息还有待进一步更新", "我们是目前了解到一些情况", "从中可以看出来国内的大学", "特别是一些对操作系统这门课很重视的一些学校", "他们还是把很多精力 除了放在原理课教学之上", "也放在了这个实验环节 所以我们希望", "同学们也可以看到通过实验 其实是有很好的", "能够进一步掌握操作系统这么一个机会", "其实除了一些教学OS之外 还有一些实际的OS", "前面已经讲到有Linux", "Solaris Windows Rtems eCos等等", "这也是一些实际存在的一些OS", "它们也是在某些学校和某些领域得到学习和掌握", "其实没有什么特别区别", "我觉得大家根据各自的特点", "可以选择不同的OS来作为你们实验的目标", "甚至还有同学说 一个OS都没有", "我们从零开始来实现OS 这也是有可能的", "我们看到有些挑战", "就是有些愿意接受挑战的同学", "他自身对计算机理解很充分的话", "我们也不觉得不能够从零开始实现OS", "据我们了解确实有这样的同学存在"]}, {"name": "视频", "block_id": "5887dbaf977e4101a60e6613984031af", "text": ["接下来我们讲操作系统的演变", "也就是说在历史上操作系统的技术", "它到底有些什么样的变化", "那么对于操作系统来说", "它主要的功能是在用户态和硬件之间", "做一个中间的协调和抽象", "然后是使得", "用户可以很方便的使用硬件的资源", "和操作系统里面的软件资源", "那么从这个道理上来讲", "这个中间的变化做成以后", "应该没有什么变化了", "但是实际上我们说", "操作系统的变化非常巨大的", "原因在于在过去", "操作系统发展的半个世纪的历史当中", "技术上有非常大的变化", "我们在这里举一个例子", "说从80年代个人计算机出现", "到2012年操作系统硬件技术", "有一些什么样的变化", "从这张表里我们可以看到", "计算机系统里的价格", "基本没有明显的变化", "我们先不考虑物价上涨之类的因素", "基本是在几千美元的尺度", "但是我们看一下计算机系统当中", "各个部分之间的变化", "就是非常巨大的", "我们从这里可以看出来CPU的速度", "从4M到3G基本上M到G", "基本增加了几百倍到1千倍的尺度", "而处理能力从0.3个MIPS到12年的76个MIPS", "基本上涨了200倍", "而存储能力变化是最大的部分", "从最早的内存从64K", "到8个G应该是涨了几十万倍", "而几十万倍的话", "从硬盘的存储能量也是类似的", "这种变化对于我们来说", "到底计算机技术里有什么样的区别呢", "大家可以想象一下", "早的时候有可能我一个文件", "从文本就是几百个字节", "几千个字节", "现在我们存的一个视频文件", "动不动几个G了", "这种变化实际上对操作系统来说", "它有至关重要的影响", "实际上在操作系统的发展历史上", "它从最简单的单用户系统", "就是说我们能让一个用户", "能够用计算机的资源", "能够算它的作业这就是它的目的了", "然后有了这个目的之后", "我计算机系统这个系统太贵了", "好 这个时候", "我能不能提高它的利用效率", "提高利用效率就是批处理系统", "和多道系统要干的事", "等到效率能提高一定程度以后", "如果说我在这里排作业算的时候", "我排到前面一个用户算的时间很长", "我在后面要等很长的时间", "这个时候怎么弄", "这个时候我们这个分时系统", "使得我可以", "在前一个作业没有结束的时候", "我后一个作业能够交替运行", "等到分时系统出现之后", "并且成熟了以后", "我们操作系统里面", "这些性能提高的这一部分", "就大致差不多了", "接下来是说个人计算机系统出现", "那这个时候", "它易用性变成它最主要的部分", "而分布式系统出现之后", "它的这种联成网络以后", "它的安全性和高可靠性", "变成它的主要内容", "我们看一下在这个变化的过程当中", "各个技术的变化的要点", "从计算机出现的", "40年代的前面的10年左右", "基本是解决", "我如何能让花很大价钱买来的计算机", "能够让它的利用效率能提高", "比如说这是最早的计算机系统", "能摆半层楼", "那在这头昂贵的计算系统", "我花了很多的时间", "去换子代穿孔机和最后打印成的结果", "这对于我来说是很不合算的", "我要努力的减少这部分的时间", "从而使得我的执行时间", "占的比例越来越高", "这样我的利用效率就高了", "怎么做呢", "它的做法是把这些", "前后打印和前面的输入", "不用昂贵的计算机来做", "用周边设备来做这种输入和最后的输出", "中间这一段价钱贵的部分", "我让它尽可能的快", "这一部分数顺序的快速的执行", "这是第一个阶段要做的事情", "顺序执行我用批处理", "然后在这里面呢", "我为了让它能快", "我在这里把若干个作业搁到一起", "它们在执行的时候还是顺序执行", "结果一块顺序打印", "这个阶段最有名的计算机公司就是IBM", "它在这里面发家", "就是靠做这些输入输出设备", "和计算机系统", "那么等到这一个阶段行了", "实际上对于我的CPU来说", "对于我的计算机系统来说", "它是满负荷的从头一个作业", "接一个作业去算", "为了进一步的提高系统的性能", "我们这个时候看怎么来做这点", "这就是我们这里的多道系统", "多道系统是干什么呢", "它利用到的一点还是为了提高效率", "也就是说我一个程序开始执行", "其中有一个做I/O", "做I/O呢我从系统调用进入系统里面来", "布置相应的设备进行I/O操作", "进行IO操作的过程当中", "我的计算机系统就在这等着了", "那这个等待呢", "我CPU是停着的", "没法干别的事", "要想进一步提高效率呢", "我让系统里同时存在多个作业", "第二个作业是", "在你第一个作业不在执行的时候", "空闲的时候", "这个时候我让第二个作业来执行", "等到你第一个作业返回结果回来以后", "我再切回来继续执行你的第一个作业", "这个时候在内存里面程序执行的", "就由原来的顺序执行", "变成的多道程序的交替执行", "但是交替的条件", "是前一个正在执行的程序", "主动让出CPU的使用权", "有了这一条以后我的CPU", "就可以变成是连续的", "尽可能的在处于运行的状态了", "这样的话我的效率又进一步提高了", "这一步提高以后再往下发展呢", "就是我们的分时系统", "分时系统它仍然是在做系统的", "多个程序的交替执行", "但是这个时候大家注意", "我们交替的条件不一样了", "我在这里加了一个时钟中断", "每一个作业算一段时间以后", "硬件会产生一个时钟中断", "时钟中断的时候", "我会暂停当前进程的执行", "去由操作系统去调度", "我让另一个程序继续执行", "等它的时间再一个时钟中断", "然后再回来", "这样的话我让多个进程交替执行", "这个时候交替执行就变成什么", "如果我有一个作业在前面", "花很长时间要算", "我又来一个作业我仅仅是做编译", "也许编译我就不一定通过了", "这种情况下我排在后面", "我会等很长时间", "有了分时系统以后大家一人算一点", "对于我刚才说的这种", "只是做编译测试的这种情况", "它可以分到它的时间很快算完", "算错了它就退出来了", "而另外一个长的呢", "它在交互式的这几个运行结束以后", "后面长的作业可以一直算下去", "这样一来就可以减少了", "我用户等待的时间", "这个时候说它的系统的性能", "在什么地方做提升", "它的提升不是在于", "有CPU的效率有提高", "原因在于CPU加了调度以后", "它的性能某种角度它会下降", "但是由于我让一些短的作业", "能够公平性能更好了", "这样的话我短作业", "用户的时间的会节约了", "从这个角度来讲仍然是提高效率的", "到了这一步以后", "分时系统我们的CPU的效率", "就基本上提到极致了", "接下来计算机发展的变化是什么呢", "就是个人计算机系统", "在个人计算机系统里面呢", "效率已经不再是我们关心的重点了", "这个时候计算机的价格", "已经降低到一个办公室", "或者说一个家庭", "可以有一台计算机的状态", "在这种状态下", "我用户也不再是局限于", "是计算机专业人士", "才能够使用计算机 写计算机程序", "很多人开始利用计算机", "来做自己的事情", "这个时候计算机的易用性", "变得非常重要了", "这个时候图形用户界面", "是这个阶段发展的重点", "在这个里面计算机变成一个", "支持沟通和交流的系统了", "而这个里头呢", "安全性的问题又变成这里最重要的了", "这个相当于安全的问题", "在操作系统里面重要程度有上升", "个人操作系统实际上", "和网络的出现又联在一起", "这个时候我们网络的", "又形成了另外一个分支", "就是分布式操作系统", "分布式操作系统", "它因为有了网络以后", "我在多台机器之间", "需要有数据的共享和协调", "然后一台机器里面", "我也可能使用多个CPU", "这个时候多个CPU的使用", "和多台机器互联的使用", "这个时候可能提高的结果", "使得我们系统的可用性", "和可靠性有进一步提高", "这个时候我们见到的一种典型场景", "是若干个用户通过网络联在一起", "我们有服务器提供一些", "共性的资源的共享", "各个用户在自己的机器上", "进行相应的处理", "使得我整个网络可以开始", "去处理一些实时的信息", "比如说我们在这样的系统里面", "可以买飞机票 买火车票", "在网上进行购物", "这个图可以很方便地的来说明", "在操作系统演变的过程当中", "计算机的处理能力和", "操作系统变化之间的某种关系", "在最早的时候计算机系统", "主要是一个大型的主机系统", "一个学校可能会有一台计算机系统", "很多的计算机专业人士", "围绕这台计算机系统", "来提高它的效率", "我们所说到的批处理系统", "多道系统 分时系统", "都是在这个阶段出现", "并且不断成熟和发展起来的", "然后等到计算机硬件成本", "降低到一定程度", "这个时候我们每一个办公室", "或者说每一个家庭", "可以有一台计算机的时候", "这个时候通过网络互联的", "个人计算机变成主流了", "在这种情况下我们的方便性", "易用性就变成其中一个重要的内容", "这是我们在桌面系统上看到的", "图形用户接口的发展", "鼠标的使用", "这些都算是这个阶段的", "再往上等到我们每一个人", "都有一台便携式的", "可随身携带的计算机系统的时候", "这个时候我们要处理的易用性", "或者说这种自适应能力变得更强", "也许到不远的将来", "甚至于现在我们一个人就有可能有", "多台计算机系统了", "比如说我会有手机", "有一台笔记本", "那在这个系统里面呢", "我们如果说到某一个状态下是", "每一个电子设备里", "都有一个计算机系统", "里面都有操作系统的话", "这个时候就是我们所说的", "普适计算 移动计算 云计算", "就变成一个主流的内容了", "而在这种环境下", "我们可能涉及到大量的数据", "而这种数据的处理", "又对主机系统又会产生一轮影响", "这就是我们这个云计算", "需要面对的环境", "在这个状态下实际上操作系统", "还会再继续往前又发展", "这个就是我们在最开始讲到的", "实际上像现在的", "谷歌 亚马逊 百度 搜狐", "这一类的互联网公司", "会把精力集中到", "操作系统研究上来的缘故", "好 这就是我们说到的", "操作系统发展的过程"]}, {"name": "3.4 系统调用", "block_id": "ac0354e2459a4e568db69e3a7e610512", "text": ["接下来我们讨论系统调用", "系统调用是操作系统对上提供服务的接口", "它是在怎么实现的", "然后我们在这里会说", "你提供的功能可以通过函数调用", "也可以通过系统调用", "这两者之间到底有什么区别", "然后他们在实现的时候开销是什么样子", "我们在这一部分来进行讨论", "首先我们看一个标准的函数调用", "比如说我想在这里的", "我的应用程序这个大家前面都写过", "我有个printf我想在屏幕上输出一份信息", "我在这里有一个printf就可以了", "背后实际上他怎么做", "你写程序设计的时候", "看到情况是说他有一个标准C库", "C库里提供了printf底下就是printf", "来实现功能给你用就行了", "但是他背后实际他是转成了操作系统的write", "系统调用 然后write系统调用", "它的实现是在内核里的", "根据你write里头参数不同", "会把你print输出的文件", "可能输出的屏幕", "那把这个图再转换一种形式来看", "我们更关心系统调用这个接口的话", "你会看到跟这个很相似", "但是这是说这是我关心的 上面是应用程序", "把我们传统说的应用程序", "和你那个系统库都算到这个上面去了", "这是我看到系统调用接口", "在这个系统调用接口里头", "进到内核里头去 由于write", "你这个系统调用的编号的不同", "我在这选择不同的系统调用编号", "这个编号导致我write里头采用它的实现", "最后给出结果来 返回回去", "那我在屏幕上或者文件里", "就写出了我的printf内容了", "这是我们说函数调用", "那么对于系统调用来说", "实际上是说他在底下提供操作系统服务的接口", "通常情况下 我们是用C", "或者C++高级语言来使用这些的", "而你在写程序的时候", "通常并不直接去使用系统调用", "而把系统调用封装到一个库里头", "比如像我们标准C库", "应用程序是访问这些库里的库函数来实现的", "实际上接见访问系统调用", "下面这几个是我们常见的应用编程接口", "也就相当于我们系统调用最后封装完了之后", "用户用到接口是什么样的", "在不同的系统里面是不一样", "比如说在Windows它有一个Win32 API", "是用Windows操作系统内核的服务来实现Win32 库", "那在这个库里用户来使用", "而在Unix Linux这一类系列的系列有一个POSIX接口", "这个POSIX接口提供了用户需要用到各种各样的库", "而这个POSIX接口底下会访问系统调用接口", "来实现它的服务", "而对于Java虚拟机来说", "实际他上面有一个Java API", "让虚拟机里的应用程序间接的", "会转到我的系统调用接口上来", "这是外界使用的情况", "他内部实现是什么样", "每一个系统调用都有一个系统调用编号", "然后依据这个编号不同", "我们来使用不同的功能", "在这张图我们可以看到这是系统调用进来的入口", "从这通过软中断进到系统内核里来", "他首先体现为一个中断", "中断看是系统调用软中断", "这个时候就转到这个地方来", "这个地方你那里系统调用的编号", "在这编号", "在这是体现为一个功能编号", "功能编号不同我会选取不同系统调用实现", "OK 得到它的结果之后返回回来", "这是对外提供的系统调用编号", "从用户的角度讲", "我们关心只是从这进 这个地方出来", "其他部分我不关心了", "你不关心的底下内容", "但是在这里我们需要关心一个事情", "就是我在使用系统调用接口的时候", "我需要把我需要的服务告诉内核", "这是我要准备参数的地方", "你把这信息准备好之后", "我就可以系统调用在内部实现", "就可以知道我如何做处理", "处理完之后把结果返给你", "而我们通常在这用的时候", "这部分又封装到函数库", "而函数库我们在上面用就不用关心了", "接下来我们说系统调用和函数调用的不同", "那对于所使用的指令来讲", "系统调用使用的是int和iret", "而函数调用使用的是call ret", "这四条指令 他是在指令级是完全不同的", "那么他们的区别体现在什么地方", "实际功能区别在于函数调用", "我们知道你在程序的设计里已经学到过了", "我为了调用一个函数", "我需要把参数压到堆栈里头去", "然后转到相应函数去执行", "执行时候从堆栈获取我的参数信息执行", "返回的结果放在那里在返回回来", "这样的话你在上面的函数调用", "就知道我相关的返回的结果", "然后用这个结果继续往下执行", "而对于系统调用来讲", "他由于内核是受保护的", "而应用程序是他自己的区域", "在这为了保护内核的实现", "这个地方内核和用户态的", "应用程序之间使用不同的堆栈", "所以在这会有一个堆栈的切换", "切换之后由于处于内核态", "我就可以使用特权指令", "这些特权指令所导致的结果", "就是我这个时候可以直接对设备进行控制", "而你在用户态是不可能进行的", "这就好比说我们在银行里头", "你可以告诉银行的营业员", "我需要从我的某一个帐号里取多少钱", "这个取钱操作到银行的内部", "他的营业员是可以去直接打开保险柜", "打开保险柜取出你所需要的钱", "并且在你帐号上做相应的记录", "这些记录就好比说你记到你堆栈一样的", "他记到他自己内部的堆栈上", "以至于说如果说", "我们两用同一个堆栈会有什么问题", "我们两用同一个堆栈", "用户其他代码可以改你堆栈的信息", "这对于系统来说是不安全", "好比说你从里面取了钱", "结果你帐号上的金额并未减少", "这银行不干或者反过来说", "你把钱存到银行里去了", "但是银行帐号上钱并没有增加", "这个时候你是不干", "基于这种理由我这会有相应切换", "银行可以在里进行特权的操作", "当然我们在这里只是对int iret call ret", "这几条指令的最主要的区别做一个介绍", "如果说大家在实现新的系统调用的时候", "你可能需要去查详细的区别", "这是对X86来讲 它的CPU指令手册", "那在手册里头有相应链接", "因特尔在不停更新它的手册", "你会看到在这里不同的CPU上", "这些指令它的实现", "有什么样的一致性和相应的区别", "你要想在特定平台上正确的运行", "最后需要准确了解它的行为", "最后我们还有一个问题需要来讨论", "就是我在什么时候用中断", "用系统调用 什么时候用函数调用", "这个时候我们说系统调用", "会比你函数调用更安全", "但是它也有它的问题 它的开销会比你大", "原因是我有一个用户态到内核态的切换", "具体有哪些开销 我们在这列出来", "首先你有一个切换的引导", "这是硬件上需要做的事情", "再有一个是你在内核里有另外一个堆栈", "如果说第一次调用的时候", "这个时候会有内核堆栈的建立", "然后我在这里传参数的时候", "这个参数的有效性合法性是需要做验证的", "切换到内核执行的时候", "由于我访问的代码有切换", "那么在这种情况下", "内核需要访问到用户态的一些信息", "这个时候会把做一个地址空间上的映射", "这些映射会导致你的缓存会有变化", "这个时候你的TLB的内容也会有失效", "所有这些都会导致用户态和内核态切换的时候", "你的系统调用开销是大于函数调用的"]}, {"name": "视频", "block_id": "08b51ff4370a4bb48abbc41dfad9ba58", "text": ["各位同学 大家好", "这学期的操作系统课", "由我跟大家一起来学习", "在开始上课之前", "我们先把这个课程的一些大致情况", "跟大家介绍一下", "这门课是第一次", "在学堂在线提供mooc方式来上", "上课的同学包括清华大学的同学", "和外边其他", "任何对操作系统感兴趣的人", "在这里我们上课的主讲老师有两位", "一位是我叫向勇", "另一位是陈渝老师", "我们两的分工是", "我会在这里介绍基本原理的部分", "陈老师会去介绍操作系统实验", "也就是我们后面会说到的ucore", "教学操作系统里实验的情况", "这门课由于人数众多", "我们的助教有七位", "除了七位之外 还有两位同学", "是负责平台的技术支持", "接下来一部分信息", "是我们在这里的交流平台", "首先 第一个是wiki", "这个wiki实际上", "我们在前边从2007年开始", "我们上操作系统课的相关资料", "在这上面都有维护", "如果同学们想知道过去几年", "操作系统课的相关情况", "可以从这里找到", "包括我们的上课的讲稿", "同学们做的作业的情况", "考试的情况", "包括考试题目的内容", "如果说有一些前面同学对ucore的完善", "大实验内容也在这里面有", "这学期我们课程当中", "一些需要发布的信息", "首先会第一时间在wiki上发布", "然后第二个内容是学堂在线", "学堂在线是在这里公布", "视频的最主要的渠道", "我们的视频", "每周会在学堂在线上公布", "同学们做的作业 练习", "也都会在这上面有", "然后第三个平台是交流平台piazza", "这是国外的一个问答的教学平台", "我在上面申请了一个课程的页面", "在这我们可以在上面提问", "提问的内容会第一时间", "由助教老师进行回答", "当然也欢迎其他同学进行回答", "建议大家在问问题的时候", "首先看一下我们的wiki", "是否有同学已经问过类似问题", "而且我们也把以前同学问过的问题", "做了一个列表", "维护在wiki上", "如果说在这里", "都不足以解决你的问题", "那么你在piazza上去问", "如果其他同学知道你可以来回答", "我们后面也会给鼓励", "这样可以增进大家的交流", "也减少老师和助教的负担", "老师和助教主要是", "负责回答比较困难和新的问题", "这是我们在这里的", "课程交流的相关一些平台", "我们这门课程是计算机专业的", "专业基础课", "是一门工作量很大的", "也很重要的课程", "也是一门很综合的课程", "这门课程它的先修的课程要求", "是这样三门", "计算机组成原理", "C语言汇编语言和数据结构", "由于操作系统要与硬件打交道", "所以需要大家了解计算机系统结构", "包括CPU的组成 总线和中断等等", "这样一些内容都是", "你在写操作系统内核代码的时候", "所需要的", "然后再有一个就是", "操作系统的编程语言是C语言和汇编", "所以你需要了解C", "如何来表达你想写的算法", "你需要使用汇编", "来对硬件设备进行控制", "这个汇编的部分代码", "在操作系统里主要是为了", "最底层的控制", "这部分代码通常情况下", "是由设备厂商", "在完成相应的设备开发之后", "最早的一波人在上面写程序的", "后面的人基本上利用这些程序", "来实现上层的功能", "最基本的要求是", "大家能够看得懂相应程序", "并且能够用这些语法", "来表达你的算法", "然后再有一个是数据结构", "在操作系统涉及很多的", "树 表 链表等等", "这样一些数据结构", "我们会在上面做插入 删除", "修改和检索", "这都要求你", "前面数据结构课程里学到的知识", "在这里有充分体现", "我们需要把这些课程综合到一起", "来为上层的应用提供一个", "最基本的操作系统环境", "所以这是我们在这里要求的", "三项先修课程", "那么我们这个操作系统课没有教材", "只有两本参考书", "第一本是操作系统概念", "这本书是一本很著名的教材", "已经出了很多版本", "2012年的时候英文版出到第九版", "中文版是浙江大学郑扣根老师翻译的", "在这我们有了第七版", "在这本书里对操作系统概念的介绍", "是比较准确和清晰的", "然后再有一本参考书", "是操作系统精髓与设计原理", "这本书是由北大的陈向群老师", "和我们这门课的另一位主讲老师", "陈渝老师他们翻译的", "这本书里头对实现的部分", "有比较好的描述", "那这两本书大家都可以", "用在你学习的过程当中作为参考", "接下来我们说一下课程的成绩评定", "这也是大家在学这门课的时候", "特别是要学分同学必须首先关心的", "我们成绩的评定", "分为平时和考试两部分", "平时又分成练习", "教学过程的参与和实验三项内容", "练习 就是随堂之后", "每次课后视频后面有的在线的练习", "需要大家结合着前面讲的内容", "来回答一些简单的", "和前面内容相关问题", "第二个是参与教学过程", "这个主要是指我们在上课过程中", "鼓励大家提问", "鼓励大家回答问题", "大家在学习过程中", "肯定会碰到各种各样的问题", "希望大家积极提问 主动回答", "为了更好的做到", "问题的积累和回答的积累", "我们也希望在这学期课程当中遇到的问题", "遇到新问题", "我们能增加到这个列表里头", "所以我这学期后面又加了一项", "由第一次提问的同学来进行问题的整理", "这样的话 后面同学再来看的时候", "就不会重复问那些问题了", "这也是大家学习过程中一种分享", "然后最主要的部分是实验", "我们这个课程包括八个教学实验", "实际上和我们前面讲的基本原理", "相对应的核心算法的实现", "然后我们的课程分成两次考试", "期中和期末分别是30  35分", "如果说有同学想知道往年考试的情况", "你可以从我们的wiki上看到", "应该是从2007年开始", "到现在每一次考试试题不包括答案", "然后我们在这里", "对于这些极端感兴趣和有余力的同学", "我们鼓励大家来做课程设计", "课程设计主要内容是", "对我们现在的ucore实验环境", "做进一步扩展和完善", "详细内容我们会在后面", "课程设计内容介绍里进行介绍", "好 这是关于课程的一些", "管理方面的基本情况介绍"]}, {"name": "3.2 系统启动流程", "block_id": "994084646ca14128bb886260b03ba4ce", "text": ["好 在刚才的描述当中", "我们说清楚了计算机在启动的时候", "它从什么地方去读第一条指令", "从磁盘上的什么地方去读第一块数据", "那接下来 我们会把刚才这个过程做进一步的细化", "也就是说系统启动的时候的流程", "按照我们刚才说的流程", "应该说我加电之后去读BIOS", "BIOS去读你的加载程序", "加载程序去读内核映像", "这个过程实际上我们又可以把它细化下去", "因为我在加载程序的时候", "我BIOS里头起来", "我们说直接去读bootloader", "但实际上这个过程它并不能直接进行", "比如说我们在最早的时候", "系统里只有一个分区", "上来之后我就直接到分区里找文件系统了", "但是对于我们现在来说", "所有的计算机", "或者大多数的计算机里头都不止一个分区", "可能会有几个分区", "每个分区上会装不同的系统", "那这个时候就在前边加上一个主引导记录", "这个主引导记录是说", "我要从哪个文件系统里", "去读我的这个加载程序", "好 有了主引导记录之后", "然后我就进到当前哪个分区里头", "分区里头又有一个分区的引导扇区", "这个活动分区的引导扇区", "再来加载我们刚才说到的加载程序", "这个过程当中实际上我们就需要知道中间", "这几个部分它的格式是什么样子", "如果你不知道这个格式的话", "那你写出来的程序", "最终存到磁盘上", "机器是不能够从里头认识的", "那我们具体说起来呢", "有这样几个过程", "首先我们在前面已经说过", "CPU加电完成它的初始化", "到一个确定的状态去读第一条指令", "我们需要知道CPU初始化之后", "它的代码段段寄存器", "和当前指令指针寄存器这两个的内容", "算出来它的第一条指令在内存当中的什么地方", "有了这个之后 说我们在这里头呢", "这是它计算的依据", "因为它是实模式", "所以是CS和IP都是16位的", "CS左移四位加在一起算出我的位置", "这个时候 我放到内存当中的BIOS的位置", "只能是在最底下的一兆", "原因在于这时候它是20位的地址", "有了这个之后我们就直接进到BIOS里执行", "BIOS里 我们刚才说", "它是从磁盘上去读你的加载程序", "那实际上在这里头它还有很多的事情要做", "首先第一个是硬件自检", "也就是说我们有可能加电起来之后", "你的内存出错 那整个后边就没法做", "这时候问大家", "你见到过你的计算机如果内存出错了", "你的显示器肯定是不工作的", "那这时候我怎么知道出这个问题了", "我们说在计算机系统里头", "它的加电自检", "它上来之后是看最关键的这几个部分是不是在工作", "如果说检测到", "这就相当于在自检的时候你需要知道", "关键的内存 显卡这几部分是否存在", "或者说干脆你的机器里就没有显卡", "如果存在的话 它的工作状态是什么样子", "把这些设备完成每一个", "这些关键性的接口卡里头", "它自己也有自己的初始化程序", "这些初始化程序完成之后", "那我就认为关键的设备是可以的了", "然后这时候 我们再来执行系统的初始化", "BIOS的初始化 这时候它是干什么呢", "我们说我们现在的系统", "很多都是可以即插即用的", "那如果说我想从一个USB接口的光驱里启动", "那你怎么启得来", "那这时候呢 在这个BIOS里的自检", "现在是能够做到系统的自检", "把这些检测并且配置你的这些即插即用的设备", "这些工作做完之后", "我就知道我现在的系统里到底都连了哪些硬件", "好 我们说在BIOS里有一个系统配置表", "这个配置表就是我们这里所说的", "ESCD 就是扩展系统配置数据", "那用这个数据 我就能知道", "我当前系统里都有些什么样的设备", "每次加电之后有可能你会插上新的卡", "或者说拔掉已有的卡", "这个数据是会变得", "每次加电的时候都必须做", "做完之后说我就把控制权", "转到我们从外部读进来的数据里头", "读进来的代码里", "那这就是按我们在BIOS里指定的顺序", "从软盘 硬盘或者光盘或者你指定的其他设备上", "读进你的第一块扇区", "读进来之后 那这时候", "我们说在我们现在说的这个过程里头", "有多个分区", "好 这时我就有一个主引导记录", "在这个主引导记录里头", "我们需要知道的内容是它的格式", "那说在里头呢", "我们说它有512字节", "但是在这 你只能说我可以用到的是446", "那其他部分是什么", "原因在于我在这里头", "我还有后边有多个分区的时候", "这些分区的状态是什么样的", "你也要存到这512字节里头", "所以这样的话", "你就只有446个字节的内容来执行你的启动代码", "在这启动代码里我需要干啥呢", "需要知道我这些分区表是不是正确的", "如果说你的分区表是错的", "那这时候我的程序是没法正常加载的", "然后还要加载并跳转到", "你的活动分区的引导记录上去", "第二个是你的分区表", "然后我们对于所有的引导扇区", "都有一个结束标志", "这个结束标是55AA", "有了这个之后 它才认为这是一个合法的主引导记录", "那有了这个之后", "它就会跳到你活动分区的引导扇区上去", "那在这仍然是一样的", "它也有一个它需要了解的格式", "那在这里头 就开始有文件卷的信息", "这个结束标志跟刚才那个主引导记录是一样的", "好 在这基础上呢", "说它有启动代码", "那启动代码就是一条跳转指令", "那这个跳转指令跟我们刚才说到的有什么区别呢", "那这地方它就跟平台相关了 你的CPU不同", "这个地方这条指令肯定也是不一样的", "然后空下的其他地方呢", "再是我的启动代码", "这个地方的启动代码就需要认识你的格式说", "我这个加载程序不是存在在512字节里头的", "存在别处 它在哪", "那就靠你这里的代码来约定说我放在哪", "而这里的代码实际上是我们存在硬盘上的", "或者说你的软盘上的", "这个时候我是可以改动的", "那改动完了之后", "我就可以把我的加载程序放在任意的地方", "只要我在这标识出来我上哪去认识它就可以", "好 接下来我们说加载程序的细化", "那在这里头呢", "我们说加载程序它首先不是直接去加载你的内核", "而是去从文件系统当中", "这时候加载程序我是能够认识文件系统的格式的", "从里头读一个启动配置文件", "这个启动配置文件", "在不同的操作系统里它是会不一样的", "你比如说Windows和Linux都有自己的格式", "这样的话它Windows和Linux", "都有自己的加载程序的格式", "依据这个选择你启动的这种参数", "比如说我是在正常启动", "还是说我是在安全模式启动", "还是说我是在一个调试状态下启动我的系统", "那这些区别都会读出来之后", "它导致我在加载内核的时候的一些内核会不一样", "或者说我加载的时候的参数会不一样", "好 依据配置去加载内核", "那么到这 我们把这个过程描述清楚了", "说到这是不是会说", "是说的足够详细吗", "如果说我要来写实际程序", "知道这些是不是就足够了", "那我可以告诉大家", "我这的介绍仍然是很粗的", "如果说你要想写实际的程序", "那么我们需要知道CPU的手册", "它在加电的时候", "处于什么样的状态 BIOS里的规范", "我在从磁盘上什么地方读的第一条", "它的格式是什么样子", "那到这呢 你还需要知道", "我的内核编译的时候", "它的一些相应的信息", "那我们说在计算机启动的过程当中", "我们有很多需要考虑的因素", "这种考虑的因素又有很多细节", "和我们实际的硬件环境", "或者说周围的情况密切相关", "那是不是我们需要在每一种硬件平台上", "我都要制定一个自己的启动流程呢", "那实际上不是这样的", "我们在实际的工业界", "它制定的一组相应的标准", "BIOS就是我们现在广泛使用的", "在PC机上的启动流程标准", "那在这里头 它是主板上的一段程序", "那它可以完成系统的启动", "但是从它最早出现的时候", "是70年代后期", "那在这应该是几十年的变化过程当中", "它已经有了许多的发展", "这呢 我们列出了几种它的变化", "刚才说到那个主引导记录这一部分", "这一部分实际上相当于是说最早的BIOS", "它是从主板上加电自检之后", "进到你的磁盘上的唯一的一个分区上", "去加载它的引导记录去了", "那有了多分区磁盘之后", "就相当于我一个系统有多个磁盘 有多个分区", "那这时候我就需要选择从哪个分区启动", "由于这种需求呢", "在上边加了一个主引导记录", "这个主引导记录呢", "告诉你我从这几个分区里的选择了", "其中的活动分区来进行启动", "那这也有了我们这里的第一个", "然后从这里头我们也可以看到", "当时谁在里头呢", "主引导记录里头我只能描述最多四个分区", "每个占16个字节", "我全部有512个字节", "你四个分区用到了64", "那再多了的话不行了", "而我们现在用到计算机很多的分区会大于四个", "那这时候怎么办呢", "这时候就有了这里说的GPT", "全局唯一标识分区表", "这个分区表 可以在我的分区表里", "描述更多的分区结构", "有了这个之后 我就不会受那四个的限制", "所以这是BIOS的两个发展", "然后PXE实际上是网络启动的一个标准", "也就是说我的机器启来了之后", "我想通过局域网或者说其他的网络", "连到服务器上 去从服务器上", "下载我的内核镜像来执行", "那这时候怎么办呢", "就是这是它的标准", "那如果从这个角度来讲", "你要从网络启动", "好 这时候就你的BIOS里加网络协议栈", "那从这个角度来讲的话", "这个BIOS的功能也会越做越复杂", "甚至于在一些系统里头", "那它就是一个小的操作系统", "好 那在这个变化的过程当中呢", "从我们刚才讲解注意到", "BIOS它可以有一些局部的修改", "来完善对后续的支持", "但这种支持总是会受到前边的制约", "比如说在我们的主引导记录里头", "为了支持多分区", "那我就把中间那地方加成了磁盘上的主引导记录", "然后再加上活动分区里头的这个引导记录", "多了两层 实际上多这两层呢", "它的意义并不是特别的必要", "如果说我设计一个全新的话", "那这件事情我是不需要这么做的", "正是由于这种原因", "那我们又定义了一种新的这个启动规范", "那就是UEFI 统一可扩展固件接口", "这个接口 它想达到的目标是在所有平台上", "一致的提供操作系统的启动服务", "为了做到这一点呢", "实际上它这个标准呢", "应该是从90年代就开始出它的第一个版本", "一直到现在呢", "都在不断的演变的过程当中", "在上这课之前呢", "我查了一下它的最新状态", "它的最后一次修改我能看到的是2015年的1月份", "好 在这里它会增加什么呢", "那我在这举一个例子", "说我们要想从磁盘上启动", "我只要能拿到一张新的磁盘塞到你的机器里", "这台机器剩下的事情我就都可以控制", "那这样的话 我这个系统", "对于一些关键性的服务器", "我允许这样做是有麻烦的", "好 针对这种麻烦", "在这个UEFI规范里头呢", "就定一个可信启动流程", "在这个流程里头呢", "BIOS起来以后", "它在读磁盘上的引导记录的时候", "那它是会对这个引导记录的可信性进行一个检查", "也就是说它会让里头有一个签名", "你只有我满足我签名的这些引导记录我才会读进来", "才会把控制权交给你", "使得我在整个的启动流程当中", "可信的这些介质上的这些代码", "可以在我的系统当中运行", "从而提高了从启动的阶段", "减少了这种安全的风险", "那我们说 这个修改的过程", "还会再继续下去", "随着这个周边环境的变化", "在这个规范里头加新的内容", "慢慢的 也会希望这个规范能够有更广泛的适用范围"]}, {"name": "Video", "block_id": "ea3bb0df267b48bc8b62d30ebb560055", "text": ["接下来 我们讨论", "为什么要学操作系统", "操作系统是计算机系统当中", "一个重要的组成部分", "但是有很多人并不一定", "直接去研究操作系统", "作为大学计算机专业本科的必修课", "我们大多数的同学", "为什么要学操作系统", "我们说操作系统是一门综合的课程", "在这里综合我们前面讲到的", "程序设计 数据结构", "计算机系统结构等", "在这里我们要去研究的对象", "是操作系统的概念和基本原理", "对应过来是操作系统的源代码", "我们在这里要学到的技能", "是操作系统的设计和实现", "说我们已经有", "很好用的操作系统在用着了", "我为什么还要学操作系统", "比如说现在我们用到的Windows Linux", "能够满足我的需求", "那我们在研究当中大量使用Linux", "里面很多开源的内容已经很好用了", "我们现在在这里面为什么要学呢", "实际上说我们修改操作系统", "去研究新的操作系统", "就是要想实现我们的需求", "这个时候说", "我们在这里到底有哪些需求", "它还没有解决呢", "实际上这个问题是说", "我们随着一个问题解决", "我们会对它有更高的需求", "这个需求导致我们会", "会进一步的研究操作系统", "对于我们本科生的", "操作系统的必修课", "我们为什么学它", "我们说学操作系统呢", "操作系统很有挑战", "我们在每一年都会有一些同学", "对操作系统极端有兴趣", "当然操作系统很复杂", "每一年也都会有一些同学", "对操作系统极端不感兴趣", "好 那我们说我们对操作系统很有用", "不感兴趣的你也得学", "因为你要用计算机", "你想把计算机使用的好", "你必须了解我操作系统里面", "是怎么工作的", "如果说你对操作系统很有兴趣", "我想知道操作系统里面是如何工作的", "我想让它能够更好的为我工作", "你也需要来学操作系统", "这是我们为什么要学操作系统", "我们说操作系统", "在整个计算机系统当中的地位", "是非常重要的", "比如说我们这在里面微软", "它最赚钱的不是操作系统软件", "是它上面的应用", "但是它投入大量精力", "去研究和改进操作系统", "那也就是说它在这里的重要地位是非常强的", "操作系统是计算机系统里的", "基本组成部分", "操作系统的硬件发展", "以至于我要在操作系统里面", "添更多的功能", "在里面对它做更好的优化", "正是由于这些原因在学术界", "和工业界都在持续的", "对操作系统进行研究和发展", "到底有一些什么样人", "都在做操作系统呢", "随着技术的发展和时代的变化", "做操作系统的人也是有一些变化的", "比如说最早的时候", "只是学计算机的专业人士", "会去研究操作系统会去写程序", "写操作系统程序是一个很专业的事情", "随着操作系统的发展和普及", "那么工业界早的时候是", "做计算机系统的人的公司", "在研究操作系统", "比如说像我们说到的IBM DEC", "这些公司实际上有一些", "已经随着历史的发展", "退出了历史舞台", "在现在实际上", "提供操作系统的服务的公司", "比如说谷歌 VMware或者说亚马逊", "国内的一些公司像", "阿里巴巴 百度 华为", "这些公司我们在这里", "组成了一些很重要的研究协会", "比如说计算机Unix用户协会", "每年的研究在操作系统领域里面", "最主要的顶级会议有这样两个", "一个是操作系统原理研讨会", "一个是操作系统设计与实现研讨会", "它们俩是隔年开一次 一奇一偶", "实际上每年有大约20篇文章", "在这个会议上发表", "这能代表了计算机", "当前发展的最前沿的状态", "那么在计算机操作系统领域里头", "还有一个重要的标志", "就是操作系统里面会", "每年评选过去10年当中", "最优秀的学术论文", "如果说你想了解操作系统", "现在最前沿的技术和研究热点在哪", "去看这些论文是非常有必要的", "我们说操作系统", "我们现在仍然需要", "去投入大量精力研究它", "它在这里有很多挑战", "首先第一个挑战就是操作系统非常庞大", "我们看Windwos XP代码已经有4500万行", "在这么庞大的代码里面", "我们要想在里面管理它的并发", "这时候你的编程挑战是非常大的", "然后操作系统要管理", "各种各样的硬件故障", "然后我需要对它的各个部分的管理", "要实现高效", "这些都会使得", "我们在这个庞大的系统里", "来处理这个问题的时候非常复杂", "而随着计算机系统的联网", "那么在网络环境下安全的问题", "又变成是越来越关键的", "而在操作系统里", "必须在操作系统层面上", "解决安全的问题", "那上面的应用才能有一个很好的", "安全基础", "这是由于操作系统庞大所带来的挑战", "第二个挑战", "实际上操作系统里面它的关系是错综复杂的", "我们说我们前面讲操作系统有并发", "两个多个进程之间交替使用资源", "这个时候有一些相互之间的相互影响", "但实际上这个时候在操作系统里面", "最复杂的一个问题是", "各个资源相互使用的时候", "到最底层你必须互斥的", "这个时候", "我们这种锁机制导致很多时候", "我们一些资源处在空等的状态", "这个实际上是提高操作系统效率", "必须解决的一个重要的问题", "也就是说它这里由于关系错综复杂", "如何能让它高效变成异常困难", "而在这种环境下", "反倒是我们传统操作系统里面", "讲到的调度这些问题都变成了", "不是当前研究的最热的点了", "操作系统面临的第三个挑战是", "各种错综复杂关系之间的权衡", "比如说我们在操作系统里面", "有时间优化目标和空间优化目标", "这两个实际上是相互矛盾的", "比如说我在这里做一个数组的排序", "如果说我有很大的空间都在内存里", "这个时候我会排起来很快", "但是这个时候", "它占用很大的存储空间", "而我的储存空间又是十分有限的", "这个时候你只能在这两者之间去平衡", "然后说我们需要提高它的性能", "这个时候需要资源多的", "我会给它分配更多的系统资源来使用", "但是这个时候另外一个应用", "如果说它长时间分配不到资源", "这个时候它的响应时间又不可预测", "这个时候我们的性能和", "行为的可预测之间又是一个矛盾", "这种矛盾在操作系统里头", "都必须对它做平衡", "再有一个我们希望各种各样的情况下", "我的算法都能体现出很好的特征", "不会对某些应用性能好", "到另一些应用里面它的性能比较差", "这种差异性呢", "和我们性能的优化目标又是矛盾的", "这是我们通常所说的", "公平性和性能之间的矛盾", "你需要在这两者之间", "牺牲一定的公平性来达到性能", "或者反之你需要牺牲一定的性能", "我才能保证它的公平性", "再有一个就是操作系统", "要面对很多硬件细节", "我如何能够实现中断 异常", "上下文切换的有效进行", "我如何能让这个快表", "有很高的利用效率", "这都涉及到你的CPU的实现细节", "所以在这里操作系统很大一部分的", "直接跟硬件打交道的地方", "都是使用汇编代码来写的", "这样才能保证它的高效", "所以学操作系统里头", "你一定会是要用到汇编代码的", "到底我们如何学操作系统呢", "不闻不若闻之", "闻之不若见之", "见之不若知之", "知之不若行之", "学至于行而止矣", "这是我们的一句古话", "在这个里面我们说", "你必须要落实到行动上", "你才能真正掌握它", "所以我们学操作系统呢", "在那的实验成分比较多的", "而另外一句提法是", "天才是1%的灵性加上99%的汗水", "你必须付出艰苦的努力", "你才能学好操作系统", "我们有同学的一个反馈意见说", "操作系统是困难的", "最好的和最有趣的三年级课程", "当然也有同学把它描述成地狱一般的", "这都是说明我们学操作系统的时候", "你必须下努力", "才能够学的好", "当然说我们这个里面太庞大了", "是不是我们就学不好了呢", "在这里给出来的是我们的Linux", "他在1991年开始做Linux操作系统的时候", "也是一个大学本科生", "1991年 2001年 2011年 20多年过去以后", "Linux操作系统已经变成了", "我们广泛使用的一个系统", "我们做这件事情的时候", "谁也不会想到几十年以后", "一个由大学生发起的一个操作系统", "能发展到目前的状态", "所以我也鼓励大家", "现在大家是三年级的大学生", "那么你的未来也可能成为Linux第二"]}, {"name": "视频", "block_id": "c90c7b98ffe94fc39defe0dd14eacd9a", "text": ["接下来 我们对这学期的教学内容", "做一个整体上的介绍", "在这里包括我们要讲的内容", "我们要做的实验内容", "和课程设计的内容", "操作系统课", "涉及到计算机系统当中资源管理", "所以我们围绕着操作系统的实现", "来介绍相关的内容", "主要分成这样几个部分", "第一个操作系统软件的结构", "任何一个软件在设计的时候", "和在实现的时候它都有自己结构特点", "那对于操作系统来说", "它有什么样的结构特点", "是我们在这里需要来讨论的问题", "第二个是中断与系统调用", "这说的是操作系统这个软件", "它和外界打交道的这些接口", "中断是操作系统和硬件打交道的接口", "操作系统在服务过程当中", "外部如果有设备有请求", "比如说你敲键盘网络有数据包来了", "这个时候操作系统如何对它进行响应", "那么这是中断里要讨论的内容", "硬件上已经有了一些机制", "能够对外边做一些响应", "但是这个时候它只是做了其中第一步", "比如说你敲键盘的时候", "这个时候的硬件机构", "已经能把数据存到相应缓冲区里头", "但是缓冲区如何到应用程序里", "那是操作系统需要解决的问题", "而系统调用是操作系统", "对上层应用提供的服务接口", "也就是说上层应用", "要想利用操作系统提供的服务", "来实现自己的功能", "必须使用系统调用", "在这里头系统调用", "如何从用户态的应用程序里头", "获取用户想使用服务的类型", "和相应的输入数据", "都必须从系统调用接口来", "这里系统调用的介绍", "如何让用户的输入能够到系统里来", "系统处理完的结果如何能回到用户态", "而接下来的这几个部分是", "我们操作系统要管理的资源", "第一个是内存资源", "也就是说在计算机系统当中有内存", "随机访问存储器", "这部分存储能力", "会有很多应用程序要使用", "那如何协调各个应用对内存的使用", "可能会是说有的应用", "它需要大量的内存空间来存储数据", "有的应用需要的不多", "那么这个时候对于我们操作系统来说", "需要要么是应用程序告诉你", "我需要多少", "要么是你在使用过程中动态进行调节", "而这种调节和内存分配和回收", "是我们操作系统要做的事情", "接下来一个是操作系统需要管理", "用户程序的执行过程", "也就是说任何一个程序在执行", "它首先需要系统给它分配", "它执行所需要的资源", "比如说CPU 内存和相应访问的", "一些外部设备和数据资源", "有了这些资源之后程序开始运行", "在运行过程中这些执行的状态", "也是在不断变化的过程当中", "它可能会占用CPU执行指令", "也可能会由于等待用户输入", "而进入暂停状态", "这些状态的维护", "就是我们这里所说进程和线程", "操作系统需要维护每一个", "正在执行的程序它的状态", "以便于在它们执行结束之后", "能够回收相应的资源", "这是进程管理需要讨论的问题", "接下来一个是处理机调度", "处理机调度是指说我们有多个进程", "在计算机系统当中交替运行", "那么如果说你只有一个CPU", "或者说你的应用进程数目", "是大于CPU的数目", "做不到每一个进程", "有一个完全独占的CPU来使用", "那么这个时候", "大家是交替使用CPU来执行指令", "这种交替就需要有一个调度", "到底一个正在执行的进程", "到什么时候让出CPU使用权", "下一个选择又是谁", "这是我们调度算法要进行解决的问题", "接下来一个是进程间通讯", "或者叫同步互斥", "这里指的是我们任何一个应用进程", "它在执行过程当中", "都不会是自己一个", "在那封闭着进行执行", "它不会跟外界做任何交道", "我们计算机上的程序", "它所做到最大好处是", "由于用户输入的不同", "那我给出不同的处理结果", "而这个处理是可以重复进行的", "所以我们在这里才会", "有计算机程序来实现自动化处理", "那为了实现这个计算机上的", "各个应用进程之间", "它们是需要有一些通讯交流的", "这种交流就是我们这里的同步互斥", "也就是说两个进程之间", "要想进行通讯", "那这个通讯是在", "操作系统控制下完成的", "操作系统控制下", "如何让进程间的信息交流", "做的流畅安全", "这是我们这部分要讨论的", "而下一个文件系统是说", "计算机系统当中", "数据大到一定程度之后", "这个时候就不能简单", "我整一张线性表来存这些数据", "我们必须把这个数据管理起来", "做持久性的保存", "而这一部分大到一定程度的时候", "就变成系统了", "在这个系统中", "我们如何来组织这些文件", "以便于方便用户的读 写和查找", "这也是操作系统也解决问题之一", "最后一个是I/O子系统", "计算机系统当中CPU 内存", "这两个部分种类相对来说比较少", "而对于它所能够", "涉及的外设会有很多种", "那据一种不完全的统计", "我们能够连到PC机上的外部设备的", "种类应该是上万种", "这些差异非常大的这些外部设备", "对于计算机系统来说如何连上来", "实际上是一个很大的挑战", "对于这部分是由操作系统里的I/O子系统", "来负责管理的", "我们需要把这些差异非常大的", "这些设备连到同一个系统上来", "并且都能对它们进行高效的控制", "比如说我们键盘的速度是很慢的", "这个时候你两只手一起敲", "你一秒钟也就最多敲几十个按键", "而如果说我们用的网络接口是10G的", "那这个时候它数据量", "在一秒钟就是10GBPS", "两者之间的差异是非常大的", "操作系统需要在里头提供一个", "尽可能统一的接口来管理", "尽可能范围大的这些外部设备", "从这个角度讲我们这学期", "操作系统涉及到的内容是非常广泛的", "所以我们这门操作系统课", "也是一种介绍性的课程", "对于每一个部分深入介绍下去", "都会是一个非常专门的", "后续课程讨论内容", "而围绕着教学内容的安排", "我们每一段教学内容后面", "都有相应的课堂练习", "这是对大家掌握知识情况的了解", "和成绩评定的一部分内容", "另一个内容是实验", "实验基本上围绕着我们前面", "教学内容形成八个实验", "这里的实验0", "是我们教学实验环境的准备", "我们在这门课程里头不会去讲", "如何使用Linux 如何使用Windows", "但是你要想", "在已有操作系统上来做我们实验", "那你必须知道Windows  Linux如何使用", "那这是建立实验环境", "希望大家下去之后能够看相关的资料", "尽可能熟练使用相应的系统", "而下面这八个实验基本上", "是围绕着我们前面内容", "起动和中断", "对应着我们中断和系统调用", "而内存管理到我们这里分成两个实验", "物理内存和虚拟存储管理", "物理内存管理是", "负责物理存储的分配和回收", "而虚拟存储实际上相当于", "我们把物理存储的存储能力", "抽象成一个虚拟的存储界面", "让用户在使用的时候", "一种明显特征是说", "我可以用到比物理内存更大的", "一个存储环境", "而对于进程和线程", "在我们这里分成内核线程管理", "和用户进程管理", "这两个部分 接下来分别是", "处理机调度对应着 实验六", "而同步互斥对应 实验七", "文件系统对应着 实验八", "这样我们所有的这些上课内容", "主要内容在这里", "都有相应的实验内容和它对应起来", "同时我们在这里做的实验", "它是一个相互关联的整体", "我们在一开始的时候", "就给大家一个实验基准代码", "然后后面你就往上添你的功能", "你每添上一个功能的时候", "你的实验系统它处理能力", "就比原来会强一些", "那你在后续实验的时候", "有可能会用到你前面实现的功能", "所以在这大家在做实验的时候", "一定不要说我在前面做实验的时候", "能通过测试就算完成任务了", "有可能在后面做实验的时候", "会发现前面的实验的代码会有问题", "所以在这对前面的实验", "要认真仔细去做", "可以方便你后边加快你的实验进度", "好 这是实验和练习内容", "对于学有余力的", "我们可以安排课程设计", "目前阶段我们课程设计", "还是围绕着ucore来进行", "大家做实验的环境叫ucore", "我们同时维护了一个", "它的扩展版本叫ucore+", "在那里头我们现在的实验环境", "是在X86环境下运行", "但实际上我们的ucore+可以在X86 ARM LIPS", "等几种不同的CPU平台上运行", "并且可以在多种硬件平台上", "能直接跑起来", "我们目前这个改进和完善工作", "还在继续进行", "我们现在工作重点是它的模块化", "我们已经可以在一些平台上", "支持ucore可加载内核模块", "那实际上在这里我们希望", "能够把这些工作做的更完善", "最极致的目标是我们希望和Linux的", "内核可加载模块的接口兼容", "以至于Linux可加载模块", "可以在我们ucore上不用修改", "就直接能够编译运行", "这样一来我们的ucore", "就可以有更多算法", "可以加在上头去了", "应用程序 如果支持动态链接的话", "你可以在里面利用的其它资源也会变得很多", "目前我们已经能够在X86-32上", "能够有很好的支持", "在ARM和X86-64上", "也有一些基本的支持了", "我们希望继续有同学来完善这个", "对于我们现在已经实现的", "这些ucore内核功能", "我们希望能够对它", "进行模块化的改造", "文件系统 调度算法", "内存置换算法和设备驱动", "现在这里头文件系统", "处理机调度算法和置换算法", "都已经有了一些基本的", "模块化的实现", "如果说我们这个工作继续做完善了", "以后大家做的操作系统的实验", "就可能是让大家", "我给你一个已经实现的模块", "让你去实现另一个完整的模块", "这样的话就比我们目前", "往里头去添代码片断", "能够有更好的训练效果", "同时你是一整块有参考", "那这个时候它的难度也会有所下降", "如果说这些内容你都觉得没有兴趣", "那么我们在这里还有更进一步的", "我们希望能在真实的硬件环境下去", "运用我们的ucore+", "现在我们的ucore+", "已经能在树莓派上运行了", "树莓派是一款开源的硬件平台", "它在这里支持有线的网卡USB", "和HDMI视频接口", "那在上头能跑标准的Linux", "我们的ucore最基本的版本", "也能跑起来了", "但是对它的HDMI接口支持并不是很好", "我们只能把它的HDMI接口", "当一个简单的最基本的VGA功能来使用", "我们希望能够在上面做更完善的支持", "右边是别人已经做成的一个", "基于树莓派的集群系统", "那这是这个系统的作者和他的结果", "我们希望有同学后面", "能给出来你的结果", "然后再有一个这是2014年英特尔新出的", "一个小的SOC", "这是Edison", "我们在前边也在Edison早期版本上", "运行过我们的ucore", "但是现在这个Edison上面", "我们还没有做到这件事情", "这个Edison相当于十多年前", "我们一台PC机的处理能力", "目前这个核心的部件上有WIFI  有蓝牙", "400M的双核的CPU", "并且有一个100M的MCU", "与此同时它还有1G的内存和4G的FLASH", "所有这些都是处理能力很强的", "我们希望在上面能跑起我们的ucore", "并且能够用它来做一些", "更有创意性的应用", "如果这些问题都不满足你的兴趣", "或者说你有更好的建议", "我们也支持自选的", "操作系统课程设计的题目", "如果你有这个兴趣你可以告诉老师", "你也可以从我们WiKi上", "看到往年做这些课程设计的同学", "他们给出来的结果", "我们希望到最后做出来之后", "你提供你的报告和你的视频", "我们来看做出来最后的结果", "希望这些介绍有利于大家", "掌握我们在操作系统课里到底讲什么", "大家能学到些什么"]}, {"name": "2.6 ucore部分编程技巧", "block_id": "d0f017f794fc4118b60cc92475d74185", "text": ["最后我们讲一下关于ucore编程里面", "常用的一些编程的方法", "让大家能够熟悉ucore编程的技巧", "这里面主要强调一些", "关于面向对象编程和通用数据结构的设计", "那么ucore虽然是基于C语言开发的", "但是它确实也产生了一些", "面向对象一些编程手段 比如说在这里面", "我们建立一个所谓物理内存的管理器", "那叫pmm_manager", "这个管理器它有很多一些函数的实现", "它的表示是用函数指针的方式来实现", "实际上对外暴露给需要访问物理内存管理器这些", "调动者一个统一的接口 这个接口不会改变", "但是你如果有不同的物理内存管理方法", "比如说有不同连续内存的分配方法", "那我们可以保持同样接口 但是它实现不一样", "这个带来所谓统一的interface", "但是它Details的实现不一样", "面向对象设计的原则", "我们来看看一般应用程序", "怎么来用双向循环链表的", "比如这么一个数据结构", "这个数据结构需要通过双向链表形式", "把它链接在一起 它有一个元素data", "同时它也有一个prev前一个指针和next下一个指针", "那么就形成了这么一个双向循环的链表", "当然这种方式确实在应用程序开发里面常见", "我们需要针对每一种特定的数据结构", "都要建立类似的数据结构", "这使得建立起来的数据结构不具有通用性", "我们有没有更好的办法", "我们以ucore双向链表结构来展示一下", "我们定义一个通用的双向链表比如叫list_entry", "这个也一样 你看到刚刚才类似Prev和next", "但是这个Prev和next并不是特定结构的指针", "它是一个通用结构指针 都是list_entry", "假设我们想建立这么一个双向链表结构", "它包含了free_area和page两种不同类型的strust", "那我怎么来用这种方式来建立呢", "我们先看free_area结构 free_area里面包含了两块", "一块是free_list这free_list就是一个list_entry", "第二个它中间的元素叫nr_free", "这是一个特定一个它的元素", "那么free_list就是这么一个数据结构", "就是list_entry_t这么一个结构", "你可以看到这里面就包含了两个指针", "那么怎么跟page连接在一起呢 我们来看看", "我们把page这个结构也是这么定义的", "它自己一些比如reference", "其它一些自己特定域在里面 成员变量在里面", "但是它最后一个page_link", "page_link也是一样也是list_entry数据结构", "有了这两个之后 这个page_link", "和free_list可以建立相应的链接关系", "就通过prev和next来建立双向链接关系", "这里面即满足了不同类型数据结构的", "它们特定一些成员变量一些表示", "而且在设计链接关系的时候", "用的是一种通用的一种结构来表示", "这是通用的双向链表的表示方式", "应该说在我们ucore里面大量存在", "这种方式大量存在", "有了这种方式之后我们可以更灵活", "更简洁来表示不同的资源", "以及资源之间的关系", "有了这个链表数据结构之后", "我们还有相应对它进行操作的函数", "这个函数的操作和我们通常链表操作差不多", "有初始化 有增加删除等等", "这都是不同函数的表示", "其实还需要很重要一点", "就是在于你怎么能够根据free_list的", "或者说根据刚才说的page_link", "它的结构能够找到它对应", "整个数据结构起始位置", "这个实际上有一定技巧", "在这里面我们可以看看一个例子", "怎么去访问链表的结点所在处的宿主数据结构", "那这里面也有一样有free_area刚才说的变量", "我们希望能够去以这个为头节点来查找", "所有的free_area管理的page这么一个数据结构", "那么它列出它一个方式", "在这里面看起来和通常的轮巡方式是差不多", "有一点不一样 需要注意在哪", "它用到一个特殊的宏叫le2page这么一个结构", "通过le2page来找到某一个page结构", "变量的头指针在什么地方", "这是它一个有特点的地方", "那么le2page怎么实现的", "这实际上是我们关心的", "le2page它里面包含了两块", "一个是指针 一个是member", "这个指针是链表节点所在数据结构的指针", "Member是它的名字 比如说在这里面", "page这个结构里面它是叫做pagerank这两块", "然后它是由另一个宏来执行的", "就是to_struct 里面包含了三个内容", "一个是le 一个是page 一个是member", "这个page怎么体现 就是这个里面le2page", "可以看出来它对一个特定的数据结构", "那么它需要一个特定的结构在这里体现", "那么这个结构到底怎么用 我们可以看到", "那么to_struct又是这三块进一步的展开", "这里面是等于这个链表节点的地址", "减去一个offset这个offset是什么呢", "就是减去它之前以page为例 它处于这个位置", "前面的一个偏移值 它减去之后呢", "实际上得到了 宿主数据结构头指针的一个信息", "这就是offsetof 包含了一个type一个member", "Type就是page member就是pagerank", "这offsetof又是什么呢 这个表达式比较特殊", "可以看出来 type*0 这个0代表什么意思呢", "它不代表具体的一个地址", "而是和在一起代表这种类型的", "一个成员变量一个member成员变量", "在这个类型中的一个偏移值", "整个代表这么一个含义", "那么有了这个含义之后", "我就可以把这个offset得到一个偏移值之后呢", "把ptr的地址减去那个偏移值", "一个指针操作就可以得到这个page", "数据结构的一个特定宿主变量它的地址在什么地方", "那这个le2page这个宏呢", "用到了三部分的内容 第一部分", "是宿主数据结构的链表节点的指针就是le", "第二个呢这个数据结构本身这个page这是第二块", "第三块是这个链表所对应的这个成员变量的", "名字叫member 有了这三个信息之后呢", "最后通过关键的一种表达式 这么一种表达式", "得出这个member 在这个数据结构中的offset", "然后把这个节点的这个地址减去offset", "就得到了这个宿主数据结构", "所对应变量的头指针的地址", "这就是它的大致结构", "知道了这个之后呢后面就可以", "用这种le2page等等 来完成", "对特定数据结构的头指针一个寻址的的过程", "这实际上是我们说 这个实验环境", "重点需要大家去掌握的内容", "好这部分内容就到这为止 谢谢大家"]}, {"name": "视频", "block_id": "5e2381f279c344dc934e55bde6861ae9", "text": ["我们现在来讲", "现在主流的操作系统", "我们现在用到的操作系统", "主流的有什么", "大家能想起来的Windows Linux", "实际上我们从划分角度来讲", "最早的操作系统是从Unix系统开起来的", "60年代这两个人", "KenThompson和Dennis Ritchie", "他们两个开始做Unix系统", "然后从它开始", "Unix系统演变出了BSD系列的", "也就相当于伯克利开始", "给出了一些全开放的代码", "你可以用它来做任何使用", "这形成了我们现在一系列的BSD系统", "然后往下这部分系统呢", "大家能看到的是原先的Solaris", "现在Solaris已经变成Oracle", "这一系列", "我们现在大家看到的比较多是mac os", "这一系列的都是从Unix系统", "演变出来的", "实际上这在我们计算机史上", "Unix系统是至关重要的里程碑式的工作", "照道理来说Unix已经取得了很大成功", "但是90年代的时候1991年", "有一个叫Linux的大学生", "开始做了Linux", "他是从Linux想来自己做一个", "完全能够自己掌控的系统", "从他开始新的开发模式", "导致了我们现在大家可以看到的", "redhat fedoro ubuntu", "等一系列的Linux系统", "实际上从我们划分的角度来讲", "它是和Unix系统是同一类的", "它们提供的API是兼容的", "或者说是类似的", "然后这套系统我们现在", "看到它的发展是什么呢", "从Linux扩展到我们的手持设备", "手机这一类的", "现在是我们的安卓的系统", "这是从Unix Linux发展起来的一系列", "它是以很好的开放性", "为它的核心思路", "开放的程度以Linux最完整", "Windows系统是另一类完全不同的做法", "它是以专用和封闭的形式", "来发行的操作系统", "我们最早知道的是", "微软给IBM的PC机做dos操作系统起头的", "到90年代初的时候", "微软从DEC了请到Dave Cutler", "开始做WindowsNT", "这个系统基于Unix系统开始改的", "他开始做Windows", "从这开始到Windows3", "在早的版本Windows并不很出名", "从3.0开始Windows发展起来", "以图形用户接口", "和易用性来得到认可", "到现在实际上我们看到", "Windows95、98、Windows7、Windows8", "到现在的Windows10", "这一系列是以完全封闭的形式", "来呈现给大家的", "那么在这里我们看到", "从操作系统来讲", "有两种完全不同的风格", "开放和封闭", "这两种我们很难说", "它们哪种好或者说是不好", "应该说是各有各的优缺点吧"]}, {"name": "Video", "block_id": "860b5e4c8c384dedbdfbe8550a13bd8d", "text": ["现在我们来继续讲", "什么是操作系统", "大家想象操作系统是什么样的", "它是一个程序", "它和其它程序是什么样的关系", "然后它有些什么样的组成", "它有些什么样的特征", "我们首先来看什么是操作系统", "操作系统实际上", "没有一个明确的定义", "它哪些功能算是操作系统里的", "那些功能是应用软件或者说硬件的", "实际上随着操作系统的发展", "操作系统内涵实际上是在不断变化的", "我们现在给操作系统是给出一个解释", "有一种解释说", "操作系统是一个控制程序", "它是一个系统软件", "它给用户提供一个运行的环境", "用户使用计算机系统的时候", "提供所需要的服务", "如果说用户的使用不当", "那么这个时候", "它需要进行项目的一些错误处理", "如果说用户在使用过程中", "我是不是能给它一些协助", "比如说你在输某一条命令的时候", "输了半截你忘掉了 后面是什么内容", "这个时候它是不是能给出一些提示", "这是我们第一个理解", "第二个理解操作系统", "它是一个资源管理器", "实际上就是说我们计算机硬件", "和应用程序之间", "用操作系统来作为它的一个中间层", "它为计算机应用程序来管理", "所有的计算机软硬件资源", "以协调于各个应用程序", "在使用这些资源的时候", "能够友好地使用下去", "那么具体说起来就是", "如果说所有的资源都是由我专用的", "那么这个时候我的使用肯定会没问题", "但是如果说多个应用程序交替着来使用", "那么这个时候这资源", "如何使用就会有一些问题了", "比如说像内存 你在用我也在用", "这个时候我到底", "两个应用它们之间各分配多少呢", "有可能给你分配多了 给它分配少了", "而你的需要又跟分配的结果不一致", "那这个时候对操作系统来说", "我就需要做一个高效的判断", "来使得我们在这里", "能够按照应用程序的需要", "给它分配合理的资源", "这是我们操作系统提供的高效使用", "所要达到的目标", "然后第二个是说", "我们可能都需要很多的资源", "这个时候操作系统", "要负责解决这种需求上的差异", "实现它的公平", "操作系统表现形式", "可能会有多种多样", "比如说我们windows我们的Linux", "它的表现是完全不一样的", "但是从操作系统内部结构上来讲", "它基本上可以分成这样几个部分", "说操作系统在中间 下面是硬件", "上面是应用", "应用我们就可以把它", "分成系统应用和应用程序", "这两个部分对于我们来讲", "我们学操作系统的人", "就是要来做操作系统", "那么你是在硬件基础上做操作系统", "这属于系统设计者", "如果说你是写应用程序的人", "或者写系统应用的人", "这个时候我利用操作系统的功能", "给出应用程序和系统应用", "如果说你是一个应用程序的使用者", "这个时候你直接使用的应用程序", "但是即使这样的话你理解操作系统", "也有利于你更好地使用计算机系统", "操作系统实际上就是", "在硬件进行一层隔离", "对上面的应用", "提供我们通常所见到的逻辑这些资源", "比如说进程 文件 地址空间", "这都是在操作系统之后", "给用户程序看到的情况", "操作系统是一个软件", "在我们软件划分当中", "这是我们操作系统", "实际上我们可以把软件分成", "应用软件和系统软件", "系统软件我们又可以", "把它分成系统应用和操作系统", "而在操作系统里面", "核心的内容是我们的内核", "而这里的命令行", "由于它和操作系统内核关系非常密切", "我们把它划在这里头", "实际上有时候也会", "把它认为系统软件的一个组成部分", "我们在操作系统里", "到底有一些什么样的组成", "首先说我们有内核", "实现我们刚才所说到的", "资源的管理功能", "操作系统之上用户要使用", "实际上我们在这提供了两种命令接口", "一个是命令行接口", "这个时候用户需要去敲键盘输命令", "另一种是图形用户接口GUI", "这个时候实际上我们是把命令", "转换成我们图形用户接口的", "一些基本读数", "比如说在这里的窗口 图标 菜单和指针", "有了这些之后", "我去看文件系统的文件的图标", "那我就对应着某一个文件", "这样的话方便用户来使用", "这个时候我们能达到一种效果", "是所见即所得", "操作系统和外界的关系", "实际上我们在这个图可以很直观表现出来", "操作系统是我们", "整个计算机系统里的核心软件", "然后在外面构造我们的", "提供对外接口和一些应用", "用户就可以来使用", "系统所提供的服务了", "这是我们用户所在的位置", "对于我们这学期课来讲", "我们的ucore小操作系统", "它在提供一些什么 我们从下往上", "中间两个黄色的部分", "是我们操作系统的内容", "下面是硬件 我们写了几种", "我们在ucore实验里头会", "涉及到的硬件 串口 磁盘和存储", "我在这有一个硬件抽象层", "硬件抽象层把底下这些做一个屏蔽", "提供一个标准的接口", "然后在这里实现我们操作系统功能", "操作系统功能是各种各样的驱动", "串口驱动 磁盘驱动 物理内存的管理", "操作系统内核提供的服务", "比如说我们的信号", "这样的话", "我们在执行一个程序过程当中", "我就可以强行让它停下来按Ctrl-C", "然后我们可以提供文件系统", "这个时候我就可以把大量的数据", "以人比较好理解的形式组织起来", "然后我们在里面提供虚拟存储", "提供虚拟存储以后我们用户", "就可以使用到", "大于物理内存的储存空间", "然后我们在这里提供处理机调度", "这个时候我们就可以在一台机器上", "让多个应用程序交替运行", "提供这些服务", "都封装在系统调用接口之上", "通过系统调用接口 上层应用", "系统库 编译器 解释器", "和我们命令行应用", "这都是提供的系统应用", "然后我们写的应用程序是", "在这上面利用系统调用和库", "提供的功能", "来实现我们应用的功能", "操作系统软件和", "其它课程里面说到应用程序", "它也是一个软件", "这两者之间有什么样的差别", "也就是操作系统内核", "它有一些什么样的特征", "这里列出来的是", "操作系统所具有四个特征", "并发 共享 虚拟和异步", "并发是指说我们在操作系统当中", "有多个正在运行的应用程序", "那么它需要操作系统管理和调度", "具体什么意思", "就是我们如果多个应用程序交替运行", "我需要知道当前每一个应用", "都执行到什么位置", "当前正在执行的是哪个应用", "如果说应用之间有切换的时候", "那切换到下一个应用的时候", "它上次执行到什么位置", "那这次我从什么地方开始", "当时的状态是什么样子", "那我在这都用操作系统来维护", "第二个特征是共享", "共享是指说我们多个应用", "并发运行的时候", "宏观上要体现出", "它们同时在访问资源的情况", "微观上要实现它们的互斥访问", "比如说我们说到的内存", "两个应用同时访问内存", "这个时候我每个应用", "需要知道它访问是哪个", "另一个应用访问的是哪个", "它们两之间不能访问错了", "我需要保护的这些内存资源", "不能让另外一个应用去访问", "而在微观上 这个时候", "我需要对它做很好的隔离", "我们知道在数据总线上任何一个时刻", "只有一个应用去访问存储单元", "这就是我们所说的微观上的互斥", "然后再一个是虚拟", "也就是说我要通过交替运行", "使每一个用户感觉到", "整个计算机都是", "由它一个用户在专门提供服务", "如何做到这点实际上就是由操作系统", "在每个应用执行的时候这种交替", "由于交替的频率非常高", "让用户在用的时候感觉不太出来", "这台机器还有其它用户在用", "当然我们这里负载大到一定程度", "用户是可以感觉到的", "再有一个是异步 异步是指说", "由于我们程序是走走停停的", "这种走走停停", "它的行为是不是可预测的", "在这里实际上", "我们需要由操作系统来提供", "只要用户的输入是一致的", "那么这个时候它的输出结果", "就应该是不变的", "当然如果说你的那个应用", "就是需要知道跟时间相关的", "这种走走停停的信息", "我们也是可以在操作系统支持之下", "能够发现时间上的差异", "这就是我们在这里说到的", "操作系统的特征"]}, {"name": "2.7 演示实验操作过程", "block_id": "d4a6d9116f1a4cd595d14eddba4d0a0a", "text": ["接下来给大家demo一下", "有关lab0的一些实验环节", "特别是实验环节的一些建立的过程", "可以看到我们现在", "已经打开virtualBox虚拟的这个模拟器", "那在virtualBox里面呢", "我们其实已经建立好了一个叫moocos.lab", "这么一个虚拟的硬盘", "这里面可以看出这个配置怎么回事呢", "我们配置这个Ubuntu64一个环境", "有4G的内存", "然后这是一些显卡等等", "这个就是一些常规的设置", "比较重要是这个硬盘", "我们这个硬盘已经建立好了", "叫mooc-os.vdi", "给它虚拟了8G这个内存空间", "还有网卡", "我们可以看看点击 启动", "那它就开始模拟一台计算机启动", "在这个启动过程中呢", "可以看到Ubuntu的一个启动过程", "我们接下来的操作呢", "基本上就是在", "这个Ubuntu环境中来完成的", "那可以看出来这里面", "这是一个linux Ubuntu的一个环境", "那我们用14.04这么一个版本", "我们首先进入全屏模式", "好 你可以看到现在进入全屏模式", "其实就和我们在一般的linux操作", "是差不多的了", "那在这里面呢 我们打开一个shell", "那我们的这个实验环境", "是放在moocos下面的", "那我们可以看到所有的", "code放在ucor_lab下面", "这里面有两部分", "一部分是labcodes", "可以看到lab1到lab8", "需要去填空的代码放在这儿了", "但是呢我们也提供了答案", "这是lab1到lab8的答案", "如果大家确实做不出来的话", "也可以参考相应的答案", "以及做出来之后", "可以跟这个参考答案做一个对比", "这里面呢没有绝对的对错", "只是做一个参考而已", "那接下来我们可以看到", "我们已经用到了OS命令是吧显示目录", "pwd呢是显示当前目录 还有什么呢", "比如说我们再建一个目录", "那会看到多了一个test目录", "当然我们也可以做比如把前面那个", "这么一个文件移到这儿来", "移到当前目录下", "当前目录下", "那可以看到test多了这么一个文件", "还有呢 我可以把它删除", "这个文件就没有了", "这是简单的创建目录显示", "然后移动文件", "还有创建文件等等", "都可以用这个来实现", "那这是所谓的通常的", "基于这个shell的一些操作命令", "当然我们也可以", "通过一种图形界面方式", "比如打开这个", "这是一个类似于资源管理器", "你也可以在这里面打开moocos", "我们刚才看到这个mooclab", "然后看到test", "那你可以采取这种图形界面方式改名", "test2这种改名", "删除呢 move to trash移到垃圾箱里面去", "看这儿可以看到", "还可以恢复它", "这儿", "restore那在这儿我可以把它彻底的删掉", "shift delete 那就可以把它彻底删掉了", "那这也是通过这种图形界面来使用", "很多同学可能对这个也比较熟悉", "这是一些", "常见的一些对文件的一些访问", "还有一个就是什么呢", "我们开发环境中也有一些命令", "比如说gcc你可以看到", "我们这里面有是有gcc的代码", "还有gdb 退出quit", "退出这个gdb的代码 make等等", "另一方面我们还可以看到", "我们希望有一个很方便", "来完成我们实验的一个环境", "当然我们完全可以", "用这种字符方式来完成", "就基于命令行的方式", "举个例子比如说", "我们现在到lab_answer目录下", "然后看一下lab1", "比如make clean一下", "make clean这时候因为有makefile", "所以make clean找Mmake file", "然后来执行clean这个命令", "会把相应的这些", "生成的这些执行文件给删除掉", "那我们make 回车", "那你看到它整个编译过程", "会把虚拟磁盘镜像给建立好", "这里面包含了kernel", "在bin目录下有kernel这么一个文件", "如果用file看一下的话", "这个文件可以看到", "它是一个可执行的一个文件", "它会把我们bootloader给加进去", "那bootloader放哪呢", "它这个Bin目录下还有一个什么文件呢", "ucore.img这实际上就是", "我们用到bootloader它生成一个磁盘镜像", "这个磁盘镜像包含了bootloader", "以及ucore的这个kernel", "我们怎么来运行它呢", "make qemu 那么它会调qemu来执行它", "这里面可以看到这是lab1", "其实lab1的代码 我们只是来做测试一下", "可以看出来它可以跑起来了", "而且这个时钟中断可以正常工作", "这是一个qemu它可以通过串口输出", "也可以输到屏幕上", "这是ctrl c", "Ctrl c整个中断了", "那么又回到了初始状态", "看到我们这里面", "当你做完make时候呢", "它生成了很多文件", "包括obj文件 包括bin文件等等", "那我们可以去编辑它", "比如说我们曾经说过有vim", "看一下这个Mmake file什么内容", "那可以看到这里面", "有定义很多的一些变量", "当然这些变量都是", "符合makefile的语法格式的", "大家需要去了解", "我们现在退出了vim", "当然这些操作都是字符方式", "如果大家对字符方式很熟的话", "用字符方式足够了", "但是也有很多同学", "可能不太熟悉这种字符方式", "需要跟windows类似的", "图形化的一种操作界面", "那我们这里面也提供了", "比如说我们这里面建立了", "这个eclipse-CDT环境", "单击一下可以把它打开", "稍微等一下", "因为它有一个加载的过程", "我们这里面可以看到是一个", "比如说我们到一个c++的一个开发环境中", "我们可以看到我们把刚才", "这个lab1_ans的目录导进来了", "可以看到这是一个Project", "这是C的一个Project", "其实是lab1的工程", "这里面包含了我们所有代码", "比如说这里面是boot代码", "你要想看这个代码点击一下 双击一下", "那么就可以看它的源代码", "就可以去分析它 这里面有c", "有足够的注释 这是bootmain.c", "这是bootloader主体函数", "它负责加载", "我们可以看到这里面", "比如这个readseg只要点一下它", "它大致的一个位置可以发现出来", "如果敲一下F3 那甚至可以到这个函数", "可以跳到这个函数里面来", "再敲一下F3 比如到了readsect", "那可以到这儿来", "它可以跨文件来查找不同函数这种引用", "通过它很好的可以来分析源代码", "那我们怎么来编译它呢", "这在编辑环境中", "我们编译它其实在这儿也是一样的", "你可以把它这里面有一个build", "build Project", "因为刚才已经编译过了", "现在啥也不用做了", "它已经编译好了", "如果把它clean掉的话", "比如说我们把这个shell打开 make clean", "再看它这个obj目录和刚才", "看到的bin目录已经消失了", "已经被删除了", "用rm-r是递归删除的意思", "就把这两个目录下的", "所有文件都删除了", "这个时候我们来切换到", "就alt tab切换到这个eclipse环境中来", "那我们可以再编译一次", "你可以看到刚才的重复这个过程", "在命令行在这里面也重现了 那编好了", "编好了我们怎么运行它呢", "我们特别是希望能够debug是吧", "运行已经看到make qemu那debug怎么办", "debug的话相对来说需要做一些配置", "在这里面 我们可以看着", "对于这个Project", "我们要有一个debug configure", "假定我们已经装了", "这个Zylin Embedded debug", "那大家可能好奇 这个plug in在哪装呢", "其实我们先把这个先关掉可以看一看", "在install new software这里面呢", "你可以看到我们当时装这个地址在这儿", "这么一个地址", "把它敲进去之后呢", "就可以查找它的那个plug in那个主键", "那么可以看到", "另一方面其实你也可以看着", "这里面已经安装的主键", "在这儿 installation Detalls", "可以看出来装好了这个软件", "那么同学可以先把这个软件装好", "就可以用来便于我们做调试", "我们再回头来看看这个配置", "有了这个之后呢", "我们在这个debug configuration里面呢", "会有一个lab1的一个配置", "这个名字随便敲", "我们这里面叫lab1 ans Default", "那Projectlab也是一个optional", "这是随便填的", "debugger这很重要", "你要选择哪种debugger", "我们这边就用了EmbeddedGDB", "然后stop on startup at bootmain", "我们想停在刚才说的bootloader", "这个函数里面", "这里面写个bootmain", "或者把它关掉也行", "因为我们在后面Commands里面", "也会在这儿有一个gdb命名break", "好 bootmain 这是设置debug", "到底用哪个debugger呢", "所以用的gdb的debugger", "这是一个命令行方式的一个调试工具", "我们这里面只是把它加个壳", "可以更方便在eclipseide环境中", "来调试应用程序", "其它这些设置保持不变", "这里面commands相当于是说", "当如果我们要启动这个调试的时候", "需要做的一些工作", "这里面工作包括", "怎么来跟qemu建立一个连接", "从而可以控制qemu来调试我们的lab1", "这里面有一些命令你大致能理解一些", "这是用来完成对qemu的连接", "这个呢第二行是干什么的呢", "你要调bootloader的话", "那我们前面已经看到的", "在boot目录下的是一个程序", "是bootloader", "在kern目录下是另一个程序", "是我们ucore", "bootloader会加载ucore", "那所以说在这里面呢", "我们首先要把bootloader", "这个符号加载进来", "用这个命名", "这是一个在obj目录下", "有个bootblock.o", "这个文件实际上", "是bootloader的主体执行程序", "它里面包含了符号信息", "比如这个函数它的位置有break bootmain", "等于是说在bootmain所对应的", "那个虚拟地址里面呢", "设置一个断点", "这是gdb初始化命名", "所以continue是让它执行", "在这个执行之前", "首先要把我们说的这个qemu启起来", "那么这里面我们也配好了一个", "外部工具来启qemu", "比如说在这里面你可以看到", "我们准备了一个什么工具呢", "lab1ans有一个运行一个make命令", "make命令会根据makefile里面", "查找一个gdb一个选项", "然后make gdb就可以把qemu提起来", "我们可以看一看", "假设我们在这里面run一下", "这所有操作都在这个集成开发环境里面", "选择外部工具 你可以看着qemu在等待", "等待跟gdb建立一个联系", "处于一个刚开始运行的状态", "然后如果我们现在之后", "再运行一下debug这个的话", "那我们就可以看到 就会有些问题", "我们这里面", "可以看到qemu先把它设在最前端", "这样可以时刻观察它的变化", "它问你是否要进入", "一个debug一个view的一个状态", "我们认为yes", "因为我们需要在debugview下面", "更好来调试和分析我们程序", "你看到现在这个已经断在了debug", "你看debug current指令指针", "我们接下来干什么呢", "很简单就像我们通常", "调应用程序一样 step Over", "就是跳过这个函数去执行它", "它为什么会跳几下", "是由于它这个做了优化", "使得这个地址和源码之间的", "对应关系并不是完全对应好的", "如果你不做任何优化就可以对上", "这里面我们可能好奇", "这个ph到底是多少值 它现在是零", "因为一开始还没有做赋值", "做完这个赋值之后就不应该是零了", "可以看到什么呢", "再看ph 它已经赋了一个值", "可以看出来这种方式", "就可以把这个程序的执行过程", "很容易的分析清楚", "在这里面需要注意", "我们如果要调试ucore", "为此我们需要把ucore", "那个符号信息加载进来", "在这里面我们会到Console这个里面呢", "会把这个加进来 在哪加呢", "会把这个叫做file bin kernel加进来", "reading symbols读进来之后呢", "这里面有一个起止函数", "这是ucore那个最开始跑的", "一个c程序的函数", "设置好了 然后这时候", "我们如果再让它继续运行", "你可以看到", "它现在已经跑完了就是bootloader的工作", "然后把控制权交给了ucore另外一个程序", "同时因为我们刚刚设的断点", "我们可以接着继续调试它", "这里面有一个字符串 message", "message等于多少呢", "刚才说的THUCST这一块", "那么cprint就会打印出来", "那我们再继续执行这个函数", "可以看到它已经进去了", "字符串已经打印出来了", "在这边你看着了有这个字符串的显示", "如果我们想进入这里面看它的细节", "step in 那你就可以看着", "它怎么一步步完成这个打印", "这是一个简单的调试", "当然我们可以看更复杂一点", "比如说我们关注的是", "刚才那一段c代码对应的汇编代码", "就在这边有展示", "我还可以看到特定里", "关注的一些变量的一些情况", "比如说这个等于多少", "这里面其实它等于这些已经列出来", "etext等于这么一个值 在这里面有展示", "这是大致的一个", "在这个eclipse环境下来调试这么一个过程", "那我们现在要继续运行的话", "那它这个跟刚才", "我们在用make qemu这种方式是一样的", "比如说举个例子", "可以看到一个是在eclipse环境下", "调试的这一个qemu", "第二个呢是直接执行的一个qemu", "这两者呢都可以看出来是差不多一个效果", "但是这里面有一些不同之处", "我们可以对它进行打断来执行", "这是它实际上在这儿 这个已经停止了", "但另一个qemu还在继续执行", "看这个qemu还在执行", "那我大致就把这个通过eclipse来调试呢", "给大家做了简单的介绍", "当然eclipse功能很强大", "大家还可以在使用过程中", "再进一步去了解和熟悉", "它不仅仅是调试", "它还可以用来做分析开发等等", "这是很好的开发环境", "另外一个工具呢", "给大家做个简单介绍 Understand", "其实向老师也给大家", "做过一个简单的介绍", "new Project", "那c代码和汇编码", "那它在哪加一个目录 这个目录在哪呢", "其实就你可以指定一下", "比如说你的机器的刚才的地址", "在这儿 ucorelab", "ucorelad answer然后是lab1 result", "那这里面选择一个choose", "然后ok next", "它会帮你做分析 建好这个目录", "那这可以看到", "关于这里面的一些调用的函数", "比如说readline", "那我们可以看到它的一个调用关系", "readline它调了这么多其它的函数", "同时也被kmonitor这个函数调用", "这个实际上通过understand", "可以更好看到一个它的", "一个函数调用关系图", "也便于大家对", "这个操作系统整体的一个把握", "这个工具是用来比较的", "比如说举个例子", "让我们看看lab1和lab2到底有什么不同", "那就可以看出来", "它里面展示出来它们之间的不同", "比如打开这个文件", "那你看lab2就多增加了一些内容", "也还有lab1和lab2之间", "其它地方的一些不同", "也都逐一展示出来了", "那可以通过很方便的", "一个一个的选择来看出", "比较它们之间的一些差异性", "这是一个diff的一个图形化的工具", "当然还有字符方式diff", "这个相对来说比较简单一些", "但是呢就是如果分析复杂软件的话", "用meld好像比较容易一些", "至于apt系列 apt.get来查找安装一些软件", "sudo是确保是处于", "超级用户的权限才能够安装软件", "这属于系统一个工具", "那比如刚才cdt空格口令", "它已经发现eclipse cdt已经安装了", "所以说你不需要再重新安装", "那么git呢是用来分析这个版本的", "或者是上载版本管理", "在这里面git status看当前状态", "你现在整个是一个很干净的一个环境", "你没有做任何更新", "那这里面所以说你的工作clean等等", "你还有其它一些命令 git Pull", "下载新代码 git push", "推你的代码到git池里面去等等", "这都是一些常见的命令", "如果大家需要了解的话", "结合我们的文档中给出的链接", "可以去进一步学习一下", "那大致的一个调试和整个过程呢", "就给大家介绍到这儿", "我想还有很多一些细节呢", "特别是gdb一些使用呢", "其实也有必要", "大家去看看它怎么来调试的", "你可以用小的应用程序来调试", "也可以用刚才说的那个工具", "比如说命令行方式也可以调试", "我们刚才展示了eclipse方式来调试", "比如make debug", "那你可以看着我起了qemu一样的", "然后它起了一个字符方式的cgdb", "那其实一样它也断到了这一点 next", "可以看到它走到哪去了", "走到了88行 86行 88行到91行等等 p.ph", "打出来这个值", "如果执行完91行的话", "发现它结果是不一样的", "刚才我们在那儿实验是一样的", "就是你可以选择你不同方式来调试", "如果continue 那你可以看着", "刚才我们把这个设置成always on top的话", "那么我们continue可以看到", "它的一个变化过程也很类似", "然后ctrl c中断一下", "它执行到了一个我们看不到的地方", "是100073对应不到源代码", "所以是两个问号 这是用gdb来调试一个简单", "做退出 quit退出 把这个要关掉", "我们可以看着了就是通过不同的方式", "有图形方式 有字符方式", "都可以用来编辑分析和运行调试", "我们的操作系统的实验", "这里面还有很多工具", "可以值得大家去探索和摸索", "关于工具的介绍大致就讲到这里", "谢谢大家"]}, {"name": "2.3 8个OS实验概述", "block_id": "79e373c97550409498ee3a9255b4f012", "text": ["为了能够覆盖到刚才说到那些知识点", "我们设计了一共8个实验", "可以看到从OS启动开始 OS怎么启动的", "为此能够跟外设打交道", "从一开始200行代码形成小code", "到最后Lab8文件系统 大约一共加起来", "整个过程大概形成了大约一万行代码", "那么整个这些实验内容基本上覆盖了", "我们上操作系统原理重要一些基本概念", "整个过程我给大家做个介绍 大家知道这个砖头", "怎么一步一步搭成最后一个建筑的", "一开始我们看到我们这里有一个硬件层", "这个硬件层其实是模拟了整个X86大致的架构", "包含各种各样的外设", "以及我们最主要的CPU内存", "这是我们硬件环境", "为了能够让我们超系统能够管理这些硬件", "我们首先设计一个Bootloader", "能够说它的目标干什么 它的目标就是加载OS", "我们用Bootloader加载OS", "让OS在我们类型中运行 这是第一步", "然后OS要运行之后它首先知道", "它所处的环境是什么 它需要去管理CPU", "第二管理内存 第三管理外设", "比如说时钟 键盘 串口 并口等等", "只有把这些都能够有效管理起来之后", "才能够控制这个硬件", "这是我们说前面几个实验", "首先从Lab1我们说Bootloader中断处理", "Lab2物理内存管理 Lab3虚拟内存管理", "都是跟内存打交道 那么Lab4和Lab5", "都是说内核线程和用户进程", "那跟谁打交道跟CPU打交道", "然后Lab6实际上我们说是一个调度", "它也是为了能更有效的利用CPU", "Lab7是完成同步互斥 这里面Lab7在这块", "有了Lab7同步互斥机制之后 我们就可以实现什么", "实现解决一些问题 可以实现进程之间的通讯", "就是我们运行程序之间可以有效进行通讯", "很多可以用来协调的一些工作都可以用这个", "有了同步互斥之后就可以完成了", "那么在进程和内存管理之上", "我们就可以给我们应用程序提供相应的支持", "那我们应用程序可以跑起来", "来可以完成它们特定的功能", "有了进程管理 内存管理", "我们就可以有用户态的各种各样的应用", "如果说你这些应用的数据", "或者你这个代码需要放在永久存储设备上面", "比如说硬盘或者磁盘那需要什么呢", "需要我们文件系统来完成相应的", "把内存中的数据存到我们这个硬盘上的功能", "它可以用很简单方式提供很简单的接口来使用", "那么最后也许还有同学说可以做扩展", "比如你可以完成网络协议栈等等", "这都是形成了我们这个完整OS", "可以看出来其实包含了三部分", "前面说一部分是硬件", "第二部分是运行在内核态的kernel", "我们说OS kernel软件", "然后有了这个OS kernel之后", "我们可以设计各种各样的应用", "来使用我们内核提供各种各样的服务", "那我们重点实现的部分", "在内核态这些各个大的模块", "涉及到我们提到的八个实验", "就是基本上覆盖了这么多内容", "简单我们会把这个八个实验做一个逐一的介绍", "从Lab1开始 Lab1讲的是Bootloader", "中断还有设备驱动 这三部分内容", "那这三部分内容实际上就是说", "首先你要理解操作系统怎么启起来的", "其实它通过Bootloader启起来的", "同时当操作系统启起来之后 它怎么管理硬件", "它需要通过中断机制", "还有通过设备驱动程序来完成对硬件的管理", "比如各种各样的外设的管理", "这是说我们在Lab1的时候会去碰到", "需要大家掌握和理解的知识", "也需要大家通过对这些知识的了解", "来进一步去完成对一些操作系统", "运行时候机制的掌握 比如说堆栈处理", "比如说它怎么去控制一些外设的", "当然具体的外设的控制", "我们这里面可以不用看那么细", "可以看的简单一点", "只要知道它大致的过程就行了", "不用去了解它那些细节", "这个我们可以不用去掌握", "主要知道它大致处理过程", "特别是它怎么去建立好这个中断机制", "这点很重要 有了中断之后", "我们就可以完成后续很多很重要功能", "这个代码其实可以看到 最开始那个代码", "比如我们加载一个OS最简单代码", "其实只有很小一些代码量 可能不到一千", "几百行代码就可以完成打印一个字符串OS", "当然它没什么功能 但是它确实就可以看到", "我们 bootloader怎么把OS加载起来了", "当OS被bootloader加载到内存中运行之后", "那OS很重要一个目标", "肯定不是仅仅是打印一个字符串", "它需要更好去管理整个计算机系统", "那第一步管理是什么呢", "管理我们内存 物理内存管理", "我们知道一个计算机系统", "它有大片的物理内存", "这个物理内存哪些可以用 哪些不能用", "实际上是由我们操作系统管理起来的", "首先我们需要去了解 既然我们说", "我们这个针对硬件是X86 32位的CPU", "那我们就需要理解X86架构下面", "它内存管理的模式 它有分段分页机制", "我们知道通过理解内存地址的表示来", "完成基于分段和分页的方式", "能够实现页表 实现对连续物理空间的管理", "这实际上是我们Lab2重点考虑内容", "我们可以看到在X86架构下", "整个内存一个分布图", "很重要的一点就是操作系代码段 数据段", "ucore代码段 数据段放在什么地方", "以及它管理空闲空间在什么地方", "这些地方都会被我们ucore操作系统管理起来", "来实现一个对内存动态分配和释放这么一个机制", "这是我们Lab2里要掌握的几点", "对Lab3而言我们还需要知道", "在有限物理空间里面 怎么实现一种更大", "超过有限物理空间的一个虚拟内存空间", "映射和管理机制 就是虚存管理", "这是Lab3的功能 那么在Lab3里面", "它需要借助我们前面之前讲到中断机制", "就是缺页故障处理", "还有借助于我们原理课讲到页面置换算法", "这两个结合在一起来实现给我们应用程序", "提供一个大的虚拟空间 即使我们物理空间很小", "比如说只有1M 但是我们虚拟空间", "给它虚拟出来一个4M 8M等等", "从而可以使得 我们应用程序", "可以更好在我们操作系统管理之下去运行", "这是我们Lab3需要去掌握的知识", "这里面需要了解什么呢", "需要知道换页这个机制", "就是我们把这个页换出去", "比如说这里边一个程序", "它怎么能够从内存换到我们硬盘", "以及从硬盘再换回到内存里面去", "这个机制怎么实现的", "这实际上需要我们软硬件协同在一起来完成", "并不是说只是靠操作系统来完成", "需要我们的CPU和我们外设", "有一定支持才能完成", "第二我们需要了解页面调换算法", "以及对应页出错的之后异常处理机制", "这个实际上是我们操作系统来完成的", "当产生这个缺页之后我们应该怎么做", "第二个就是选择哪页换出去和换入", "这个也是一样 就是我们操作系统来管理", "有相应的算法 这一套实际上实现了", "我们整个Lab3大致的一个内容", "就是关于虚拟内存管理这块", "Lab2和Lab3实现了什么", "实现了我们对内存的一个管理", "无论是虚拟还是物理的", "操作系统一个很重要部分", "就算基本上告一段落", "接下来是对什么管理呢 是对CPU的管理", "CPU的管理实际上什么呢", "我们需要让不同的程序来分时占用CPU去执行", "这实际上是我们线程管理", "和进程管理很重要一个思路", "为了实现线程管理", "我们首先是在内核里面实现一个线程管理", "这个实验相对来说比我们后面讲到", "在Lab5中的用户态进程管理要简单一些", "但是它他基本的一些机制是类似的", "我们通过在内核实现线程管理", "可以使得我们利用CPU来高效完成各种工作", "你要创建它 你必须要干什么呢", "需要建立关于线程的内部一些关键数据的描述", "你可以看到在这里面它有堆有栈", "有它的代码有它的数据", "那怎么去表示它", "这需要我们在内核线程中有相应一些关键信息", "第二个如果CPU只有一个", "这个时候每某一个时刻有一个线程运行", "下一时刻可能是另一个线程运行了", "你怎么完成切换 这也是需要去理解的", "你需要有效地管理它 完成切换", "这点是我们在内核线程管理上", "重点去考虑的问题", "当你能够完成这个切换之后", "那其实应该说关于大家不同的进程", "或者线程来分时占用CPU基本机制", "就已经建立好了 那接下来问题是什么呢", "我们说我们需要应用程序", "也能够完成各自特定功能", "而这些应用程序呢", "由于它的可靠性不够高 也可能出错", "我们希望把应用程序放在用户态", "它出错了没关系 不影响内核", "不影响我们处于内核态的这个操作系统", "为了能够让应用程序运行在用户态", "我们需要设计一个所谓用户进程", "我们怎么能够让应用程序运用在用户态", "为此我们需要创建所谓的用户进程", "这里面设计到进程的创建 执行切换", "等等一系列动态管理过程", "这个过程我们Lab4是很相近", "但是又有不同 为什么呢", "这里面其实可以体现出来你需要了解", "建立一个用户级的进程", "它需要的一些关键信息", "这些信息运行在这个空间", "而不是在内核空间", "那么运行在所谓用户空间的话", "很明显它不能够破坏我们用户空间", "怎么能保证这种机制", "我们实际上去分析进程和内存这种关系", "才能知道它们有一定区别 这是一个", "第二个你还要知道运行在用户空间应用程序", "无法直接访问我们操作系统内核里面的函数", "它不得不通过另外一种机制", "我们称之为系统调用", "才能够得到操作系统提供的服务", "这点大家也需要通过Lab5中", "来实现系统调用才能知道这回事", "这也是我们操作系统", "在Lab5中需要去完成一些工作", "你可以看到系统调用和我们中断相关", "我们进程创建和我们内存管理相关", "它的调度和我们Lab4的线程切换相关", "就是你要切换到另一个线程上去执行", "其实你看到Lab5其实建立在", "我们前面的Lab1到Lab4基础之上才有Lab5", "那么有Lab5之后", "我们最终基本就可以完成一个很简单的OS", "它有能够支持用户空间进程来运行", "它建立一个基本的功能", "它有了内存管理 CPU管理", "接下来我们看Lab6", "那既然说我可以让不同的进程", "或者线程来分时占用CPU执行", "到底那个时刻需要那个进程占用CPU执行", "这点其实是有一个策略在里面的", "这实际就涉及到什么呢 进程调度", "我们需要去了解操作系统调度过程", "基于哪些原则来选择哪一个进程去运行", "这点你会涉及到怎么去设计一个调度器的框架", "怎么实现不同调度算法 这里面的调度算法", "和我们在原理课讲的调度算法也是一一对应的", "但是你会发现 原理上讲的一些知识", "如果真的在实际机器里面去实现", "比如我们在一个ucore里实现", "跑在X86这个机器里面的话", "你会发现可能还有点偏差", "为什么 这也是希望大家通过做实验", "能够知道实践和理论之间其实还是有偏差的", "并不是完全对应的", "这也希望大家做实验的时候", "能够深刻的体会到这点", "那Lab7是同步互斥 既然我们现在", "已经可以在计算机系统里面", "在操作系统管理之下可以同时跑多个进程", "但是其实这些进程之间它们也是需要去沟通的", "并不是完全隔离 相互之间没有任何打交道", "它们还是需要去说交换一个信息", "相互之间有一个谁先谁后执行", "这么一个相互关系 这里面就涉及到", "所谓同步互斥一些技术 我们需要知道", "我们操作系统要建立哪些机制", "来支持进程间的同步互斥", "为此我们需要了解比如说", "我们后面说到spinlock 就是锁机制", "semphpore信号量机制 还有condition variable", "就是调节变量机制 它是怎么实现的", "那么这些实现应该说", "和我们操作系统原理课也是一一对应的", "但是比原理课要更加贴近实际", "它和我们硬件是紧密相关的", "第二个假设有了这些实验之后", "我们怎么能够用这些同步机制", "来解决所谓同步问题 比如说我们原理课里面", "经常讲哲学家问题 哲学家吃饭", "在有限的资源情况下", "怎么确保更多哲学家能够吃上饭", "而不被饿死 这些基本问题", "其实当你在我们ucore里面实现这些机制", "就可以用完全原理和算法来实现", "这也是我们说在Lab7里面", "需要大家去体会的一些问题", "如果说你实现不对 有可能出现死锁", "有可能出现其它异常情况", "这就避免了一些问题", "通过实验相信对同步有更深入的理解", "最后一个实验文件系统", "为什么要有文件系统 很明显", "有了文件系统之后 我们写的代码", "可以永久存在一个地方", "我不用每次要敲代码进去", "我只要重新放在一个永久存储介质", "比如我们硬盘上面的一个代码", "加载到内存中去执行就可以了", "我们不需要说每次要重新敲代码", "所以这个永久存储这个介质有效管理和方便管理", "实际上我们说是操作系统", "很重要一个功能文件系统来完成的", "它可以把我们内存中的数据", "按照某种简单的方式", "我们从文件系统转换到磁盘上去", "本身对磁盘的处理实际上挺复杂的", "有了这个文件系统之后", "应用程序只需要通过一些简单的原语", "比如说打开文件 读文件 写文件 关闭文件", "这些基本的简单的原语", "就可以完成对数据的存储", "甚至包括我们执行代码存储也是一样的", "最后你就发现 连我们操作系统本身", "也是一个文件形式存在我们硬盘上面的", "整个文件系统完成之后", "你就可以理解它和我们内存有什么关系", "和我们进程有有什么关系", "和我们外设有什么关系", "在文件系统里面都会有涉及", "那我们最后还可以考虑一下", "这个文件系统不同组织方式以及抽样方式", "怎么样来支持不同的存储介质", "不同的设计机制", "所以说还有一些什么呢", "文件系统抽象层设计等等", "这些都是一个相对来说比较实际的", "文件系统需要考虑的问题", "有了硬件系统之后  我们最后就可以", "完成一个用户可以操作的小型的OS了", "相对来说功能比较完备了 有内存管理", "有进程管理 有同步互斥 有文件系统", "有了这些应该说我们可以在这个基础之上", "开发一些简单的小的应用程序是没有问题的", "就类似于大家写算法 上算法课上数据结构课一样", "你开发简单小应用程序", "就可以在ucore里面跑起来了", "当然也许有些同学说", "这个实验还是比较简单 不具有挑战", "我们的同学也去做了很多具有挑战性的实验", "下面列出了一些例子 大家可以看到", "比如说能够把ucore跑在64位CPU上面", "我们同学已经完成了 把ucore跑在X86 64位上面", "能不能说设计一些不同的页替换算法", "并不仅仅简单我们在实验课中提到", "页替换算法", "还更复杂一些 比如说像Linux一些页替换算法能不能实现", "也有同学去做尝试 还有支持其它CPU", "不光是X86 CPU 我们可以支持", "现在在手机平板用的很广泛armCPU", "这个有同学做过尝试", "还有支持新的文件系统", "我们前面讲到是这种最简单一种实验文件系统", "相对来说比较实际一些文件系统", "比如说FAT文件系统等等", "那么这些文件系统也有同学做过尝试", "能够去实现让ucore支持FAT格式的系统", "最后甚至还有同学去尝试", "让操作系统支持不同的语言", "我们都知道像ucore基于C语言来开发的", "那么我们能不能在ucore之上跑一些", "基于其它语言的一些应用程序", "有同学尝试了GO语言", "这是谷歌开发的一种新的编程语言", "也取得了一定成功", "我觉得这是很好的扩展", "那也有更多一些扩展 这里面没有一一列出", "其实操作系统这个领域", "有很多事情值得大家去探索和摸索的", "从中可以掌握更多一些功能和知识", "最后大家想了解一点是说", "你做了这么多实验 你到底有什么样的收获", "这个收获其实有好有坏", "我们这边把同学一些反馈给大家列出来", "可以看到 第一个理论和实践能够很好结合", "这样不会在感到OS课本", "只是需要一个死记硬背的课", "以前如果说不做实验的话", "基本上把概念死记下来就行了", "至于这个概念到底是怎么实现的 不用去关心", "上这门课你们需要了解这个实验", "和理论怎么去对应 这是一个很重要点", "第二点你在一个全局观 我们说上OS课里面", "原理课里面很多讲的是一些", "概念相对分散独立的概念", "那么你通过做实验", "你需要把这些概念揉合在一起形成", "一个完整可以工作的OS", "这也是通过实验能得到", "第三个很多概念和原理做了大量的抽象", "对于很多细节", "没有再进一步展开讲解", "那么通过做实验能够把这些细节知道更清楚", "特别是跟硬件结合 这实际上说", "在某种程度上可以说是计算机原理课", "和操作系统课一个综合", "能够知道在OS里面怎么控制一个硬件", "同时也有同学提出来", "这确实是大学期间碰到最复杂软件设计", "那么学到了分析和设计大型系统软件的方法", "也许大家将来不会开发OS", "但是你这种方法的掌握", "便于你后续去做跟计算机软件系统", "相关的一些事情打下很好的基础", "大家可以看到", "其实完成操作系统实验可以有很大的收获", "所以说这些实验之确实值得你去做深入的尝试"]}, {"name": "2.2 OS实验目标", "block_id": "68d3d9c1789949ffb1d6168459971612", "text": ["那上操作系统实验课的目的是什么呢", "最主要的目标是在我们操作系统原理", "和操作系统设计实现上面建一座桥梁", "能够辅助同学能够更好深刻理解", "操作系统基本概念怎么产生的", "怎么具体实现的 这是一个很重要目标", "另一方面我们希望同学通过的操作系统实验", "能够对操作系统设计有个全局的感觉 全局观", "这一点也是很重要的一个特点", "因为操作系统相对而言", "在大学期间是同学能够碰到一个", "相对比较大型比较复杂的软件系统", "那么你怎么能够很好在一个全局的角度把握它", "能够对它进行改进扩展分析理解等等", "这对我们同学提供新的挑战", "这也是一个能力的锻炼和培养", "第三方面其实我们也知道操作系统", "它的实现相对来说还是比较复杂的", "并不是说我们每个同学", "都需要去能够对它进行很深入的理解", "然后能够对它进行改进扩展", "甚至从头实现一个", "其实提出了一个很高的要求", "我们其实也知道同学一般会分三等", "针对不同的同学我们其实应该有不同方法", "所以说我们强调什么呢 差异化教学", "那差异化教学体验在什么地方呢", "对于高水平 中等水平和较弱水平的同学", "我们分别有不同的要求", "对于高水平的同学在他完成基本的操作系统实验情况下", "我们希望他去做创新的实验", "甚至挑战一些没有尝试过的一些东西", "比如说举个例子", "现在的ucore它没有去对多核处理器有支持", "我们有没有同学可以挑战一下", "实现一个对多核处理器支持的这么一个ucore操作系统", "这是一个可以去尝试一个工作", "第二个对于中等同学来说", "我们最基本的要求是什么呢", "就是能够完成我们布置的基本实验", "你完成了基本实验 其实就基本说", "能够把我们操作系统原理上面的一些知识点对应起来", "在很大程度上体现了", "我们操作系统原理课讲的知识点", "那么你能够知道知识点怎么回事 具体实现怎么回事", "通过这样的话就可以使得同学", "对于操作系统理解会更加深刻", "对于比较弱的同学 我们希望他能够理解代码", "他也许编程还确实无法完成我们的实验", "但是我们也提供了实验的答案", "所以说通过理解这个代码", "他能够知道原来操作系统", "是这么来完成这么一个功能", "比如说我们后面讲到的内存管理", "文件系统进程调度等等 这些他能把代码读懂", "能够运行起来 能够调试分析它", "也可以很好地去把我们原理", "和我们实验给对接起来", "这是我们说对于相对来说比较弱的同学", "他的要求 这也是对差异化教学的一种尝试", "为此我们就要设计相应的操作系统实验", "我们主要思路是基于一些大量的开源软件", "来从各个层面来使的同学们更好掌握OS", "首先你的实验环境是什么", "就是我们这里面由于大量的工具是基于Linux", "所以说我们希望同学能够在Linux环境中", "来开展实验的过程 这是一个", "第二个你需要去理解代码", "理解代码有很多代码有这样的工具", "比如说我们讲的Eclipse understand", "这些工具都可以便于你去从一个细节", "或者从一个全局的角度来看这个代码", "还有就是生成一些自动文档", "也是便于理解和分析的 比如Doxygen", "你能够把你这个代码能够编译成", "最后能够执行的机器码  你需要一些编译器", "GCC Make 等等一系列辅助工作", "来帮你来把你写代码变成最终的OS", "一个可以执行的执行码", "那你编好了OS之后你要运行", "那运行在什么地方呢 我们有两种", "一种是说我们可以跑在真实的机器里面", "比如说我们这里面ucore针对是32个X86机器", "我们可以用真的机器来跑", "当然这相对来说比较麻烦一点", "我们也可以基于模拟器比如说QEMU", "它是一个软件 它可以模拟出一台X86的机器", "这个上面去跑我们编写的OS", "但是你在编写的过程中还可能出错", "出错我们需要调试 我们有调试工具", "比如说基于GDB和QEMU来进行调试", "而且我们还可以基于集成开发环境", "比如Eclipse的CDT来进行编辑", "分析 运行 调试 整个这个环节的工作", "更加简化 大家在完成实验中的难度", "这是我们提供一系列工具", "所有这些工具都在Linux里有很好的支持", "也有同学尝试在Windows里跑 也有可能", "配置的环境相对来说更加复杂一些", "所以我们这里面鼓励大家基于Linux", "来进行整个实验环境的建设", "和最后的实验过程的完成", "我们可以看看实验内容里面主要包含哪方面", "跟我们操作系统课的知识点是对应的", "我们一开始会讲到中断 外设", "你这个操作系统针对的机器", "针对一台计算机来进行管理和处理", "那么这里面会涉及到相应的IO管理和中断管理", "这是一块 这是跟外设相关的", "第二块跟我们计算机内存相关", "内存管理 它怎么有效管理内存", "来放置我们的代码和我们的数据", "第三个跟我们CPU相关", "那怎么有效的利用CPU来完成相应的工作", "需要分时 把这个CPU的时间", "分给不同的程序去运行完成特定的工作", "这也是我们操作系统很重要一个管理过程", "还有就是涉及到当多个程序在一起跑的时候", "它们有一些并发同步的一些管理", "这个也需要我们操作系统来保证", "才能使得整个程序正常工作", "否则就会出现类似我们说的", "后面我们会讲到死锁等等一系列问题", "还有最后你这些数据 你这些代码需要永久存储", "需要长期存储的环境 那这个环境是什么呢", "我们说的这个 我们一般都知道有个硬盘 磁盘等等", "但是操作系统为了能便于我们用户应用程序", "放置它的数据和代码 我们设计了文件系统", "从而更简单完成对操作系统管理", "这些部分都是覆盖在我们8个实验中", "我们会在实验过程中来体会讲到这些原理", "具体在OS是怎么实现的", "这是我们希望做到的", "那为了减少这个代码量其实大家都知道", "像比如说Linux Windows那是上千万行的代码", "太大了 不要说学生了 就是一个资深的工程师", "也很难把它全部掌握到", "所以我们希望能够减少代码规模量", "使得学生在有限时间内", "比如一个学期能够去掌握和理解这个代码", "我们理解是说大概控制在一万行代码量之内", "从Lab1到Lab8 Lab1可能只有几百行代码", "到Lab8大约控制在一万行代码以内", "从而可以实现对OS的更深入的理解", "同时我们提供的相应的讲义和文档来帮助同学", "甚至我们答案也提供大家", "可以更好的去理解和掌握实验是怎么完成的"]}, {"name": "3.6 ucore+系统调用代码", "block_id": "ac60099786f8435384a90e4196a19b6e", "text": ["接下来 我们看一下在实际代码当中", "一个系统调用的引用到最后的实现", "在这我们可以看到在我们ucore里头", "我这里演示的ucore", "实际上我们用的是ucore+代码", "和我们现在同学们做实验ucore会有一些区别", "为了有所区别 所以我在这演示的时候", "用的是ucore+", "以便同学在里头做的时候需自己去找一遍", "在你那个系统里头他的函数的实现情况", "在这里一个例子 在这个例子就有一句去读文件", "在这里后面有参数 这是一个应用态的一个测试应例", "他在里面去访问的 我们看一下这read个函数", "他调用其他调用其他函数情况", "这有很多例子会调用read", "然后他会调sys read然后是sys call", "这两个函数在往下就没有了", "这个转过来到这sys read实际上就是转变成sys call", "然后这个时候你的函数功能变成这里一个参数", "后面内容都变 这是sys call函数", "然后sys call函数实现在哪", "实现在这 我们看到这是sys call实现", "前面有一些相应的参数获取", "然后对于我们来说", "我们需要关心代码是这段", "这是在X86情况下他的系统调用", "这是num是我们刚在PPT里看到的", "是他的系统调用的编号", "这是系统调用的中段号 这是系统调用", "到这我们从用户态的情况", "在往下就已经跟踪不到了", "我们转过身来在内核态", "内核态我们刚才在PPT里说", "他是从all trap到trap然后在我们这里我们先看trap", "这里头实际上就是从中段进来之后", "他填了一个数据结构叫trap free", "在这个数据结构当中", "是获取到了相应中段产生的一些信息", "他里面有我们说的中段号和相应寄存器的值", "到这就转到trap dispatch 这我们可以看到其中有一个sys call", "他会判断trap num是多少", "根据不同情况我们关心的是在这里的sys call", "如果说你是其他 比如说时钟终断", "那在这里他的时间代码在这", "我们关心到这 他到sys call这个函数", "这个函数我们看一下这是他函数调用图", "我们trap dispatch到这是sys call然后这个sys call实际下去之后", "在里面有很多内容 我们看直接代码", "这是sys call 到这来之后 他会转到sys read", "到这会去读取你的参数", "这实际上就是从系统调用进来之后", "获取他一二三 这三个参数", "然后这个时候转过之后变成sys write", "我们看到这来的时候 这是sys read到sys write", "然后再往下就是相应的实现了", "我们看在这sys write到这里最后下去之后", "我们带这里根据不同情况完成相应文件的读取工作", "在这里实际我在介绍中间还缺了一段", "就是从trap再往前那段", "和sys dispatch到sys read这段我在这没做展示", "希望大家下去之后能够把", "相应的整个从用户态到内核态", "然后到函数的实现 一直到返回", "把整个这条路分析明白", "那这样你就知道一个系统调用是如何实现的", "好今天的课就上到这里 下课"]}, {"name": "3.1 BIOS", "block_id": "38bf993f17d54965a460dd3c57c9ceac", "text": ["各位同学 大家好", "我们现在开始来讲 第二讲", "这一讲主要内容是中断 异常和系统调用", "首先我们需要来了解一下", "计算机系统在加电的时候", "从什么地方去读第一条指令", "从磁盘上的什么地方", "去读的我操作系统内容", "在这里头就相当于我们在说", "计算机系统的启动过程", "这张图大家在前面的课程当中都已经见到过了", "说CPU是有计算能力", "它可以执行指令 内存它有存储能力", "我们在程序运行的过程当中", "代码数据是存在这个内存里的", "然后这个I/O设备可以跟外交有交互能力", "我们的键盘输入", "我们的磁盘输入输出 网络的输入输出", "都是作为I/O设备来跟系统打交道的", "但是在今天的课程里头", "我们会更进一步来讨论这样一个问题", "CPU在加电之后", "它执行的第一条指令在哪", "那说我们在CPU在加电", "电源稳定之后", "那这个时候它会对里头的寄存器做一个初始化", "到一个指定状态", "这个时候开始去执行第一条指令", "那这第一指令在哪", "它会在内存里头", "但是我们在前面讲的内存的时候", "说内存是用来存数据的", "里头一关掉电源之后", "再加电的时候里面就没内容了", "这个时候你去执行第一条指令", "这第一条指令从哪来呢", "我们这个时候会", "内存会分成RAM 随机访问存储", "还有一个ROM只读存储", "这两个部分 内存当中有一部分区域里头", "就是ROM它是只读存储", "也就是说加电之后", "里头还会有一些我们原来写入的一些内容", "这些内容我们的系统初始化代码", "就从那里开始执行", "具体说起来我们可以这样来看", "在计算机系统加电的时候", "我们在这里头1MB下面有一段", "这段就是我们的BIOS固件", "这部分它在加电的时候我们蹦到那去执行", "这个时候就有一个约定", "计算机系统CPU在初始化完成之后", "里头的代码段寄存器和当前指针", "这两个寄存器的值是多少", "因为这个值直接决定了我们从内存当中", "读数据时候的位置", "我们在系统CPU完成初始化之后", "它处于实模式下 在实模式下", "它的地址计算把段寄存器左移四位", "然后加上它的当前指令指针", "这两个加在一起作为", "我们当前访问第一条指定位置", "还有一条限制是说", "在加电的时候 它处于实模式", "这个时候地址总线", "并不是像我们现在用到通常系统是32位", "它只有20位的地址可用", "那在这20位地址里头", "我们用的区域就是2的二十次方", "这个时候就只有1M", "所以放的区域就只能放在最底下1M里头一小块", "这块代码它为了从磁盘上读数据", "那这个时候必须提供相应的服务", "如果没有这些服务", "你是没有办法访问到磁盘设备的", "为了做到这件事情", "在BIOS里头 它需要提供这样一些功能", "基本的输入输出", "然后系统的配置信息", "开机自检和系统启动程序", "这几个部分基本输入 输出", "它是完成能够我从磁盘上读数据", "从键盘上读用户的输入", "我可以在显示器上显示相应的输出", "这是它基本的输入 输出的功能", "然后系统的配置", "我们都知道系统在刚开始的时候", "你需要有配置", "我到底是从硬盘启动 从网络启动", "还是说从光盘启动", "那这些启动是在你加电的时候", "由你的BIOS的设置来完成", "依据这些设置系统执行它的启动程序", "我能从硬盘把我的加载程序和操作系统内容", "加载到系统当中来", "具体的过程 我们可以这样来看", "在BIOS里头 它启动起来的时候", "它的初始化完成之后", "它就会从磁盘上读引导散区", "这个引导散区是只有长度512字节", "更长的它没有这个能力在BIOS程序", "它不允许你能读更多内容", "读进来放到指定的位置", "然后跳转到其中的固定位置", "就是这里的7C00", "然后这个时候我们就把控制权", "转到从磁盘上读进来的程序", "在我们这里 这是我们这里的加载程序", "加载程序里头我们又可以做进一步的事情", "这加载程序能干什么呢", "它能将操作系统的代码读到内存里头来", "并且能把控制权交给操作系统", "来继续执行操作系统功能", "这个时候有个问题 说", "你既然能从磁盘上读数据", "那为啥我不是直接从BIOS里头", "直接把操作系统的内核映像读进来呢", "实际上这时候它是有这样一些问题", "首先我们磁盘上是有文件系统的", "文件系统是多种多样的", "我们在机器出厂的时候", "不可以说我直接限制死你", "你只能用某一种文件系统", "为了增加这种灵活性", "那我在BIOS又不可能加上认识", "所有文件系统代码", "那怎么办 我就在里有一个基本约定", "我不需要认识格式", "我也能从里头读到你的第一块", "读了这块之后 这块的加载程序里头", "我们会用加载程序来识别你磁盘上文件系统", "这时候我认识磁盘上文件系统之后", "我就可以读到我内核的镜像", "并且把它加载到内存当中来", "这就是我们这里看到", "用加载程序读到操作系统来", "有了这个过程之后", "我们再把相应的控制权转到", "读进来的操作系统内核代码上", "我们操作系统就可以开始运行的", "我们在BIOS还要提供一些什么样的功能", "基本的输入 输出功能", "比如说我们需要知道", "如何在屏幕上显示基本的信息", "然后我从磁盘上读写扇区", "那我能知道我的内存有多大", "我能从键盘上读用户的输入", "当然在这里BIOS只能提供最简单", "最基本的输入 输出功能", "并且它的使用也受到很大的限制", "比如说在我们的英特尔的CPU上", "它受到一条限制", "就是你只能是在实模式下工作", "那如果说我们的操作系统是工作在保护模式下", "那这些就都不可以用了"]}, {"name": "3.3 中断、异常和系统调用比较", "block_id": "3149398745ea44d4bba4f10e59460759", "text": ["好 接下来我们介绍中断异常和系统调用", "那在这里呢 我们会说中断异常和系统调用", "它到底是用来干什么 解决什么问题", "然后这几个的应用场景", "或者说他们之间有些什么样的区别和联系", "它在用处的时候 它们之间会有一些差异", "但是也有很多会共同的东西", "再一个就是说我们需要来说明", "中断异常和系统调用它的实现机制", "首先我们说在上前边的内容里头已经说过", "操作系统 计算机系统启来了之后", "它会加载操作系统的内核", "然后就把控制权转给操作系统内核了", "在这前面这一段呢 是可以信任的", "但是在操作系统内核之上呢", "实际上我们还有很多的应用程序", "这些应用程序我们没有办法", "对它做到完全的信任", "而这应用程序要使用操作系统内核提供的服务", "那这时候怎么办呢", "实际上我们就需要解决一个操作系统内核", "和外界打交道的问题", "那我们说操作系统内核是可以信赖的", "我可以在里做对计算机系统里的任何内容的控制", "可以执行它的特权指令 这种信任呢", "并不是它跟外界完全的隔离", "它还需要为上边的应用程序提供服务", "也就是说我可以信任的内核", "它必须对外界提供某种访问的接口", "或者打交道的通道 然后再一个呢", "我们除了会是跟应用程序打交道之外", "我们在程序或者计算机系统", "在运行过程当中会有各种各样的问题", "比如说我在外设", "你在跟他做交互的时候你敲键盘", "我并不能确认 你会在什么时间", "准确的一个什么时间点去敲键盘", "你敲了键盘之后 可能我的系统正在干别的事", "这时候我没办法给你做出响应", "那这样的话就会让你感觉", "这个计算机系统很不好用", "所以为了能够让计算机系统", "能够对外界做出适当的反映", "我们需要提出中断机制", "也就是说当外设与系统有交互的时候", "我需要怎么来处理", "还有一种情况呢", "是说我的应用程序在执行过程当中", "比如说我做除法 除了一个零", "那这时候是要出问题呢", "而是否会除零呢", "我只有执行到那一步的时候我才知道", "好 等到这个时候你再知道的话", "那我已经没办法往下做了", "所以总会有一些意外情况", "我在事先写程序的时候我是没办法预料到的", "对于这种意外的情况", "我们怎么来处理 所以在我们这里呢", "通常的做法是说应用程序提供你所需要的功能", "那里头的异常呢 这种意外的情况呢", "把它控制权转给操作系统", "由操作系统来处理它", "这是我们这里说到的应用程序执行当中意外", "有异常来做处理 那还有一种情况呢", "是说我们要解决用户程序如何来解决系统的服务", "就好象说我们提供给银行对外提供服务", "银行为了保证安全 所以它有很多的防护", "这个防护又和对外提供服务这是有矛盾的", "为了方便用户来使用银行的服务", "你必须提供灵活的访问接口", "但是这种灵活的接口 又不能影响到银行的安全", "操作系统内核也是一样的", "我们需要来通过系统调用来提供一个接口", "让应用程序既方便的使用内核提供的服务", "又不至于用户的行为对我内核的安全产生影响", "那也就是说使用服务呢 我们有很多种方式", "那在这里头呢 用内核提供服务", "和我们通常写程序的时候用函数库", "来提供服务有啥区别 那这是我们在这里呢", "你在选择用系统调用 还是用函数库的时候", "需要做出的判断", "好 有了刚才这些问题我们来看", "用下边这个图来看一下", "内核和外界之间打交道的地方", "这是我们内核 然后我们在里呢", "提供了相应的一些内核服务 这些内核服务", "首先会是说跟外界的硬件打交道", "比如说我敲了键盘 那我在敲下一个键的时候", "可能里头会有一个缓冲区", "缓冲区的大小是有限制的", "那存多了 前边的内容就会丢", "好 那我在这里呢 有数据之后", "我就必须告诉操作系统", "那你在这里面及时把我的数据读走", "否则的话", "后边来的数据就会丢了 那这时候呢", "有一条通道 那这就是我们这里的中断", "好中断 通知内核 内核通过驱动", "来与你的设备进行数据的交互", "比如说键盘我是读进去 磁盘的话", "即是会有读有写 然后还有一种情况是说", "应用程序在执行的过程当中", "好 正常执行 那跟内核没关系", "好 执行到某一个位置的时候", "比如说某条指令做除法 除了个零", "或者说一条存储访问指令", "访问到某一个存储单元", "但这个存储单元是不允许你访问的", "就好比说储户你想说银行里有你的钱", "你就想直接去开银行的保险柜", "把你的钱取出来 那这是不行的", "对于这种情况呢", "我们在这里跟操作系统是类似的", "它会提供一个异常机制", "那我们把这些情况都认为", "是你代码执行过程当中的出错", "有些错误呢 实际上是我们事先有预计的", "好 那这时候呢 把空闲交到内核", "内核可能做出的处理呢", "要么说我把你遇到的问题解决掉", "比如说你访问到的某一个存储单元", "原来的存储单元不存在", "好 那我把原来的存储单元的内容放到内存里头", "OK 对于虚拟存储来讲", "这时候你就可以执行了", "而另外一些问题 比如说像是除零之类的", "那你这时候除零 我就没有办法继续下去", "这时候我就会把应用程序", "所占这些资源还给操作系统", "那这是我们异常 那最主要的一类呢", "是正常情况下的使用", "应用程序会使用到函数库", "那这时候跟内核不打交道", "但是内核 应用程序或者函数库", "会间接的通过系统调用接口", "使用到操作系统内核的服务", "比如说我要读写文件", "那我应用程序不能直接访问磁盘设备", "它怎么办呢 发出操作系统", "提供了一个磁盘读写的一个系统调用接口", "好 那应用程序通过调用这个", "读写接口所提供的这个函数", "好 那这时候进到内核里头来", "内核把相应的数据读出来", "还给应用程序 那这个流程就结束了", "所以从这我们可以看到", "操作系统内核和外界打交道基本上就是中断", "异常和系统调用这三个接口", "这是我们在这里说到这三条", "从这三条我们就可以看到", "中断 异常和系统调用他们之间", "到底有什么样的定义", "系统调用是应用程序", "主动向操作系统发出的服务请求", "而异常呢 是非法指令或者其他原因", "导致的指令执行失败之后的处理请求", "那这种处理请求呢 可能会是说我终止程序", "也可能会是说解决你遇到的问题", "然后重新执行这条指令 而中断呢", "是硬件设备对操作系统提出的处理请求", "比如说我缓冲区里有数据", "需要内核把它读走", "或者说我缓冲区里的数据已经全部用完", "需要内核补充新的数据", "那这里我们说到的中断异常和系统调用", "那这三者之间的区别到底怎么来描述呢", "我们可以从这样几条来区别", "第一个是它的源头 那在这呢", "我们标出了系统调用的触发条件", "中断的起头和异常的起头", "这三个分别对应着我们这里的来源不同", "外设 应用程序 实际上这个异常", "在这个图里描述是适宜性的", "我在执行内核代码的时候", "也可能由于代码的执行出现问题", "这时候呢 也可能是内部出现的", "然后第二个呢 是他们的响应方式不一样", "那这三个箭头分别对应着系统 调用", "中断和异常的响应方式 那系统调用呢", "通常情况下我们会是同步的或者异步的", "也就是说应用程序发出系统调用请求", "然后它就在那等着了", "一直到你算完内核服务完成之后给它结果", "那也可能是异步的", "说我们在这里系统调用发出了之后", "你内核在处理时候", "处理的过程当中", "我就切换过去干别的事情过去了", "然后等到其他条件准备之后", "你这才会回来 而中断的它是异步的", "也就是说你上边应用程序", "该怎么做处理怎么做处理", "我不会感知到中断的存在", "那中断只是在应用程序暂停执行", "处理完中断所需要的服务之后", "继续恢复你应用程序的执行", "就跟没有这件事情一样", "而异常是跟你的这个当前指令有关的", "这个是同步的 也就是说必须处理完", "当前这条异常所产生的指令所导致的问题", "我才可以继续下去 那当然他们之间的处理呢", "会都在内核里头来做", "但他们的处理也会有一些区别", "中断会持续的进行", "而系统调用它会是用户提出之后会处理", "等待然后再继续 而异常呢", "是会处理当前所出现的问题", "那具体说起来 中断的处理", "那这个中断实际上我们把它理解为", "系统调用异常和中断这三种情况的总称", "对于硬件上的处理呢", "这主要是在硬件中那个地方", "在CPU做初始化的时候", "它其中就有一项工作 要对中断使能", "也就是说在许可外界打扰CPU的执行之前", "CPU是不会对外界的任何中断请求发出响应的", "那只有我CPU把相应的准备工作做完", "外界来一个请求之后 我知道怎么处理了", "我才会允许这种处理", "如果我不知道怎么处理的话", "你给我一个请求 我也不知道怎么办", "所以在这 在初始化的时候", "它有一个中断使能 使能之后", "我才能够进行中断的处理", "第二个是说这个事件产生了", "产生了之后通常是一个电平的上升沿", "或者说是一个高电平", "那CPU会记录下这件事情", "也就是说我有一个中断标志", "表示出现了一个中断", "然后这时候我需要知道中断", "到底是由什么设备产生的", "需要知道中断源的编号", "这一部分工作是由硬件来做的", "好 硬件做完这一部分工作之后", "剩下的事情就是由内核的软件来做", "那在这里头呢", "也就是说这几个进来都到了这个中断向量表", "中断向量表如果是中断", "那它直接绕到这边的中断服务例程", "驱动程序里来做出响应", "如果是异常 它直接转到异常服务例程来做处理", "如果说是系统调用 由于系统调用的量很大", "那我们在这儿 系统调用之后", "系统调用它之后总共占用一个中断编号", "然后它自己的不同的系统调用的功能呢", "是用系统调用表来表示的", "好 在这呢 根据你系统调用表里的", "功能的选择不同", "我去选择不同的系统调用实现", "那么在这个过程里头呢", "我为了不影响程序的正常执行", "我前边有一个保护现场和恢复现场", "而在这里头呢 要做系统调用的交互", "我还需要知道系统调用产生之前", "我准备的上下文的信息 比如说你到底让我干啥", "那这一部分工作呢 是会和你的编译有关系", "然后中间这一部分到底如何实现", "那这个是由操作系统来做的", "然后如果是中断的话", "那么你在执行的过程当中", "需要清除这个中断标志", "这个也是由你的中断服务例程来完成的", "好 我们说中断可以满足应用程序", "外部设备 或者程序执行异常的服务请求", "那这时候可能会出现一种情况", "我正在处理一个请求的时候", "有来了一个请求这时候我怎么办", "那我们说在操作系统的里头呢", "它是硬件的中断 它是允许被打断的", "也就是说我正在处理一个中断的时候", "可以允许你再出现其他的中断", "如果两个中断源不同 那这时候呢", "我可以通过优先级的高低", "让一个往后推一段", "或者说让一个暂停下来", "那使得我可以同时在做", "交替在做处理 然后在中断服务例程里头", "并不是说我任何一个时刻都可以做任何一个处理", "它会在一定的时间里呢", "禁止中断请求 比如说我电源有问题", "那可能其他的问题就变得不重要了", "这时候我在做电源的处理的时候", "我就会禁止掉其他中断", "然后中断服务请求会一直保持到CPU做出响应", "然后对于异常呢 我也可以被打断", "你比如说我在程序执行当中出现了异常", "这时候正在做异常的处理", "比如说我在这里头虚拟存储里头", "它访问到的存储单元的数据不存在", "我正在从硬盘上倒数据进来", "倒的过程当中 它会用到磁盘I/O", "这时候也会再有磁盘设备的中断", "这时候是允许它可以做嵌套的", "然后对于异常服务的嵌套呢", "这是我们说到的 异常服务和缺页", "这两个在异常服务里头还会再出现异常", "也就是说我执行中断", "执行异常处理例程里头", "有一段存储访问它是缺页的", "那这时候两个异常也是可以嵌套到一起"]}, {"name": "2.4 实验环境搭建", "block_id": "729ca0a71fb746678784a6da0e6c4cb1", "text": ["接下来我们开始第二部分内容的介绍", "就是系统实验环境怎么去搭建问题", "首先我们需要在刚才前面也提到", "在Linux环境中搭建出整个实验环境", "需要装很多软件", "为了避免大家去搭建这个环境", "我们建立一个虚拟机", "只要安装好这个虚拟机", "就可以把这个实验环境搭建起来", "就已经帮你装好这台机器", "第二方面你需要使用一些工具", "我们前面也已经讲到有一系列工具", "需要你去掌握和理解 一些基本操作", "比如说能够对文件进行相应的处理", "第二能够更新一些软件", "上载你的代码 下载你的代码等等", "第三个能够编辑软件", "阅读和编辑软件 这里面列出一系列的工具", "第四个去比较软件 这有些工具是比较软件", "两个源码有不同 看看它到底不同在什么地方", "第五个是关于编译调试开发使用的gcc gdb等等", "写好代码之后你要通过编译器编译", "生成最终可以执行操作系统", "最后你还需要有一个硬件模拟器", "来确保操作系统可在qemu模拟硬件中去运行", "这块实际上我们说在做实验过程中", "需要掌握一些工具 看起来挺多的", "但是没关系 这些工具相对来说比较简单", "有些工具也不需要你去亲自去操作", "你只要能够把它启起来", "做一些简单事情就OK了", "那我们后面会有实验环节", "给大家介绍怎么使用这些工具", "另一方面我们需要去了解X86硬件", "这也是说因为你是针对操作系统是和硬件相关的", "是跑在X86-32机器上面的", "那我们对X86-32要有一定了解", "它的特征 它的特点是什么", "当然这点有很多同学可能会发现", "和我们之前学的知识", "相对来说还有更多的要求", "这个我们后面逐一开始", "大致掌握什么方面呢的 它的运行的模式", "它运行在比如32位模式还是16位模式", "有没有保护机制来保护它", "第二内存怎么访问 有什么样的映射机制等等", "第三个它的寄存器有什么样特点", "通用寄存器 特殊寄存器怎么去使用它", "这些都是需要去了解的", "当然这样的知识相对来说比较少", "我们希望大家以最小的代价", "能够掌X86-32这个硬件", "最后还去了解什么 了解ucore", "它在开发ucore时候用到的一些方法和技巧", "这里面虽然ucore是用C语言开发的", "但是它也用到了很多C++的", "一些面向对象的思路 比如说", "它通过函数指针建立一个数据结构", "来提供统一的接口", "但是它具体实现不一样", "函数指针这是一个", "第二个建立相对通用的数据结构", "来把不同特征的数据结构给连接起来", "我们建立一个相对通用的", "比如说双向链表 来把不同的", "比如说关于某一个数据结构", "是关于页的 关于进程管理的", "还是关于文件系统", "这些不同类型的数据结构", "都可以用这种相对通用链表结构给表示出来", "这两点应该说在ucore用的很频繁很常见", "大家对这个相对来说要熟悉一下", "这里面给大家简单介绍一下", "它怎么搭建这个环境", "我们考虑到很多同学他是在", "windows环境下做平时工作的", "所以我们可以在windows环境下", "装一个VirtualBox虚拟机", "在装完虚拟机之后的 在这个虚拟机里面", "我们已经提供好了一个虚拟的硬盘", "这个硬盘里面已经装好我们所需要所有的工具", "包括实验代码都在这里面", "那你可以在这里面来找到转建工具硬盘镜像", "把这个解压下来之后会看到这么三个文件", "最后通过这个VirtualBox来运行VBox", "这么一个文件就可以把这个", "虚拟硬件环境给搭建起来", "我们可以得到一个ubuntu那么一个运行环境", "这就是我们实验环境", "它的用户名是mooc-os口令是空格", "假设我们装好了这个实验环境", "当然有同学说我自己就平常喜欢Linux", "已经有自己一个Linux环境", "当然你也可以把这个工具都装上上之后", "一样可以开展相应的实验", "不需要说非要用这种虚拟机的环境", "只是说用虚拟机之后", "大家已经建立好实验环境之后", "大家可以更方便一点去完成后期内容", "第二部分你要去使用它", "你要掌握这些工具基本一些使用的方法", "这里面有这么多东西 当然并不是", "每一个都必须要掌握 你是选择你最顺手的", "有的同学可能他喜欢vim", "可能用是比较古老的vim的编辑器", "另一个同学可能用的是Eclipse-CDT", "还有一个同学用的是understand等等", "无所谓 你只要用惯一种工具就OK", "用这个工具来完成相应的功能用它来做编辑", "用它来做编译开发调试等等都行", "一般来说我们需要必须的是qemu", "gcc是必须的 其它的一些", "你基本上掌握就OK了", "这个命令是关于我们称之为命令行的一些操作", "完成对这个相应文件系统中有效的访问", "显示目录 进入目录 删除文件", "得到当前目录的名字 创建目录", "查找文件等等 那么这都是基于所谓", "bash一个命令行的界面来完成的", "有同学如果对Linux有一定了解的话", "就对这些很熟悉了", "我们也会给大家简单的demo", "第二个是apt和git", "apt主要是用来干什么 你要装很多软件包", "这是一个安装软件包管理器", "git是用来开发软件 它有不同版本", "这是版本维护工具 这是最常用的两种工具", "在Linux用的很多 我们这里面", "也为大家做个简单介绍 第三个有源码", "你要分析源代码 你要看源代码", "你需要源码的编辑工具", "最后还要编程 有这么多种Eclipes-CDT", "相对来说是比较简单 有很多同学开发Java程序", "也是用这种集成开发环境", "也类似于我们Visual Studio (Windows中的IDE) 第二个understand", "understand它主要是用来理解程序的", "Eclipes除了理解还可以去调试", "可以Debug运行 understand 主要是理解", "它可以生成跟漂亮的函数调用关系图", "这是它的一个特点", "gedit就是我们通常一个edit编辑器", "但是它也是很方便的一种文本编辑", "如果你的代码不是很大那么用它也就够了", "vim是Unix或者Linux里面相对来说", "存在历史很久远一个编辑器", "有一些开发人员很喜欢它", "如果用熟的话效率也很高", "类似于emacs等等", "还有其它一些工具都是用来", "便于我们去理解 分析 编译 运行", "这是一些编辑工具", "另外也有一些工具是专门用来比较", "不同源代码之间差异性", "diff是一个命令行比较工具", "meld是一个图形界面", "图形界面看起来更加漂亮的一个工具", "它可以比较目录比较单个文件等等", "功能很强大 这个是gcc gdb make", "都是用来编译程序用的 一系列工具", "gcc是编译器 C语言的编译器", "gdb是Debug调试器", "make是软件工程的管理工具", "它可以自动把你更新过的文件编译起来", "形成新的最终的程序", "这些也是我们在开发ucore常用到一些工具", "qemu是硬件模拟器", "当然我们操作系统是要跑在硬件上面的", "当然我们也可以用真实硬件", "但是相对来说用真实硬件", "比较复杂 所以我们用qemu", "qemu可以模拟多种CPU硬件环境", "在这里头我们让它模拟X86-32这个机器", "然后看我们ucore操作系统能否正常", "在X86-32这个机器上面跑起来", "这里面还有信息去查找一下", "来看看具体的一些操作 有个建议是说", "你要把某一工具用的特别熟要花很多时间", "但是完成基本功能 开发ucore就够了", "那我觉得看一下相关的信息就足够了", "没必要为此花大量的时间", "我们只需要它的基本功能"]}, {"name": "3.5 系统调用示例", "block_id": "b1aa2add8eb74a5da934ed8caadaf4a6", "text": ["今天我们通过一个实例", "来介绍系统调用的使用和实现", "在这里我们通常从应用程序的写法上来说这个事", "我们说我想写一个程序", "能够把一个文件的内容复制出来", "写到另一个文件里头改一个名字", "这个地方是我把这件事情展开之后", "我写程序会是什么样的", "首先我会在屏幕上输出一个提示", "要求用户输入", "你要读的那个文件的名字", "然后等待键盘输入", "接下来 我会提示用户", "在屏幕上给出提示说让它输入输出文件的名字", "等待并接受键盘的输入", "等到这两个信息都有了", "然后说我们就试图去打开相应的文件", "首先去打开输入文件", "如果输入文件在你的文件系统当中有", "那这是成立的 如果说文件不存在", "这个时候肯定出错了因为我要复制的源没有了", "接下来说我去看看创建输出文件", "如果说你有这个文件", "这个时候我会把原来东西覆盖掉", "这是不对的 这个时候如果文件存在", "这个时候我出错退出 这几步都做完了之后", "那我就确认我的输入文件是存在的", "输出文件是没有的", "然后开始循环从文件当中读数据写到输出文件", "从输入文件当中读数据", "从输出文件当中把数据写到输出文件中", "那为什么会在这做循环", "有可能这个文件很小我一次就搞完了", "如果这个文很大我可能会循环若干次", "等所有这些都做完", "那么这个时候我关闭输出文件和输入文件", "然后屏幕上提示我整个事情做完", "整个程序正常退出 那这是我想写的程序", "对于这个程序来说", "我会用到哪些系统调用", "我们会有键盘的输入 有屏幕的输出", "有文件的输入和输出", "实际上在操作系统内核里", "它这个实现键盘 屏幕和文件", "都视为是文件系统里的", "只是说键盘和屏幕作为特殊的文件来使用", "那么在这里头涉及到的系统调用是", "open close还有一个应该是create", "然后再有一个write read", "有了这几个系统调用之后", "那么我这件事情在上边", "用我的函数库里内容就可以完成", "具体怎么来做 我们看到要想在应用程序写", "那应用程序会使用到一个库函数read", "这和我们用到其他函数是一样的", "在我们ucore有这样一个头文件", "告诉你他格式什么样子", "然后这里头你需要知道这里的参数是什么意思", "你读写的文件 你读出来的数据放在什么地方", "缓冲区域头指针", "然后这个缓冲区域并不是无限大的", "它的最大长度你不能超过这个长度", "然后我从里头读数据往里放", "那我实际读出来的时候", "有可能比这短", "因为我实际文件里可能没有这么多数据", "如果说我实际数据比这个缓冲区大怎么办", "这个时候最多读出来是缓冲区长度", "因为在多就缓冲区溢出了", "然后读完之后返回值 这个地方有个返回值", "返回值是你的长度 你在使用的时候怎么做", "你打开文件 把这三个参数填上去", "返回来的时候", "返回的结果就是你实际的程度", "这是你在用的时候", "对于我们系统的实现来讲", "在编译程序的时候", "你的应用程序用到相应的库函数", "这个库里头在编译系统调用的内容的时候", "它就会前面准参数", "实际上这段都会往堆栈压栈", "压占完之后最后有函数调用", "而这个函数调用最后都转到我有一个", "你说这不是系统调用 是的", "这是一个函数调用", "这个函数调用所有的系统调用", "它都是通过一个宏展开形成相应的函数", "实际上在这里有一段汇编", "大家注意这段汇编有可能你现在还不能完全看懂", "那你需要值得这个int", "是我们前面说到系统调用的指令", "后面i实际上是你系统调用的中段向量编号", "后面num实际就是系统调用read系统调用编号", "然后后面是相应的参数", "这些填完之后", "实际上最后你在的执行应用程序", "执行到这个地方 到这里来的时候", "它就会转成系统调用进到内核里去", "接下来我们操作系统里是如何实现系统调用read", "首先我们刚才说在用户态一个int进到内核里来之后", "这实际上是一个软中段", "所有这些都会到你最开始一段汇编程序叫alltraps", "在这里会获取到中段所需要的", "相关信息组成的数据结构", "这个时候实际上TF数据结构", "那么在这里头我们注意到其中有一条", "是其中的中段向量", "那么在这里是系统调用对应中段向量", "然后依据这个那么在trap函数里头", "它就会转到我们系统调用这个函数里头", "在这个函数里头它会读其中的EAX", "实际上就是你的系统调用编号", "这个系统调用编号会看到它是等于read", "等于这个实际上相当于这个时候", "我们知道进来是系统调用", "并且这个系统调用调用是哪个功能", "我们还缺什么", "我们还缺它参数", "这些参数就会转到相应的系统调用实现里头", "这个实现里负责去堆占里头SP", "获取相应我们当时填进堆占里头那三个参数", "这个文件 缓冲区 头指针", "然后缓冲区长度 有了这三个之后", "实际上这个时候就相当于", "已经从用户态转到内核态", "如果说我是一个函数调用的话", "这个时候就已经转过来", "我在继续做相应函数实现就可以了", "这个时候我们就看到最后它到sysfile read", "这个函数里头去完成相应的文件读取功能", "这个文件读取就是直接操作底下的驱动程序", "在往下 等到它最后返回的时候", "ok 那这个时候我们到这trapret", "在这里头我们去看这类代码最后会有ireturn", "这个return会把相应的返回值的长度", "读到内容长度返回给用户态", "整个实现就全部完成", "那接下来我们会去看看实际的系统里的代码是什么样子的"]}, {"name": "视频", "block_id": "5a48f3feb4b04f65a415f58d50ff2857", "text": ["接下来我们来讲操作系统的结构", "任何一个软件它都会有自己的结构", "操作系统也不例外", "操作系统在发展的过程当中", "它的结构实际上有了非常大的变化", "我们从历史上发展的过程来看", "操作系统可能采取的结构", "和每种结构它的特征", "最早的时候实际上", "操作系统它是一种简单的结构", "对下控制硬件", "对上提供用户应用程序所需要的服务", "中间的功能实际上实现的很简单", "我们在BIOS里面有一层", "对硬件进行管理的驱动程序", "操作系统内部它把这一层", "做了更进一步的完善", "这种完善形成了系统里面的驱动", "然后有一些常驻的服务系统程序", "然后上面是应用程序", "应用程序有可以使用操作系统提供的", "设备驱动服务", "也可能直接使用", "底下BIOS提供的系统服务", "在这个里面它没有进行模块化的划分", "实现的时候操作系统的代码", "也主要是汇编来写的", "基于这种情况操作系统", "它是从一个平台", "操作系统只能用在这个平台上", "到其它的品平台上不能使用的", "所以这样的话", "每个操作系统都是只针对", "特定硬件平台来写的操作系统", "在这个阶段我们有很多种操作系统", "在PC机上主要是DOS系统", "它只能用在X86的系统上", "第二种结构实际上", "随着Unix系统不断发展完善", "形成的这就是分层结构", "在分层结构当中", "我们会把操作系统功能分成若干层", "最底下一层是硬件", "最上面一层是用户接口", "在中间实际上", "我们按照功能的不断的丰富", "不断的完善把它分成了N层", "每一层只使用下一层提供的服务", "这种分层结构", "使得各个层依赖关系得到一定的限制", "使得我的可靠性能够进一步提高", "这个里面分层结构很大贡献", "在于它把可移植性", "作为操作系统的一个重要的目标", "以前的话我们是说", "对于一个特定的硬件平台", "我要全新对它写一套操作系统", "现在我只需要", "把整个操作系统代码分成两部分", "一部分与硬件平台无关的部分", "这一部分我们用高级语言来实现", "另外一部分是跟特定硬件平台", "密切相关的部分", "这一部分我们仍然", "使用汇编程序来实现", "做了这种划分以后操作系统的移植", "只需要改汇编的部分", "我们在这里说到Unix系统和C语言", "我们前面说Unix系统的时候已经", "见过这两位Thompson和 Ritchie", "他们实际在Unix系统发展过程当中", "他提出来的C语言", "C语言也会由于Unix系统的发展", "而得到广泛的使用", "最后他们得了图灵奖", "这是第二种结构", "我们所使用ucore教学操作系统", "它的结构基本是采用分层的结构", "我们在这里要学的内容", "是划红线的这几个部分", "我们基本涉及到", "从最底层的中断 系统加载", "一直到操作系统内部", "各个核心模块对上提供的服务", "和系统服务里的命令行", "这是分层结构", "分层结构随着层次的增加", "依赖关系这种层次越来越复杂", "复杂的结果是", "操作系统内核里面的东西越来越多", "效率越来越下降", "在这个基础上微内核结构", "因为分层结构的层次多", "所带来的效率低的一种做法", "我们希望实际上是", "把一些操作系统内核提供的服务", "放到用户态是不是这样的话", "能够提高它的效率", "所以在这做了一种尝试微内核", "把尽可能多的内核的功能放到用户态", "在内核里面只保留进程间通信", "和底下对硬件的支持", "然后在这之上", "这个时候会说如果用户态应用程序", "想使用传统内核提供的", "系统服务功能怎么办呢", "这个时候说用户态的应用程序", "要想跟内核进行通讯", "它需要先绕到内核然后再回到用户态", "这样做之后它的安全性和可扩展性", "就会有大幅度提高", "但是它也会有问题", "它的性能就会有大幅度下降", "实际上在这个里面", "我们现在用到的操作系统", "你看它的结构", "它是微内核结构和", "分层结构的一个混合体", "在这种情况下", "我们会注意到有一些系统里面的", "某一部分内容", "在某一个版本里是放到内核里面", "到另一个版本里把它放到用户态去了", "又有可能过了一段时间以后", "它又把它放回来这是微内核结构", "在针对微内核结构", "进一步的改进叫做外核", "它的做法是什么呢", "它的做法是向内核里面", "放更少的东西", "它只是起到资源的保护和隔离的作用", "然后把资源管理的任务", "交给应用态的代码去完成", "这个时候", "原来的操作系统功能怎么办呢", "原来操作系统的功能", "是由用户态的函数库来提供", "这种情况下我们看到的是", "操作系统的硬件资源", "在上面只有一个很薄的", "一层安全绑定", "在这个安全绑定里面", "它控制哪些资源归哪一个系统使用", "而相应的资源管理", "由各自的系统自己来维护", "在这种情况下我们可以在一个系统上", "支起不同的操作系统服务", "某种角度来说", "这好像是一个虚拟机的结构", "我们现在意义上的虚拟机", "它不是一个我们传统说的", "操作系统的一个结构", "实际上这个时候", "它是把我们现在用到的DSM", "早期的时候就是以这种结构出现的", "接下来我们说虚拟机管理系结里面", "计算机的硬件之上我们架了一个VMM", "它负责把真实的硬件", "虚拟成若干个虚拟的硬件", "然后我们操作系统在这上面", "来实现传统操作系统的功能", "这一部分功能虚拟管理器来决定", "我每一个虚拟机到底可以使用", "哪样一些硬件资源", "有了这个管理器以后", "我们传统的操作系统与硬件", "和应用之间的关系", "就会发生一个变化", "这种变化在什么地方呢", "原来的操作系统是直接底下接触硬件", "上面对应用提供服务", "现在变成是", "虚拟机管理器和硬件打交道", "操作系统来和虚拟机管理器打交道", "但是实际上", "它其中有一部分", "还是会和硬件直接打交道", "这个时候的区别在什么地方", "在于管理器负责资源的隔离", "操作系统负责资源的管理", "好 到现在为止", "我们第一讲的内容就讲到结尾了", "我们说操作系统是很有趣的", "它可以很好的控制一台完整的计算机", "如果说你最后做完实验以后", "能够用自己写的操作系统代码", "去控制一台真实的物理机器", "你的感受会是非常好的", "但是要想实现这一点", "你需要付出非常多的努力", "同时操作系统它现在仍然很不完善", "不管你花了多长时间做测试", "用户实际使用的时候它仍然会有错误", "仍然会性能或者功能不满意", "这个时候仍然有很多", "我们需要去改进的地方", "这也是我们学操作系统课", "想要去挑战的地方", "同时它很庞大", "通常情况下我们现在用到ucore", "它有一万行代码左右", "这是你在前序的一些课程里面", "不会学到这么多代码的", "综合利用它你才能够完成操作系统实验", "理解操作系统这些原理", "最后我们想说操作系统尽管很困难", "但是我们前面例子", "我们能够做到依靠你自己的努力", "最后我们是能够实现", "一个小的教学操作系统", "今天的课就上到这里"]}, {"name": "2.5 x86-32硬件介绍", "block_id": "d980d759b2614b7eac9d1e7e1703c191", "text": ["前面我给大家介绍了一下", "我们在完成实验中所要用到一些工具", "简单介绍了一下 接下来我们看看", "对X86-32一个基本理解", "这里面讲解在Lab0里面讲解应该说很简单一个介绍", "随着实验的逐步进展", "我们会对硬件有更深入的介绍", "特别是内存管理 特别是进程调度等方面", "还有中断处理 会有更详细的介绍", "来看看X8632怎么回事", "第一个就是X86 我们说X86是个简称", "其实这里面指的是什么 80386这种机器", "这种机器是因特尔32位的CPU", "早期使用的很广泛", "特别是在上个世纪90年代初", "这个机器是很普遍使用的机器", "它有四种运行模式", "在我们ucore操作系统实验中涉及到两种", "一种实模式 一种是保护模式", "实模式等于它只有16位的寻址空间", "且没有保护机制 但是保护模式就不一样了", "保护模式有32位的寻址空间", "且有很强大保护机制来确保", "操作系统的安全", "以及跑的各个程序之间的安全性", "就是用保护模式来实现", "所以说在这里面我们需要理解", "什么是实模式 什么是保护模式", "实模式其实就是80386机器为了", "兼容早期的8086十六位机器", "做的一种模式 这种模式机器加电之后", "一启动就处于实模式运行状态", "在这个时候它的寻址空间不超过1M", "且无法发挥80386 4G内存管理机制", "那么早期的Microsoft", "微软的dos操作系统就运行实模式环境中", "这也是一个早期很早的OS", "也是微软最早一个OS", "当然它这个完全不能够发挥我们30位机器特点", "所以我们希望我们运行在保护模式", "在需要一个设置Lab1就会碰到", "你怎么从一开始处于实模式切换到保护模式", "一旦有了保护模式", "第一个它的寻址空间发生了变化", "它从16位或者说1M空间变成了32位寻址空间", "有4GB的寻址空间 这是一个", "第二它提供所谓分页和分段机制", "这两种机制能够让不同软件放在不同的特权级", "访问不同空间 且相互之间是隔离的", "这种不同的机制就可以使得", "我们应用程序可以运行在较低的级别", "它限制在运行在一个有限的空间里面", "不会破坏操作系统 不会访问那些特权指令", "那这就是我们保护模式提供一种功能", "我们ucoreos是充分利用了保护模式的特点", "完成了一个OS很重要的内存管理", "还有特权管理的机制", "这里面有一个地址问题", "好象大家听地址很简单", "地址就是类似于我们每一个同学", "家里面都有一个自己地址", "这也是地址 家庭地址", "我们说对于80386机器而", "它对每一个类型单元都有一个编制", "当然这个地址实际上我们访问", "内存空间的一个索引", "既然80386是一个32位的处理器", "所以说它寻址空间是4G空间了", "这是一个 第二个我们说在计算机里面", "它有很多不同寻址方式", "首先我们硬件 我们CPU的物理硬件", "它有一个物理内存", "物理内存是处理器发出一个地址", "寻址一个地址请求 这地址请求发哪呢", "发到总线上用于访问计算机系统中的所有内存", "和外设的最终地址", "我们都知道大家如果拆开机器可以看到内存条", "那么内存条里面的地址就是所谓物理地址", "我们访问某一个物理地址", "是把内存某一个内存单元内容给读出来", "这是物理地址 第二个叫线性地址", "这个是80386机器里面引用的一种地址", "线性地址什么意思呢", "它是说由于我们有了一个所谓的段模式", "让某一个应用程序", "能够有一个相对独立地址空间", "这个应用程序它认为它自己", "是独占了计算机系统地址空间", "这个地址空间我们把它称之为线性地址空间", "当然这个线性地址空间是靠所谓", "我们后面说的段模式和页模式", "集中在一起来保护来实现的", "第三个我们称之为逻辑地址空间", "逻辑地址空间是应用程序直接使用地址空间", "看起来好象是有点混乱", "没关系我们把它简单的", "用我们硬件的表述方式来表述一下", "如果说80386的段机制启动", "页机制没有启动的时候", "逻辑地址通过段机制的映射能转变成线性地址", "然后线性地址就等同于物理地址", "这两个是等价的 那前提是什么呢", "段机制启动了 页机制还没有起动了", "当然我们讲Lab2的时候", "还会对页机制有更深入的讲解", "Lab1会对段机制有更深入讲解", "第二个是如果段机制和页机制都启动", "那么这个时候逻辑地址通过所谓的", "段机制它会映射成线性地址", "线性地质通过页机制映射成物理地址", "从而可以看出来它其实这所谓段机制", "和页机制只是一种映射关系", "把一个地址从A地址映射到B地址", "然后再B地址映射到C地址", "然后ABC地址内容是不一样的", "当然需要有一个映射关系的实现", "那实际上我们的段机和页机制处理的问题", "那我们对这个地址空间有一定了解之后", "我们再看看访问的寄存器就是CPU", "从内存到CPU CPU有一系列寄存器来存储数据", "这个寄存器分为以下几组", "一共有8组 我们通常看的最多是通用寄存器", "跟段相关的所谓段寄存器", "然后和寻址相关有指令指针寄存器就是EIP", "还有所谓标志寄存器就是Eflags", "还有什么呢 就是控制寄存器", "和其它调制寄存器等等", "最后两位一般开发应用程序用不到", "但是我们开发操作系统的时候需要用到", "因为这些特殊的寄存器是用来完成特殊的功能", "比如说我们刚才讲到让它进入保护模式", "让它启动分页 或者启动分段等等", "那都需要涉及一系列的控制寄存器", "系统地址寄存器等等", "这两类应该说专门是用来给", "类似于操作系统这样一些系统软件来使用的", "而前面的寄存器你在了解", "一般应用程序的时候也会用到", "那么我们来看看通用寄存器", "通用寄存器包含什么呢", "EAX EBX等等一直到ESP", "它有不同的功能 EAX主要用于累加 寻址", "ECX是用来记数", "最后ESP是用来堆栈寻址等等", "都是很重要的寄存器在我们应用程序", "和操作系统编程里面大量使用", "但是在ucore操作系统里面", "有一小部分是汇编语言", "你需要了解汇编语言含义", "你就需要知道这些寄存器有什么样功能和特点", "从而可以知道汇编语言到底表示什么意思", "当然我们在Lab1里面还会对汇编语言做深入讲解", "第二个是段寄存器", "段寄存器主要是用来寻址", "比如说我们要访问是代码段", "数据段还是堆栈段等等 那么这是堆栈段", "那么你这个CS的值是代表特定含义", "在实模式和保护模下它的含义是不一样", "这个也需要注意 接下来是指令寄存器", "和相应标志寄存器的介绍", "指令寄存器主要是指EIP", "当然对于16位CPU8086而言", "它是由CS和EIP共同决定地址", "那个EIP是低16位", "实际上就是IP 8086的IP地址", "那么CS和IP合在一起", "能够访问一共1M的内存地址空间", "但是如果是到了保护模式32位的CS", "和EIP就有了新的含义", "它们结合在一起来完成对32位地址空间的寻址", "在这个时候EIP已经表示了什么", "是指令的段内偏移地址", "这所谓的EFLAGS", "这是标志寄存器", "那么标志寄存器很有用", "比如说你做个加法是否溢出", "那么这些所有标志都是记录在EFLAGS里头", "而且还有一些特殊的位", "比如说是否允许中断等等", "这个都是由EFLAGS寄存器里面的", "特定的BIT来表示的 大家需要注意", "但是也需要了解是有一些BIT", "并不能由应用程序来修改", "而只能是用操作系统来修改", "这属于运行在特权态的操作系统", "才有能力去完成标志位的修改", "这是所谓的EFLAGS寄存器"]}]