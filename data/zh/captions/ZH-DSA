[{"name": "05D-2 BinNode接口", "block_id": "c1da5404e60a4413b2334d9e08c5389b", "text": ["这里我们首先对BinNode模版类的", "几个常用的接口做一具体的介绍", "首先是insertAsLC这个接口", "也就是说", "我们要对传入的参数e进行封装", "使之成为一个新的节点", "并且将它作为当前节点的左孩子", "接入所属的这棵树中", "当然作为入口条件 我们可以假设", "当前节点的左孩子现在是空的", "我们可以看到", "这个功能的实现方法是", "首先我们可以通过", "BinNode构造方法", "创建一个新的BinNode节点", "这个节点的data域就是e", "而它的父节点呢", "就是this 也就是当前这个节点", "从这个图来看", "就相当于我们在这里生成了一个", "新的BinNode节点", "同时将它的parent引用指向我们", "当前的这个节点", "当然这还不够", "这只是自下而上一个方向的连接", "为了保证整体的一致性", "我们还需要相应地完成", "自上而下的连接", "也就是令当前这个节点的左孩子引用", "能够正确地指向新创建的这个节点", "我们知道新创建的这个节点", "本身返回的就是一个位置", "一个position", "因此完成这样一种自上而下的", "连接的最简洁的方法", "莫过于直接用这个新生成的链接", "赋予当前节点的lChild引用", "也就是完成一次这个方向的赋值", "好 当然insertAsRC接口", "实现的方式完全对称", "只需相应地将左孩子引用", "替换为右孩子引用", "我们再来看BinNode的size()接口", "也就是返回包括当前节点在内", "所有后代的总数", "可以看到这是一种递归的实现方式", "也就是说 我们总是递归地去", "统计当前节点的左孩子", "其实也就是它对应的", "那个左子树的size()", "以及对称地 当前节点的右孩子", "所对应的那棵子树的规模", "两项合计再加上当前节点自身", "就是以当前节点为根的", "这棵子树的规模", "就运行时间而言", "无论是左孩子接入 还是右孩子接入", "都可以在常数时间内完成", "而统计子树规模的size接口", "必须遍历其中的所有的节点", "所以我们说它需要O(n)线性的时间"]}, {"name": "12a1-1: 分而治之", "block_id": "91c6d7563fdf4c419919bdfd4dd84c81", "text": ["同学们好", "从今天开始我们进入到第12章", "这也是我们这门课程的最后一章", "我们的主题将是排序", "实际上我们对于排序问题并不陌生", "你应该记得在最开始的几章", "我们就分别介绍过起泡排序", "插入排序 选择排序以及归并排序", "而在介绍散列技术时", "我们也曾介绍过桶排序", "计数排序 以及基数排序", "在讨论优先级队列时", "我们也结合堆这种结构", "介绍过堆排序", "以及更为通用的锦标赛排序", "因此在本章中", "我们将进而重点的学习若干种", "高级的排序算法", "并讨论与之相关的几个衍生问题", "在接下来的第一节", "就让我们首先来学习快速排序算法", "快速排序quicksort", "是霍尔爵士在上世纪六十年代", "发明的一种算法", "这也是基于分治策略的又一典型算法", "具体来说对于任何一个待排序序列", "这里也需要将它们分为", "前后两个子序列", "并对这两个规模更小的子序列", "递归的事实排序", "听到这个思路", "你或许会想起归并排序", "是的", "quicksort和mergesort", "都采用了分治策略", "但二者又有很大的区别", "比如对于快速排序来说", "子问题之间的独立性更为鲜明", "比如这里要求前一序列中的任何元素", "在数值上都不得超过后一序列中的", "任意元素", "这是一个非常强的条件", "如果这条件的确满足", "那么在分别递归的", "对前一序列和后一序列进行排序之后", "只要将二者简单的串接起来", "也就自然的得到了整体的有序序列", "从而完成最初的排序任务", "当然与归并排序一样", "只含单个元素的序列", "自身就是有序的", "因此也可以作为平凡的递归基", "由上可见", "按照霍尔爵士的设想", "只要能够完成这种左小右大式的", "子序列划分", "那么剩余的工作", "可以完全的教给递归来完成", "因此对于快速排序来说", "核心的任务与难点", "在于如何完成子任务", "或子序列的划分", "从这点来看", "归并排序恰好相反", "我们知道对于归并排序算法而言", "其计算量以及难点", "都在于如何将子任务的解进行合并", "那么霍尔爵士所设想的这种划分", "具体的又当如何实现呢"]}, {"name": "05D-3 BinTree类", "block_id": "ab6d0a65431b470bbe295a2031b472fa", "text": ["好了", "在完成了对二叉树节点类的定义之后", "我们就可以基于它", "来实现整体的binary tree", "简称BinTree", "这样一种模板类", "代码的主体结构如下", "我们可以看到这里", "通过内部的两个变量", "分别记录当前树中的节点总数", "也就是规模", "以及最最重要的", "作为整棵树的入口", "树根节点的位置", "另外在内部", "我们针对节点高度", "还提供了两个更新的接口", "其中updateHeight这个接口", "是以virtual来修饰的", "也就是说 它是一个虚的方法", "后面我们会看到二叉树", "尤其是二叉搜索树", "是一个庞大的家族", "其中的每一个成员", "对于高度的定义", "当然也相应地包括更新的方法", "都不尽相同", "因此我们通过将它定义为虚方法", "可以便于各种派生类对这个方法", "进行适当的重写", "那么从对外的开放接口而言", "这里包括最基本的size()", "以及empty()、root()之类的", "都可以通过刚才所设定的内部变量", "直接查询并且返回", "而作为完整的一个BinTree模板类", "还需要设置并且实现", "更多的功能接口", "在这里我们暂且把它们忽略掉", "在随后随着内容的不断展开", "我们将对不同的接口", "以及背后的算法及实现", "逐一地详加介绍"]}, {"name": "08B2-7\tBTNode", "block_id": "634e9339b007495bbcf2d6adc5a488d2", "text": ["我们现在来讨论B树的定义与实现", "与BST一样 我们首先将注意力集中于如果实现B树的节点类BTNode", "既然每一个超级节点都包含n个关键码 以及n+1个分支", "不妨分别将它们视作为一个线性序列", "相应的 我们也可以通过此前所学过的线性序列直接来实现它", "比如使用向量", "因此一个超级节点在内部可以实现为两个向量", "其中的一个 用以存放n个关键码", "而另一个呢 则用于存放穿插于其间的n+1个分支引用", "按照这一思路 我们可以给出超级节点类的一种实现方法", "每一个节点拥有一个指向父亲的引用", "此外更主要的 拥有一个向量 用以存放所有的关键码", "还有一个向量用以存放指向它所有后代的各个引用", "这里也给出了两种常用的构造方法", "首先是构造一个空节点", "另外呢 我们也可以生成一个初始规模为1的超级节点", "只包含一个关键码 以及两个孩子", "而具体的实现过程呢 完全是借助此前向量业已实现的操作接口"]}, {"name": "07D2-1 插入：单旋", "block_id": "ebabb7b91ab348759147fec5bd9fd2ae", "text": ["首先来考察插入操作的第一种情景", "我们在某个节点原本已经更高的分支", "插入了一个新的节点", "这个分支的高度继续上升一层", "从而导致它的平衡因子", "从-1变成-2", "突破了AVL树的底线", "请注意 新的节点", "可能插入在这儿", "也可能插入在这儿", "我们在它们之间引入一条虚线", "表示二者只能取其中之一", "而且我们假设g是所有因此", "而发生失衡的祖先中", "最深的那个", "那么从g出发", "沿着这个新增长的分支", "我们可以找到它的孩子节点", "以及孙子节点", "我们将它们分别命名为v p和g", "分别暗示着是一个节点", "以及它的父亲parent", "以及祖父grandparent", "根据这样的命名方式 我们也不难理解", "尽管一个节点的插入", "有可能会导致多个祖先的失衡", "其中最低的那个", "也不会低于它的祖父辈", "那么既然此处已经发生了失衡", "我们又当如何令它重新恢复平衡呢？", "实际上 我们能做的无非是上一节", "所介绍的等价变换", "也就是zig或者是zag旋转", "在此处 我们只需要做一次旋转", "也就是所谓的单旋", "我们来通过下面这个动画", "了解整个调整的过程", "从我们刚才失衡的局部出发", "接下来我们要围绕着", "失衡的节点g", "做一次逆时针的zag旋转", "这样的一个旋转", "可以由接下来的几步组合完成", "首先引入一个临时的引用", "指向节点p", "接下来 我们要令p的左子树T1", "成为g的右子树", "为此我们只需这样调整", "好", "再接下来 我们要令g", "成为p的左孩子", "因此需要做这样的调整", "再接下来 我们要将局部子树的根", "由g替换为p 也就是说", "我们要做这样的调整", "好 此时的临时引用", "也完成了历史使命", "它可以退出了", "而旋转操作", "也同时宣告完成", "至此重平衡化已经完成", "为了更清楚地看到平衡化之后的效果", "我们不妨对这个图稍事整理", "不难验证 局部的这棵子树", "的确已经恢复了平衡", "然而好消息还不止一次", "实际上 如果在此前g以上", "还有其它的祖先", "同时发生失衡", "那么在这个局部重新恢复平衡之后", "也会同时一揽子地重新获得平衡", "你能看出这背后的原因吗？", "在此你不妨暂停片刻", "就这个问题做一思考", "好的 我想你已经找到答案了", "没错 在这里除了平衡因子以外", "局部子树还有一个重要的指标", "就是它的高度", "那么 它的高度是在哪呢？", "请留意这里我们所设置的三条基准线", "不难发现 在插入新节点之前", "原先这棵子树的高度", "应该是以中间这条水平线为基准", "然而对照重新平衡之后的", "这棵树我们会发现", "它的高度又重新地回到了", "这样一条基准线上", "这棵局部子树的高度能够复原", "又意味着什么呢？", "我们说这意义非常重大", "这意味着它的所有祖先", "在计算平衡因子时 所得的结果", "也将与插入新节点之前 完全一样", "换而言之", "在局部子树高度复原之后", "所有祖先也必然会", "统一地恢复平衡", "而全树呢 也将因此恢复平衡", "请注意 对于这种情况", "我们无非是做了一次zag旋转", "这种旋转只涉及到局部的常数个节点", "因此它所对应的时间消耗", "应该是O(1)的", "这个结果也再好不过了", "当然这种情况只是所有情况中的一种", "其特点是我们刚才所定义的gpv", "这连续三代的节点", "在方向上是朝向一致的", "比如这里它们同时向右", "所以我们也相应地称之为zag-zag", "不难理解 对于对称的情况", "也就是它们一致向左的情况", "同样可以参照这种方法予以处理", "那种情况我们也称作zig-zig", "那么如果它们的朝向并不一致", "而是呈所谓的之字形形式呢？"]}, {"name": "08B1-6\t1B = 1KB", "block_id": "7bf7926be3e44d7086f5824ecdbeafb9", "text": ["关于存储器特性的第二个事实是个好消息", "这个事实指出 如果我们希望从磁盘之类的外存中去读取一个字节", "其时间成本与读入一千个字节几乎是一样的", "我们刚才的例子 依然可以来说明这样的一个特性", "也就是说 如果我们的确需要乘火车去广州采购粉笔", "那么采购一支与采购一千支甚至一万支 其时间成本几乎是一样的", "是的 典型的存储系统的确大多是采用批量式的方式来支持读或者写操作的", "具体来说 无论我们是需要从内存向外存输出数据", "还是需要从外存向内存读入数据", "涉及的数据都是以页面为单位进行核算和组织的", "比如在C语言标准的输入输出库中 你应该能发现这样一段代码", "其中setvbuf接口就允许你来设置页面缓冲区的大小", "以及缓冲的工作模式等等", "因此在涉及频繁而大量数据访问的算法中", "我们就需要充分利用这样一个特性", "也就是说我们要逐渐习惯批量式的访问", "要么就一次性的读写若干个KB 要么就一个字节也不访问", "这就犹如我们要么就集中的去一次广州 采购一大批粉笔", "要么就一支粉笔也不采购", "就边际的时间成本来说 这样的一种组织和访问方式", "才能够达到尽可能的优化", "那么我们的主角B树 在其间又能起到一个什么样的作用呢"]}, {"name": "02D4-2\t 版本B", "block_id": "9d48905dbb244e4b93cea1c5b851e631", "text": ["我们来看这个算法的具体实现", "可以看到，整个算法的流程", "与此前的版本A大同小异", "但是这个小异实际上是很本质的", "我们来看有哪几点", "首先我们的终止条件不再是lo和hi相等", "也就是说，区间的长度未必要缩到零", "而是缩短到1的时候就可以退出算法", "并且通过最终的一句", "比对，来确认到底是成功在lo这个位置", "还是失败", "一般的情况下", "同样是取lo和hi的中点mi", "这里不同的在于，只一次判断", "正向我们此前建议的那样", "这个问题实际上是问e", "是不是在middle point的左侧呢？", "如果是，那我们就移动右侧的界桩", "如果否，那我们就移动左侧的界桩", "从而达到向左或者向右深入的目的", "需要注意的是", "如果是向左，实际上等效于这个区间", "是以mi作为右边的边界哨兵", "具体来说，就是这个", "反过来，如果是向右", "和前面的版本A很不一样", "大家如果还记得起来的话", "咱们版本A这个位置实际上是mi加1", "可是这里头没有加1，换而言之", "它确实将mi这个点也涵盖进去了", "所以这两个区间中间是无缝的", "没有当前的这个元素", "好", "我们说这个算法是封闭的，可以运转", "运转的非常好", "而且可以完全实现此前一样的功能", "与此前的版本A", "如果我们要做一个对比的话", "它在最好情况下", "反而有所倒退", "原因是在于，在这里", "即使是成功的情况", "它也一直要推迟到最终", "只有在经过最终的这次比对之后", "才会确定是否成功", "而此前的版本A呢", "它的最好情况是非常好的", "最最好的情况莫过于", "在你第一次试图做减而治之的时候", "所采用的那个切分点", "我们就成功命中", "只需要O(1)的时间", "而我们这里头，无论如何都一直要切分到最后", "整个长度为N的这么样一个区间", "迭代次数应该是logn来决定的", "所以最好的情况，新的版本反而更坏", "但是反过来最坏的情况，又会更好", "因为我们这里最坏的情况不会出现那种", "每一次都是向右", "也就是说，每次都要花费两次比较的情况", "所以最坏的情况会得到抑制", "所以从总体而言", "此前的那个版本", "如果说它在性能上，好坏情况相差非常大的话", "那么新的这个版本A", "在整体性能上，它就会趋于更加的稳定", "也就是说差异化不是那么大", "当然这还不是它的最大的优势所在"]}, {"name": "02D3-4\t 最优性", "block_id": "4f833f3063b44414abd69706db209e31", "text": ["其实我们也已经能够发现", "无论是binary search", "还是fibonaccian search", "它的模式其实都是大同小异的", "概括而言，它们都属于一类算法的模式", "具体来讲，这种模式表现为，在每一次", "试图减而治之的时候", "我们所选取的那个切分点", "也就是轴点的不同", "一般而言", "对于一个长度为N的有序向量", "我们采取的策略，实际上是", "决定于某一个在0与1之间的常数λ", "也就是说，一旦这样的一个λ确定以后", "每次我们都是以λn作为我们的轴点", "比如说，对于binary search而言", "这个λ取的其实就是0.5", "而对于fibonaccian search而言", "取的数恰好是小写的φ", "也就是这个很神秘的黄金分割比例", "可以说，每一个λ其实都对应着一个算法", "那么λ取什么样的一个数值的时候", "才能使得这个算法的性能达到整体的最优呢？", "在这里而言，其实也就是平均查找长度", "达到最小", "所谓的最优，其实就是最小", "如果我们这里的查找长度", "从渐近地意义上讲", "依然可以度量为一个logn", "那么实际上，这里所考量的更重要的是", "它对应的那个常系数", "这个系数是取决于λ选取的", "所以我们不妨把它", "记作是一个函数 α(λ)", "所以我们的问题，归结一下就是", "在[0,1]之间取一个什么样的λ的时候", "能够使得α(λ)达到最小", "我们可以得到这样一个递推式", "我们来理解一下", "这个递推式的左右", "实际上算的都是同一个东西", "所以它可以用等号连起来", "是什么呢？", "其实就是对于最初的这个向量而言", "平均查找长度是多少", "它的左侧是一个简便的记法", "其实就是我们刚才所定义的那个", "以logn为渐近复杂度", "然后配上一个系数", "而右侧呢", "分为左右的两部分", "是一个总和", "哪两部分呢？", "其实分别的对应的就是", "我们向左侧深入", "以及向右侧深入的情况", "不同的在于，我们要用它们的概率", "来做一个加权平均", "它们的概率，如果假设所有的元素", "出现的概率都是一样的话", "那么每一个区段所进入的概率", "其实就等于它的区段的长度", "具体来说一个是λ", "一个是λ-1（注：应该是1-λ）", "好，递推下去", "对于左侧的这个长度为λn的这个序列而言", "它所对应的平均查找长度，当然是这个了", "对应右边那个长度为1-λ", "再乘以n的这个序列而言", "它的平均查找长度，当然也就是这个了", "那么不要忘了", "在我们这里", "在目前的这种实现机制下", "对于原来这个序列", "如果要做切分", "那么如果某一个方向", "可以做到一次比较就够了的话", "那么另一个方向必然需要两次", "当然可能对称过来", "所以这里我们不要忘了", "还要把这里的成本", "就是进入左侧的这个成本1加上", "再把进入右侧的这个成本2再加上", "经过整体的这样一个解释之后", "我们就应该说", "这个递推式的确是成立的", "接下来的呢", "接下来的事情就要相对简单一些了", "因为它只需要运用", "高等数学的一些基础的知识", "比如一种方法是", "我们可以对这个递推式进行整理", "得到这么样一个等式", "接下来", "只要运用求极值的一些常规方法", "不难证明，非常巧", "恰好这个λ，在选作为黄金分割比", "也就是小写的φ的时候", "这个α(λ)达到最小", "而且这个最小值", "确切地讲，就是1.44左右", "相对于我们上一节所介绍的二分查找", "1.50这样一个常系数", "又有了一定的改进", "而且从我们这一页的分析可以看出", "这种改进已经达到了极限", "如果我们不再改变", "这个算法的总体模式和框架的话"]}, {"name": "09D1-3 开放定址", "block_id": "a0e4e282a3ab442aa7c0142c597fc8d2", "text": ["反观独立链法 其采用的是所谓封闭定址策略", "closed addressing", "也就是说 对于散列表中的任何一个单元", "在其所对应的列表中", "能够存放而且只能够存放那些", "与这个桶单元的地址 比如K相冲突的词条", "也就是说 每个词条应该属于哪个桶所对应的列表", "都是在事先已经注定的", "不难理解 只要采用这种策略", "就很难保证每组冲突的词条在空间上能够彼此毗邻", "因此或许我们应该放弃这种策略 并反其道而行之", "也就是采用所谓的开放定址策略 open addressing", "这种策略的特点是", "散列表所占用的空间在物理上始终是地址连续的一块", "相应的所有的冲突都在这块连续的空间中 加以排解", "而无需向独立链法那样 申请额外的空间", "没错 所有的散列以及冲突排解", "都在这样一块封闭的空间内完成", "因此相应的 这种策略也可以称作为闭散列closed hashing", "既然是闭散列 那么每一个桶单元", "都应该面向所有可能的词条开放", "也就是说 在特定的情况下", "每一个词条都有可能存放在任何一个桶中", "当然 对于每一个特定的词条", "具体存放在哪个桶中 是有不同的优先级的", "其中优先级最高的自然是它本来就应该归属的那个桶", "从这个桶开始 所有的桶都按照某种优先级关系", "排成一个序列", "而在查找对应的词条时", "我们也总是从这个序列的起点出发", "顺次去尝试每一个桶单元", "每个词条所对应的这样一个序列 也称作试探序列", "试探链 或者查找链", "当然 沿查找链的查找 同样有两种结果", "或者在某一个特定的桶中", "找到目标元素 也就是所谓的成功", "或者一旦抵达第一个空桶 即可报告失败", "那么具体的 应该如何来约定查找链呢"]}, {"name": "02F-6 \t归并排序：性能分析", "block_id": "a7ccfedca04a4963b15143274eb9c043", "text": ["这个二路归并算法的复杂度", "主要应该消耗于其中的那个for循环", "为了更好的进行分析", "我们不妨把这个循环在此默写一遍", "整体的是一个for循环", "它的初始化 我们暂时可以忽略掉", "最重要的是 这里通过或", "连接起来的一个条件判断", "总共有两部分组成", "第一部分是说左侧", "那个子向量的长度控制变量j没有越界", "对称地 后面那个是说", "右边那个子向量的控制变量k没有越界", "它们俩之间只要有一个没有越界", "这个循环就会执行下去", "那么这个循环会怎么执行呢？", "内部无非是两个并列的if语句", "它们的逻辑判断 我们刚才已经看到了", "相对比较复杂", "但是好在我们有很简明的语义解释", "也就是说 无论是相对于实在的元素", "还是相对于虚拟的哨兵", "只要B当前的那个元素更小", "我们就将它取出来", "并且转移到A中去", "对称地 如果C当前的元素可以认为是更小", "那么我们也把它取出", "同样地转移到A中去", "所以我们说 整体这个算法的流程无非如此", "那我们可以注意到", "这里棘手的地方在于", "同时有两个控制变量j和k", "我们不妨先来分析一下", "我们看到 在初始的情况下", "j和k都是初始化为零", "那么最终的条件呢？", "在这个算法退出的时候呢？", "这两个条件都需要违反", "也就是 j要一直增加 直到抵达lb", "k也一直要增加 抵达到lc", "所以我们知道 在退出的时候", "必然有j和k分别取值就是lb和lc", "换而言之 在这个时候", "它们的总和是lb加上lc", "也就是两个子序列的长度之和", "好 我们这里注意到了j+k", "没错", "这个东西就是我们打开下面大门的钥匙", "这样一个循环 虽然我还不确切地知道", "它需要执行多少次", "但是我可以知道它的一个上限", "因为我们可以注意到", "每经过一次迭代", "两个if语句中 至少有一句会执行", "当然有可能会执行两句", "但是至少会有一句执行", "每执行第一句 j就必然会自加", "每执行第二句 k也会自加", "所以我们得出一个结论", "每经过一次迭代", "j和k之间至少有一个会增加", "或者笼统地来说", "我们刚才所说的那个观察量j+k", "也至少会增加一个单位", "那这说明什么呢？", "我们刚刚看到过", "j+k在最初的时候是0", "而最终的时候 无非就是n", "作为一个整数", "j+k这个观察量", "从0开始 随着迭代的进行", "不断地递增而且是严格地递增", "每次至少增加一个单位", "所以我们自然可以得出结论", "这种迭代至多只会经过n次", "换而言之 这个二路归并的merge算法", "在最坏的情况下", "也只需要线性次的时间", "那么相应地来说 基于这样的一个二路归并", "所实现的归并排序", "它的算法复杂度是多少呢？", "那么我们根据此前所写的那个递推式", "也就是 如果要去用", "归并排序求解一个n个元素的排序问题的话", "相当于去递归地", "对两个规模分别为", "二分之n的子序列进行排序", "然后至关重要的是在这儿", "按照刚才的推断", "只需要最多O(n)的时间", "就可以将它们归并起来", "这样一个解将得到", "在大O意义下的n*logn的一个算法", "我们要注意 这是在最坏情况下", "也能够做到的一个结果", "我们在此再次提醒大家注意", "二路归并这个算法", "其实是可以处理更一般的情况的", "比如说 待归并的两个子序列", "不仅不必像刚才所说的那样", "必须互相紧邻的排列", "而且它们在长度上也是不必相等的", "它们可能有差别", "甚至差别非常悬殊", "但是这个算法总体只消耗它们累计长度", "也就是线性这么多时间的结论", "是不受影响的", "依然成立", "这个算法也可以很方便地、很自然地", "推广到另一大类的序列", "也就是与向量对称的列表", "我们在下一章中呢 将会介绍这种数据结构"]}, {"name": "04C4-6D \t实例D", "block_id": "20e6a69a37d14f44adc1c3b5723de3a1", "text": ["这个时候如果你手头有", "那张优先级表的话", "我建议你去看一下", "右括号所对应的那一列", "你会发现大多数的表项都是大于号", "这意味着什么呢？", "这意味着一旦我们扫描", "并且处理到一个右括号", "介于这个右括号以及", "与它配对的左括号之间的", "那个子表达式中，所此前缓存起来的", "无论多少个运算符，都等到了", "可以依次计算的时机", "这与我们通常进行", "中缀表达式计算的常识", "是吻合的", "因此接下来", "我们此前所缓存的阶乘运算", "以及减法运算都会相继执行", "也就是说，我们接下来", "要执行0的阶乘，得到1", "然后接下来，再执行减法", "也就是89减去1，得到88", "至此，正如我们刚才所指出的", "介于这对括号之间的", "那个子表达式已经计算完毕", "它所对应的值", "已经存放在操作数栈的顶端", "因此这个右括号，与这个左括号", "其实也就是我们当下的", "这个栈顶操作符", "同样完成了它们的历史使命", "现在是它们该退出历史舞台的时候了", "而在它们退出历史舞台之后的情景", "应该自然是这样，它们消失了", "而我们的关注点呢，将转向下一个字符", "再一次地，按照我们刚才所总结的规律", "一旦出现右括号", "它所对应的那个比较项", "通常都是大于号", "也就是意味着在此前缓存起来的计算", "也就是这个减号等到了", "可以执行的时机", "因此接下来，我们将执行", "7减去88，应该是-81", "此后，我们的当前右括号运算符", "与配对的左括号相逢了", "这意味着它们", "联手退出历史舞台的时候也到了", "此后的场景呢，自然应该是这样", "同样，我们会继续去关注下一个字符", "仍然是一个右括号运算符", "同样地，它的出现意味着", "此前我们所缓存起来的这个减法运算", "已经可以执行了", "是6减去-81，得到正87", "紧接下来，这个右括号和这个左括号", "应该联手退出", "得到这样一个情况，依然是右括号", "这就意味着，我们此前所缓存的", "这个减法运算也到了可以执行的时机", "因此接下来，我们要执行", "120减去87，得到33", "好了", "最后这对括号", "退出历史舞台的时候也到了", "它们会黯然地离去", "至此，我们终于抵达了这个表达式的末尾", "也就是我们原来所说的那个\\0", "我们依然需要去查询\\0", "与当前的栈顶乘号之间的优先级关系", "我们会发现是个大于号", "那么这意味着什么呢?", "意味着乘号可以执行了", "同样地，如果你手头有那张优先级表", "我依然鼓励你去察看一下", "\\0所对应的那一列", "你会发现这样一个大于号，并非个案", "实际上，凡是遇到当前运算符为\\0", "它都会促成此前所缓存下来的", "任何一个常规运算符的执行", "如果你还记得我们刚刚总结的规律", "就会发现\\0和我们的右括号", "是完全效果等同的", "更确切地讲", "我们这个结尾处的\\0", "以及最开始铺垫", "在运算符栈中的那个\\0", "联合起来的功效", "就相当于在最前端增加一个左括号", "同时最末端增加一个右括号", "只不过它们都是\\0", "从功能语义上讲", "它们联手等效于一对括号", "所以作为右括号", "它会促成当前的栈顶运算执行", "也就是61乘以33,得到2013", "而再接下来的最后一步呢?", "末尾处的\\0和起始处", "此前铺垫的那个\\0", "也终于经过长途的奔波之后，相逢了", "既然它们分别等效于左括号与右括号", "它们的历史使命也至此完成", "携手退出历史舞台", "从而最终运算符栈变空", "那我们讲过", "当最末尾的字符也扫描处理完之后", "如果栈为空", "而且你的语法是正确的话", "你所需要计算的解", "就应该是在运算数栈中", "那个唯一的元素", "2013"]}, {"name": "08A3-7\t综合评价", "block_id": "b3d90812864c4798bb43b3464f0626a4", "text": ["最后我们来对伸展树的性能和特点", "做一个综合的回顾", "首先需要再次强调的是", "相对于此前的AVL树", "伸展树显得更为灵活和变通", "它不需要再记录节点的高度", "或者平衡因子之类的附加信息", "因此从编程实现的角度来看会更为简便易行", "而另一方面 就时间复杂度而言", "依然可以确保是在logn的范围以内", "这也与此前的AVL树相当", "请注意这样一个复杂度界限", "并没有任何更多的先决条件", "包括我们最初所介绍的局部性的条件", "事实上 当局部性存在的时候", "伸展树的性能还会更高", "不妨考虑一种极端的情况", "也就是局部性非常强的时候", "在这个时候 即便数据集的规模能够达到n", "在相当长的一段时间之内", "我们所访问的数据", "可能只是其中很少的一部分", "比如只有远远小于n的k个", "而我们的操作次数呢 却要远远的大于n", "比如你用电脑的过程往往就是这样", "尽管你的硬盘上所存放的数据文件等等", "是数以万计甚至几百万计", "但是在很短的时间内", "你所经常使用的数据", "往往只是其中非常低的一个百分比", "比如当你在我们的online judge上", "苦苦做题的几天之内", "你所访问的数据很可能只是", "你的硬盘中屈指可数的那么几个文件", "是不是", "也就是说 这类情况的特点 可以概括为", "尽管我们所存放的数据非常的多", "但是在相当长的时间内", "我们所访问的只是其中很小的一部分", "如果我们把这个数据集组织为一棵BST", "并且采用伸展树的策略进行自我调整", "那么可想而知的是", "经过一段时间的使用之后", "我们最常用的那部分数据", "都会逐步的集中到树根的附近", "以至于其他部分的数据几乎可以忽略掉", "他们存在与否 已经不甚重要了", "也就是说 我们完全可以认为数据集", "无非就是一个规模为k而不是n的一棵BBST", "这样一棵规模为k的BBST 其访问的效率", "自然就应该接近于每次是logk而不是logn", "因此对于任何一个足够长的操作序列而言", "其中每一次操作的均摊时间复杂度", "也就大致是logk", "当然在达到这种状态之前", "我们大致要经过常规的n次操作", "每次的操作时间复杂度是logn", "你使用电脑的经历", "也应该能够验证这样一个规律", "难道不是吗", "你的每一台新安装的电脑", "不都是在经过一段时间的应用之后", "就会变得非常顺手", "使得在接下来的足够长的时间之内", "都能够飞速的运转", "是的 这是因为通常的操作系统", "都充分利用了数据访问的局部性", "从而使得缓存的命中率能够达到尽可能的高", "当然 尽管具有以上的诸多优点", "我们不得不说 伸展树也并非十全十美", "比如尽管它的分摊效率很好", "它依然不能够保证杜绝单次最坏情况的出现", "实际上 在此前我们已经看到", "伸展树的形状在任何时刻", "通常都是不平衡 甚至是极其不平衡", "因此我们完全可能在某一个不幸的时刻", "需要访问一个足够深甚至是最深的节点", "尽管伸展树在此后会随即", "将这条路径缩短至接近一半", "但是在此前的这次查找过程中", "你不得不仍需付出沉重的代价", "因此在对单次操作效率十分敏感的场合", "伸展树依然是不能适用而胜任的", "这类例子虽然不多 但也的确存在", "比如在手术室里 控制手术器械的程序", "断乎不能采用伸展树这一类的数据结构", "当然也正如我们所看到的", "伸展树的复杂度分析是一个非常复杂的课题", "在这里我们只是以形象的方式", "通过举例进行了一定的验证", "而严格的证明却要更加复杂", "关于这一结论的严密证明", "请参照我们的习题[8-2]"]}, {"name": "11c3-2: \t避免回溯", "block_id": "1f3a839f707143d69a16f1672dd2c7e1", "text": ["当然 你应该记得", "在这种情况下 KMP并不会去逐一尝试所有的t", "事实上 在next表中 针对于每一项 只会给出唯一的一种选择", "那么 KMP所选取的 究竟是其中的哪一个呢", "为此 我们需要考察这里的位移量", "是的 如果是用t来取代原来的j", "那么对应的位移量就应该是j和t之差", "在这里 j是相对固定的", "因此 t越小 对应的位移就越大", "反之 t越大 相应的位移也就越小", "而位移量更小 也就意味着某种意义上的更加安全", "什么意义呢", "避免回溯", "是的", "KMP在所有候选者中最终所选取的", "的确就是这个集合中最大的那个t", "如此可以保证对应的位移量是安全的", "实际上 这种原则也暗藏了另一个不变性", "也就是说 由KMP所舍弃的那些对齐位置", "的确都是不值得对齐的"]}, {"name": "01c-6: \t2−Subset", "block_id": "4e9bbc3fa59e4c788758c962c0bfdb43", "text": ["考察这样的一个问题", "如果我们给定了n个正的整数", "而且他们的总和正好是两倍的m", "也就是说 是一个偶数", "那么 作为一个整体", "是否它存在一个其中的子集T", "使得T中的元素的总和", "是整体总和的一半？", "那么其实这个言下之意就是说", "不仅T中的元素总和是m", "其实T的补集中的所有的元素的总和", "也应该是等于m", "或者简而言之 就是说", "原来那n个整数 能否被恰好分成两部分", "元素的个数可能未必相同", "但是他们的总和都是各自为m", "我们来看一下这个问题具体的一个模型和实例", "我们来考察一下美国的大选", "我们知道美国的大选 采用的是所谓的", "选举人团这么样一个制度", "也就是说 整个国家 按照行政区域的州", "包括特区在内 划分成若干个区", "具体来说 是51个区", "每一个地区都有自己", "由历史和包括人口等因素决定的", "一个具体的选举人票数", "各自有各自的分布", "而在选举的过程中 每一州", "都是要做各自独立的统计", "如果某一选举人 在某一个州获胜", "理论上讲只多出一票", "也可以称他在对应的这个州获胜", "而一旦他在某一个州获胜", "这个州的所有的选举人票", "比如说 对于马里兰来说 就是10票", "对于加州来说 那就是55票", "都会归入 这个候选人的名下", "而最终确定谁能够当选", "是由每一个候选人", "所获胜的那些州的选举人票的总和", "来相比较以后决定的", "查看一下近年来选举的数据", "我们可以发现 美国总共51个区", "累计起来有538张票", "换而言之 如果是有两个候选人的话", "那么其中 只要有一个人", "能够获得至少270张选举人票", "那他就可以当选", "这个不难理解", "我们作为细节 要考虑的就是", "会不会出现这么样一种特殊的情况呢？", "也就是 如果这两位候选人恰好各得269票", "那我们又该如何呢？", "在回答这个问题之前", "我们也许应该首先回答一个问题", "就是 如果给定你这样一张表", "由若干个州各自的选举人票", "所构成的这样一张表", "我们能否确定 肯定", "有可能或者根本不可能出现", "刚才我们说的这种", "各自得恰好一半选票的情况呢？", "这个问题 如果我们对照一下的话", "其实就是我们刚才所说的", "这个问题的一个特例", "具体来说 在这里n", "其实就是刚才的 50+1=51", "而所有整数的数值", "分别就是这51个区各自的选举人票数", "我们看到 他们的总和538", "确实是一个偶数", "而我们所担心的那个问题", "其实就是这个问题所询问的", "是否有一个办法 能把所有的州", "按照选举人分成两部分", "使得它们各自所累积起来的选举人票", "恰好是各自一半", "在对这个问题有了这么样", "一个具体模型的理解之后", "我相信 大家很容易都会", "马上得出一个直觉的算法", "也就是说 我们逐一去枚举", "S的每一个子集 并统计其中元素的总和", "也就是说 我们针对其中的某一个候选人", "去枚举出 他所有可能获胜的那些州的组合", "并且统计出各自", "每种情况下他所得的票的总和", "如果一旦其中有发现得一半的", "比如说269 在这种情况下", "那么 我们就报告确实存在", "这样的一种出现歧义的风险", "否则的话 如果到最后也没有发现", "我们就可以安然地说", "根本不会出现这种情况", "所以这种算法的正确性是毋庸置疑的", "然而他的计算成本是多少呢？", "我们不得不表示担心", "因为理由是 我们注意到", "我们所枚举的这些子集", "相对于原来那个集合来说", "就是不折不扣的所谓的幂集", "而幂集的规模 就是原来那个集合的规模", "相对而言的以2为底的指数", "所以 其中这些要枚举", "考察的这些实例的总数", "其实就是一个指数规模的", "而我们这个算法 刚才说过", "必须要去逐一枚举它", "换而言之 即使是从迭代的角度来看", "最简单的情况 它也需要迭代这么多轮", "换而言之 在最坏的情况下", "它需要多达2的n次方这么多时间", "这是一个我们刚才说需要回避的", "所谓的指数复杂度的算法", "有没有更好的办法呢？", "有没有超过我们这种直觉更好的办法呢？", "应该有 对吧？", "但是结论是 没有", "因为我们这里有一个定理", "这样一个两个子集的划分问题", "是一个典型的npc问题", "NP-complete 什么意思呢？", "我们在一些算法的理论课程里头", "应该也许有介绍 在这里", "我也简单把这个意思说一下", "就目前所采用的计算模型而言", "是不存在 可以在多项式时间内", "求解这个问题的算法", "除非 你对这个问题施加一些条件", "比如说 最多的总数n不能超过多少", "或者说 所有的那些元素的数值", "也就是那个票数的分布", "必须符合什么规律等等等等", "如果不做这些假设的话", "这个问题是不存在多项式的算法", "所以 就这个意义而言", "上述我们那种直觉的算法", "居然已经是最优的了", "然而很可惜 也很可悲的是", "它只能是一个指数的算法", "所以 从这里我们也可以看得出来", "这种类似的问题 实际上是很多的", "当然 它不是我们这个课讨论的重点", "我们可以把所有的刻度汇总到一起", "这样的话 我们就对整个这把直尺", "以及上面的刻度 有了一个总体的 一个感觉", "当然需要指出的是", "这里同样 我们需要放眼长远", "如果我们只是在一个相对比较小的尺度", "比如像这个复杂度是从零到30的这个尺度", "我们只观察局部的话", "我们甚至可能会往往得出一个错误的结论", "比如说 在这里", "我们认为 最高复杂度的指数复杂度", "在这里头 并不见得 体现的增长速度是最快的", "原因很简单", "因为我们这里的尺度太小", "所以我们也许应该 换成一个更大的一个尺度", "比如说 只要到大概2000以后 我们就可以看得出来了", "比如说 刚才所说的指数复杂度 2的n次方", "就可以在这地方 很明显地看出", "虽然在小的尺度范围之内", "它并不见得胜过", "比如这里头的 n的立方", "但是 毕竟 它的增长速度在足够远之后 是会体现出来的", "它总有一天会超过 刚才所说的", "所有这些固定阶次的多项式", "所以 这也是我们从总体上 获得了这个标尺（的）一个感觉", "在后边 我们将得到 更加具体的", "针对具体问题的 一些这方面的感觉"]}, {"name": "03D-5\t selectMax()", "block_id": "239b4d390af14a26bb20e674213651b9", "text": ["至此我们只剩最后一个细节 未作交待", "也就是如何从一个指定的区间中", "挑选出最大的那个节点", "对于列表L而言", "我们考察的是一个一般性的区间", "这个区间的起点", "是以节点p来指示的", "而这个区间的长度呢 是n", "所以同样地", "我们可以假想着 在这个位置", "有一个尾部的哨兵", "我们的算法朴素无华", "具体来讲就是 我们要从首节点出发", "逐一地进行比对", "并且在这样的一个过程中", "记录下当前最大的元素", "当我们抵达终点时", "这个最终的记录", "就是我们所要找的最大节点", "这样一个思路可以兑现为这几行代码", "这个selectMax接口", "要准备一个名为max的变量", "用以记录当前所能够找到的最大节点", "而整个过程呢", "是一个for循环形式的迭代", "当前的节点由cur来指示", "而每经过一步迭代", "cur都会转向它的后继", "由此完成对整个区间中", "各个节点的遍历", "而对于每一个当前的节点", "我们都会取出它的数据域", "并且与目前号称为max的", "这个节点的数据域作一比较", "如果前者反而不小", "我们就将max更新为", "这个不小的新节点", "所以在整个迭代的过程中", "max只可能逐次地递增", "而绝对不会下降", "这样一种算法称作画家算法", "painter's algorithm", "原因在于 整个这样的一个过程", "非常像油画家画画的过程", "在一张画布上", "你可能会堆积上不同的颜色", "而最终这个位置所体现出的颜色", "是由最后那一笔油彩所决定的", "我们这个过程也是如此", "对max的每一次更新", "都犹如是在这块画布上", "涂上了一层新的颜色", "最终所获得的那个最大值", "其实就是最后一次更新的那个元素", "这个过程和画家画油画完全类似", "你可能已经注意到", "我们这里所采用的比较器是", "not less than 也就是不小于", "换而言之", "只要当前的这个节点", "大于或等于目前的max", "我们就需要做相应的更新", "就像重新地涂上一层新的油彩一样", "之所以采用这样一种方式", "是因为我们这里需要", "对重复元素进行适当的处理", "根据这样一个比较器 不难理解", "如果这个序列中存在重复的元素", "比如说 对于当前的max来说", "可能会有多个", "那么这样一种实现方式的好处就是", "它会最终选取其中最靠后的那个", "而这个元素也相应地", "会被优先地转移到sorted的那部分", "就总体效果而言 所有的这些重复元素", "都会依次地转移到相应的位置上去", "从而保证算法的稳定性", "作为对比 你可以考虑一下", "如果将这个比较器换成", "严格的大小比较", "比如说 greater than 会怎么样？", "我们把这个作为你在课后的思考题"]}, {"name": "05A-2 应用", "block_id": "9ea442a3e5584bb6ac16e2d3e76652bb", "text": ["实际上对于树型结构这种概念", "我相信我们每个人都并不陌生", "比如在我们此前所介绍过的", "以RPN为典型代表的表达式运算问题中", "我们可以把RPN所对应的那种后缀表达式", "直接地表示为一棵树", "比如1加上2就可以表示为这样一个形式", "如果再继续乘以3", "则可以表示为这样一个形式", "另外 小到我们文件系统的目录结构", "大到整个Internet的域名结构", "都可以描述为这样的一棵树", "而大学 无论是实在的", "还是虚拟的Hogwarts", "相对于下属的各个学院", "也可以表示为树型的结构", "这些例子给我们的第一印象就是", "树是用来按照层次关系", "组织一系列数据项的一种方式"]}, {"name": "02A-1 接口与实现", "block_id": "31757785fb1d4e6e984be520bc42c0db", "text": ["欢迎回到数据结构的课堂", "我们今天开始进入到第二章向量", "与下一章将要介绍的", "列表结构一样", "向量同属于最最基本的线性结构", "我们笼统地称之为线性序列", "在这一章我们主要围绕", "这种基本的数据结构", "展示和讨论", "两个方面的问题", "首先如何根据统一的接口规范", "来定制并且实现一个数据结构", "这种定制的方法和实现的形式", "将会被我们后续的", "数据结构所延用", "另外 我们也会围绕", "这种最基本的数据结构", "展示如何通过更加有效的算法", "使得我们对外的接口", "能够更加高效率地工作", "在这里讨论的", "查找以及排序等算法", "都将成为后续章节", "相关数据结构", "高效实现的重要基础", "我们首先需要", "辨析一组非常相关", "但是又非常容易弄混的概念", "也就是抽象数据类型", "以及我们这里所说的数据结构", "那么什么是Abstract Data Type呢？", "以及什么是Data Structure呢？", "可以从字面上给出定义", "不妨来读一下", "所谓的抽象数据类型", "其实就是在一组数据的模型上", "定义的一组操作", "那么什么叫作数据结构呢？", "是基于某种特定的语言", "真正实现的一套完整的算法", "听懂了吗？", "我想你现在的感觉", "肯定跟我当初学习", "这两个概念一样", "一头雾水", "所以不妨把镜头拉回到", "我们此前比较熟悉的程序语言", "先不要考虑什么抽象数据类型", "我们先来看看", "什么叫作Data Type", "数据类型", "比如在高级程序设计语言中", "int 也就是整型", "这就是一个数据类型", "而float也是", "还有呢 char", "诸如此类地", "那么这种数据类型能做什么呢？", "没错 我们能定义其中的一个成员", "比如n是一个整数", "从此以后我们就可以使用它了", "我们也可以说x是一个浮点数", "c是一个字符", "没错 我们凡是这样指定了某一个元素", "是来自于某一个数据类型", "或者说属于某一个数据类型", "那么它就自然地具有了", "这种数据类型的特点", "包括什么呢？", "支持相应地处理方法", "比如说运算", "那么这里那些操作的运算", "具体是如何实现的", "我们并不知道", "我们也并不需要知道", "没错 这是最重要的", "把这样的一个概念抽象出来", "施加到我们所将要实现的", "那些数据结构上", "比如马上就要实现的Vector", "我们希望在使用的时候", "能够参照数据类型的这种形式", "把它等同地当作是", "一个数据类型", "比如说我可以来定义", "我的一个Vector结构", "包括下一章将要介绍的List", "我们也可以类似地来定义它", "这种使用方法", "使得我们可以将数据结构", "与数据类型等同起来", "我们只需要知道它", "所提供的那些操作", "比如说向量的查找、排序", "而不需要去关心它其中的细节", "比如说这些操作是如何实现的", "那么从这个意义上讲", "它就是一个经过了", "抽象以后的数据类型", "所以我们称之为", "Abstract Data Type", "经过以上的解释", "我相信你可能对这两个概念", "稍微理解的深入一点了", "为了获得更形象的认识", "我们不妨来举个例子", "在这里", "我们可以将数据结构", "比喻成某种产品", "比如说汽车", "那么相关的呢 有两类人", "首先是用户", "我们笼统地称之为", "应用Application", "另一类人呢", "是汽车这种产品的", "设计和制造者", "称这个为", "实现Implementation", "这两类人所关心的", "以及他们的职责是不同的", "作为用户而言", "他只关心这种产品的外在特性", "能够提供的功能", "而实现者呢", "则需要对这些功能", "以及特性具体如何落实负责", "我们说在这二者之间", "实际上是有某种形式的一个协议", "没错 也就是使用说明书", "产品手册", "而这种手册或者说明", "在数据结构的使用者", "与数据结构内部算法的", "设计者之间", "达成了这么样一个协议", "两类人可能互不见面", "互不相识", "但是他们通过这样一个规范", "可以很好地彼此沟通", "并且有效地合作", "我们接下来就来看看", "向量这种结构", "是如何按照", "这种ADT的规范", "加以定制并且实现的"]}, {"name": "12b3-6\t: linearSelect：性能分析C", "block_id": "789d1530db9a418bb867dba1568e1f4d", "text": ["好了", "现在我们就可以来准确的界定", "linear select算法的渐进复杂度", "实际上根据此前的分析", "我们可以得出这样一个递推式", "难道不是吗", "为了利用这个算法来完成选取", "我们除了需要花费线性的时间", "做一系列的准备工作", "至于实质的计算无非两次递归调用", "第一次递归", "是为了从N/Q个中位数中", "确定全局中位数 也就是那个大M", "第二次递归", "则是针对规模已经缩小的新问题", "我们刚刚证明过", "新问题的规模至少会缩减25%", "不要忘了我们的目标是线性", "而为了使得我们能够从这个递推式", "解出一个线性函数", "我们只需保证", "那两个递归项的参数之和", "严格的小于线性", "也就是说1/Q与3/4的总和", "必须严格的小于1", "这一点并不难做到", "比如我们只要将Q取作5", "就能保证这一点", "针对于Q等于5时的这个递推式", "你不妨在课后做一细致的推导", "你将会发现尽管就渐进意义而言", "它的确是一个线性函数", "但其中的常系数却相对很大", "也就是说这里的linear select算法", "更具有理论意义"]}, {"name": "05E1-5 实例", "block_id": "49596a49a13d4bf5a62ccccc6accb74e", "text": ["来看这样一个具体的实例", "请记住 在我们这里", "总是按照先序遍历的原则", "在任何局部都是先访问根", "再遍历左子树 再遍历右子树", "最终才能完成任何一个局部的整体遍历", "按照刚才设计的迭代算法", "我们首先要引入这样一个空栈", "并且作为初始化", "首先要将根节点 也就是a 纳入其中", "此后我们进入那个while循环", "每一次我们做的动作都是弹出当前的栈顶", "并且随即地访问这个节点", "在这里 我们用深色来表示", "已经接受访问的节点", "此后我们应该首先去检查", "这个刚被访问的根节点是否拥有右孩子", "有 就令它入栈", "接下来 是否还拥有左孩子", "有 所以我们也令它紧接着入栈", "以下我们的while循环进入下一步迭代", "同样地弹出当前的栈顶节点b", "并且将它染为黑色 也就是访问它", "此后呢 我们也需要去右顾左盼", "此时我们会发现", "当前这个节点b左右孩子都没有", "所以也就不会实施任何入栈动作", "从而直接进入下一步迭代", "在接下来的这一步 我们依然是弹出", "当前的栈顶节点c", "并且对它进行访问", "请注意 虽然在这个瞬间栈是空的", "但这并非我们判断循环退出的时机", "实际上 接下来应该判断", "刚被访问的这个节点c是否拥有右孩子", "以及左孩子", "只要有 我们就按照先右后左的次序", "令它们依次入栈", "而接下来一次迭代再进行检查的时候", "就会发现这个栈并非是空的", "所以也同样地会取出栈顶", "并且随即访问这个新弹出的节点d", "此后 我们依然要去右顾左盼", "其中的右顾可以发现一个孩子", "所以令它入栈", "而左盼却发现没有孩子", "因此在这种情况下只有一个右孩子会入栈", "在接下来的下一步迭代中", "栈顶的节点e会被弹出并且接受访问", "而且因为e没有任何孩子", "所以也相应地没有任何入栈的动作", "好 在最后一步迭代节点f将会被弹出", "并且接受访问", "而且节点f依然是一个叶节点 没有任何孩子", "所以这个栈在让出了最终的一个节点之后", "因为没有新的节点进入", "而成为一个空栈", "在这个时候算法就可以退出", "纵观整个算法所输出的节点序列", "不难验证 它们恰好就是我们所希望得到的", "先序遍历序列", "我们的第一个迭代版算法非常简明", "然而很遗憾", "这种算法策略并不容易直接推广到", "我们此后要研究的中序乃至后序遍历算法", "因此我们或许应该另辟蹊径", "寻找其它等效的策略"]}, {"name": "08XA4-8\tBB-3", "block_id": "285aea76d87a490eb4e3a9b176cbe948", "text": ["我们最后来讨论兄弟节点s为红色的情况", "我们不妨将这种类型的双黑缺陷统一的记作BB-3", "实际上 对于这种情况我们并不需要做什么实质的处理", "而只需将其转化为此前所介绍的某两种子情况", "为此我们需要再次站在对应B树的角度", "可以看到 此时的p和s", "共同的结为一个3分支的超级节点", "在此时的B树中 我们不妨简单的令s和p互换颜色", "而无需做任何实质的结构调整", "当然 在对应的红黑树中", "如此却需要做一次结构调整", "具体来说 也就是要围绕着节点p 做一次zig或者是zag旋转", "同时 翻转s和p的颜色", "看到这个结果 你多少会有些失望", "因为问题并没有解决", "比如 原先黑高度的异常 依然存在", "然而实际上 这步转换并非没有意义", "因为此前的矛盾焦点在于节点r的兄弟s为红色", "那么现在呢 在无形中r已经拥有了一个黑的兄弟s'", "于是此后必然会跳出BB-3这种情况", "而转入此前所讨论的3种情况", "而更好的消息是", "实际上接下来只可能转入其中的BB-1以及BB-2R", "而绝对不会是BB-2B", "什么是BB-2B呢", "它的要点之一是 父节点p必须是黑的", "而经过刚才的变换", "同样在无形中父节点p已经悄然的变为了红色", "你应该记得 从计算复杂度的角度来看", "后面的这两种情况要更为简单", "因为他们不会像BB-2B的那样 不断的向上蔓延", "因此我们可以断定", "经过如此调整之后 只需再做一轮调整", "整个红黑树必然会得以完整的修复"]}, {"name": "02F-3\t 二路归并：实例", "block_id": "d83bd3b1946e41649ff9d867d9699356", "text": ["首先 这个a图给出了", "两个各自有序的子序列", "那么这个二路归并算法的要诀就是", "我们只需要把注意力关注在", "这两个序列的首元素上", "这样一个方框", "是我们的关注焦点", "其余的元素 可以暂时不用顾及", "那么每当我们取出", "这两个序列各自的首元素的时候", "都要从中挑选出更小的那个元素", "如果是打平局的话", "你可以任意取一个", "比如 就这个例子而言", "应该取出的是这个2", "我们将它择出来", "相应地呢", "在摘除了首元素以后", "后续的元素将逐次递补", "也就是说 我们会把注意力关注到", "新顶替上来的这个首元素上", "同样 在接下来的一轮比对中", "我们考察这两个首元素的大小", "并且同样地取出其中的更小的那个", "4依然比5小", "所以4被取出", "同样 它的后继们会顶替上来", "对这个例子而言 就是10", "在接下来的一轮", "对两个子向量的首元素", "进行比较 发现5更小", "无论谁更小 都是一视同仁", "我们要把5取出来", "同样地 在左侧的这个序列中", "它的后继元素8会顶替上来取而代之", "所以在接下来的这一轮比对中", "我们的关注的焦点", "同样聚集在这两个序列新的首元素上", "根据刚才所确定的算法和策略", "8同样会被摘取出来", "13会继续顶替上来", "好 在接下来这轮里头", "10又因为更小被取出", "29取而代之", "在接下来13被摘出", "顶替上来的21", "相对于29 依然还是要小", "所以21会被取出", "直到最终", "一旦有一个向量已经变成空的", "那么另一个向量所剩余的元素", "无论多少 都直接串接在后边", "我们可以看到 按照这样的一个原理", "我们确实可以得到一个", "更大的单调序列", "我们所给的这种二路归并的算法", "实际上是非常通用的一个版本", "那么在这里 针对于归并排序而言的", "实际上 我们用到的是其中的一种特例", "也就是说 在这个时候", "参与归并的两个序列", "实际上是来自于同一个更大的向量", "只不过是由其中的三个界桩", "也就lo、mi和hi来联合定义的", "如果左侧的这个向量称作B", "右侧的称作C的话", "那么合并起来的整体的这个向量就是A", "那我们就来看一下", "针对这样一种特殊情况", "我们的二路归并算法应该如何实现"]}, {"name": "03A-1\t 从静态到动态", "block_id": "037d3673e6c049448b7ee1f88f235205", "text": ["欢迎回来", "第三章的主题是列表", "与向量一样", "列表也是典型的最基本的一类", "所谓的线性结构", "但是正如我们马上要看到的", "列表结构与向量结构", "在几乎所有的方面都是对称的、互补的", "因此它的特点也十分的鲜明", "不同数据结构所提供的操作接口", "形形色色不尽相同", "但是总体而言", "无非分为静态和动态的两种", "前者是所谓的读取式", "也就是说 只是获取数据项的内容", "而不对它进行修改", "比如说 典型的像向量的get和search操作", "而后一种呢 是所谓的写入式的操作", "也就是说 确实会对数据结构的局部", "乃至整体进行修改", "比较典型的是 向量的insert和remove操作", "相应地 那数据元素在数据结构中的", "存储与组织方式呢", "也可以分为静态的和动态的两种", "前者是以向量为代表的", "具体来说 在这个数据结构的生命期内", "数据区是在创建之初统一确定的", "因此其中元素在逻辑上的次序", "可以与它们在物理上存储的次序", "直接联系起来", "存在一一对应的关系", "根据秩 能直接访问到这个元素", "因此在静态操作方面", "这类数据结构体现出效率上的很大的优势", "比如说 get只需要O(1)的时间", "如果按有序排列的话", "search只需要logn的时间", "但是反过来 这类结构在动态操作方面", "却显得力不从心", "回顾一下 无论是insert还是remove", "都需要将当前这个元素的后继", "向后移动一格 腾出一个空位", "或者反过来 有的时候需要向前递补", "填补一个空位", "而最坏情况乃至平均情况下", "我们都需要O(n)的时间", "为了改变在动态操作方面的不足", "我们应该相应地改用动态的存储方式", "也就是说 各个元素所占的物理空间", "是在生命期内动态地、逐步地分配", "这里的代表就是我们这一章的主题：列表"]}, {"name": "04C3-1\t 混洗", "block_id": "dd34d4fa43f449e1898509843328bd7a", "text": ["同学们好，在接下来这一节", "我们将讨论一个与上一节", "括号匹配问题非常相关的问题", "也就是所谓的栈混洗问题", "所谓的栈混洗", "就是按照某种约定的规则", "对栈中的元素进行重新的排列", "初始情况下 所有的元素都存在栈A中", "这里我们采用一个约定", "也就是分别用尖括号和方括号", "来表示栈的顶以及底", "栈混洗的目标是将所有这些元素", "都通过某种方式", "转入到另一个初始为空的栈B中", "为此我们也需要借助一个中转栈S", "在整个混洗的过程中", "我们允许的措施只有两种", "第一种是由这个箭头来表示的", "形式上说 也就是将A中的栈顶弹出", "并随即压入中转栈S中", "另一种允许的操作 则由这个箭头指示", "也就是说 需要将S栈顶弹出", "并随即转入栈B中", "我们来看这样一个具体的实例", "最初总共有四个元素", "依次编号为1 2 3 4", "接下来 在符合上述规则的情况下", "经过一系列的push或者pop操作", "最终将这四个元素成功地转入栈B中", "构成一个新的排列", "称作stack permutation", "再次提醒大家注意", "我们在记录栈B的内容时", "依然采用这样的习惯", "也就是分别用尖括号和方括号", "来对应于栈的顶部和底部", "因此我们在记录", "栈A的内容和栈B的内容时", "方向是正好颠倒的", "不难理解 在遵守以上规则的前提下", "同一输入序列", "完全可能导出不同的栈混洗序列", "就以刚才的1 2 3 4为例", "按照刚才所述的过程", "最终可以得到输出序列3 2 4 1", "而如果我们每对S做过一次push", "就随即做一次pop", "我们就可以得到1 2 3 4", "这样的一个顺序序列", "反过来 如果我们连续地", "执行完四次push之后", "再连续地执行四次pop", "我们就会得到一个完全颠倒的逆序序列", "当然 在符合规则的情况下", "其它的push和pop的组合", "也会得到更多的可能的序列", "那么我们可能会关心", "对于长度为n的序列", "可能的栈混洗总数", "如果记作SP（n）的话 等于多少呢？", "当然栈混洗的总数不可能超过全排列", "也就是n的阶乘", "那么准确地来说 又是多少呢？"]}, {"name": "12b3-3: \tlinearSelect：算法", "block_id": "ba918d979e1544739dc4c975bfc21729", "text": ["我们接下来将要介绍的这个选取算法", "就是在刚才quickselect算法的基础上", "进行的改进", "因为这个算法即便在最还情况下", "也只需渐进的线性时间", "因此我们也称之为linearselect", "这个算法需要用到一个常数Q", "它的数值不大", "我们稍候就会具体来确定它的取值", "这个linearselect的算法", "将以递归形式给出", "因此我们首先需要准备好递归基", "也就是当问题的规模已经足够小时", "我们就不妨调用任何一种", "平凡的选取算法", "接下来我们需要将整个数据集", "均匀的切分为若干组", "每一组依然是一个随机的序列", "它们的规模都统一取作", "刚才引入的那个常数Q", "如此我们将得到N除以Q个子序列", "接下来对于每一个这样的子序列", "我们都分别对它们进行排序", "没错 排序", "而且在这里", "你可以不必过于在意排序的效率", "比如可以直接采用插入排序算法", "而在经过如此排序之后", "我们也就可以直接得到", "每一个子序列所对应的中位数", "既然总共有N除Q个子序列", "所以这里中位数也总共应该有", "N除以Q个", "接下来我们再从所有这些中位数中", "去找到它们的中位数", "也就是中位数的中位数", "median of the medians", "具体如何来找到呢", "通过递归", "也就是调用linearselect的算法本身", "我们将这个中位数的中位数", "记作大写的M", "接下来我们就需要", "以这个中位数的中位数为基准", "对整个数据集中的所有元素", "进行分类", "具体来说所有小于M的元素", "都归入L中", "所有大于M的元素都归入到G中", "而所有与之相等的元素", "都归入到集合E中", "此时的状态以及可能的情况", "可以由这组图来表示", "既然这三个集合之间", "有明确的大小关系", "所以无论如何", "从大到小", "它们必然是L在最左侧E居中", "以及G在最右侧", "当然它们的规模大小可能有所不同", "不要忘了我们的查找目标", "是在全局秩为K的那个元素", "所以接下来我们可以沿用", "quickselect算法的思路", "根据不同的情况", "相应的对问题的规模进行裁减", "从而实现有效的减而治之", "具体来说根据目标元素", "具体应该落在L E或者G中", "无非三种情况", "如果L足够长", "以至于K应该落在其中", "那么不难看出E以及G都可以被减除掉", "因此在这种情况下", "我们接下来", "只需将查找的范围缩减到子集L", "然后递归的进行查找", "对称的如果G足够大", "则意味着E以及L都可以被减除掉", "因此在这种情况下", "我们同样可以将搜索的范围", "缩小到子集G", "并同样通过递归来完成后续的查找", "需要注意的是", "如果子集G是以序列形式给出的", "那么在这个序列中", "原先秩为K的那个目标元素", "在G中所对应的秩将有所减少", "在这里我们不要忘了对它及时的更新", "那么最后一种情况", "无非就是目标元素落在子集E中", "不要忘了 E中的元素", "都等于全局的那个中值", "这意味着什么呢", "没错", "意味着全局的这个中值", "恰好就是我们的查找对象", "也就是说我们在这个位置已然命中", "因此可以直接将其返回", "这也是算法的最终出口", "这个linearselect算法", "尽管略显复杂", "但是我们不难验证", "它在功能上的正确性", "因此我们接下来", "需要回答的关键问题就是", "它的时间复杂度有多高", "是否如它的名字所暗示的那样", "即便在最坏的情况下", "也能保证不超过渐进的线性"]}, {"name": "04C1-1\t 应用", "block_id": "c94020fad5544c8394a8547b545093cc", "text": ["同学们好 接下来的几节", "我们将结合几个具体的实际问题", "来介绍栈的实际应用", "栈结构的典型应用场合", "大致可以分为以下四类", "在这一节 我们首先来考虑", "其中的第一类 也就是", "所谓的逆序输出问题", "这类问题的特征是", "计算或者说处理的次序", "与最终结果的输出次序", "正好是颠倒了", "而且我们整个的计算的深度", "与输出的长度", "并不容易在事先判断出来", "我们这里以进制的转换", "作为这方面的实例", "说到进制转换", "相信大家都不陌生", "在你的电脑乃至手机中", "往往已经提供了类似的工具", "比如采用习惯的十进制", "每次当我们输入一个数字", "比如2013", "我们只需切换到相应的进制", "比如说十六进制", "就可以得到这个数字", "在对应进制下的表示", "包括常见的八进制以及二进制", "那么这样一个转换的过程", "在背后是如何实现的呢？"]}, {"name": "02D1-5\t 实例与分析（高效版）", "block_id": "073d6055b89649468a8762c564697eac", "text": ["考察这样一个实例", "最开始的时候", "算法首先考虑的i和j元素", "其实就是0和1号元素", "对这个例子而言", "它们是彼此重复的元素", "所以在那个循环中", "将会通过那个隐藏着看不见的else", "直接将它忽略掉", "并且使得j进而转向下一个单元", "以及在接下来的一个循环中", "再下一个单元", "以及再下一个单元", "事情到这一步的时候，发生了转折", "可以看到，3和5出现了第一次的不同", "按照刚才算法的逻辑", "会把i++得到这个位置", "然后把第j号元素取出来", "复制到对应的这个位置上", "所以这就是为什么变成了3和5相邻", "注意，在这个过程中", "我们并没有做显式的删除操作", "好，接下来i依然会++", "转向这个地方", "接下来j呢", "也会继续地，因为重复++ ++ ++ ++", "跟刚才一样", "直到j抵达第一个8，这个位置", "这个情景，又是一次跟刚才一样地", "我们再次碰到了i和j", "而且它们是不相等的", "这个时候，我们又是如法炮制", "将i++，也就是指向这个位置", "然后将j填充到新的这个位置上去", "这就是为什么", "这个地方会出现一个8", "接下来，还是如此", "以这个8所在的这个位置", "为i这样的一个基准", "j继续往后扫描", "所以会忽略掉重复的这些8", "直到第一次碰到13并且把13", "移动到8的右侧，紧邻在这，排列于此", "再往后呢，以这个i为基准", "j继续往后扫描", "我们会发现后面的元素", "都是一直雷同，直到最后", "所以它们都会统统被忽略掉", "直到j第一次越过右侧的边界的时候", "循环退出，算法也就终止", "我们说这个时候，经过重新设置", "向量的规模size", "也就是指向在这儿", "这个是0", "这是1 这是2 这是3", "这是4的话", "我们已经无形中将后边的这些元素", "统一地给删除掉了", "这种删除非常的高明", "因为我们没有做任何的一次", "显式的删除操作", "而只是通过我们合理的计算", "得知了这样最终的规模之后", "对size这个量重新进行了一次设置", "这个例子非常具有典型性", "因为我们通过它，可以得出一个结论", "在整个这个算法过程中", "无非是经过了i+1次的迭代", "这个可以从j的移动看出", "因为在每一次迭代中", "i虽然不见得会增加", "或者说向右移动", "但是j必然总是会向后面移动一位", "累计而言，如果它是从一号元素开始的话", "那么总共不过是线性次", "而且在每一次过程中，我们看到", "所做的操作无非就是一次比对", "然后只有在比对不同的情况下", "我们才会做一次复制", "即便是最坏的情况", "既比对而且也复制的话", "我们说，累计起来也不过是常数的时间", "所以换而言之，整个这样的一个新的算法", "只需要O(n)线性的时间", "这个时间复杂度", "相对于此前那个低效的版本", "整整提高了一个线性的因子", "之所以能这么做", "我们也可以再反过头来", "体会其中的技巧", "正像我们此前所说的那样", "后边凡是需要复制的元素", "无论是这个5，还是8，抑或是这个13", "我们都不再是那样", "亦步亦趋地小步前进", "而是直接地、直接地", "以及直接地一步到位", "所以我们也可以说", "这样的一个实现方法", "很好地体现了", "我们在经过反思之后所发现问题", "并且拟定的一个改进的策略", "所以才会使得效率有如此之高的改进"]}, {"name": "01XC-5: Fib()：迭代", "block_id": "5372d31bb3a4444bb3540d4af446d7b2", "text": ["去掉这样的重复以后", "我们的第一种改进方法", "是直截了当的 也就是说", "在我们每一次试图生成", "一个新的递归实例的时候", "都去检查一下", "它 当然也可能是它", "或者是它 无论是谁", "是否在此前 已经被唤醒", "并且计算 得出过相应的结果", "如果是 那么我们就", "不必再重新的唤醒它", "并执行一次计算", "当然 也会包括引发后续的计算", "而是直接把原先的结果", "取出来就可以了", "没错 这是最好的方法之一", "我们把这种方法称作", "记忆法 memoization", "大家记住 这里并没有写错", "不是memorization", "而是memoization", "具体来说 对于这个例子而言", "我们可以将Fibonacci数的各项", "所计算的结果制成一个表格", "初始化的时候 这个表里", "可能 比如说 都是负数", "以表示还没有计算出来", "而一旦某一个递归实例", "比如说 第二项Fibonacci数", "已经被调用", "并且执行计算出结果", "我们就将相应的结果", "存入表中对应的那一项", "无论是0 1 2 3", "还是诸如此类地", "以后呢 一旦每一次", "需要去再次唤醒", "这个递归实例的时候", "我们按照刚才的设计", "都会首先去查这个表", "并且会发现表中的项", "已经不再是一个负数", "这就意味着这项", "是此前已经计算出来的", "所以它会智能的", "回避掉这次调用", "包括后续引起的那些调用", "从而在O(1)的时间内", "返回所需要的结果", "这种方法非常好", "当然 对这种方法而言", "对原来的程序的改进 也不是很大", "虽然这里我们没有给出具体的形式", "但是大致可以想像的到", "也就是在程序的入口处", "增加这么一句", "对于全局表格的查询", "只有在表格中还没有有效的", "这样的一个结果的时候", "才会执行实质的计算", "这样的话 我们就有效地", "克服了刚才的缺点", "第二种方法", "更加通用而且更加自然", "我们可以认为", "就这个例子而言", "如果说此前", "递归的计算方向是从大到小", "自顶而下的话", "我们受到刚才", "上楼梯那个问题的启发", "不妨倒过来", "改为自小而大 自底而上", "这样由原来的递归算法", "改进为迭代的一个算法", "我们说同样可以完成刚才的工作", "而且更重要的是", "它在每一个台阶上", "只需要停留一次", "总体而言", "可以使得复杂度更低", "这样一个算法", "我们具体的可以落实为", "这样一张图", "也就是说", "不妨用两个变量f和g", "分别来记忆当前", "我所处的相邻的两级台阶", "最开始当然是0和1", "接下来就是1和2", "再2和3 继续3和4  4和5", "就这个例子而言", "一直到最终的6", "很好", "这确实是一个可行的方法", "而且它的代码也非常的简明", "我们可以看一下", "初始化 然后不断地迭代", "每一次迭代都通过", "这样的两句赋值语句", "更新这两个变量f和g", "使它始终指向", "这个楼梯中相邻的两阶", "也可以说是在Fibonacci数列中", "当前相邻的两项", "它们整体地呈现一种", "交替的滚动的方式", "不断地向前推进", "直到我们所希望得到的最终的解", "这个算法需要多少时间呢？", "我们可以看到", "除了这样的一个循环", "没有任何更多的", "引起复杂度的部分", "它的复杂度 简明地可以看出", "是由n来控制的", "与n是呈线性的关系", "也就是说 它只需要O（n）的时间", "而且更重要的是", "我们在这里", "只需要f和g两个存储单元", "总体而言", "只需要常数的空间", "如果大家回去估算的话 会发现", "我们刚才的那个递归的版本", "在空间上也同样是非常破费的", "具体来讲 它需要O（n）的空间"]}, {"name": "08A2-6\t分摊性能", "block_id": "0f1cbe5252f641b7ab7320c9bfa14179", "text": ["通过刚才的那个实例不难发现 Tarjan所建议的这种新方法", "具有某种意义上的路径折叠效果", "具体来说 包括最坏节点在内的任何一个节点", "一旦经过访问 再经过此后的双层调整之后", "这个节点所对应的那条路径长度就会随即折减一半", "我们甚至可以说 这种效果具有某种意义上的智能", "既然在一棵BST中 我们非常忌讳很深的节点", "那么这种折叠效果 自然就会具有对坏节点的修复作用", "这就犹如含羞草那样 一旦它感受到威胁", "就会通过迅速的收缩 将自己的弱点隐藏起来", "因此在采用Tarjan所建议的这种新的策略之后", "刚才所举的那种最坏情况 将不至持续的发生", "实际上 可以严格的证明 按照新的策略 就分摊意义而言", "单趟伸展操作所需要的时间 都不会超过logn", "也就是说 我们现在不仅足以应对此前所涉及的那种最坏情况", "而且也不会有任何其他的最坏情况", "这是一个再好不过的消息了"]}, {"name": "01d-2: 级数", "block_id": "c55e5ef98f9e4564af1e36c4906320e3", "text": ["首先来复习级数方面的一些知识", "并且做一归纳", "最基本的形式 莫过于算术级数", "也就是说 从某一个数开始", "以固定的间隔为单位 不断地线性递增", "它们的总和 称作算术级数", "第一个等号 是我们在中学时代就非常熟悉的", "第二个等号 则是在引入了大O记号之后所得出的结论", "那么 这个结论我们归纳一下可以说", "所谓算术级数 在阶次上讲", "应该是和它的末项", "也就是在这里讲n的平方 同阶的", "这是我们需要记住的第一个规律", "再来考察在幂方的意义下对算术级数的推广", "具体来说对于任何一个幂方次", "无论是2、3、4还是5", "我们都在算术级数原来的基础上", "使得每一项都统一地变成", "2次方、3次方、4次方", "或者是5次方 诸如此类", "那么这种类似的级数", "运用此前所学过的一些基本的数学知识", "实际上是不难得出一些对应的通项公式", "比如这个 以及这个 以及这个", "这里最重要的是 在大O意义下", "我们可以将这些等式的主要脉络归纳出来", "我们可以看到分别是3次方 4次方和5次方", "所以从归纳的角度", "我们大致可以得出这么一个结论", "幂方这种级数的总和", "应该是比这个幂的方次", "其实也是这个级数的末项", "要恰好高出一阶", "当然我们这里是不完全的归纳", "如果要严格地证明", "我们需要借助这样一个准确的分析", "而这个准确的分析的最关键的一步", "主要是这样 将幂方级数求和转化为", "0到n之间x d次方的这么样一个积分", "这样一个近似的估计是最重要的一环", "而后面的这个求解", "都是我们在微积分课程中", "所应该已经学会的概念和方法", "我们看到 确实对于幂次为d的幂方级数而言", "它的总和 确实是比这个d要恰好高出一阶", "这也是我们需要总结并且记忆下的一个规律", "几何级数也是算法复杂度的一种重要形式", "也就是从某一个常数开始", "不断地以固定的倍数", "呈现几何式的增长", "这样一种级数的总和 我们在中学时代", "应该都已经得到过它的通项公式", "就是这个", "在这里我们同样运用大O记号", "可以将这个总和 从数量级上简化为a^n", "也包括这里最常用的一种特例", "就是从1开始以2为倍数的这么样一个几何级数", "我们说结论是类似的", "概括而言 这类几何级数的规模", "在大O记号渐近意义下", "是与这个级数最后一项同阶的", "因为这里的a^n既是总和", "也可以理解为是这个级数的末项", "2的n次方 同样对应于2的n次方", "再来考察所谓的收敛级数", "也就是说 级数中的各项会逐次递减", "而且这种递减的速度足够快", "以至于尽管每一项都是保持正数", "但是他们的总和 不会超过某一个上界", "这个上界虽然数值不同", "但是从渐近意义上讲 都可以视作是常数", "因此从大O记号的角度来看", "它们都可以记作是O(1)", "那么有同学很自然地就会问这个问题", "这样一类每一项都可能是分数的级数", "在我们这里 有必要讨论和应用吗", "他们的理由非常自然", "因为我们这里考察的是基本操作的次数", "以及存储单元的数目", "这种数目 怎么可能是分数或者小数呢", "很有意思的是 在某种意义上讲", "的确如此", "考察这样一个实例", "假设某段代码的迭代循环", "可以等效地描述为硬币的投掷过程", "这枚硬币投中正面的概率是λ", "介于0和1之间", "当然反过来 投中反面的概率就是1减掉λ", "现在这个程序可能运行的效果是等效于", "不断地投掷这枚硬币", "直到第一次出现反面", "而算法的复杂度呢", "取决于你在整个这样的过程中", "总共投掷了多少次硬币", "那么可能有不同的情况", "有投一次即命中的情况", "有投两次即命中的情况 以及投三、投四", "理论上讲投任何多次都有可能", "那么有概率基础的同学就能回想起来", "这是一个典型的几何分布", "它的数学期望", "也就是说我们从期望的意义上讲", "这个过程需要投掷多少次", "可以表示为这样一个表达式", "而它的解恰好就是1减掉λ分之一", "λ既然是常数 所以这个确实也是常数", "当然还有另一类级数", "它虽然未必是收敛的", "但是它的长度是有限的", "以至于它的界也是我们经常用到", "而且是需要记下的", "典型的有两个", "一个是1/1 加上1/2 加1/3", "一直累计到1/n", "这是典型的调和级数", "它的界可以估计为logn 这是个确界", "另外一个呢 是所谓的对数级数", "也就是log1 其实是0", "log2、log3一直加到logn", "我们说了 所有对数的和等于乘积的对数", "所以这相当于是n的阶乘 再去取对数", "通过Stirling逼近可以得到这么样一个结论", "也就是说n的阶乘log", "实际上是和nlogn在渐近的意义上讲等阶的", "这两个级数 都是在我们后面的课程中要经常用到的", "也是希望大家能够熟练掌握的", "更多的级数呢？", "我们这个课程里没有时间去逐一地介绍", "有兴趣的同学 我们推荐大家去读", "有一本书叫《Concrete Mathematics》", "也就是《具体数学》", "在那里头呢 有相当多的篇幅", "就是介绍这方面的内容", "当然 也包括很多与我们的课程相关的内容"]}, {"name": "06C-4 可能情况", "block_id": "9bfebe9dbe4f44ff9e3585fc07c358d7", "text": ["限于篇幅", "这里不妨掐头去尾", "只保留算法中的最主体部分", "也就是这个while循环", "我们讲过每次迭代都会首先取出", "队首的顶点v", "并且记下它的时间标签", "这个顶点既然能够出队", "那么在此前必然曾经入过队", "请注意 我们这里所采用的原则就是", "每当有一个顶点入队", "都会标记为三部曲中的第二个状态", "也就是DISCOVERED的状态", "所以如果处于UNDISCOVERED的", "状态的顶点 可以用白色来表示", "那么我们这里不妨用黑色", "来表示处于DISCOVERED状态的顶点", "接下来 通过一个内嵌的for循环", "逐一枚举出v的每一个邻居u", "这里粗略地将u的状态分为两种情况", "第一种情况 u还处于最初的", "UNDISCOVERED的状态", "用图来表示u现在的状态是这样", "按照算法的策略 我们应该对它进行访问", "这也就是为什么我们将它", "标记为第二种状态DISCOVERED", "并且随即令其入队", "相应地 此后u的状态", "也可以用这个图来表示", "这种总体的效果意味着", "我们从当前的顶点v成功地发现", "并且访问了它的一个邻居u", "因此从v通往u的那条边", "将被算法采纳并保留下来", "你应该记得初始化时", "每一条边都会统一地被设置为", "UNDETERMINED的状态", "而按照算法的规则", "一旦发现某一条边应该被采纳", "我们就将它置为tree", "也就是从UNDETERMINED", "转入tree这种状态", "顾名思义 所谓的树边tree edge", "将会构成我们最终所需要构造的", "那棵遍历支撑树", "对于广度优先而言", "也就是所谓的BFS Tree", "好 我们每次所枚举的下一个邻居", "未必总是处于", "最初的UNDISCOVERED的状态", "实际上 u还可能处于DISCOVERED状态", "甚至在某些情况下处于VISITED的状态", "尽管两种状态还是有本质的区别", "但这里为了简化起见", "不妨笼统地归入else这个分支", "好在在稍后介绍的深度优先搜索", "也就是DFS中", "我们将对不同的情况做更为细致的分类", "而那种分类的方法", "同样是可以为DFS所借鉴的", "在这种简化的版本中", "我们此时都将由v通往u的那条边", "归入CROSS类型", "也就是跨边", "至此既然我们已经完全了解了", "邻居顶点的不同处理方法", "整个算法也就介绍完毕"]}, {"name": "06B1-2 邻接矩阵+关联矩阵", "block_id": "6952016a9a4143bba9b1ef1288f2792d", "text": ["实际上图论已经为我们", "提供了现成的图表示方法", "比如其中最典型的", "就是邻接矩阵以及关联矩阵", "我们首先来看邻接矩阵", "顾名思义 所谓的邻接矩阵", "就是用以描述顶点之间", "相互邻接关系的一种形式", "具体来说 这是一个方阵", "如果图中包括n个顶点", "这个矩阵也就是n乘n的", "于是矩阵中的任何一个单元", "比如对应于第i行", "第j列的那个单元", "都表示顶点i与顶点j之间", "是否存在一条边", "也就是说 它们是否关联", "如果是", "可以简明地将这个元素取作1", "反过来 如果否 取作0", "不难看出", "如果是无向图 那么它对应的", "邻接矩阵就应该是对称的", "也就是说 第i行第j列的元素", "必然与第j行第i列的元素雷同", "特别地 在该矩阵对角线上的元素", "都对应于我们此前所说的自环", "上一节曾经做过交代", "在本门课中", "我们不考虑此类的边", "当然 如果我们考察的是所谓带权图", "其中的每一条边", "都拥有某一个称为权重的指标", "那么我们只需对这样的形式的矩阵", "略加扩充", "具体来说", "如果在顶点i与j之间", "存在一条边", "而且该边的权重是w", "就不妨将这个权重存入", "矩阵中对应的单元", "可以看到 如果说无权图", "可以简单地用0101的比特矩阵来表示", "对于带权图", "我们只需要将每个单元的类型", "从单个的比特", "扩展为对应的一个整数", "或者浮点数即可", "我们再来看所谓的关联矩阵", "如果当前的图有n个节点", "那么这个矩阵就有n行", "如果图中总共包含e条边", "那么这个矩阵就对应的有e列", "n行 e列", "相应地 矩阵中的任何一个单元", "表示的也就是对应的顶点", "与对应的边之间", "我们再来看所谓的关联矩阵", "类似地 如果存在关联关系", "这个单元就记作1", "否则 就记作0", "不难看出", "对于这个矩阵中的任何一列而言", "应该恰好只有两个单元的数值为1", "而其余的都是0", "在我们这门课中", "将主要介绍邻接矩阵", "尽管在有些算法中", "关联矩阵也同样可以大显身手"]}, {"name": "07B2-1 插入：算法", "block_id": "e3590abf09f94836b4603cb02967bc16", "text": ["我们来介绍BST的插入算法", "具体来说 如果插入的关键码为e", "我们就需要首先调用search接口", "对它进行定位", "既然我们已经约定", "禁止雷同元素的存在", "所以这里不妨假设e还不存在", "请注意 此时的search尽管会以失败告终", "但_hot变量将会指向", "我们查找路径的末端节点", "而更重要的是", "作为我们的返回值", "_hot的某一个当前仍为空的孩子", "恰好就是我们待插入节点", "应该接入的位置", "来看一个具体的实例", "同样地 你也需要首先确认这是一棵BST", "接下来 如果我们需要插入40", "就会在search的过程中", "经过一系列的比较", "将查找的范围逐步地收缩", "直至最终失败于46", "请注意 在此时", "_hot指向的就是这个46", "而此时search的返回值恰好就是", "46当前为NULL的那个左孩子引用", "因此我们只需将待插入的关键码", "封装为一个节点", "并且令46对应的那个孩子引用", "改为指向这个新节点", "即可完成这次插入操作", "插入之后就像这样", "在此接入了一个新的节点", "好 我们进一步地假设需要再插入55", "同样地 经过一系列的搜索", "我们最终失败于53", "请注意 尽管此时53的左孩子是存在的", "但是根据55和53的大小 在这个位置", "我们最终试图转向的是它的右孩子", "只不过这个右孩子当前为空", "所以search返回的恰好就是53", "这个当前为空的右孩子引用", "而根据我们此前所做的统一语义约定", "在此时_hot指向的恰好就是53", "因此同样地 我们只需将待插入的55", "封装为一个节点", "并且令53原先为空的那个孩子引用", "改为指向这个新节点", "也可以顺利地完成一次插入操作", "新插入的节点以及此后所对应的BST", "就是这个样子", "既然每个新节点所插入的位置", "在此前都是为空", "所以在插入之后", "它们也必然是叶子", "这也是为什么它们都被画作方形", "而不是圆形", "好了 接下来的问题自然就是", "这样一个插入的过程", "如何兑现为具体的代码呢？"]}, {"name": "02F-2 \t归并排序：主算法", "block_id": "1c44c022606f44b4b804293c35403fa0", "text": ["我们首先用C++语言的形式", "把刚才的思路", "兑现为这样一段具体的代码", "我们可以看到", "这里和所有的递归程序一样", "首先要处理递归基", "就相当于在启动汽车之前", "先系上安全带", "好 接下来开始实质的分", "也就是除二 取到中点", "这样的话 我们可以将整体的一个序列", "分成左和右两部分", "分别由lo和mi", "以及mi和hi来界定", "那么对于这两个序列", "这里分别是递归调用自己", "mergeSort前一个序列", "mergeSort后一个序列", "接下来 最重要的实质的工作是在merge", "我们不妨来通过一个实例", "获得对这个merge算法初步的印象"]}, {"name": "04C4-1\t 把玩", "block_id": "3f7138c460f64484a6ed444fc9c8cd1d", "text": ["同学们好，我们接下来的这一节介绍", "中缀表达式的求值算法", "根据我们所做的归纳", "这也属于栈结构的另一类", "典型应用场合", "我们称之为延迟缓冲", "具体来说 在中缀表达式求值", "这样一类线性扫描算法中", "我们并不能保证处理的速度", "和读取的速度同步", "而往往是需要预读", "足够多的信息之后", "才能够确定足以处理的一个前缀", "对于我们这里所讨论的", "算术表达式求值问题", "大家都应该并不陌生", "我们这里不妨只考虑", "语法正确的算术表达式", "我们的任务是计算出", "它所对应的准确数值", "这个问题无所不在", "其实相应的工具也是处处可见", "如果你使用过Unix", "或者Linux的话", "你就应该知道如何用echo这个命令", "来计算某一个表达式的数值", "对应地 在DOS系统中", "我们也可以通过set /a", "来完成这一个表达式的求值", "比如我们在这个DOS窗口中", "输入set /a", "然后再输入一个语法正确的表达式", "接下来 我们只要一回车", "就能得到相应的结果", "在Postscript之类的栈式语言中", "更是提供了更为规范的", "表达式计算语法", "也就是我们稍后要介绍的", "逆波兰表达式", "当然 在功能强大的", "电子表格系统Excel中", "更是提供了功能更为丰富的", "表达式计算语法", "在Excel中", "我们不妨使用这样一个表达式", "我们可以在某个单元格中", "输入一个等号", "然后继续输入这样一个表达式", "当我们回车以后", "就可以得到这个表达式的数值", "即便是在以文字处理而闻名的", "Word系统中 也提供了类似的功能", "我们只需在这里", "插入一个公式域", "然后在其中填入某个公式", "我们只需更新这个域", "就可以将它转化为对应的数值", "当然计算表达式数值的最直接工具", "莫过于系统所自带的计算器", "我们可以将某个语法", "正确的表达式输入其中", "就像这样 按下等号 就会得到", "相应的数值", "当然最新的计算器", "支持的功能远不只这个", "还有很多新的运算", "比如乘方运算", "我们同样可以把这个表达式", "输入到我们的计算器中", "这次我们随同等号一并输入", "同样地 我们将这个表达式粘贴进去", "得到一个数值", "但是很可惜这个数值", "似乎并不是我们所需要的", "问题出在哪呢？", "其实问题并不大", "问题恰恰就出在这个乘方运算上", "在我们的计算器运算的语法中", "乘方运算并不是用这个尖冒号", "而是使用Y 为什么呢？why？", "我们只要将这个表达式中的尖冒号", "替换成Y", "然后重新地粘贴进去", "随同我们最末位的等号", "就应该得出我们所期望得到的数值", "那么在林林总总的", "这些计算工具背后", "采用的都是什么样的算法呢？"]}, {"name": "01XC-9: LCS：复杂度", "block_id": "5f63ee449c424c9aa5aaafc78918ac64", "text": ["这个算法的正确性", "是可以得到保证的", "准确地讲 是由于它所具有的", "某种单调性", "这种单调性 可以理解为", "在这个算法中 每经过一次递归", "无论减而治之 还是分而治之", "我们只需要经过一次比对", "原问题的规模 总是可以减小", "确切地讲", "每经过一次比对操作之后", "新生成出来的递归实例", "所对应的一对序列中", "至少有一个的长度", "会相对于此前 缩短一个单位", "比如说 在最好的情况下", "会始终只出现减而治之", "而不会出现分而治之的情况", "在这种情况下", "每一个递归实例", "都会缩减为一个", "而不是两个递归实例", "而且它所对应的", "两个序列的长度", "都会单调地减少一个单位", "所以相应地 这样下去", "至多经过这两个序列的", "长度总和这么多时间", "算法必然就会终止", "这个结果非常好", "因为这意味着 在这种情况下", "我们只需要线性规模的时间", "然而 一旦有第二种情况", "也就是 分而治之出现", "就不那么简单了", "因为在这种情况下", "原来的那个问题", "将会被分解为两个", "而不是一个子问题", "更糟糕的是呢", "这两个子问题的规模之和", "居然大致是原来那个问题的两倍", "而且在进一步导出的子问题中", "也有类似的情况", "从而造成总体上 大量的雷同", "这种现象 与我们此前所讲的", "Fibonacci数的那个递归算法 完全类似", "我们可以把刚才那个", "表格的局部展开", "放大来看一下", "为什么会出现这种情况", "在这个表格中 任何一个单元", "都对应一个递归实例", "每一个递归实例", "都分别对应于一对序列", "每一次 我们都会去比较", "它们的末字符", "比如说 这里的是LG", "这里的是AG 包括这个是LA", "如果它们确实是相同的", "比如说 这里的情况", "刚才我们讲过", "它会减而治之地", "降解为一个新的问题", "这个问题相当于", "把原来的这两个序列", "相同的末字符都抹掉", "我们刚才说 这是好的情况", "但是更一般的情况是 不等", "比如这里的情况", "在这个时候 每一个递归实例", "都会转化为两个递归实例", "就像我们刚才所说的", "这两个递归实例", "不仅在数量上增加了", "而且总的规模", "几乎是原来的两倍", "更糟糕的是 它们还会继续地", "引发雷同的递归实例", "比如 还是这个例子", "由这个递归实例会引发", "这样两个递归实例", "而我们这两个递归实例", "都会进而唤醒", "这个公共的递归实例", "这就是我们所说的雷同", "这种重复度是远远超乎", "我们的直观想象的", "为了就此做一估算", "我们不妨从更宏观的角度", "来重新审视", "刚才我们所制作的这张表格", "不妨把其中所有的递归实例", "分别按坐标的形式", "也就是它们所对应的", "那一对序列的长度", "表示为n m或者是a b", "当然包括最初的0 0", "那么我们来问一个问题", "为了计算出 最终这个递归实例", "也就是n m所对应的解", "我们需要唤醒其中", "某一个特定的递归实例", "也就是a b多少次呢？", "其实不难理解", "根据这样的行走的方向", "我们说最坏的情况下", "所唤醒的次数应该等于", "介于这两个隔点之间的", "所有通路的数目", "这样的路径每一条", "就对应于a b 被唤醒一次", "反之亦然", "因此运用一下组合数学", "就可以得出", "为了计算出最终的这个结果", "我们唤醒a b", "这个递归实例的次数", "应该是等于在它们之间", "所有合法通路的总数", "也就是n－a 再加上m－b中", "去挑选出n－a条", "水平路径的总数", "这样的方案数", "或者等效地", "在刚才那么多段路径中", "挑选出互补的", "m－b条垂直的路径的总数", "这个总数是多少呢？", "我们不妨取其中的一个特例", "也就是0 0来做估算", "这个时候a b分别等于0和0", "所以这个总数其实也就是总体", "这个表格的行和宽的总和", "也就是m+n中 去挑选出n", "或者等效地挑选出m", "如果这个表格是接近", "甚至是完全是方形的话", "这个总数大致就是2的n次方", "没错 我们这里", "又再次地碰到了指数", "又掉进了指数复杂度的悬坑", "下面我们就来看看", "如何跳过这个悬坑"]}, {"name": "02A-3\t 接口操作实例", "block_id": "64e4a8f775a14f58a36f10572be8ce50", "text": ["为获得向量ADT操作的", "具体感受", "不妨来看 这样一个具体的实例", "最开始向量与", "任何一个数据结构一样", "初始化的时候", "都是不包含", "任何实质的内容的", "我们称它是一个空的向量", "那么接下来呢", "如果我们调用", "插入操作insert", "然后这个意思是说", "在rank为0的这个位置上", "插入一个元素9", "所以我们就会看到", "向量的组成", "将由空变成包含一个元素", "也就是这个9", "接下来我们继续", "调用insert接口", "在0号这个位置上", "rank为0的这个位置上", "插入一个元素4", "所以4会插入在这", "而原来的元素呢", "比如说这个地方只有9呢", "原来的元素呢 将会后移一位", "同样地 我们也可以", "调用插入接口", "在rank为1的位置上插入5", "这就是为什么", "在这个位置上出现了5", "而它的后继统一地", "向后后移了一位", "我们也可以调用put接口", "这个接口的意思是修改", "它会把当前", "rank为1的那个位置上的元素", "数值 由原来的5修改为2", "我们也可以通过get这个接口", "获取秩为某一特定值的元素", "比如说 秩为2的那个元素", "实际上就是", "0 1 2这个位置上的9", "我们看到这是第一次", "我们有了一个", "output 有一个输出", "当然还包括其它的", "比如说insert insert", "包括remove", "这是我们需要重点看一下的", "我们说remove", "这个接口的参数是2", "这说明 它希望在原来这个向量中", "将rank为0 1 2的这个元素", "恰好它的数值也是2", "把它剔除掉", "所以剔除之后", "会把这个被剔除的元素", "作为输出 返回回来", "同时它的所有的后继", "与插入时候的操作的现象相反", "会向前平移一个单元", "包括其它的insert insert", "当这个时候我们调用", "size的时候", "因为这里所包含的元素总共是6个", "所以它返回6就不奇怪了", "我们可以看到在整个", "这个操作的过程中", "向量都确实具有这么样一个特点", "就是它在逻辑上", "甚至在物理上", "必然是彼此紧邻的排列的", "所有的元素之间", "没有任何的缝隙", "接下来我们可以通过", "disordered()这个接口", "来检测这个向量的有序性", "或者更准确地讲 它的无序性", "我们在此前介绍bubble sort", "算法的原理的时候", "曾经指出", "包括向量在内的序列", "是否有序", "当且仅当其中", "是否存在紧邻的逆序对", "那么这里总共有6个元素", "共定义了5组紧邻对", "其中有3组", "也就是4和3", "7和4、和9和6是逆序的", "所以这就是为什么", "它返回的是3", "只要这个数值不是0", "就说明它尚未构成有序的序列", "好 对于这样的一个无序的向量", "我们已经可以通过find接口", "来查找其中特定的某个元素", "比如说9", "你可以看到9号元素", "是位于rank为", "0 1 2 3 4的位置", "所以这就是为什么", "我们这里需要返回是4", "同样地 也可以查找", "下一个比如说5", "我们一眼扫去就会发现", "5并不存在", "这个时候", "我们统一地约定", "返回一个数值 是-1", "这个-1肯定不是", "一个合法的rank", "表示查找失败", "好 再接下来", "我们可以通过sort这个接口", "对整个向量排序", "大家注意 无论是此前", "所介绍的这些接口", "还是后面我们要所介绍的接口", "就目前而言", "我们并不关心它的具体实现方法", "我们关心的只是它的操作语义", "这就犹如刚才所说地", "这些规范其实就相当于", "一个冰箱的使用说明", "或者一辆汽车的驾驶规范", "我们并不需要", "现在就了解它的实现细节", "我们只需要了解它的功能", "所以从功能上讲", "这个排序确实可以做到这一点", "接下来再调用", "disordered()这个接口", "它已经没有任何逆序的紧邻对了", "所以返回0", "对于有序向量", "我们可以通过另一套接口", "也就是search来进行查找", "比如说 可以首先通过search", "然后引用9来查找", "数值为9的元素", "这个元素的rank为", "0 1 2 3 4 5", "所以这就是为什么", "这里返回的是5", "那么如果查找8会怎么样呢？", "一眼望去 这里并没有8", "当然我们简便的方法", "是直接返回-1", "但是我们后面会讲到", "这种方法并不好", "实际上 这里我们采用了另一种约定", "比如说 对这个例子来讲", "我们返回的是4", "为什么是4呢？", "因为我们这里约定", "如果没有找到这个元素", "我们要找的是不超过这个元素的", "最大的那个元素的值", "对这个例子而言", "不超过8的最大的元素", "实际上就是7", "而这个7的秩是多少呢？", "就是0 1 2 3 4", "所以这是为什么返回的是4", "同样 我们如果要去查找10的话", "会返回不超过10的", "最大的那个元素", "也就是9的秩 也就是5", "另一种特殊情况", "就是我们查找一个全局都没有", "而且小于全局的最小的", "那个元素的数", "比如说1 后面我们会讲到", "我们会假设在这个-1的", "rank这个位置上", "有一个假想的哨兵", "它的数值是负无穷", "所以这里返回的", "应该是在整体这些元素中", "不大于1的", "其实就只有那个", "负无穷 那个元素的rank", "也就是-1", "这样一套约定", "可以使得我们在语义上", "更加的明确", "使得我们在后续的操作过程中", "可以便利地来搭建不同的算法", "当然 还有一点", "在有些时候", "我们要查找的元素尽管有", "但是它反过来却有很多次出现", "比如说这个4 出现了两次", "那这个时候我应该返回谁呢？", "同样跟我们这里的语义", "所定义吻合的是", "我们要返回其中不超过4", "这个目标元素的", "最后边那个元素", "所以如果有两个甚至多个的话", "我们会取其中rank最大的那个元素", "并且把它的rank给返回回来", "对这个例子而言 也就是", "0 1 2 2号元素", "那么这种语义为什么要这么定义", "需要在后边讲到相应的算法的时候", "再去细细体会", "最后 看一下这个uniquify()", "对于一个有序的向量", "我们在其中", "把所有的重复的元素", "比如说4都剔出掉", "只保留一个拷贝"]}, {"name": "08XA2-2\t实例验证", "block_id": "bbedf7ac7a8b4127aff361ae632dbe70", "text": ["来看红黑树的这样一个具体实例", "对照此前所给定义中的4条规则", "我们不妨来逐条核对一下", "首先根节点是黑色的 这没有问题", "然而 第二条在这里却似乎没有满足", "因为你会注意到 这里似乎存在红色的末端节点", "但请记住 此前这里已经做过一个预处理", "也就是为所有有需要的节点", "都添加了一个或两个外部节点", "这些外部节点 都是假想的 实际上并不存在", "引入他们只是为了便于我们后面的分析乃至对红黑树的实现", "因此在通常的演示中 我们也可以将它们统一的忽略掉", "接下来第三条也不难验证", "因为这里的每一个红节点 其父亲以及孩子都是黑的", "当然 对于这些末端的叶节点而言", "它们的孩子 也就是刚才所说的外部节点", "统一也是黑的 尽管在这里我们没有将它们逐一画出", "再来验证第4条 比如对于这个外部节点而言", "从它通往树根的路径 应该是这一条", "不难看到 在这条路径上 除了这个假想的外节点之外", "真实存在的黑节点有3个 如果这的确是一棵红黑树", "那么其他的外部节点所对应的路径也应该如此", "为此我们不妨再来考察另一个黑色节点下属的外部节点", "该外部节点所对应的那条通路应该是这样", "不难验证 除了这个外部节点本身", "这条路径上还包括1 2 3 也是3个黑色的节点", "当然 你可以花费更多的时间", "逐一验证所有外部节点 都具有这样的性质", "其中非常建议你同时再去验证那种", "只有一个外部孩子节点的情况"]}, {"name": "05C-2 真二叉树", "block_id": "d62c4dae8fef47f887c55c6be97fe72b", "text": ["我们刚才所介绍的一般性的二叉树", "只对每个节点的出度", "做了个上限的约定", "也就是说不得超过2", "换而言之 可能有三种情况", "有些节点是没有出度的", "也就是所谓的叶子节点", "对应的指标是0", "另一个极端是有些节点", "可能有两个孩子", "那么也就是对应于指标2", "还有一些节点呢", "只有一个孩子", "对应的指标也就是1", "比如在这样一幅图中", "我们就将每个节点的指标", "也就是它的出度", "记在这个节点本身上", "我们可以看到 0度的节点", "也就是我们所说的叶子节点", "以及满度的和两度的节点", "双分支的", "以及1度的单分支的节点", "这样一般性的一棵二叉树在很多操作", "包括算法的实现", "以及对算法的理解上", "都会引来一些不必要的麻烦", "而反过来一个比较有效的改进方法", "就是将任何的这样一棵", "一般性的二叉树", "转化为一棵所谓的真二叉树", "那么什么是一棵真二叉树呢？", "简而言之就是", "每个节点的出度都是偶数", "或者是0", "或者是2", "但是绝对不可能是1", "为此我们可以假想着", "为每一个节点添加上", "足够多个孩子节点", "具体来说 如果某一个节点", "原来的度数是0", "那么我们就在它的下方", "通过增加两个新的孩子", "使之变成两度", "如果某一个节点原先的度数是1", "我们就在缺失的那一侧", "同样地引入一个新的孩子节点", "从而同样使得它的度数由1变成2", "这样一棵新得到的二叉树中", "就不再含有1度的节点", "我们称这种二叉树为真二叉树", "请注意 尽管表面看来", "这里添加了很多节点", "但是不难证明 从渐近的意义上讲", "它们的总数依然保持", "与原先的规模相当", "而更重要的是在稍后", "我们实现相应的算法的时候就会看到", "这种添加实际上完全是假想的", "你并不需要真正去引入它们", "你只需要假想着它们存在", "你的算法就可以更加简洁的实现", "而且更加简洁的被理解", "这样一种策略", "就犹如伽利略所擅长的那种", "在头脑中的虚拟实验一样", "你只要想象它", "它背后的逻辑是对的", "你并不需要在实际中", "将它严格的兑现"]}, {"name": "04C1-2\t 算法", "block_id": "d448e30cb7b940f3bc3f936a8a31ccbe", "text": ["那么这样一个转换的过程", "在背后是如何实现的呢？", "我们这里要使用到", "所谓的短除法", "比如 我们有可能需要", "将十进制下的89", "转换为二进制下的某一个表示", "具体是多少呢？", "我们来填空", "我们需要将89写在这", "然后画一条足够长的竖线", "既然是二进制", "所以我们首先要对89", "做一次关于2的除法", "我们将除的余数", "也就是 此时的1记在这", "再将整除所得的商", "也就是44 记在这", "好了 这就是典型的一步迭代", "所谓的转换算法中", "这是最重要的一步", "以下无非是反复做这样的迭代", "也就是说 我们要继续对这个商", "做除2处理", "而且每次将余数", "比如说0 记在这", "而将新的商记在这", "以下余数、商", "余数、商", "余数、商", "余数、商", "以及最终的余数和0商", "至此 我们只需由底而上", "将所得到的这一串比特位记录下来", "1 0 1 1 0 0 1", "也就完成了这样一个转化的过程", "再来看一个更一般的例子", "我们来看如何将十进制下的2013", "转化为五进制下的对应的表示", "算法是一样的", "首先将2013抄录于此", "并且准备一条足够长的竖线", "每次依然做除法 留余取商", "我们这里看到 对于5的整除而言", "其实最重要的是看最后一位", "因此可知余数为3", "而商呢 也不难得出是402", "接下来 同样地 余数为2 商为80", "余数为0 商为16", "余数为1 商为3", "最后一步 余数为3 商为0", "至此 我们同样地自下而上", "将所得到的各个数位", "抄录于此 3 1 0 2 3", "也就完成了这样的一个转化过程", "这样的一个算法不难理解", "甚至你可能会立即跃跃欲试", "想要把它变成一个具体的程序", "然而 我相信你很快", "就会遇到一个棘手的难题", "具体来讲 也就是", "我们这里的计算过程", "可以认为是自上而下", "但是输出的过程却是自下而上", "如果不借助对数的话", "我们也很难在事先预测最终", "会有多少个数位", "也就是整个计算的深度", "到底有多少", "那这个问题应该如何解决呢？", "我想你应该想到了栈", "是的 我们只需引入一个栈", "在计算的过程中", "我们每得到一个数位", "就随即通过push将它压入栈中", "也就是说 这些数位进栈的次序", "恰好就是它们被计算出来的次序", "在这个图中 是自上而下", "我们还应该记得栈的特性", "也就是后进先出", "last in first out", "所以 一旦计算终止", "我们就可以通过一系列pop操作", "将这些数位按刚才的逆序", "重新输出出来", "从而得到我们所需要的结果"]}, {"name": "02D1-4\t 唯一化（高效版）", "block_id": "838c5fcf65cc472699de619cbf85c772", "text": ["为了得到更高效的算法", "需要首先对原有的算法进行反思", "我们会发现造成低效率的根源在于", "其中的同一个元素有可能会作为", "被删除元素的后继", "而多次地参与前移操作", "我们知道 对于这样的一个元素来说", "虽然它每次都是向前移动", "但是很可惜 它的每一次移动", "只会移动一个单元", "而不是一次性地", "一步到达它最终的位置", "反过来 我们的诀窍也就在这", "我们如果能够将每一个重复的区间", "作为一个整体来考虑", "成批地删除雷同的元素", "而不是像刚才那样逐个地去删除", "并且逐个地移动", "我们就有可能实现这种", "一步到位式的移动", "从而使得整体的性能大大地改进", "这个新算法的思路", "可以由这样一个图来表示", "也就是说 在任何时刻", "我们关注的都是i和j两个元素", "而且这里有一个不变性", "也就是在i之后 j之前的", "所有这些元素都与i重复", "这个算法呢 将一直扫描", "直到发现第一个与i不同的元素", "如果它确实是不同的话", "我们就只需将j向前移到", "与i紧邻于右侧的这个位置", "注意 这是一个很高明的删除算法", "因为在这样的一个过程中", "我们虽然没有显式地去做", "这些重复元素的删除", "但是实际上已经无形中", "将它们忽略掉了", "等效于做删除", "那么这个算法可以真正的", "兑现为这样一段代码", "正如刚才所言", "我们这里需要维护两个元素", "一个是i 一个是j", "初始值分别都是零", "其实我们知道第一次循环之后", "j首先会+1", "所以你也可以认为是", "从第0号和第1号元素开始", "每一次我们都来检查一下", "新转向的j 这个元素", "是否还在合理的范围之内", "只要它在合理的秩范围之内", "我们就继续进行比较并且处理", "而每次处理是什么呢？", "我们可以看到", "确实如刚才的那个图示一样", "取出第i个和第j个元素", "并且对它们做一次比对", "没错 这里并不需要比较", "而只需要比对", "如果二者不相等", "正像这里所说的那样", "我们就将j取出来", "移到与i紧邻于右侧的位置", "那么如果是二者相等呢？", "这里没有说", "但并不是没有说", "只是没有看到它的形式而已", "具体来说 这里实际上隐藏了一个else", "虽然它什么都没有做", "换而言之 如果是相等的话", "它会直接地转向下一次循环", "像这种情况", "如果这个j和i继续是重复的话", "那它就会去转而考虑j的下一个邻居", "我们可以看到", "经过这样的一次循环以后", "尽管没有做任何实质的操作", "但实际上 我们重复元素的区间", "确实向后延长了一个单位", "这也等效于是我们刚才所说的", "忽略了所有的重复的元素", "当所有的j都运行完之后", "i最终的那个位置", "就是这个向量实际的有效的规模", "而在这个过程中", "虽然向量的规模会有所减少", "但是这里并没有做任何显式的删除操作", "当然 为了这个算法能够", "被其它的算法更方便的利用", "在这里的最终 我们还要返回", "这样的一个差", "也就是这个向量在", "去重之前和之后的规模的差", "这个差当然也就是在此过程中", "发现并且剔除的重复元素的个数", "我们说 这个算法", "确实可以使得效率变得更高", "当然为了验证这一点", "我们还需要做进一步的举例和分析"]}, {"name": "08B4-5: 实例演示", "block_id": "cbedc2d5f41b4e7da1bfeaa4500be2a4", "text": ["接下来 我们就通过几个实例加深对B树算法过程的理解", "首先 请确认这是一棵4阶B树", "其特点是 每个节点的分支数至多是4 至少是2", "或者等价的 每个节点所包含的关键码数 至多为3 至少为1", "首先 假设我们要插入555 经简单目测 不难发现", "应该将其紧邻于556 插入于这个节点之中", "是的 经过逐层查找 可以确定待插入的位置", "接下来 我们也的确只需将555紧邻于556的左侧", "插入于这个节点之中", "现在 我们来检查一下", "尽管这个节点增加了一个关键码", "但关键码的总数依然不超过4阶B树所对应的上限", "这就意味着这次插入操作顺利结束", "以下 我们再假设需要插入关键码444", "经简单的目测 不难发现", "应该将其紧邻于435的右侧 插入于这个节点之中", "是的 我们的确可以通过查找 确定这个节点的位置", "并的确如我们所预期的 将其紧邻于435的右侧", "插入于这个节点之中", "然而 与刚才的情况不同的是", "当前这个节点 在接收了444之后", "其所含关键码的总数已经超过上限3", "也就是说 此时发生了上溢", "根据我们修复上溢的算法", "此时应该以其中的中位数关键码为界 将这个节点一分为二", "同时 中位数关键码提升一层", "并纳入到父节点 也就是这个节点的适当位置", "当然 在父节点接纳了一个新的关键码之后", "我们依然要对它再进行一次核对", "所幸的是 它依然是合法的", "再接下来 我们假设需要插入500", "整个过程是 我们首先通过查找 确定这个节点", "并且相应地 将500插入于482与511之间", "接下来 我们同样会发现这个节点因此发生了上溢", "为修复这一缺陷 我们依然故伎重演", "也就是 以中位数关键码511为界 将这个节点一分为二", "同时 511提升一层 插入于父节点中的适当位置", "至此 尽管底层的上溢缺陷 得到了修复", "但父节点却因为额外接纳了一个关键码 而随即发生上溢", "当然 在这种情况下 我们依然可以如法炮制", "继续在此做一次分裂操作", "同样的 我们可以看到", "刚才那一层上 所出现的上溢缺陷 得到了修复", "然而遗憾的是 再上一层的父节点", "也就是此时的根节点 也随即发生了上溢", "当然 在这时 我们也依然需要对这个节点 做一次分裂操作", "请注意 刚才的那个中位数关键码 虽然因此得以提升一层", "但是因为此前已经是树根 它并没有实质的父节点", "因此 这时的处理方法就应该是", "让这个被提升的关键码独自成为一个根节点", "而整棵树的高度 也因此增加了一层", "我们讲过 这也是B树得以长高的唯一可能", "至此 关键码500的插入过程 才得以最终完成", "尽管我们这里展示了一个 因为某关键码的插入", "而需要不断分裂 并一直持续到根的所谓最坏情况", "但是需要指出的是 这种最坏情况出现的概率其实非常非常的低", "其概率之低远远超出了你的直观想象", "关于这一方面的分析 你不妨参考我们所提供的习题解析"]}, {"name": "12c2-2: \t定理K", "block_id": "6d5e944761824cd585d09232f80f1011", "text": ["回到排序问题", "我们首先来引入h-sorting", "以及h-ordered的这两个概念", "在某个序列中", "如果任何一对距离为H的元素", "都保持前小后大的次序", "我们就称它为h-ordered", "也就是以H为间隔是有序的", "当然作为其中的一个特例", "在任何一个one ordered的序列中", "根据定义任何一对相邻的元素", "彼此之间都是顺序的", "你应该记得我们在最初介绍", "起泡排序算法时就指出", "某个序列中只要任何相邻的元素之间", "都是彼此顺序的", "那么必然就是整体有序的", "所以我们说任何one-ordered的序列", "也必然是全局有序的", "也就是我们排序算法", "最初需要输出的结果", "那么对于任何一个随机序列", "如何使它变成是H-ordered的呢", "实际上如这幅图所示", "我们只需采用希尔排序的那种方法", "将输入的（一维）序列", "在逻辑上转换为一个", "宽度为H的矩阵", "然后分别的逐列排序", "你应该记得将整个序列", "在逻辑上转化为一个", "宽度为H的矩阵", "并且逐列进行排序", "在希尔排序中就称为h-sorting", "由此我们可做一简洁的归纳", "也就是任何一个序列", "在做过h-sorting之后", "必然是h-ordered", "你应该记得在希尔排序中", "每向前迭代一步", "对应的矩阵宽度都会相应的减少", "比如从前一轮的g减少为后一轮的h", "我们知道在经过前一轮的逐列排序之后", "整个序列应该是g-ordered", "而在后一轮的逐列排序之后", "这个序列也自然的应该是h-ordered", "那么在整个序列达到", "以h为间隔有序的同时", "此前以g为间隔的有序性", "是否能够依然得以延续呢", "这个问题的答案", "并不是那么一目了然", "所幸的是Knuth", "已经在他那本著名的专著中", "给出了正面的答案", "Knuth指出任何一个原先", "已是g-ordered的序列", "在此后经过h-sorting之后", "依然保持是g-ordered", "也就是说相对于任何一个", "固定间隔而言的有序性", "在希尔排序的过程中", "将会不断的保持", "并且持续的积累下来", "这个定理的证明", "需要颇费一些时间", "如果你对此感兴趣", "不妨在课后去参考我们的习题解析"]}, {"name": "10c-2: 就地", "block_id": "730cb7a2aac24a4b87f44dc0ca340d0c", "text": ["准确地讲，在空间复杂度方面，我们希望堆排序算法可以做到就地，", "也就是除了输入数据以外，只需要常数的辅助空间。", "这种构思是有可能实现的，因为我们注意到，", "所谓的完全二叉堆在物理上就是不折不扣的向量。", "因此我们或许可以令完全二叉堆与已排序的部分在同一个向量中和平共处，", "经过精巧的设计，我们的确可以将这一构想兑现为这种形式，", "具体来说，已排序的部分依然居于向量的后端，", "而与之互补的前缀则恰好构成一个完全二叉堆，", "如果沿用大顶堆的惯例，我们立即可以发现，", "堆中的最大元始终都是0号元素，", "而接下来需要与之对换的X，则必然是相对于已排序元素而言秩为-1的那个元素。", "按照以上堆排序的初始版本，我们首先需要取出这个最大的元素，", "然后用X来取而代之，然后再将备份的最大元植入X这个位置。", "当然，为了算法能够继续持续下去，我们还需要对新的根节点做下滤调整。", "对于这样的连续四步操作，你发现了有什么可以优化的地方吗？", "是的，这里的1、2、3完全可以整合起来，", "只需m和x之间的一次对换即可等效地完成。", "因此，算法过程中的每一步迭代可以进一步地规整为两大步骤，", "也就是第一步交换，以及第二步下滤。", "是的，反复地交换下滤，交换下滤。", "直至堆变空。", "在整个算法的过程中，除了交换需要用到常数个辅助空间之外，", "我们并不需要任何更多的辅助空间。", "以上过程可以描述为这样的伪代码，但是它又如何进一步地实现为真正的代码呢？"]}, {"name": "02B-5\t 分摊复杂度", "block_id": "8554d022afa64361b6096f98021ca3bd", "text": ["刚才所做的分析过程中", "我们无意中", "已经引入了一个概念", "叫作分摊复杂度", "相应的方法也称作叫", "分摊分析法", "那么这种概念", "和我们一般说的平均复杂度", "以及平均分析法", "实际上是有本质的区别的", "在此我们不妨对它们二者", "做一个简要的对比", "我们先来看", "所谓的平均复杂度", "或者叫作期望复杂度", "那么这种复杂度", "要首先对特定的数据结构", "所提供的各种操作", "做一个概率上的假设", "比如说", "某种操作出现的概率是多少", "另一种操作出现的概率是多少", "诸如此类地", "然后呢 再对照各种操作", "各自的计算成本", "做总体的加权平均", "这种方法的好处是确实", "可以对一个数据结构", "更一般的一个性能", "做出一个考量", "但是我们说", "它也有它的缺点", "具体来说 就是", "在一个数据结构生命期内", "所能够执行的各种操作", "在这里是作为孤立的事件", "来分别考察的", "所以在某种时候", "在某些场合 它会体现为", "将这些操作之间", "本来具有的某些相关性", "和连贯性割裂开来", "所以在这些场合", "我们不能够通过平均复杂度", "来准确地评判和度量", "一个DSA的真实性能", "分摊分析呢 在这方面", "相对要更好一点", "在后面 我们会看到更多的实例", "这种分摊分析的思路是", "要连续地考察", "对一个数据结构", "能够实施的足够多次操作", "大家注意 这些操作", "既是数据结构允许的", "而且它们作为一个整体的", "生命周期内的操作序列", "是必须能够出现的", "然后在这样的一个序列的", "总体范围之内", "再对其中所涉及的各种操作", "各自的时间成本进行总和", "并且反过来分摊到", "各自操作上的", "因此相对于此前的", "平均复杂度而言", "它可以更好地", "从实际可行的角度", "对数据结构真实的", "生命期内所能够支持的操作", "做一个整体的考量", "更加忠实地刻画", "所能够出现的操作序列", "以我们刚才这种扩容的算法为例", "如果我们只是孤立地看待其中的", "每一次扩容操作", "那么我们会发现", "无论是对于递增式的", "还是加倍式的扩容策略", "它们的最坏情况", "都是单次的O（n）", "而这并不足以反映二者的", "性能总体的差异", "唯有将整个过程中", "所实施的所有的扩容操作", "作为一个连续的整体", "来进行总和和分摊考量", "我们才能够像刚才所看到的那样", "更加准确地反映出", "两种策略的真实性能的差异"]}, {"name": "05E1-9 实例", "block_id": "5db205cb40c14af38355dff4f49f4347", "text": ["最后我们通过这样一个实例", "来对刚才那个算法获得更为具体的认识", "当然在继续之前", "我强烈的建议你熟读刚才的主算法", "以及那个子算法", "甚至不妨将它们背诵下来", "准备好了吗？", "那么我们接下来就来一边对照这个例子", "一边背诵刚才那段算法", "整个算法始自于树根 也就是a", "按照刚才的算法逻辑", "我们将首先调用", "visitAlongLeftBranch那个例程", "首先访问始自于a的这样一段左侧链", "我们可以看到 此时只包含a和b两个节点", "所以这也是为什么a和b会被依次访问掉", "请注意 这个子程序在访问a和b的同时", "还会将它们的右孩子 也就是c", "以及节点b的那个看不见的空的右孩子", "推入栈中", "我们可以清晰地看到", "在我们访问a的时候 会将c推入栈中", "在我们接下来访问b的时候", "会将一个空节点也推入栈中", "因此在主程序接下来的一步中", "首先会弹出栈顶 也就是这个空节点", "并且试图以这个空节点为起点去调用一次", "visitAlongLeftBranch那个例程", "然而我们会看到 这只是一个过门", "不会有任何实质的动作", "因为这个例程会首先检测", "当前的x是否为空", "一旦为空 它就会立即返回", "所以我们主程序的下一步迭代", "将弹出当前的栈顶节点c", "并且同样地会在以c为根的子树中", "调用一次visitAlongLeftBranch这个例程", "依次地访问当前左侧链上的c以及d", "请记住同样地 在访问c和d的同时", "还会将c的右孩子 也就是f", "以及d的右孩子e 依次地推入栈中", "再接下来 新的栈顶节点e将会被弹出", "并且同样地会试图以它为起点", "针对它所对应的那棵子树", "其实现在是一棵退化的子树", "调用一趟visitAlongLeftBranch例程", "我们可以发现 既然这是一棵退化的树", "那么自然也就没有真实的任何右子树", "实际上 只会将e的那棵实际为空的右子树", "推入栈中", "同样这样一个空节点的入栈以及出栈", "在整个算法过程中 只不过是过门", "它并不会有任何实质的动作以及输出", "因此在接下来的一轮迭代中", "新的栈顶 也就是f节点将会被弹出来", "同样每当弹出一个新的节点", "我们都会试图以它为起点去调用一次", "visitAlongLeftBranch那个例程", "相应地访问这个局部子树的", "左侧链上的每一个节点", "具体来说 这时也就是f和g", "f和g并没有实质的右孩子", "此后只不过是一系列的过门", "的确 没有任何实质的动作", "直到最终栈被清空 算法终止", "而反观刚才依次输出的这些节点", "它们构成的恰好就是", "这棵树的先序遍历序列"]}, {"name": "11a-1:\t 定义+特点", "block_id": "eb25fcc8bad346688c25593c5c7b1f10", "text": ["同学们好 从今天开始我们进入到这门课程的第11章", "我们讨论的主题是串", "正如我们马上就要看到的", "无论从抽象数据类型 还是从具体实现的角度来看", "串 相对于此前所介绍的数据结构来说 都更为简单", "因此 我们可以将更多的时间用于讨论串的相关算法", "尤其是串匹配的算法", "是的 算法", "在接下来的最后两章中", "我们将会更多地讨论 不同的数据结构在算法中的运用", "在接下来的第一节 就让我们从ADT的角度 来看看串作为一类数据结构 应该提供哪些功能接口", "简而言之 所谓的字符串 也就是由来自于某个字符表中的一系列字符 所构成的一个长度有限的序列", "比如 这就是由8个英文字母所构成的一个字符串", "一般地 串中的每个成员都称作一个字符", "而字符串 就是由若干个字符由前至后所构成的一个线性序列", "当然 这里并不要求所有的字符都互异", "也就是说 有可能会存在雷同的字符", "但无论如何 它们的确都是按照一个线性的次序 依次排列的", "线性次序", "我想 你很快就会想到利用此前所学过的线性序列 来直接实现串", "例如 向量 或者列表", "是的 的确如此", "因此 从数据结构的角度来看", "串的实现 对于我们来说 已不再是一件难事", "然而 我们之所以还需要花费一章的时间来对它进行讨论", "是因为相对于一般的线性序列而言 串结构更具有鲜明的特征", "其中最为突出的一个特点是 组成字符串的字符 种类并不见得很多", "但参与构成串的字符总数 也就是所谓的串长", "却往往相对而言 要高出很多个数量级", "以英文文章为例", "一篇典型的英文文章 篇幅大致在数千个字符左右", "而所有这些字符 无非都是大写 或小写的英文字母", "再加上空格 以及为数不多的标点符号", "我们所编写的每一段程序 比如典型的C或C++程序", "也可以认为是一个字符串", "尽管这类串的篇幅 通常也可长达数千乃至数万个字符", "但组成它们的 无非是那95个可打印字符 以及回车、换行符", "如果将氨基酸视作字符 那么蛋白质也可以视作为字符串", "事实上  尽管这类字符串的长度很长", "但组成它的字符 却只有为数不多的可能", "类似地 如果将碱基对视作字符 那么DNA或RNA也可视作为字符串", "再一次地 尽管这类字符串的长度可能很长", "但是正如众所周知的 组成这种字符串的字符 种类却屈指可数", "实际上 计算机中所存储的任何序列 从本质上讲都可视作是二进制序列", "也就是说 组成它们的字符 非0即1", "是的 所有这些例子 都告诉我们", "我们这里所讨论的串 其长度的确都要远远大于字母表的长度"]}, {"name": "11b1-2\t算法测评", "block_id": "5d2a176734044168b3ea21526f38d780", "text": ["关于算法的性能评测", "在第一章中 我们也已介绍过一般性的原则和方法", "那些总体的原则和方法 在此自然仍可适用", "但是鉴于串匹配问题的特殊性", "为了更为客观而准确地评判相应算法的性能", "我们需要对相应的标准和策略 作针对性的细化与调整", "例如 参照其他算法通用的模式", "我们很有可能首先会想到将这里的输入 也就是文本串T以及模式串P 同时作随机采样", "然后通过数学上的概率分析 或实际测量的统计", "来评判算法的性能", "然而很遗憾 这种生搬硬套的模式 并不适用于模式匹配这一问题", "什么原因呢", "其背后的根本原因在于", "关于什么是查找成功与失败", "现在这一问题 与我们此前所遇到的问题", "已有本质的区别", "比如 我们此前所谓的x是否等于y", "完全是一对一的", "然而在这里 情况已经大不相同", "具体来说 无论是主串 还是模式串", "都是由多个元素 也就是字符 组成的", "两个串在某种意义下的相等", "意味着多对字符的同时相等", "也就是说 此时匹配成功的概率 必然会远远地低于匹配失败的概率", "我们不妨以二进制串为例", "对于这样的字符表 我们知道长度为m的模式串 总共可能会有2^m种", "而在T中 所有长度为m的子串 累计也不会超过n个", "尽管我们讲过 通常n会远远地大于m", "但是m本身也并非是常数", "因此 如果是以2为底的幂次", "又会反过来 远远地大于n", "因此 如果按照刚才完全随机的测试方法", "匹配成功的概率 应该不会超过n/2^m", "这个数大致是多大呢", "依然参照刚才我们网页搜索的那个实例作为估算", "将n大致取作10^5", "将m大致取作10^2", "经过封底估算 我们知道分母大致是10^30", "因此这个概率不会超过10^-25", "如此之低的概率 完全有可能会被任何一种微小的波动所掩盖", "因此 这种测试方法 的确是非常不妥的", "那么 反过来 又有什么行之有效的方法呢", "实际上 一种简明有效的方法就是将成功与失败的情况分别考虑", "针对失败的情况 我们可以继续沿用以前完全随机的方法", "而针对成功的情况 为了更准确地评估算法的性能", "我们就需要将文本串中所有长度为m的子串悉数取出", "并以它们作为测试的输入实例", "好 现在我们已经针对串匹配的问题给出了算法评测的标准与策略", "那么接下来 我们自然就可以着手讨论 都有哪些串匹配的算法"]}, {"name": "06C-7 复杂度", "block_id": "d19f6b8f8d544cea9f933d1f5d18fc9a", "text": ["好", "回到我们的广度优先搜索算法", "它的复杂度是多少呢？", "这取决于你的不同实现方法", "尤其是图结构自身的实现算法", "这里不妨就以我们的实现版本为例", "我们将主体的复杂度部分剥离出来", "也就是由while以及for所构成的两重循环", "我们的第一个问题是", "while循环累计会执行多少步呢？", "为此我们需要考察这里的出队操作dequeue()", "不难验证 在整个算法的过程中", "dequeue()只出现这在一处", "因此dequeue()执行多少步", "整个while循环就会迭代多少步", "我们知道在进入while循环之前", "队列中只有一个顶点", "也就是起始顶点s", "然而此后的入队操作却是不定的", "在有些迭代步中", "可能会连续地执行多步enqueue操作", "而在另一些迭代步中", "却有可能一次也没有执行", "所幸的是我们可以发现每一个顶点", "都会入队一次 而且仅一次", "因此enqueue操作将累计执行线性次", "所以相应地 dequeue()操作也将执行O(n)次", "由此可知", "整个while循环累计执行恰好O(n)次", "然而内部的这层for循环却并非一目了然", "为此我们不妨将它拆解为两部分", "首先是for循环这条语句本身", "其次才是进入这个循环之后所执行的操作", "关于for循环本身", "需要回顾它的实现机制", "我们知道其实就是对顶点v", "所对应的那个行向量", "进行一次线性的扫描", "具体来说 自后向前累计扫过n个单元", "因此与外层的while循环组合起来", "for循环语句累计需要执行的时间为n×n", "所幸的是", "我们并不需要对于每一条潜在的边", "都实质地进入一次这个内循环", "实际上 当前顶点v有多少个邻居", "也就会实质地进入几次内循环", "因此内层循环的实质操作", "累计而言 不过边的总数 也就是e", "两项合计 e这一项可以忽略掉", "由此我们可以得出一个结论", "这样一个算法从渐近意义而言", "需要执行n平方的时间", "然而我们需要指出的是", "这只具有理论上的意义", "在实际中却远远不是这样", "背后的原因在于", "内层循环的for语句本身", "所对应的那个渐近O(n)", "实际上是非常非常小的", "至少在常系数的意义而言是这样", "这可以从两个方面加以验证", "首先这个for语句对行向量的操作", "实际上都非常简单", "无非就是逐一地取出其中的每一个元素", "并且判断它是否为空", "相对于其它更为复杂的基本操作而言", "这种基本操作更加的名副其实", "而更重要的第二个方面在于", "组成每一个行向量的所有元素", "不仅在逻辑上是连续的", "而且在物理上也是连续的", "构成一个紧凑的整体", "这样一种物理上的组织和存储方式", "可以有效地激活系统的缓冲机制", "换而言之 在对整个行向量的访问过程中", "所有的元素都有极高的概率处于高速缓存中", "在此后的第八章介绍B树时 我们将会指出", "任何一级存储 相当于它的高速缓存而言", "在访问速度上的差异", "会高达5到6个数量级", "在实际效果上的这么样一种极大的差异", "完全足以抵消理论上的分析结论", "因此我们完全可以将这样一个O(n)忽略掉", "并代之以常数", "因此这样实现的BFS算法", "实际的运行性能", "更接近于n加上e", "当然如果将邻接矩阵改为所谓的邻接表", "则可以直接得到这样一个效率", "我们可以说这样一个结果", "应该已经是不能指望更好的了", "原因在于 既然是要遍历", "那么至少要对n个顶点中的", "所有顶点分别访问一次", "也至少需要对每一条边访问一次", "当然这样一个结论也是至关重要的", "因为正如我们此前所介绍的", "无论是这里的BFS", "还是稍后要介绍的DFS以及PFS", "所有这些遍历算法实际上都是", "后面更为具体也更为复杂的", "算法的一种基本实现框架", "作为所有算法的一个基本框架", "它能够达到如此低廉的一个成本", "对我们算法设计者而言", "这是一个不能再好的消息了"]}, {"name": "07D4-4 综合评价", "block_id": "269768414c124a70af08b78212b3e565", "text": ["最后 我们来对AVL树的性能和特点", "做一个总体的评价", "首先 我们注意到AVL树", "具有极高的理论价值", "因为它正面地告诉我们", "的确存在这样一种数据结构", "可以在渐近Logn的复杂度意义下", "兼顾所有的静态和动态操作", "而且为此 我们的存储负担", "也不会有实质的增加", "当然 AVL树的缺点也是非常明显的", "这也将成为我们的动力", "促使我们去不断地改进", "并提出更好更高效的数据结构", "那么 AVL树的第一个缺点就在于", "它人为地引入了一个", "所谓的平衡因子概念", "并且要求在这个数据结构中", "隐式地或者显式地存放", "为此我们往往需要去改造", "数据项原有的基本结构", "或者再做额外的封装", "无论如何这一要求都过于做作", "显得不是那么自然", "那么针对这一问题 在下一章", "我们将首先引入所谓的伸展树", "我们将会看到 伸展树", "将无需记录和维护", "任何诸如平衡因子式的指标", "无论是显式的 还是隐式的", "另外 AVL树的实测性能", "与它的理论性能之间", "存在着较大的差距", "尤其是正如我们所看到的", "它的删除操作要更为复杂", "尽管knuth曾经指出", "这种最坏的情况以及较坏的情况", "出现的概率其实很低", "平均而言 大致每五次操作", "才会引起一次旋转", "如果说以上的两个缺点", "都属于鸡蛋里挑骨头", "那么第三个缺点却的确是致命的", "因为我们已经看到 对于AVL树而言", "它的插入操作和删除操作是非常不对等的", "这种不对等就集中体现在每次操作之后", "所涉及的旋转调整次数", "具体来说 每次插入操作之后", "最多只需一轮调整 也就是常数次", "而在删除操作之后", "为了使得全树重新恢复平衡", "正如我们已经看到的 在最坏的情况下", "我们需要做多达Logn次旋转调整", "因此就全树中各节点之间的", "拓扑连接关系而言", "在插入操作之后", "可以保证变化量保持在常数的范围", "而删除操作却未必能做到这样", "实际上 在很多高级的数据结构和算法中", "都对这种拓扑结构的变化量", "有严格地要求", "具体来说 我们这里高达Logn的变化量", "绝对是不能满足要求的", "我们希望将它们控制到更低", "比如在下一章 我们将要介绍到红黑树", "则可以将这个变化量严格地控制在", "每次不超过常数", "无论对于插入操作", "还是删除操作都是如此"]}, {"name": "06C-6 多连通", "block_id": "7a4844aed3c9490f8b4e9974137dc186", "text": ["由算法的原理以及过程，不难看出", "与起始顶点s相连通的每一个顶点", "都迟早会被bfs搜索、发现并访问", "也就是说s顶点所属的那个连通域", "确实可以被悉数的遍历", "然而问题是并非每幅图", "都只包含一个连通域", "那么在含有多个连通域的时候", "从任何一个起点s出发", "未必能够抵达其它的连通域", "那么这种情况如何处理呢？", "如何使得bfs搜索足以覆盖整幅图", "而不是其中的某一个特定的连通域呢？", "我们不妨采用这样一种方法", "可以看到这里只不过是对", "刚才所介绍的bfs算法", "做了一个while循环的封装", "具体来说 逐一地检查", "图中的每一个顶点v", "一旦发现新的这个顶点v", "仍然处于最初的undiscovered状态", "就会随即地启动一次", "源自顶点v的广度优先搜索", "为以示区别", "封装之后的这个算法以小写的bfs来表示", "这样无论原图中包含多少个连通域", "我们总是能够在其中找到一个起始顶点", "并且启动对对应这个连通域的遍历", "这样我们也就顺利地实现了", "对多个连通域的统一遍历", "当然尽管这个封装之后的算法", "在功能上是毋庸置疑的", "但是难免我们会对它的效率产生质疑", "我们的质疑是有理由的", "因为这里毕竟引入了一层新的循环", "而且至少从表面看来", "这个循环的迭代次数将多达线性次", "然而我们说这种担心是不必的", "因为这里并非对每一个顶点", "都启动一轮bfs搜索", "而是只有在当前的顶点", "能够经过这个if判断之后", "才启动这样一次搜索", "这种处理方式可以保证", "对于每一个连通域只有一个顶点", "可能作为起点引起它所属的那个连通域", "被完全的遍历掉", "每一个连通域启动", "而且只启动一次广度优先搜索", "因此所有花费在搜索上的时间", "累计也不过对全图的一次遍历", "而不是多次"]}, {"name": "08A3-2\t伸展算法", "block_id": "dadc80e0399f4b04abf862b3277b16a1", "text": ["这个居于核心位置的伸展功能 大致可以实现如下", "其原理如此前我们所介绍的 首先要确定带伸展的节点v", "以及他的父节点p和祖父节点g", "只要二者同时存在 我们就执行一次双层调整", "具体来说 无非是分4种情况分别处理", "这4种情况 可以通过嵌套的两重if-else判断来加以识别", "比如 如果我们能判定v是左孩子", "那我们就知道 应该属于zig类型", "那么至于是zig-zig或者是zig-zag", "只需在进而检查父节点是左右孩子", "相应我们还可以区分zag-zag和zag-zig", "每经过一次双层伸展 我们都需要将局部的这棵新的子树", "接入到原树中对应的位置 并且更新相应节点的高度信息", "在所有的双层伸展都已完成之后 如我们刚才所言", "还有可能要执行一次单层的调整", "直至最终 整个伸展得以完成", "而v呢 顺利的成为了新的树根", "因此我们也需要对这个树根 做以标识", "那么这里所分出的4种情况 又当如何具体的分别应对的"]}, {"name": "12b3-4: \tlinearSelect：性能分析A", "block_id": "ca78ba9516e64aabafe6fd99c9948435", "text": ["接下来", "我们就来对linearselect算法的复杂度", "做一界定", "按照我们的习惯", "将该算法所对应的运行时间", "记作Tn", "以下我们对照这个算法的各个步骤", "分别进行估算", "首先是作为递归基的第0步", "我们讲过当问题的规模", "已经降致足够小时", "我们将直接采用任何一种", "频繁的算法", "比如直接借助排序的方法", "当然所对应的时间复杂度", "也自然就是Q logQ", "然而因为这里的Q是取作一个常数", "所以QlogQ实质上也是一个常数", "我们再来看算法有效的第一步", "也就是对整个集合的均分", "如果数据集合表示为序列", "那么这一步只需对整个序列", "做一趟线性的扫描", "因此我们也只需线性的时间", "接下来是对每一组元素进行排序", "并进而找出其中的中位数", "同理因为此时每个子序列的长度", "都不超过Q", "因为我们也可以认为", "每个子序列的排序", "都可以在常数时间内完成", "考虑到总共有7除以Q个子序列", "因此所有这些子序列的排序", "以及从中找出中位数", "累计所需要的时间", "也依然不过是线性", "再来考察第三步", "也就是从上一步所得到的", "N除以Q个中位数中", "递归的去找到全局的中位数", "也就是那个大写的M", "我们知道这一步是通过递归来完成的", "但问题的规模已经缩减到N除以Q", "所以对应的时间复杂度", "也可以表示为T n除以Q", "在接下来的第四步", "是根据全局中位数", "将整个集合划分为三个子集", "并分别计数 不难看出", "只需一趟线性扫描", "这项工作既可完成", "因此这一步所需要的时间", "累计也不过线性", "以下是最关键的第五步", "这一步的任务是递归的求解", "规模已经缩小的新问题", "在这里我们宣称", "无论如何新问题的规模", "都会得到有效的压缩", "具体来说", "它们的规模至多是原问题的75%"]}, {"name": "08B2-8\tBTree", "block_id": "b30b294e2194472c8b69f713e2b781e4", "text": ["我们再来看B树类的接口定义", "作为一棵树 它首先需要记录它的规模 阶次以及根节点等必要信息", "与BST类似 这里也需在内部提供一个名为_hot的引用", "以便辅助动态的操作", "就公共的接口而言 依然是我们常用的3种", "静态的查找 以及动态的插入和删除", "这些接口背后的具体算法以及实现", "也是我们接下来将要分别讨论的话题", "需要提前指出的是 其中关键的技术", "无非是在B树经过动态调整之后 一旦违反定义", "我们应该如何进行调整 使之恢复为合法", "我们后面会看到非法情况无非是发生节点的上溢以及下溢", "而一旦发生这种非法的情况", "我们都需要通过节点的分裂或合并相应的处置", "因此 不妨将这两种主要的调整算法以内部接口的形式予以定义", "并在稍后详细实现"]}, {"name": "08A1-2\t局部性", "block_id": "9373ae98eb71478482c50f08a066de6f", "text": ["实际上 引入伸展树的最初动机非常的基本和原始", "具体来说 也就是试图利用所谓的局部性", "那么什么是局部性呢?", "所谓局部性 是实际的计算环境中", "普遍存在的一种规律或现象", "具体来说 也就是刚被访问过的数据", "极有可能很快的被再次访问到", "在实际的生活中 你应该也有类似的经历", "比如 你有可能在机场偶遇某位", "时隔五年甚至十年的老朋友", "但在紧接着下来的第二天", "你们或许可能又会在另一个场合", "比如某个会议上再次谋面", "这样一种现象或规律", "在信息处理的过程中是普遍存在屡见不鲜的", "比如 我们这里讨论的BST 就是一个很典型的例子", "对于BST来说 这一规律 可以具体的描述为", "我们每次刚刚访问过的某一个节点", "都有可能很快的会再次被我们访问到", "或者推而广之 我们接下来访问的那个节点", "即便不是你刚访问过的那个节点", "也不会离他太远 所谓的虽不中 亦不远矣", "通过此前的学习 我们已经知道", "对于AVL树而言 每一次查找所需的时间都是logn", "因此任意的连续m次查找", "所需要的累积时间 无非就是mlogn", "这无可厚非", "那么进一步的 如果我们对于数据的访问", "的确具有上述的局部性", "那么我们对数据集的访问效率能否做到更高呢?"]}, {"name": "11f2-3: 应对冲突", "block_id": "9f2b39d6a4a44b1fbdfcf396a3fed607", "text": ["没错 冲突", "既然是散列", "冲突就必然不可避免", "不过好在", "我们这里只用到了指纹相等置于匹配的必要性", "至于散列中的试探过程 完全同理", "你应该记得", "在试探查找的过程中", "即便我们发现对应的桶非空", "我们也不会贸然地认为它必定就是我们要找的元素", "是的 为了最终确定它的身份", "我们还需要做一次严格的比对", "而在这里 我们也不妨沿用这种方法", "来看这样一个实例", "依然是刚才我们已经熟知的那个文本串", "只不过这里将模式串替换为1 8 2 8 4", "首先确认 模式串的指纹为48", "以下 我们依然是去逐个尝试每一个对齐位置", "在第一个对齐位置 我们得到的是指纹22", "既然它与目标的48不等", "我们也可自然地将这一对齐位置排除掉", "接下来的第2个对齐位置", "所对应的局部子串是7 1 8 2 8", "很显然 它并不是我们要找的模式串", "然而很不幸", "它所对应的指纹", "却是48", "与模式串的指纹一模一样", "当然 这也没有什么奇怪的", "两个不同的元素在经过散列变化之后", "有可能会被映射到同一个散列码", "这种现象正是我们所谓的冲突", "好在我们沿用了散列表的策略", "我们在这种情况下还会对这两个字符串作逐位的比对", "以最终确定它的确是匹配", "当然 经过这样的严格比对之后", "我们也的确可以排除掉这个对齐位置", "事实上 这个算法会如此不断地运行下去", "直到最终抵达真正的匹配串 也就是1 8 2 8 4", "当然 我们的算法在此 也不会遗漏掉这次匹配", "因为显然 这个局部子串所对应的散列码", "也应该是48", "这样 我们又再次向前迈出了坚实的一步", "至此 我们距离Karp-Rabin算法只差最终的一小步了"]}, {"name": "06D-6 多可达域", "block_id": "65ea4be644024dd0b21717d6c3ceae1d", "text": ["如果你还记得", "我们对广度优先遍历算法", "bfs的处理手法", "就不难发现", "我们完全可以效仿那种做法", "在这样的dfs算法之外", "再包装一层循环", "来枚举图中的所有顶点", "这样的话就可以无一遗漏地", "遍历图中的所有顶点", "而且只要我们处理得当", "对所有可达域的遍历", "都不会彼此有所重叠", "从而在时间效率上", "也依然可以得到保证", "那么这部分内容", "我们留给大家 在课后自己完成", "从效果上看", "经过这样的一个封装以后", "我们或许应该会继而从顶点D出发", "也就是在第11秒发现顶点D", "并接下来发现一条跨越边", "再接下来 在第12秒发现顶点E", "而且同样地", "我们会在顶点E和顶点f之间", "标记出另一条跨越边", "最终 在第13秒结束对顶点E的访问", "并在第14秒结束对最终一个顶点", "也就是顶点d的访问", "至此整个这幅有向图的", "深度优先遍历过程", "也就顺利结束", "我们不妨来盘点一下", "遍历所获得的成果", "首先是这些粗边", "它们构成了两棵遍历树", "整体地构成了一个遍历森林", "此外 我们还对所有未被采纳的边", "进行了分类", "有的被分为是跨越边", "有的被归入为前向边", "而有的被归类为后向边", "无一例外 无一遗漏", "在通过遍历所获得的所有这些信息中", "遍历树或者说遍历森林", "无疑是最为重要的", "然而相对于原图", "它们毕竟只不过是一个子集", "这样一个子集所携带的", "难道是原图的所有信息吗？", "从某种意义上讲 的确是这样的", "而其中至关重要的一点就在于", "我们通过遍历不仅获得了这样一棵树", "而且为每一个顶点都标记了dTime", "和fTime两类时间标签", "而这两类时间标签的作用", "是非常巨大的", "这种作用之大远远超过你的直观想象"]}, {"name": "01XC-4: Fib()：递归跟踪", "block_id": "80fcf851e63e4ac398d993340b95dad1", "text": ["我们也可以采用", "我们的第二种手段", "也就是递归跟踪", "来对刚才那个", "所谓的算法进行分析", "比如说 不用多", "我们只要针对", "Fibonacci数第5项的计算过程", "把所有递归实例", "之间的调用关系 绘制出来", "得到这样一幅图", "我们来验证一下", "为了计算出第5项", "我们需要递归地计算出", "第4、第3项", "而为了计算出第4项", "我们需要递归地", "再计算出第3和第2项", "诸如此类地", "直到最后到平凡的情况", "也就是0或者第1项", "这个图能告诉我们什么呢？", "如果敏锐的话", "同学已经发现这个问题了", "没错 这里有大量", "重复的递归实例", "比如说2", "更不用说1", "以及0等等", "这还只是一个很小的一个数5", "如果更多的话呢", "可想而知", "会有更高的重复度", "那么准确地讲", "应该是多少呢？", "我们说其实准确地讲", "每个递归实例", "只需要一个就够了", "大家可能都记得", "以前学习Fibonacci数的时候", "老师应该讲过这样的", "一个很通俗的应用实例", "我们来考察一个上台阶的过程", "在某一个楼梯", "允许你每次走一步", "也可以每次走两步", "当然不能更多", "那么请问上到某一级", "比如说第6级台阶的时候", "总共有多少种走法", "老师应该当时讲过", "这个数字就是对应的", "比如 第6阶的话", "就是第6项Fibonacci数", "原因在哪呢？", "就是因为整个这样的一个过程", "就可以描述为", "为了上到第六层", "我们实际上 从最后的一步来看", "无非有两种走法", "一种就是从第五层", "通过一阶上来", "或者从第四层", "通过两阶上来", "整个这个情况 我们说完全如此", "所以概括而言", "实际上 每一个递归实例", "从原理上讲 只需计算一次", "非常重要 只需计算一次", "所以我们接下来的", "诀窍和改进的方法", "也就在于此", "能不能按照这样一种理解", "对每一个实例只计算一次", "从而同样地完成", "这样一个任务呢？", "我们说 可以", "而且完全可以"]}, {"name": "01XC-8: LCS：理解", "block_id": "426aefada003441ca5c6891fe9ec3b82", "text": ["如果沿用刚才那种表示方式", "我们就可以把在", "这个算法过程中", "所能够生成的", "所有的递归实例", "汇合整理成这么一张表格", "这张表格的横向和纵向", "分别对应着", "定义问题的两个序列", "而每一个横纵坐标", "所确定的由3×3 9个小方格", "对应的一个大方格", "分别对应于一个子任务", "或者是一个递归实例", "我们可以看到", "如果是减而治之的情况", "就直接绘制成一条对角线", "比如说 这个地方的A", "和这个地方的A 是相等的", "刚才说过 这是减而治之", "所以我们会直接去把", "这两个A都抹除掉", "递归地求解", "它左上方的那个问题", "对应的就是ADV和EDUC", "所对应的那个子问题", "如果递归地求解", "能得到是1", "那么我们只要", "在它的基础上缀上A", "从长度上来讲 再加1", "就可以得到原问题的解", "那么对于分而治之的情况呢？", "我们会同时考虑它的上方", "那个子问题和", "左侧那个子问题", "对于这个问题而言", "这是T 和这边的I", "是不相等的", "所以这个问题", "应该属于分而治之的情况", "这时候我们要考虑", "左侧去掉了I", "对应的那个问题", "我们说它的解", "递归地可以求到 是3", "以及上方去掉了", "这边的T所对应的那个问题", "那么它的解", "递归地可以求到 是2", "而这个原问题的解是多少呢？", "那么就应该是在", "这两个子问题的解", "也就是3和2之间", "取更长者 也就是3", "所以这里我们把通往更长者", "那子问题的那条递归的边", "保留下来", "而更短的那条边 给它去掉", "当然也有可能", "有的时候是歧义的", "比如说 在这个时候", "这个3 既可以理解成", "是从这儿 延续下来的", "也可以理解成是从这儿", "延续下来的", "无论如何 我们都可以表示成", "这样的一个形式", "这样的形式有什么好处呢？", "我们说这个形式", "可以帮助我们理解", "整个计算的过程", "具体来说 我们可以看到", "在这样的一张表中", "我们最终求解的问题", "实际上 必然是右下角这个单元", "所对应的子问题", "而它呢 分别会递归地引发", "一些更小的子问题", "直到最终收缩到平凡的", "长度为0的问题", "我们也可以认为", "每一个LCS 最终的解", "其实都对应于 从最左上角", "这个0 0 这个位置", "一直沿着刚才的", "这种可行的深色的路线", "通往最右下角", "这个单元的一条路径", "每一条这样的路径", "对应于这样一个解", "反之 每一个这样的解", "也必然对应着一条路径", "所以在这里头", "我们很好地可以来解释", "所谓的多个解的情况", "也就是说 同时可能存在多条路", "我们来看 从这个地方", "第一个字符D 是必须要去的", "第二个字符A 也是必须要去的", "但是第三个字符", "我们可以走T 也可以走N", "然后 第四个字符", "我们又重新走下一个A", "所以 这也是为什么", "这个问题具有两个解", "一个是data", "一个是dana", "当然我们也鼓励同学 在课后", "针对讲义 考察这个例子", "同样 解释为什么", "不仅有多个解", "而且它同时存在这样的歧义"]}, {"name": "08B4-3\t再分裂", "block_id": "d497775eae1e426b86e223862010ccfc", "text": ["是的 如果上溢节点的父亲 原本已经处于饱和状态", "那么 如果经过分裂 并将中位数关键码插入其中的话", "父节点也将随即发生上溢", "当然这并不是什么了不起的事情", "这无非也是一次上溢而已", "故此 我们完全可以如法炮制", "继续在这个新的上溢节点中", "挑选出中位数关键码 也就是68", "并以它为界 将这个节点一分为二", "同时  中位数关键码也被提升一层 转交给它的父亲", "当然 这种上溢的现象 的确可能会持续的发生", "然而 好消息是 这种上溢的传播过程满足单调性", "也就是说 就高度而言", "逐次发生上溢的节点 应该会持续的向上", "也就是说 充其量也不过是自底而上遍历各层", "并最终抵达根节点", "当然 根节点的上溢处理 的确有些不同"]}, {"name": "05E1-3 递归实现", "block_id": "19a0ee82c50c4f2fb6869df9ab8fc29e", "text": ["其实从递归的角度来看", "以上三种典型的遍历策略 都并不难实现", "因为它们的定义本身就是递归式的", "以先序遍历为例", "只需短短的四句就可以忠实的实现", "先序遍历整体策略", "其中的第一句是对退化情况", "也就是递归基来做处理", "对于任何一个递归函数来说", "这都是非常重要的", "而且是首当其冲的", "这就犹如你在开车之前", "首先要系上安全带一样", "当然以下蕴含着一个else分支", "也就是说 当前子树非空", "以下的处理才是有意义的", "具体来说 既然是先序遍历", "那我们就需要首先将树根节点取出", "并且进行访问", "接下来呢 递归地对左子树", "也就是以左孩子为根的那棵子树进行遍历", "以及再递归地对以右孩子为根的那棵子树", "也就是右子树做递归遍历", "从而整体地完成对整树的遍历", "通过这样一个简明的递推式", "我们可以严格地证明", "这个算法具有线性的时间复杂度", "我们甚至可以说", "这已经是不能再好的结果了", "的确如此 然而这只具有渐近的意义", "在实际的运行过程中", "因为递归程序的实现机制", "并不可能做到针对具体的问题", "来量体裁衣 而只能采用通用的方法", "在运行栈中", "尽管每一个递归实例都的确只对应于一帧", "但是因为它们必须具有通用格式", "所以并不能做到足够的小", "而针对于具体的问题", "只要我们能够进行精巧的设计", "完全是可以使得每一帧做到足够小的", "尽管从big O的意义上讲", "这两种策略所对应的每一帧", "都可以认为是常数", "但是这种常数的差异 实际上是非常巨大的", "因此作为树算法的一个重要基石", "遍历算法非常有必要从递归形式", "改写为迭代形式", "同时 从学习者的角度", "经过这样的改写之后", "我们也可以对整个遍历算法的过程", "以及原理获得更加深刻的认识", "稍加观察 我们不难发现", "此处的两句递归调用", "都非常类似于我们所谓的尾递归", "其特征是递归调用出现在", "整个递归实例体的尾部", "这种递归是非常容易化解为迭代形式的", "为此我们只需引入一个栈"]}, {"name": "03D-4\t 推敲", "block_id": "418129b827844ee3a938aa05a652d821", "text": ["现在我们重新来审视一遍这个算法", "并且对其中的几个细节来做一推敲", "第一个问题是 大家注意到", "我们在这里套用了此前所实现的", "remove和insert", "这样一些标准的操作接口", "从整个代码实现的简洁性来说", "这不失为一种好办法", "但是我们要指出的是", "从效率而言 还是值得推敲的", "这其中的原因在于", "如果我们回顾一下 就会记得起来", "这两个操作都要使用到动态空间分配", "也就是insert的时候", "我们必须要用new", "remove的时候我们需要delete", "请注意 虽然这两个操作", "都可以大致认为", "依然是常数的时间复杂度", "但是从实际的时间消耗而言", "它大致是我们通常的基本操作的一百倍", "也就是说 要高出两个数量级", "因此在实际中", "这一对操作应该尽可能少的使用", "就这个意义而言", "貌似简明的这句", "或许应该改用另外一种实现方式", "比如说 或许我们可以", "只通过对这里", "和这里两处局部引用的修改", "来实现同样的功能", "另外一种可行的方式就是", "只需将M与T当前的前驱", "直接交换它们的数据域即可", "再来讨论一个更为有意思的问题", "细心的同学可能已经观察到", "有些情况下", "这样一个对M的搬动操作", "其实是不必进行的", "如果我们所找到的这个最大节点M", "恰好正是tail的直接前驱", "那么它自然已经就位", "当然也就无需搬动了", "没错", "的确有这种可能", "那么基于这样一种观察", "或许你会倾向于去做这样一种优化", "也就是说", "如果经过刚才的那样一个判断", "我们在此忽略掉", "留给大家来填空完成", "能够判断出M确实", "就是T当前的直接前驱", "那么我们就可以省略掉这样一次移动操作", "或者反过来说", "只有当这个条件不成立的时候", "我们才会真正地去执行这一句", "这样一种改进的方式 本身的确是可行的", "但是我们并不认为这是一个优化", "其中的原因在于", "在通常的随机分布下", "这种情况出现的概率极低", "以致于我们这里所做的", "这种所谓的优化会得不偿失", "对此有兴趣的同学", "可以去阅读我们的习题解析", "并且完成其中的3-14题"]}, {"name": "10b4-2: \t自上而下的上滤：效率", "block_id": "abaabe3775e74db0bf032a0ef2a42b03", "text": ["这里我们就从最坏情况的角度对上述算法的效率作一分析。", "回顾刚才的蛮力算法，我们需要需要自上向下自左而右地处理每一个节点，", "而每一个节点都要相应做一次上滤，", "因此我们也将这种建堆的模式称作自上而下的上滤。", "不难看出，在最坏的情况下，每一个节点都有可能要一直上滤到根节点，", "其对应的计算成本也应该线性正比于其深度，", "因此总体的时间成本也应该是每一个节点深度的总和。", "当然，你可以精确地对此做一个计算，", "但实际上我们只需要对部分节点进行计算就足以验证这个算法是低效的，", "比如我们不妨考虑那些所有底层的叶节点。", "我们知道，在完全二叉树中，至少有一半节点是叶节点，而且在渐进意义上它们的深度是log(n)，", "因此就大O记号而言，仅这部分节点消耗的时间就会多达nlog(n)——", "没错，多达nlog(n)。我们认为这是一个不可接受的效率。为什么这么讲呢？", "你应该记得，我们设计和实现优先级队列的最初动机在于，我们需要代价低廉", "同时又能维护所有元素之间偏序关系的结构——", "没错，偏序。", "而我们早已知道，在多达nlog(n)的时间之内，我们完全可以对所有元素做全排序——", "是的，用nlog(n)的时间，得到了一个超出我们预期的，更强的功能。", "因此反过来，我们如果只是满足于偏序，而无需考虑全序的话，或许应该能够指望成本更加低廉。", "好消息是，事实的确如此。"]}, {"name": "11d3: 画家策略", "block_id": "9b188ebdcbf14063b3b7121afa787823", "text": ["这里 我们就给出bc表一种可能的构造算法", "我们知道 bc表需要为字母表中的每一个字符准备一个表项", "二者的长度相等", "因此  我们首先就要为它开辟出这样的一个空间", "比如 长度为256", "接下来 我们需要通过一趟循环遍历", "将所有表项的初值", "统一设为-1", "如果你能从设置哨兵的角度来看待这一操作", "那么就可以非常清晰地理解这步操作的涵义", "是的 这样等效于将所有的表项都统一地指向那个通配的哨兵", "接下来又是一趟循环", "这一个循环将遍历整个模式串", "逐一地枚举出其中的每一个字符", "并用这个字符所对应的秩", "来更新对应的bc表项", "请注意 即便同一个字符在模式串中出现了多次", "按照这种方法", "依然可以按照我们的要求正确地设置好对应的bc表项", "其原因在于", "我们这里采用的是自左向右的扫描次序", "而整个计算过程采用的正是画家的策略", "也就是说 在画布上的任何一个位置", "后画上去的颜料必然会覆盖掉此前所画的颜料", "而当画家作画完毕时", "每一个位置所体现的颜色", "是取决于在那个位置上留下的最后一笔", "因此就bc表而言", "任何一个字符所对应表项的最终取值", "是取决于它在模式串中出现位置最靠后的那一次", "可以看到", "在空间上 这里的消耗主要来自于", "bc表本身", "因此 空间复杂度应该线性正比于字母表的规模", "构造bc表所需的时间主要花费在两次for循环上", "前者 依然线性正比于字母表的规模", "而后者 则线性正比于模式串的长度", "在这里 有一个非常有趣的问题", "也就是说", "第一趟循环实际上是可能省略的", "而且这种方法是通用的", "可以适用于任何散列表的初始化", "如果你对此感兴趣", "同样可以参考我们所提供的习题解析中的对应习题", "那么 使用如此构造出来的bc表", "BM算法本身的性能", "又是怎样的呢"]}, {"name": "10xa3-1: 插入即是合并", "block_id": "b7824d4012824b5793deca0904d885b3", "text": ["以上，我们已经实现了对于左式堆来说最为在意的合并算法。", "非常有意思的是，尽管合并操作并非优先级队列所要求的基本操作接口。", "但基于合并操作，我们同样可以实现左式堆高效的插入和删除操作。", "也就是说，从本质上讲，左式堆只需要“合并”这一个操作便足矣。", "正所谓“一招鲜，吃遍天”。", "我们首先来看，如何基于合并操作实现左式堆的节点插入算法：", "这就是一个典型的场景。我们需要将一个新的节点e插入到一个已有的左式堆中。", "这样一个场景与左式堆的合并算法有什么联系呢？", "没错，只要将这个新的节点视作只含一个节点的左式堆，", "那么这次插入操作不就是一次不折不扣的合并操作吗？", "如果你能参透这一点，你就自然能够写出这样一个算法。", "我们可以将这个待插入的元素封装为一个二叉树的节点，", "当然它也自然就是一个左式堆的节点。", "或者更进一步地，它也就是以它自己为唯一成员的左式堆的根节点。", "因此根据刚才所参悟到的原理，我们只需要调用左式堆标准的合并接口，", "将这个新生成的节点与此前的左式堆合并起来。", "除此之外，我们并没有更多的实质操作，仅此而已。"]}, {"name": "01b-8: \tRAM实例", "block_id": "c90f2f191fef400283dfc603f452dcac", "text": ["我们来看基于RAM模型", "实现的一个具体算法实例", "这个算法的功能是", "在向下取整的意义上的除法", "具体来说 对于任何一个非负整数c", "和正整数d 我们都需要在做完除法之后", "再实施向下取整 得到一个整数", "那么这个输出", "实际上也就是不超过c/d的那个最大整数", "我们可以将它表述为", "在所有那些与d相乘以后", "不大于c的整数x中的最大值", "也可以等效的表述为", "在所有乘以d以后严格的小于c+1的", "那些整数x中的最大值", "这样一种重新的表述", "其实不光是文字上的一个转换", "更重要的是", "它为我们提供了一个对应的算法思路", "我们可以将它表述并且实现如下", "具体来讲 我们需要保留c+1", "并且以它为基础 反复的从中去减除d", "因为RAM模型只支持加或者减运算", "不断的减除", "直到对应的那个寄存器R[0]发生下溢", "也就是说 它不再是一个正数", "这个时候 我们统计下", "在此之前所做过减法运算次数", "那么它就是我们所要得到的输出", "我们可以将整个这个思路兑现如下", "因为这里所有的加法运算和减法运算", "都不允许直接对常数进行", "而我们一上来就需要做个预处理", "对c+1 所有需要利用常数赋值语句", "将这个增量1预先的存到一个寄存器", "比如R[3]中去", "所有接下来我们对R[0]", "也就是最初输入的c", "加R[3]之后 实际上效果就是c自增", "所以在经过这样的预处理之后", "c+1确实被存放到R[0]中去了", "那么接下来 从第二句开始", "如果注意到这里有个goto第2个语句的话", "我们就知道这实际上是构成了一个循环", "那么这个循环是做什么事呢", "正如我们前面所说的那样", "它是不断的需要从刚才那个量里头去", "刨除掉d", "d本身也是作为输入的一部分", "已经事先存放在1号寄存器中了", "所以每次做的事情", "就是从刚才经过预处理以后", "存放的实际上是c+1的", "那个寄存器R[0]中减除掉d", "不断的减除 每减除一次", "我们刚才说过", "要相应的把计数器累计", "这个计数器在哪呢", "在我们这里取做的就是R[2]", "第2个寄存器 它的初值是0", "所以每一次它都要自加", "加一个1 而加的这个1", "依然是通过我们预先赋值", "那个常数存到R[3]中去来实现", "经过了这样一次自减", "经过了一次计数器的累加之后", "我们这个时候就要判断 R[0]", "也就是c+1初始的那个数", "是否已经不再是一个正数了", "如果它还是正数", "那就说明还没有减除完", "这个时候我们可以通过goto语句", "像刚才所说的继续执行这一步", "所以反过来说", "如果我们有朝一日执行到了第5条语句", "那就说明R[0]经过若干次减除以后", "已经不再是一个正数", "而这个时候呢", "我们大致就可以返回这个x", "当然 通过精细的分析我们会发现", "实际上这个数值是差一的", "所以这里头我们还要将R[3]", "也就是原来存放的这个常数1", "再减一次", "经过了这样一次减法以后", "再把这个数值返回回去", "才会得到真正准确的", "我们所需要的那个向下取整的除法值", "那么我们把这样的一个", "具体实例也罗列出来了", "具体来说就是", "对于c=12以及d=5来做的一个除法", "不难发现 如果不取整的话是2.4", "所以向下取整的话 应该得到的是2", "不出意外 在我们对照代码", "逐行逐条的将整个寄存器序列的内容", "作一罗列之后", "我们会发现 最终在R[0]这个位置上", "会得到并且返回我们", "所需要的那个值 也就是2", "那么这个算法的正确性", "以及更多的例子的给出", "留给同学们在课后完成", "而我们这里需要向大家", "传达的一个重要的概念", "是这张表所暗示的", "也就是说 我们不光可以把整个计算过程", "逐次罗列出来", "更重要的是 正像刚才所说的那样", "我们将整个计算过程所需要的计算成本", "转化为了这个表的规模 或者说它的高度", "具体来说就是它的行数", "其实就是执行的基本操作的次数", "按照我们刚才的推断", "实际上就是我们这个算法", "所需时间的一个最客观的度量", "而这个度量是清晰的 明确的", "可比较的 而且没有歧义的", "概括一下", "我们通过图灵机模型和RAM模型", "给大家一个清晰的尺度", "这个尺度确实可以用来对算法进行度量", "我们可以此判断 哪个算法的性能更好", "至少在什么情况下更好", "当然 也像我们开篇的时候所说的那样", "这只是一把尺子", "我们这节只告诉你尺子是什么", "那么更重要的一个问题就是", "尺子怎么用 如何用好这把尺子", "有什么样的一些规则 有哪些技巧", "那么我们要留待后续课节再向大家作介绍"]}, {"name": "07C-1 极端退化", "block_id": "6b6eaee631c8406bad8199a4092aefe7", "text": ["同学们好", "本章前两节所引入的二叉搜索树", "为我们同时实现对数据集", "高效的静态操作以及动态操作", "打开了一扇新的大门", "正如我们所看到的", "从策略上 BST可以视作是", "试图将此前的向量结构", "以及列表结构的优势结合起来", "然而多少令我们失望的是", "我们目前所实现的BST", "还显得略微有些粗糙", "这表现为它的时间复杂度", "在最坏的情况下", "仍未得到有效地控制", "在上一节我们讨论了", "BST各种接口算法的具体实现", "概括而言 无论是静态的search操作", "还是动态的insert或remove操作", "在最坏的情况下 它们所需要的时间", "都线性正比于树的高度", "然后对于BST的高度", "我们至今为止还没有任何有效的控制方法", "比如作为一种极端情况", "我们假设在一棵BST中", "所有的节点度数都不超过1", "也就是说 从整体的拓扑结构而言", "这棵树实际上已经退化成了一条单链", "从逻辑结构看", "已经完全退化地等效为一个列表", "不难看出 此时整棵树的高度", "与整棵树中节点的个数", "成线性正比关系", "在这种情况下", "无论是就平均 还是最坏意义而言", "静态操作以及动态操作", "都需要高达O(n)的时间", "这一结论也不足为怪", "因为毕竟在此时整棵树", "已经退化成了一条一维列表", "当然 这只是一种极端的退化情况", "而若要对BST的总体性能", "做出一个更加客观的评价", "我们或许应该就BST的平均性能", "做一个系统的分析"]}, {"name": "05E1-7 新构思", "block_id": "2f8e9e2868804c378e97e3abd1f2d3d3", "text": ["我们不妨将每一条这样的左侧链", "也就是这样的一个left branch", "突出地绘制出来", "当然它的长度必然有限", "我们假设长度为d 终止于Ld", "那么相应的呢 沿途的每一个节点", "也应该各自有一个右孩子以及右子树", "右孩子以及右子树", "尽管有可能这个右孩子或者这个右子树", "根本就不存在", "我们也不妨将它折叠起来", "统一地画成这样一个形式", "你不难说服自己", "任何一棵二叉树都可以抽象地表示为", "这样的一个沿左侧链不断下行", "同时 其它的部分分别地归入于", "这个左侧链上沿途各个节点的", "右子树的形式", "经过了这样的一个抽象", "我们就很清楚地能看到", "整个先序遍历的次序和脉络了", "的确可以看到在任何", "这样的一棵子树的局部", "我们的访问都是", "首先沿着这样一个左侧的分支", "依次地去访问各个节点", "正如我们刚才所看到的", "第一批被访问的节点", "必然是左侧分支上沿途的这些节点", "当然这样一个过程必然会终止于", "刚才我们所约定的那个Ld", "的确如此", "整个遍历的这个故事", "在这个地方情节发生了转折", "因为接下来 从宏观上看", "我们应该调转方向 自底而上的", "依次去遍历刚才所定义的", "这一系列的右子树", "没错 最低的这棵右子树", "稍高一些的右子树", "再以及更高一些的", "乃至再高一些的", "以至最高的那棵右子树", "对于这些右子树 我们需要做什么呢？", "同样地 是做遍历", "好 我们再总结一下", "整个过程分为两个阶段", "首先是自顶而下地依次访问", "左侧链上的沿途节点", "再倒过来 自底而上地依次遍历", "各个层次上的每一棵右子树", "这就是我们整个先序遍历的宏观过程", "而我们的算法", "正是沿着这样的一个思路来进行设计的"]}, {"name": "04C2-2\t 尝试", "block_id": "673389ee248b4342a7993aeae93a7121", "text": ["为了得到这个问题的有效解法", "我们或许应该继续沿用", "不断将问题简化的总体策略", "为此 我们需要首先来考察", "最基本的平凡情况", "也就是 如果一个表达式", "根本就不含任何的括号", "从而实质上等价于一个空串", "那么它自然是匹配的", "接下来 我们注意到这样一个事实", "如果某一个表达式E", "已经是括号匹配的", "那么我们在它的左侧和右侧", "添加一对匹配的括号", "那么整体依然将是匹配的", "此外我们也会注意到", "如果两个表达式E和F", "已经是各自匹配的", "那么我们只要将它们串接起来", "就可以得到一个更大的匹配表达式", "然而很遗憾", "这两个性质都不能", "使得我们很好地运用此前所介绍的", "减而治之或者分而治之的策略", "请注意", "我们这里两条性质的条件都是仅当", "也就是only if", "从逻辑推理的方向来看", "它是由左侧的前命题", "推向右侧的后命题", "与我们简化问题的方向背道而驰", "它们只能作为", "括号匹配判断的必要条件", "而不是充分条件", "事实上 它们各自都存在对应的反例", "我们来看第一个反例", "表达式E是中间这一段", "显然它是不匹配的", "因为我们看到", "它是以一个左括号结尾", "但是如果我们在它的末端和前方", "分别配上一个右括号和左括号", "居然可以得到一个完全匹配的表达式", "这意味着我们不能", "如此来做减而治之", "类似地 再来考虑下面这个反例", "如果左侧这个子表达式是E", "右侧这是F的话", "不难验证 它们都是不匹配的", "因为至少它们各自所含的括号", "都不是偶数个", "然而我们注意到", "如果将它们串接起来", "我们居然同样可以得到", "一个跟刚才一样的", "完全匹配的表达式", "这就意味着", "我们如果试图在某个地方", "来做分而治之的话", "也是不容易行得通的", "综上所述", "为了真正使这个问题", "能够得到有效的简化", "我们必须发现", "并且借助这个问题背后", "所蕴含的某种充分性"]}, {"name": "05E2-7 分摊分析", "block_id": "3793582c18894ca0902c7bd2f5087357", "text": ["最后我们重新回到这个算法", "这个算法需要运行多少时间呢？", "我们知道递归的版本可以简明地实现", "O(n)的复杂度", "尽管它的常系数非常之大", "那么如此改造之后的迭代版本", "又当如何呢？", "乍眼望去", "我们不免对这个算法的复杂度表示担忧", "因为从结构上来看", "它大体呈现的是一个循环", "以及内部隐含着还嵌套了一个循环", "而且外循环总共需要执行O(n)步", "因为它必须对每一个节点都至少访问一次", "而内循环也就是这样一个", "沿着左侧分支不断下行的过程", "在最坏的情况下 本身也可能就是O(n)", "试想这样一种最坏的情况", "也就是在从某一个节点开始的", "那样一条左侧链中", "累计包含的点数就已经达到了", "与n相当的地步", "比如说n/2或者是n/4", "都是这样", "如此说来两个规模分别为O(n)的循环", "彼此嵌套之后", "难道总体的复杂度是n^2吗？", "我们说这个结论虽然并不错误", "但是从界的估计来看 却远远地不紧", "没错 整个算法的确是呈一个迭代形式", "而且在每一步迭代中", "所对应的那样一个goAlongLeftBranch过程", "可能距离会或长或短", "甚至最长的的确会达到刚才我们说的", "Ω(n)的量级", "但是我们不难发现 所有这些左侧链的长度", "合在一起也无非是O(n)", "为了看出这一点 我们不妨将目光", "集中在这里的入栈动作上", "不难验证 整个算法中只有这个位置", "会发生入栈操作", "而且进一步地 每一个节点", "至多会参与一次入栈操作", "回到这个图", "每一个节点的入栈操作", "无非对应的是它所属的那个", "左侧链上的一步", "因此所有这些左侧链的长度", "无非就是这些push操作的累计次数", "而这个次数我们刚才说过了", "不会超过所有的点数", "也就是O(n)", "因此我们刚才所得到的这样一个", "n平方的结果只不过是一个假象", "这一估计远远不紧", "形象地说 这就犹如我们在估计的时候", "使用了这样一个n乘以n的方框", "里面有很多长条 或长或短", "它们累计 不过这个方框的面积", "也就是刚才所说的n平方", "而更准确地说", "它们的累计长度也只不过是", "与n在同一个数量级的O(n)", "所以现在我们终于得出了一个结论", "也就是整个这样一个迭代的版本", "所需要的运行时间依然是线性的", "而且更重要的是 相对于此前", "递归版本的线性", "这里虽然从程序结构上讲更为复杂", "但是从常系数的意义而言", "却要远胜于递归的版本", "这也是本节的立论依据", "以及我们所做相关研究的意义所在", "你或许已经看出来了", "我们这里所采用的方法", "无非就是分摊分析", "这种分析的方法和技巧", "也同样适用于其它几种迭代的遍历算法"]}, {"name": "01a-3: \t尺规计算机", "block_id": "a6bb13b456834d7395b7e12066029eb3", "text": ["我们再来看另一个例子", "这个例子来自于我们中学的平面几何", "也就说任意的给定由端点AB确定的一条线段", "如何在这条线段上找出恰当的两个切分点", "使得这两个切分点能够将这条线段", "均匀的切分为3段", "稍加回忆以后 我相信大家都会想起", "中学的尺规作图解法", "大致可以描述成这样", "首先 我们从它的某一个端点", "不失一般性 比如说取做A出发", "做一条非退化 也就是和AB不重合的射线", "并且在这条射线上", "取间距相等的3个点", "注意 它们的间距相等", "但是它们的总长未必是等于AB", "好 接下来我们连接B'和B", "这样呢 我们得到了一条线段", "当然也包括它所在的那条直线", "好 在接下来我们经过D'", "做这条直线的平行线", "那么当然它会与AB相交于一个点", "我们称这个点对应的叫做D", "同样的对另一个刚才我们取的点C'", "我们也做类似的操作", "通过引入一条经过它的平行线", "和AB产生第二个交点", "我们说这个时候 C和D这两个交点", "就是我们问题所需要得到的解", "因为这两个点恰好把这条直线", "切分为均匀等长的3段", "那么它背后的原理在这里不用再重复了", "我们需要的是从计算的角度", "来反思一下这个过程", "我们说 计算的过程确实需要工具的", "我们在这里用的工具是什么呢", "应该就是欧式作图所允许的那两样东西", "理想的直尺和理想的圆规", "所以这种工具我们也可以", "不妨称做是尺规计算机", "另外呢 我们也注意到整个这个计算过程", "也是会被分解为若干步骤", "而且每一步骤都可以明确的描述出来", "并且机械的执行", "这与刚才绳索计算机是类似的", "当然作为拓展我们还有一些问题", "比如说这种类计算机作为任何一类计算机", "它能解决什么 它能力范围在哪", "以及它不能解决什么", "这个是大家课后去思考的", "另外我们注意到", "这里我们实际上隐隐约约也隐含了一种", "如果在程序员的那个角度来看叫做子程序的概念", "也就说一个算法里头", "可能同时它又会包含解决另一个", "相对来说更小的问题的一个算法", "不妨称它也相应的叫做子算法", "比如在这里 如果大家观察仔细的话", "就会注意到 其实刚才我们有个通用步骤", "就是过给定一条直线的外面一点做它的平行线", "这件事只在这里头说了一句", "但实际上它本身就是作图的一个问题", "当然我们也知道它肯定能做出来", "只不过在这里没有详细的交代而已", "在这里我们也发现 算法与算法之间", "实际上也可以互相的套用", "这是它的一个特点", "但总而言之 它本质的特点", "其实我们通过这两个例子已经能够看出来", "我们现在也许已经到了", "可以稍微做一个总结的时候了"]}, {"name": "09E-1 大数据 + 小范围", "block_id": "c55f5cd5a2b74da2afc23c5a74fcba88", "text": ["作为散列思想的一个具体应用实例", "我们来学习桶排序算法 以及相应的计数排序算法", "有意思的是 这类算法的性能", "已经不再完全取决于输入的规模", "也就是待排序序列的长度n", "同时也取决于待排序元素的取值范围 通常记作M", "不失一般性 可设为是从0到M的一个整数区间", "没错 M", "你应该记得 我们曾经用它来表示过散列表的长度", "事实上新算法的渐近时间复杂度将是O意义下的n+M", "或者等效的 取决于n与M之间的更大值", "因此 待排序元素的取值范围越是有限", "这种算法的优势也就越是明显", "比如在很多应用中 元素的取值范围 都会不超过O(n)", "当然 这也意味着在输入元素中 存在着大量的重复", "而若果真如此 新的算法就有望在线性的时间内完成排序", "我们来考察对一组英文大写字母的排序问题", "比如这一行就是输入的待排序序列", "而这一行 则是对应的排序序列", "我们现在就来看看 如何采用桶排序和计数排序算法", "完成这一有序化的任务", "首先 不妨来感受一下", "无论输入序列如何变化", "我们的算法总是可以正确的完成有序化的任务", "那么这里的桶排序和计数排序 究竟是如何工作的呢", "其原理又是怎样的呢"]}, {"name": "01c-4\t: 有效解", "block_id": "141b29a77dac437cb151518a08734eb7", "text": ["接下来的一个刻度 是一个大家族", "我们统称之为多项式复杂度", "我们可以看到多项式复杂度", "从一般的意义上讲", "确实呈现出多项式的一个形式", "正如我们此前讲过的", "所有的低次项 其实都是可以忽略的", "即便是最高次项", "它的常系数也是可以去掉的", "所以我们说这类的复杂度", "可以很简明的界定为 其中最高次", "也就是这个多项式本身的次数", "这样的一个复杂度", "它的具体形式很多", "比如说我们看 这是一次方的", "这个地方呢 我们也可以做这种", "以后要习惯于这种一眼看过去的计算", "比如说 在这里我们可以很快地把这个抹掉", "在这里 可以把这个和这个都抹掉", "所以很快地 我们可以得到这两项", "而这两项的常系数 其实我们都可以抹掉", "或者说等效地 把它们当成1", "所以很快地 可以得到结果", "是n的3次方", "这个地方也一样", "我们很快把这些低次项抹掉", "把常系数抹掉", "很快地 做一个指数之间的减法", "2减1次方 所以很快地也能得到是1次方", "笼统来说 它们都属于多项式形式的复杂度", "在其中 有必要提一下的", "就是所谓的线性复杂度", "也就是说 对于一个规模为n的问题", "它所需要的时间成本", "恰好就是由n一阶的 来度量的", "在我们的很多相应的编程习题中", "更多的问题 大部分的问题", "都是介乎n的1次方到n的平方之间复杂度", "更高的复杂度 其实会使得这个问题的难度一下增加", "计算时间也会很快地提高", "我们可以再来看 这样一个", "稍微复杂一些的例子", "同样用我们刚才的那些方法", "可以看到 先从最里层来入手", "经过比较以后 可以断定", "低次项都是可以抹掉的", "所以我们可以很快地得到", "这个的结果应该是 2013除以3", "应该就是671 这是它的次数", "所以相对而言 后边的这个", "无论是567 还是 更不用说是123", "都是更低阶的 都可以直接忽略掉", "所以相应的 我们这里头其实就等于是", "可以估算为是 n的671次方", "再经过1次开方 再除一个11以后", "我们就可以得到是 n的61次方", "以后 我们要习惯于这样的估算", "这类算法的效率 通常我们认为是", "已经可以令人满意的了", "当然 我想第一次接触到这个结论的同学", "往往持一个怀疑的态度", "这样的一个标准是不是太低了呢？", "因为我们说这里的多项式的阶次c", "并没有更多的限定", "只要它是个正数就可以", "它可能是1 可能是2", "也可能是20 甚至可能300 4万", "难道这样就可以了吗？", "我们说确实是如此", "因为在理论上讲 我们不得不把它归类为", "稍微容易求解的问题", "而再往下的问题 我们的下一个刻度", "就要被归结为所谓难解的问题"]}, {"name": "02D5-3\t 性能分析", "block_id": "2a9c9e56bab448afb723ba3415884072", "text": ["插值查找平均而言会怎么样？", "那么这里我们需要用到一个非常基础", "类似引理的结论", "这个结论是这么说的", "在插值查找算法中", "每经过一次迭代", "或者说每经过一次比较", "我们都可以将查找的范围", "也就是我们所说的", "减而治之之后 剩余的部分", "由原先的规模n 缩减为根号n", "通过姚先生", "包括其他人在早期的一些精确的论证", "可以证明这一点", "在习题解析第二章的第24题中", "我们也花了相当的篇幅", "给出了较为严密的这样的一个证明", "所以在这里", "我们不妨把这个作为一个事实", "再说一遍 每经过一次比较", "插值查找算法", "就可以将查找范围从n缩短为根号n", "那么根据这样的一个事实", "我们就不难得出这个算法整体的效率了", "也就是平均而言", "大致需要做多少次迭代", "因为查找区间的宽度必然是从n", "变到根号n 然后继续开根号", "再开根号 一直开下去", "直到开到足够小的一个数", "平凡的情况", "那么在此期间", "我们总共要迭代多少次呢？", "我们不妨把它写出来", "每一次开方 相当于在做一次1/2次方", "每做一次 就是1/2次方", "累计起来 如果是叠加了k步的话", "那么当然是1/2次方的k次方", "然后再去做n的指数 这么多幂", "那么这个数在什么情况下", "又小于2了呢", "那么这个应该是很基本的数学功夫", "这样的一个代数推导", "我们留给大家", "我们说最后的结论是", "总体只需要log再取一次log", "loglogn这么多次迭代", "当然 从渐近的意义上讲", "比原来说的logn要小很多", "从这个图我们也可以大致看出来", "如果原来这个是n的话", "很快就缩减为根号n", "再根号根号n 根号根号根号n", "一直下去 很快就会收敛 收敛的非常快", "当然我们这里跟此前我们所强调的一样", "我们并不希望过多的使用数学", "而是应该恰当的使用数学", "比如在很多时候 你应该学会准确的估算", "那么我们来看看", "对于这个例子而言", "我们同样可以来估算"]}, {"name": "10b4-4\t: 自下而上的下滤：实例", "block_id": "70f94333875e4b4883afc0b10353dafe", "text": ["来看这样一个实例，这是由9个节点构成的一棵完全二叉树，", "因此在物理上的向量中，最末尾内部节点所对应的秩也就是floor(9/2)-1=3，", "也就是这个节点。请不要误解，这里它的数值也为3，纯属巧合。", "请注意，在初始情况下，无论如何，每一个叶节点都可以认为是自成为一个子堆，", "因此在此局部恰好就构成了我们此前所说的一个典型的模式：局部的子树根，", "以及下属的左和右两个子堆，我们的任务是将左和右两个子堆合二为一。", "我们的算法非常简明，为此我们只需对局部的子树根节点3做一次下滤，", "下滤的结果是这样：可以看到，不出意外，我们的确完成了两个子堆的合并，", "接下来该轮到再往前一个的内部节点，也就是6。在此，我们又一次看到了那个典型的模式：", "一个局部的子树根，以及左右两个子堆，", "同样地，我们只需对局部子树根6做一次下滤，即可将此局部调整为一个更大规模的堆，就像这样。", "再接下来，应该轮到内部节点1，请注意，这里依然是我们算法可以处理的模式：", "一个局部的子树根，以及左右两个待合并的子堆。", "依然套用现成的算法，我们只需对局部子树根1做一次下滤，即可完成局部的合并。", "合并的结果是这样。", "好，最终应该轮到全树的根节点2，", "此时我们依然可以看到这样一个算法可以处理的典型模式：", "根节点，以及左右两个待合并的子堆。", "对于我们的处理手法，你现在应该非常熟悉了：", "只需对根节点做一次下滤，即可完成整体的合并。", "最终的结果是这样：不出意外，我们的确得到了一个由所有元素构成的完全二叉堆。", "这个算法的正确性也同样显而易见，那么它的效率究竟有多高呢？", "是否如我们所预期的那样，严格优于我们此前的nlog(n)呢？"]}, {"name": "02A-4\t 构造与析构", "block_id": "c022cd0c7dc9489d9dbc1be70b7bdd0e", "text": ["在明确了向量结构的", "上述接口规范之后", "我们就可以遵照这种规范来看一下", "如何具体地 在C++语言的平台上", "实现这样一种向量模板类Vector结构", "那么这里我们讲一下", "在大家可以下载到的讲稿中", "你都可以去关注一下", "这些对应结构和算法的链接", "比如说这个链接", "只要你的电脑是在线的", "你就可以通过一次点击", "直接从我们的课程服务器中打开", "并且阅读对应的源代码", "就这个例子而言", "这里给出了Vector这种模板类的", "详细的实现", "课堂上 不可能把所有的细节", "都展示出来", "所以我们把它的主体框架给出来", "我们来看一下", "首先这里约定用int", "来定义这里所说的秩这种概念", "接下来 因为我们会首先采用", "一种基本的扩容方式", "它的初始容量需要设定", "这里不妨取它的DEFAULT_CAPACITY", "取作3 当然", "这只是为了测试和演示", "我们取非常小的一个数", "在实际应用中呢", "你完全可以取更大的一个数", "那么下面是C++语言中", "基本的一个模式", "如果大家以前学过 固然很好", "如果没有学过的话", "我们也可以简单地来看一下", "也就是 我们通过template这种方式", "再给一个模板参数T", "它的意思可以认为是", "我们定义了一个Vector这样的模板类", "其中的元素类型是什么呢？", "可以是将来指定的任何名字", "现在叫作T的类型", "所以与其说它写的是一个类", "不如说这个模板类", "给的是一系列的类", "你可以根据实际需要", "直接地生成相应的Vector类", "好 那么在这里头呢", "我们有一些私有的", "也就是封装和隐藏起来的变量", "比如说 它内部会记忆", "它到底有多少个元素", "我们有一个_size 在内部", "我们在前面加一个下划线来表示", "以及它目前的容量", "也就是加了下划线以后的_capacity", "还有呢", "包括真正存放元素的一个空间", "我们可以看到这确实是", "地址连续的一段空间", "那么其它的内部函数", "以及公开的接口函数", "我们会在后边陆续介绍", "我们来看一下它的原理", "正像我们原来所说的", "整个Vector结构是被封装起来", "那么能供来自各种应用的用户", "使用的操作接口有哪些呢？", "是这些", "这些就相当于", "Vector结构的使用说明书", "它告诉你这里提供了", "哪些操作渠道 途径以及可能", "用户呢 如果他感兴趣", "固然可以把这个结构打开", "去了解它是怎么实现的", "如果不感兴趣", "他完全可以按照说明书", "通过这种接口规范直接使用", "所以这里我们也可以看得出来", "经过了这样地一个剥离之后", "确实使得我们的应用和我们的实现", "相互之间可以很好的分工", "又同时很好的协作", "那么具体内部怎么实现的呢？", "我们这里可以看得出来", "其实是开辟了一个", "名字叫作_elem的数据区", "它的容量至少要足以容纳", "所存放的有效数据", "对外而言的每一个元素", "都通过某种形式转译为", "内部这段数据区中的", "实际上是这个有效的数据区中的", "某一个元素", "由此实现了", "对内部数据项的封装", "作为一种数据结构", "与所有的类一样", "Vector也首先需要解决", "构造和析构的问题", "我们来看一下", "向量的默认的构造", "实际上只需指明", "初始的容量就可以了", "如果没有指定", "会按照默认的容量", "指定一个数值", "那么在内部的操作呢", "其实就是通过new", "申请一个长度为c", "基本类型就是模板参数T的", "一段连续的数据空间", "在创建了这样一个空间之后", "我们把这个空间的首地址", "交给内部的_elem记下来", "当然 这个时候虽然它有一定的空间", "但是其中有效的数据", "其实是没有的", "所以这就是为什么", "_size初始化是0", "当然我们还有其它的一些构造的方法", "比如说 如果已经有一组", "以数组的形式存放的数据", "我们也可以将其中", "从lo到hi的这段区间", "中的元素取出来", "作为初始向量", "我们可以看到", "它是通过调用一个叫作", "copyFrom()的内部接口实现的", "同样地 它还重载了其它的一些形式", "比如说 我们被复制的元素", "可能不见得是来自于一个数组", "而是来自于一个本身已经被封装了的向量", "这也不要紧 我们可以从这个向量的", "_elem区域中去读取出来", "并且同样调用copyFrom()来做这件事", "所以这里有区间的复制", "也可以有对整个向量的一个克隆", "那么析构呢", "当然也是反过来的逆过程", "只需要把这个曾经动态分配", "获得的数据区域释放掉", "归还给操作系统", "所以我们这里的关键问题在于", "copyFrom()这个接口如何地来实现"]}, {"name": "12a2-3: 平均情况", "block_id": "7042db9e4296422b95a1a9d9c4e81e6e", "text": ["非常幸运的是以上基本的", "快速排序算法", "在常规的随机意义下", "平均性能的确可以达到最优的nlogn", "以下我们不妨针对", "最为常见的均匀独立分布", "来做一精确的估算", "也就是说我们在这里假设", "所有的元素都是均匀的取自于", "某一个数值范围", "同时各元素在确定各自取值时", "是互不依赖的", "我们来考察任何一个这样的随机序列", "调用partition算法", "对它所进行的划分", "将有几种可能呢 无非n种可能", "具体是哪种情况", "完全取决于最初所选定的", "那个侯选轴点", "更准确的讲", "是这个侯选轴点", "在最终有序序列中", "所具有的秩", "如果将侯选轴点的这个秩", "记作k", "那么partition算法所输出的", "子序列L长度也应该是k", "这个子序列所对应的那个子任务", "所需的平均运行时间", "也因此就可以表示为Tk", "对称的partition算法", "所输出的子序列G", "长度应该为n减k减1", "这个子序列所对应的那个子任务", "从递归的角度来看", "所需要的平均运行时间也因此", "可以表示为T n减k再减1", "这样的一对排序子任务", "总共所需要的运行时间也自然就是", "二者之和", "进一步的", "既然按照假设这里服从均匀独立分布", "因此各种情况出现的概率应该均等", "具体来说都是n分之1", "因此所有这些情况所对应的", "平均运行时间", "也就是用这个概率对它们的总和", "进行平均", "以下的分析", "焦点就会聚在这个求和号上", "尽管这个求和涉及到", "前后两个序列", "但是略加观察之后", "我们不难发现", "这两个序列的求和", "应该完全是相等的", "你能看出原因来吗", "没错", "这两个序列的取值范围", "都是从零到n减1", "只不过前者是递增的", "从零到n减1", "而后者只不过是递减的", "从n减1到0", "因此我们只需保留其中的一项", "同时作为补偿", "将它的系数加倍", "接下来我们将这个等式的两端", "同时乘以n", "于是就可以得到这样一个等式", "如果将其中所有的n都替换为n减1", "我们又可以进而得到下面这个等式", "现在我们只需将这两个等式相减", "就可以得到这样一个等式", "除了系数这个等式主要都包含", "一个Tn以及一个和两个T n减一", "接下来我们只需对Tn和T n减1", "合并同类项", "就可以得到这样一个等式", "对于这样一个等式", "我们不妨令它的左右两端同时除以n", "以及n加1", "于是就可以得到这样一个等式", "如果我们将这个等式的左侧", "表示和理解为另一个函数Sn", "那么右侧的这一项", "也就对应于Sn减1", "这样我们也就得到了一个", "关于Sn的简明递推式", "因此接下来我们可以进而将右侧的", "Sn减1替换为Sn减2", "当然为此我们需要追加一项", "这种递推可以持续进行下去", "也就是说我们可以将Sn减2", "替换为Sn减3", "再将Sn减3替换为Sn减4", "以及Sn减4替换成Sn减5诸如此类", "在递推到最终一步之前", "我们所引入的各项", "将构成一个级数", "你应该看得出来这是一个什么级数", "没错 调和级数", "我们在第一章就曾介绍过", "就渐进意义而言", "调和级数是与自然对数logN同接的", "由此可见我们这里所需要的估计的", "快速排序算法的平均运营时间", "在渐进意义下的确不超过nlogn", "那么它对应的常系数呢", "为此我们只需将logn替换为", "以2为底的对数", "相应的也自然可以得知", "常系数应为两倍的ln2", "具体来说也就大致为1.39", "这样小的一个常系数也保证了", "快速排序算法在通常情况下的", "优异性能", "也就是说快速排序的确名副其实"]}, {"name": "03E-8\t 逆序对", "block_id": "fde9e62121c94cc09b35f8f28aa99ace", "text": ["在结束这一节之前", "我们再来讨论与插入排序非常相关", "也是非常有意思的一个问题", "我们来介绍这么样一个概念", "也就是逆序对 inversion", "对于任何一个序列", "我们都可以在其中发现这种逆序对", "既然是对 肯定就涉及到两个元素", "没错", "如果有某两个元素一左一右", "而且左侧更大一些 右侧更小一些", "我们就称它们构成了一个逆序对 一个inversion", "当然反过来 如果是这样的顺序的", "也就是左小右大的形式", "这就不是个逆序对", "当然你也可以称它叫作顺序对", "实际上 在整体的n个元素中", "任何两个元素都可能构成一个逆序对", "因此 对于一个长度为n的序列而言", "逆序对的总数有可能会多达n平方", "那么inversion和我们这一节的主题", "insertion sort是什么关系呢？", "为了说明方便", "我们先还要做一个铺垫的工作", "我们看到inversion实际上", "涉及到的是两个元素", "这样不利于我们记帐", "我们不妨采用一个统一的习惯 也就是", "将每一个inversion都记入到后边", "也就是靠右的那个元素的帐上去", "因此我们只需要", "在这种意义下 统计每一个元素", "所对应的inversion有多少个", "那么累计而言 就得到了", "整个序列中所蕴含的逆序对的数目", "再强调一遍 我们将每一个逆序对", "都记到后者的帐上去", "于是对于任何的一个节点p", "我们都可以依此来定义", "它所对应的逆序对的数目 记作i(p)", "所有节点p所对应逆序对数的总和", "也就是 整个序列所包含逆序对的总数", "好了", "回到插入排序的一般的场景", "也就是说 如果当前有序的前缀为s", "我们就要将无序后缀中的首元素", "插入到这个前缀中的适当位置", "正像我们此前所讲过的", "这个对应的位置是一个切分点", "在它之前 都是比待插入元素e", "不大的元素", "而反过来呢", "在这个分界点之后的那些元素", "都应该严格大于这个待插入的元素e", "左边都不大于e 而右边都大于e", "这说明什么呢？", "这说明这个区间内的任何一个元素", "都与待插入元素e构成了一个inversion", "而且这个inversion正好能归入到", "刚才我们记帐于p的那样一个统计值中", "或者反过来讲", "p所对应的inversion有多少个", "p就需要经过多少次比较", "才能抵达最终的插入位置", "从这个意义上说", "i(p)其实就是p所对应的查找长度", "因此 如果我们将整个序列中", "所包含的逆序对数 记作大I", "那么这个大写的I", "实际上 也就对应于插入排序算法", "在一次又一次定位搜索过程中", "比较次数的累计总和", "而这个我们说过", "就是这个算法所消耗时间的最主要部分", "当然不要忘了还有另一部分", "也就是对元素真正实施", "插入操作所花费的时间", "每个元素各自是1 累计是n", "所以确切地讲", "插入排序所需要的时间", "应该是这两个量的总和", "而刚才我们所分析的", "最好情况和最坏情况呢", "无非是它的特例", "在最好情况下", "我们讲过 它的复杂度是n", "为什么是n呢？", "回忆一下 最好情况", "就是所有的元素都是顺序输入的", "逐次递增", "我们可以看到 在这样的一个序列中", "根本就不含任何的逆序对", "逆序对的总数是0", "那么0加上n 当然也就是n了", "反过来 再看最坏的情况", "也就是 完全逆序输入的情况", "这个时候我们说过", "它的复杂度是n平方", "为什么是n平方呢？", "因为对于这样一种输入序列而言", "其中任何一对元素都是逆序的", "因此 它的逆序对的总数", "当然也就等于", "所有n个元素两两组合的总数", "这个总数恰好就是n平方量级的", "概括一下 从逆序对的角度来看", "可以将插入排序算法的复杂度", "度量为这样的一个结果", "而这个结果向下可以很好的解释", "并且对应于最好的情况", "向上也可以很好的解释", "并对应于最坏的情况", "它是一个更一般的表示", "也是一个更加本质的解释", "就这样的意义而言", "我们如果把刚才的逆序对总数", "也就是I 作为序列无序程度的度量尺度", "那么insertion sort", "就可以理解为是", "通过一次一次的努力", "去修复这种无序性", "原来有多无序 它就需要多少次修复", "因此它的算法复杂度", "其实不光是取决于问题的规模", "而更多的是取决于", "输入本身所具有的特性", "也就是它的无序程度", "所以这样一种算法", "也称作输入敏感的", "input-sensitive", "在排序算法家族中", "并非每一种算法都具有这样的一个特性", "而插入排序 也正因为它具有这样一个特性", "而显得非常的独特", "在我们最终要介绍的希尔排序中", "我们将会看到", "这种特性对于希尔排序整体的性能", "乃至这个算法的有效性", "都是至关重要的"]}, {"name": "08B3-5\t最大高度", "block_id": "1629df4b26174066a2577f374f8da097", "text": ["以下 我们分别从最大和最小两个方面", "对B树树高的变化范围做以估算和界定", "首先我们再次强调", "对于B树而言其高度是由外部节点的深度决定的", "如果从0开始自顶而下依次编号", "那么树根节点所在的就应该是第0层", "其孩子节点所在的应该是第1层", "再往下 第2层 依次类推", "直至叶节点所属的h-1层 以及外部节点所属的第h层", "我们的第一个问题是 对于固定阶次的B树", "如果其中包含的关键码数也固定为N", "它的最大高度 可能达到多少呢", "不难理解 在阶次与关键码数固定的前提下", "会使整棵树的高度更大", "每个内部节点中所包含的关键码数都应该反过来尽可能的少", "形象的说 每个内部节点都需要尽可能的瘦", "因此其中关键码的数目都应该尽可能的取做下限", "而相应的分支数应该取做m/2的上整", "如此我们来考察各层的节点数", "首先顶层应该始终只包括树根这一个节点", "其次作为根节点的特权 它在最瘦的时候", "可能只包含一个关键码 同时只相应的拥有两个分支", "而以下的各层呢 每个节点分支数都至少是m/2的上整", "因此以下各层所含节点的数目", "应该以m/2的上整为倍数成几何级数递增", "具体来说 第k层所含的节点数", "自然应该就是2乘以m/2的上整的k-1次方", "这个规律适用于所有各层", "直至我们需要考察的外部节点所在的第h层", "自然的 这层所含的节点数就是2乘以m/2上整的h-1次方", "你应该还记得 我们在介绍B树实例时曾经总结的一条规律", "如果一棵B树中包含的真实关键码数为N的话", "那么其对应的外部节点总数应该恰好就是N+1", "具体到这里 也就是N+1应该等于nh", "通过数学归纳 不难证明这一性质", "我们也可以对这一结论做一个简单的理解", "也就是说 树中所包含的N个关键码", "如果理解作对应于N种成功查找的可能", "那么外部节点也各自对应于一种失败的情况", "既然有N种成功的可能 自然也就有N+1种失败的可能", "总而言之 我们借助算两次的技巧", "分别得出了nh的一个确界和下界", "现在nh的历史使命已经完成 我们可以将其忽略掉", "并转而考察由它的确界和下界所构成的不等式", "略加整理之后 我们即可得到这样一个不等式", "在大O意义下 也就是log以m为底N的对数", "如果将m视作常数 也就是logN", "与BST的性能 渐近同阶", "然而正如我们所设计的", "B树的意义并不在于降低搜索的渐近时间复杂度", "而是更加关注于常系数意义下的优化", "那么关于常系数的改进 这里的阶次m又扮演了一个什么角色呢", "将B树的性能与常规BBST的性能做一对比", "即可得到这样一个结果", "比如按照常规的设置 将阶次m取做256", "即可发现B树的高度 大致是所对应BBST高度的1/7", "你应该还记得我们此前关于大学4年学制与30年学制的比喻", "是的 这个结果背后的原因恰恰正在于此"]}, {"name": "12c1-2: \t实例", "block_id": "4113614a053f4b06b4570222d9d9b377", "text": ["考察这个由13个整数所构成的", "待排序序列", "采用希尔排序算法", "我们首先将矩阵的宽度取作8", "于是我们按照不超过8个元素为准则", "将整个序列分为两段", "而每一段都对应于矩阵的一行", "这样我们就得到了一个宽度为8的矩阵", "接下来我们对这个矩阵逐列排序", "很容易验证第一列的排序结果是这样", "第二列是这样", "第三列是这样", "第四列是这样", "以及第五列是这样", "最后三列是退化的情况", "直接得到排序的结果", "至此我们已经完成了", "对应于宽度8的一趟sorting", "在转换为新的矩阵之前", "我们需要将它重新复原为", "一个线性的序列", "具体来说与刚才构成矩阵的操作", "完全相反", "我们这时候需要将矩阵的每一行", "逐个取出", "并依次串接", "从而构成一个线性序列", "我们接下来采用的矩阵宽度为五", "因此我们接下来要以五为单位", "将此序列切分为若干段", "而每一段都将作为新矩阵的一行", "接下来我们依然需要逐列排序", "不难验证这是第一列的排序结果", "这是第二列的排序结果", "以及第三列第四列第五列的排序结果", "一旦完成了这样的逐列排序", "我们又需要在逻辑上", "将这个矩阵重新恢复为一个序列", "具体的方法", "依然与刚才构造矩阵的过程相反", "也就是说我们需要将矩阵中的每一行", "逐个取出并依次串接", "从而还原为一个线性的序列", "此时我们不妨稍作停留", "来观察一下这两个中间结果", "虽然我们现在还不能精确的度量", "但是我们依然能够隐约", "而切实的感觉到", "整个序列的有序性", "是在不断的改善", "那么接下来还会继续改善吗", "我们不妨继续下去", "再接下来的一步", "我们将矩阵的宽度取作三", "也就是说我们将以每三个元素为单位", "将整个序列分割成若干段", "这些段也就分别构成了新矩阵的各行", "这个新矩阵共有三列", "我们接下来依然需要", "对这个新矩阵中的三列分别排序", "同样不难验证", "各列分别排序的结果应该是这样", "接下来我们依然需要逐行取出", "所有的元素", "并将它们依次串接起来", "恢复为一个线性序列", "至此你也不妨再次的大致体会一下", "经过刚才的这样一趟逐列排序", "整个序列的有序性又向前有所改进", "为了再进一步的提高", "整个序列的有序性", "我们接下来将要采用的", "矩阵宽度取作2", "也就是说我们要以两个元素为单位", "将整个序列切分成若干段", "而且同样的每一段", "都构成新矩阵的一行", "此后我们又可以分别针对", "这两列各做一次排序", "不难验证排序的结果分别是这样", "接下来同样的", "我们又需要将这个矩阵中的元素", "逐行取出", "并将它们依次串接起来", "恢复成为一个线性序列", "请再次的体会一下", "经过这样的一趟逐列排序", "整个序列的有序性又有所改善", "与所有的步长序列一样", "我们最终也是终止于W1等于1", "也就是说我们要将此时的线性序列", "完整的视作为一列", "并且对它进行排序", "在经过了以上的各步之后", "不出意外", "我们的确得到了原序列的", "一个排序结果"]}, {"name": "07D1-4 接口", "block_id": "34185cddfedf460b8696088ec3dc855b", "text": ["接下来 我们首先就将AVL树", "关于适度平衡的标准", "以及它作为数据结构", "所应该提供的各种接口", "以C++语言的形式明确定义下来", "首先是什么叫作平衡", "可以看到 所谓的理想平衡", "就是左右子树的高度完全相等", "而所谓的平衡因子呢", "在这里也严格地按照AVL树的定义", "取作左子树的高度", "与右子树的高度之差", "那么AVL树所谓的适度平衡标准", "也就可以转译为平衡因子", "最大不过1 最小不过-1", "我们也可以依然采用模板类的形式", "由标准的BST", "派生出AVL类", "因此包括search在内的", "很多公用标准接口", "都可以直接沿用", "而作为派生类", "这里需要重写的", "无非只是涉及重平衡的动态操作", "也就是插入以及删除", "那么在这两种动态操作之后", "AVL树的失衡现象", "具体是什么样的呢？", "究竟又有多严重呢？", "在我们给出具体的重平衡算法之前", "或许应该首先获得一些感性上的体会"]}, {"name": "10c-3:\t实现", "block_id": "5ef2258e2f1f467f86db383bd32639d8", "text": ["在这里，我们给出堆排序的一个更为通用的算法版本，", "也就是说对于任何的向量，这个算法都可以对其中任意指定的区间进行排序，", "作为初始化，首先需要调用完全二叉堆的建堆算法，", "在线性的时间内，将向量的这个区间整理为一个完全二叉堆。", "此后进入反复迭代，请留意这个迭代所具有的不变性，", "也就是完全二叉堆当前所在的区间是由lo和hi界定的，", "按照我们一直以来采用的惯例，lo所对应的是堆的首元素，而hi所指示的则是这个堆尾部的哨兵。", "因此在每一步迭代中，我们都只需取出首元素位置处的最大元，并将它与末元素交换，", "而新的堆顶元素的下滤功能则同样是由delMax在底层完成。"]}, {"name": "08B2-3\t还是I O", "block_id": "685604a307cd4cdc9b953f119eae3e09", "text": ["这背后的原因恰恰在于", "在我们通常都是按多个层次来分级组织的存储系统中", "如果使用B树可以针对我们此前所说的外部操作", "大大降低IO访问的次数 从而极大的提高计算效率", "那么难道我们此前业已熟悉的AVL树在这方面还不够么", "我们不妨具体估算 考察某个由10的9次方 1G个记录的数据集", "如果将它们组织为一棵AVL树 高度大致为30层", "也就是说 在最坏的情况下 单次查找需要深入30层", "而每一层我们都需要执行一次IO操作", "那么B树又能如何呢", "我们刚刚看到 B树中的超级节点同时包含多个而不是单个关键码", "因此在B树中每下降一层 都可以超级节点为单位", "读入一组而不是单个关键码", "从而将外存批量访问的特点 转化为实在的优点", "如果将关键码比作粉笔", "那么每一个超级节点都相当于那列火车的一节车皮", "其中既可以装载一根粉笔 也可以装载一大堆", "既然如此 采用B树的策略将它们成批的而不是单个的读取", "也是再自然不过的", "那么这样一节车皮具体的应该设计为多大呢", "这取决于磁盘等外存本身所设定的数据缓冲页面的大小", "通常的情况下 都是若干个KB", "如果每个关键码通常取做4个字节的话", "那么很自然的就应该将每个超级节点的规模设置为200至300之间", "比如若将超级节点的规模 取做256 也就是2的8次方", "那么同样存放1G个记录的B树 高度不会超过4", "这就意味着即便在最坏的情况下", "单词查找所需进行的IO操作也同样不超过4次", "是的 4次对30次 我们说这是很大的一个提高", "讲到这里 你或许会有一个疑问", "难道4和30不都是可以视作常数吗", "是的 就渐近的意义而言 的确如此", "但是当这个常数的每一个单位都相当于10的5至6次方时", "我们就不得不斤斤计较了", "这就犹如虽然1秒和1天乃至1年 都可以视作是常数", "但是对于有限的人生来说 却有本质的区别", "比如绝大多数人都会接受花费4年的时间就读大学获得一个学士学位", "但如果将这个期限换成30年 我想应该不会有很多人继续做此选择了"]}, {"name": "10xa1-4:\tNPL", "block_id": "0e528f6c94f0447798f1b8c20c3cac58", "text": ["为了度量和判断左式堆的单侧倾斜性，我们需要引入一个概念，也就是所谓的“空节点路径长度”。", "为了便于我的讲解和你的理解，我们继续沿用之前在红黑树和B树中已经多次采用的一个技巧，", "也就似乎通过引入足够多个外部结点将整个堆假想地转化为一棵真二叉树。", "比如在这幅图中，所有深色节点都是原有的真实存在的节点，", "而所有浅色，也是方形的节点都是我们假想的引入的外部节点。", "可以看到，经过这样的一个转换，的确所有节点的度数都变成了偶数。", "那么，所谓的空节点路径长度(Null Path Length)又是如何定义的呢？", "首先作为基础，对于刚刚引入的每一个外部结点而言，其NPL值都统一设作0，", "而对于任何一个原本就存在的内部节点而言，为了确定它的NPL值，", "我们需要找到它的左孩子以及右孩子，并且在其中挑选出更小的一个NPL值。", "在已知的基础增加一个单位。", "看到这个定义的表达式，你或许会想起点什么，没错，节点的高度。", "事实上只要把这个min()换成max()，也就是不折不扣的高度。", "通过这样的对比和类比，我希望你能够对这两个概念有更深刻的认识。", "就这里的NPL而言，我们不难验证以下两个事实：", "首先，任意节点x的NPL值，必然等于x到所有外部节点的最近距离，", "比如任何一个外部节点的NPL值之所以为0，", "是因为它到所有外部节点的距离就是它自己到自己的距离，这个距离自然是0。", "我们再来看这个节点，它的NPL值为什么是2呢？", "因为尽管它有一个外部节点后代与它的距离为1、2、3，", "但这却不是最近的距离，实际上最近的距离应该实现于这样三个后代外部节点：", "而且这个距离恰好是1、2。", "类似地，这个例子中的根节点NPL值之所以为3，是因为这些外部节点到它的距离最近，", "而且这个距离都是1、2、3。", "另一个可以验证的事实是，对任何一个x而言，它的NPL值也是以它为根的最大满树的高度。", "回到刚才的这个实例，依然考察NPL值为2的这个节点，它的NPL值为2，", "我们也可以理解为存在一棵以它为根的高度为2的满树。", "事实上，对于其它的节点，例如这个节点，也是如此：", "这个节点的NPL值为2，是因为以它为根的最大满子树的高度也是2。", "而根节点的NPL值3，也可以理解为以它为根的最大满子树的高度也是3。", "至此，我们已经建立了NPL值这样一个重要的指标。以这个指标作为基准，我们就可以来度量堆结构的倾斜性。"]}, {"name": "02D5-1\t 原理", "block_id": "a9ead6cde5c24bb1a26e4112f8d2c85a", "text": ["同学们好 接下来这节我们来介绍", "有序向量查找算法的一个另类的变种", "我们称之为插值查找", "我们此前所介绍的", "斐波那契search或binary search", "包括它们的各种版本", "对向量只做了一个假定", "也就是说其中的元素是单调有序的", "但是对于其中元素的分布情况", "我们并没有做任何的假设", "也就是可以是完全理想任意随机的", "但是在某些情况下 也许不是这样", "比如说 我们可能不仅知道向量是有序的", "而且其中的元素可能是", "按照某种先验规律随机分布的", "在这里呢 我们考虑一种最常见的随机分布", "也就是所谓的均匀独立的随机分布", "比如在这样一个从lo", "一直到hi的秩的范围之内", "所有的元素都互相不影响", "也就是所谓各自独立的", "然后从取值来看", "是均匀的取自于某一个", "在这里用横向来表示的区间范围", "我们说 如果我们确实知道", "诸如此类的规律的话", "我们就有可能实现", "优于此前那些算法logn的更高的查找效率", "具体来讲就是一个小写的o", "small o", "以这样的一个效率 来完成一次查找", "好的 我们来考虑", "最终所谓的均匀且独立的随机分布", "不难理解", "果真是按照这样一个随机分布的话", "那么所有的元素在排序之后", "也就是组织成一个有序向量之后", "必然大体上是按线性增长的趋势分布的", "就像这里 从lo开始 最小值", "大致是线性的增长到hi 最高值", "那么这意味什么呢", "意味着对于其中的任何一个潜在元素mi", "我们都可以写出这样一个近似的线性等式", "也就是说 它们的秩的比", "与它们的数值比", "二者是近似接近的", "这样的话 实际上就给了我们一个启示", "也就是说 我们在每次确定mi的时候", "既不需要固定的用1/2", "也不需要固定的用小写的φ", "也就是黄金分割比", "甚至不见得要用某一个一般的", "我们此前用过的λ", "而是可以动态的来猜测这样一个轴点", "怎么猜呢？", "其实根据的就是这个等式", "我们将这个等式稍微整理一下", "把mi专门的提到左侧", "我们就可以知道", "根据lo、hi", "以及它们对应的这两个元素的数值", "以及每次动态要查找的那个元素的数值e", "我们就可以大致的估算或者猜测出了mi", "这样的话 如果整个的减而治之的搜索过程", "可以认为是一个不断收缩包围圈", "逐步收敛的一个过程", "那么它将会使得收敛的速度极大的加快", "从而更快速的完成我们整个的查找", "我们可以来举个例子", "正如这个图所画的那样", "就是我手头一本英文词典中", "abcd 一直到z开头的单词", "各自起始的页码", "我们说 它大致是1300多页", "换而言之 如果它确实", "是一个大致平均分布的话", "每一个字母大概占50页", "所以我们可以大致估算出来", "从1到50页 大概是a", "50页到100页 大概是b", "100页到150页 大概是c 诸如此类", "我们可以猜测 其实诸位可以想想", "你们在翻阅英文词典的时候", "虽然没有去做精确的计算", "但是大致你也应该是按这样的来估算的", "比如说你去查binary b的话", "那么因为它是第二个字母", "所以它大概会在整书", "从2/26这个位置开始", "而s呢 search呢", "s是第19个元素 所以大概呢", "它会位于19/26的位置", "所以你查字典的时候", "如果查binary 你绝对不会往后边去查的", "而会集中在前面的部分", "而s呢 你会更倾向于", "在比较靠后的那部分进行查找", "我们说 如果你是这么做的话", "那么其实你对这种算法的原理", "实际上已经很清楚", "正因为这种算法在确定切分点", "也就是轴点的时候", "采用的是近似的插值估算的方法", "所以我们也称之为Interpolation Search", "插值查找", "我们来看一个具体的例子"]}, {"name": "07C-3 理想+适度", "block_id": "df76cf2024ad4e0cae554a5dbed4a539", "text": ["为了有效地控制树的高度", "我们或许首先应该弄明白", "什么样的树相对而言高度是更低的", "我们会发现 在节点数目相对固定时", "左右兄弟子树的高度越是接近", "全树通常也会更加倾向于高度更低", "也就是说 全树越是接近于平衡", "那么它的高度也会倾向于更低", "因此我们可以通过控制全树的平衡度", "以控制全树的高度", "关于树的高度 我们有这样一个结论", "由n个节点所组成的二叉树", "其高度最低不会少于log 2为底n的对数", "因此如果某棵树的高度", "能够达到这样一个理想的下限", "我们也称之为理想平衡的", "那么哪些树能够达到", "这样的理想平衡状态呢？", "你应该会联想起我们此前所讲过的", "完全二叉树 Complete Binary Tree", "是的 在这样的树中", "叶节点只能出现在最底层以及次底层", "当然 其中最好最好不过的", "自然是所谓的满二叉树 Full Binary Tree", "然而很遗憾 这样的树在实际应用中", "只能是可遇不可求的", "而且即便BST在某一个时刻", "能够达到这样高度紧凑的形式", "在接下来的动态操作过程中", "这样一种完美的形式也是难以持续的", "因此所谓的理想平衡", "在实际应用中是不具任何意义的", "是的 理想平衡出现的可能性", "非常非常的低", "而且为了维护这样的理想平衡", "我们的计算成本也相应地会十分的高昂", "相对而言 我们会得不偿失", "而真正可行的方法是", "我们或许应该适度地放松平衡的标准", "没错 适度地放松", "你或许会联想起我们此前的渐近分析", "没错 那正是我们的一个法宝", "实际上只要能够保证全树的高度", "能够从渐近的意义而言不超过logn", "那么也就可以称之为是平衡的了", "因为这种平衡并非严格意义上的理想平衡", "所以我们也不妨称之为适度平衡", "这样一种适当的放松", "但又不失原则的方法", "也就是我们通常所谓的退一步海阔天空", "那么相应地 能够保持适度平衡的BST", "也称作平衡的二叉搜索树", "Balanced Binary Search Tree", "简称BBST", "也就是说 如果将所有的BST", "视作一个全集", "那么BBST只是其中的一个子集", "对于目前而言其中任何一棵BBST", "如果经过某次操作之后", "它不再保持适度平衡", "也就是说 会游离到这个子集之外", "果真如此 我们就需要有一整套方法", "将这棵BST重新拉回到这个子集中", "使它重新成为一棵BBST", "那么我们应该采用什么样的一些方法", "来做到这一点呢？", "或者先退一步 我们来考虑一下", "我们可能采用哪些方法呢？", "概括而言", "所有这些方法都必须是所谓的等价变换"]}, {"name": "08B5-4\t实例演示", "block_id": "1dcf1019ec36499bad027b9e38afdc76", "text": ["接下来 我们就通过几个实例加深对B树算法过程的理解", "首先 确认这是一棵5阶B树", "其特征是节点内所含的关键码数最多为4", "而除根节点外的其它节点 所含关键码至少有两个", "现在 假设 我问你删除249", "为此 我们首先需要通过查找 定位其所属的节点", "接下来 将这个关键码从该节点中剔除掉", "导致这个节点发生下溢", "我们知道在修复下溢时 我们并不急于去做合并", "而应该首先左顾右盼", "的确 此时的右兄弟包含四个关键码 足以借出一个", "当然 我们也知道 这种借出是迂回的", "具体来说 下溢节点应该首先向 它的父节点借出268", "而右兄弟的最左侧关键码315 则应该转而交给父亲", "填补268留下的空缺", "这也就是我们所说的旋转", "请注意 果真若是发生了旋转 不仅原下溢节点会得到修复", "其余所涉及的节点 无论兄弟 还是父亲", "都不致因此继而发生下溢 因此这种解决方案是彻底的", "也就是说 整个删除操作至此顺利结束", "当然 还有其它的可能", "比如 我们可能会接下来需要删除619", "同样的 为此我们需要经过查找 确定619所属的那个节点", "然后将这个关键码从这个节点中剔除掉", "可以看到 在损失了一个关键码之后这个节点发生了下溢", "为了修复这一缺陷 我们首先要站在这个节点的角度左顾右盼", "然而 很遗憾 它没有左兄弟 而右兄弟虽然存在", "但可惜自己已经处于即将下溢的边缘临界状态", "并不足以借出任何关键码", "也就是说 旋转的技巧在此并不可行", "我们只得借助另一技巧 也就是合并", "这等同于分裂的逆过程", "就这个例子而言 我们需要从这两个节点的父节点中找到", "介于它们之间的那个关键码 也就是703", "并且将这个关键码取出下移 作为粘合剂", "将这两个节点合二为一", "具体过程 如这个动画所示", "请注意 尽管此前位于最底层的下溢缺陷得到了修复", "但是更高一层的这个父节点 却随即也发生了下溢", "为了修复这一缺陷 我们依然需要站在这个节点的角度左顾和右盼", "情况与刚才居然类似 没有右兄弟", "而左兄弟呢 依然因为处于下溢的临界状态 而无法借出任何关键码", "因此 我们不得不再次求助于第二种技巧 也就是合并", "具体来说 需要从父节点", "也就是此时的树根中找到介于下溢节点及其兄弟之间的那个关键码", "可以注意到其实此时根节点只含有唯一的一个关键码 528", "尽管如何 我们也需要将这个关键码取出 并且下移", "作为粘合剂 将下一节点及其兄弟", "粘合起来 构成一个合法的节点", "整个过程如下", "可以看到 的确如我们所期望的", "在这一层上的下溢缺陷 的确得到了修复", "然而接下来出现的问题是", "原先只包含唯一关键码的那个根节点 现在却变成空的了", "我们知道 在B树中 根节点拥有特权 只需拥有两个分支即可", "但即便如此 却不可能只拥有一个分支", "实际上 这样一个根节点是没有任何实际用处的", "因此这时 我们不妨将它删除", "而用刚才经合并所得的这个节点取而代之 作为新的树根节点", "因此结果是这样 可以看到 整棵B树的高度 因此降低了一层", "这也是B树高度得以下降的唯一可能", "具体来说 在删除节点之后 需要进行合并操作", "而且这种合并操作会不断的向上蔓延 直到树根", "而树根节点只含有唯一的一个关键码", "以致于在借出这个关键码之后 树根成为空节点", "同样需要说明的是 尽管这种最坏情况不难构造出来", "但在实际运转过程中 却是十分罕见的", "关于这一方面的分析 你可以参照我们的习题解析"]}, {"name": "02D2-7\t 查找长度", "block_id": "0082436c841f4ff7bd4107dd8da5da27", "text": ["有序向量的查找是非常基本的一种算法", "而且它存在多个版本", "因此除了我们上面利用渐近的复杂度", "能够从总体上把握它的大体性能以外", "我们还需要对不同版本算法的性能", "做更加细微的评定", "具体来说 也就是来考察", "渐近复杂度logn前面的那个常系数", "而具体地 在统计和分析的时候", "我们更多的是来考量", "所谓的关键码的比较操作次数", "也就是在其中所执行的if语句的次数", "我们将此称作是", "不同的算法在不同的情况下", "所对应的查找长度", "那么我们也需要从不同的情况出发", "比如说最典型的是成功和失败两种情况", "并且从不同的侧面", "最好、最坏以及平均 不同的这样(注：种)侧面", "来进行评估", "比如 针对我们这里所说的", "二分查找的版本A而言", "我们在教材以及习题解析中", "都给出了这么样一个分析", "最后的结论是说", "无论是失败还是成功的情况", "平均的查找长度大体都是", "以1.5为系数的一个logn", "以下呢", "我们不妨来看一个具体的实例", "这是一个由七个元素构成的有序向量", "其实它的数值是具体是多少 我们并不在意", "只要它是非降排列的就可以", "如果我们把整个的算法改写成递归的形式", "那么整个的那个不同情况的递归跟踪", "将构成这么样一个递归跟踪图", "我们来看一下 这里总共有", "七种成功的情况", "更准确地讲 对于其中的每一个元素", "都各自有一种成功的情况", "假设它们出现的概率均等", "那么相应地呢", "我们还会有7+1", "也就是8种失败的情况", "这也是一个普遍的规律", "我们先来看成功的情况", "按照刚才的算法", "如果是成功在中间这个元素", "也就是这个元素", "它需要经过几次比较呢？", "我们说是两次", "第一次 它试图向左 结果失败", "第二次 它试图向右也失败", "最后告诉它说", "目标既不小于也不大于当前这个元素", "所以它就在这命中", "但是为此我们需要花费两次比较", "好 我们再来看这个元素", "这个元素 如果是它要成功的话", "我们说肯定是首先", "经过了一次比较 判断比第一个切分点要小", "所以才会深入到左侧这个向量中来", "并且进而跟这个相比", "同样在这个地方", "我们也要经过一次向左和一次试图向右", "最后确定在这块命中", "在这个结点上 我们花费了两次", "而转向这个子向量 我们花费了一次", "所以累计而言 在这里我们应该花费的是三次", "好 同样在这边 也是这种情况", "本身这个地方要花费两次", "而这个地方转向 大家注意这是不对称的", "往这个左方向转向 我们只需要一次比对", "但是向右侧转向 我们却需要花费两次", "所以本身转过来两次", "在这个本地又花费两次", "所以累计在这个节点 如果是成功查找到的话", "需要的成本是四次比较", "好 接下来 我们再来看这个方向继续", "如果是成功在这个位置的话", "那么它是经过了", "在这个位置一次比较 转入到这个子向量", "然后再在这个位置经过一次比较", "才转入这个子向量", "并且针对这个切分点来做比较", "同样 如果在这块命中的话", "在这个本地要再进行两次", "所以一次 再加一次 再加两次", "我们需要四次", "同样地 大家可以按照这种方法验证", "这个地方是五次", "如果成功在这个地方 也需要五次", "而成功在这个地方呢", "是最耗时的 需要六次", "所以累计起来 我们做一个心算", "我们可以看到", "两次 加三次 再加四次 这是九次", "再加上底下是二十", "所以总共是二十九次", "而总共呢 有七种情况", "我们说大致等于多少呢？", "大致等于4再略加一些", "我们再来看失败的情况", "也就是这八种情况", "那么对于最左侧的这个情况", "如果在这边失败的话", "那么我们需要在这个位置做一次比较", "从而转入这个位置 然后再做一次比较", "最终判定失败", "所以在这个位置对应的次数就是三次", "而这个位置呢 如果失败的话呢", "此前的一次、两次情况完全一样", "不同的是在于 最后这一个位置", "我们这个时候为了拐向右侧", "实际上需要进行的是两次", "而不是像刚才那样的一次比较", "所以相应的总体的", "比较的次数 要多加一次 是四次", "同样的这边 我们也可以看到", "写的也是四次 为什么呢？", "我们来走一遍", "从这个方向深入到左侧 这是一次比较", "但是每次凡是向右都是两次", "凡是向左都是一次", "所以一次 加两次 再加上一次 得到四次", "相应的这边 也会多一次 是五次", "而这边呢 我们说也是四次 为什么呢？", "因为这条路径上向右 这是两次", "向左是一次", "再向左一次 所以累计是四次", "而这个失败的情况呢", "是有一次向右 累计两次", "再一次向左 累计一次", "然后再向右 两次", "所以是二加一 加二 等于五次", "同样地 这边也是六次", "把这些我们总和加在一起", "我们也可以去心算一下", "总共八种情况", "累计需要比较的次数是36次", "如果这些情况是等概率出现的话", "比较的次数正好平均是4.5", "4.5大概等于多少呢？", "无论是上面还是下面 大概都等于", "log以2为底 这个长度是7", "或者是说 随着这个向量的更大", "我们更喜欢用它再加1来粗略地估算", "也就是8", "所以这个系数大致就是", "我们刚才所说的1.5", "那么这个1.5是不是已经最好了呢？", "我们说其实还有改进的余地", "这也是我们接下来的两节", "需要讨论的问题"]}, {"name": "04C5-4 \t算法", "block_id": "3bf1207553bb477d831c3387967795d7", "text": ["回到我们此前所学过的", "中缀表达式的求值算法", "相信你已经对这个算法比较熟悉了", "所以我们这里为了简便", "只列出了其中最主要的框架", "这个算法在对中缀表达式", "进行求值的同时", "也捎带着完成了RPN的转换和生成", "你现在应该知道", "为什么这个接口", "需要提供一个名为RPN的", "引用型的字符串了吗？", "对了", "它最终返回的就是原来", "中缀表达式所对应的RPN", "如果你对这个还有点怀疑的话", "建议你打开我们的示例代码", "并且对这段代码进行编译执行", "如果你的方法得当", "我相信你应该能看到", "RPN转化的详细过程", "以及最终的结果", "如果我们对这个算法", "进行一个关键词RPN的搜索", "我们会发现 对RPN的引用和修改", "无非只出现在两个位置", "第一处位置对应的是", "我们当前扫到的这个字符", "是一个数字digit", "我们曾经讲过", "这意味着遇到了一个数字", "因此我们可以通过", "readNumber把这个数字读进来", "那么它将作为一个操作数", "被推入操作数栈中", "而随即呢？大家看到", "我们可以非常简明地", "直接将刚刚推入栈顶的这个操作数", "续接到当前的RPN尾部", "而else另一种情况", "也就是当前的字符实际上", "是一个运算符的时候", "我们并没有急于像刚才运算数那样", "直接把它后缀到RPN的尾部", "而是只在某些特定的时候", "才将它缀在其后", "什么时候呢？", "我们可以看到", "在else这个分支底下", "还有很多个sub case子分支", "其中只有当对应于", "大于号的优先级关系", "也就是说", "栈顶的这个元素可以立即执行的时候", "当然 只要表达式的语法正确", "每一个运算符都会入栈", "而且都会等到它应该执行的那一天", "那这一天是什么时候呢？", "考察任意的这样一个运算符", "以及它所对应的那个子表达式", "还有无论是显式的", "还是像刚才我们手动方法", "那样加入的隐式的", "总会有一对对应的括号", "我们说只有当我们的求值算法", "扫描到这个显式的", "或者隐式的括号的时候", "这个运算符执行的时机", "也恰好就在此时", "请注意", "对应的那个右括号 就是", "这个运算符被真正执行的时机", "所以反过来 我们就在它", "真正执行的那个时候", "将它续接到RPN的尾部", "其实完全就等同于", "我们刚才在手动的算法中", "将这个运算符移到紧邻于", "它所对应的这个右括号的右侧", "二者实际上在做同一件事情", "只不过刚才你需要纸和笔", "而现在呢 是由这个算法", "聪明地简便地帮你实现的", "好了", "现在你应该对这样一个", "原本是用来求值的算法", "同时还能够正确地完成RPN转换", "不存质疑了吧？", "在说再见之前", "我还希望大家和我一起", "来反观一下这段程序", "我们可以看到 对于操作数来说", "每遇到一个就随即接至RPN的末尾", "所以这也是为什么", "它们不会改变相对的次序", "而运算符呢", "你刚才已经看到了 未必如此"]}, {"name": "07D2-3 插入：实现", "block_id": "727981ecf74d43c4bbd3a70050c4b572", "text": ["在这里 我们给出AVL树插入算法", "一种可能的实现", "可以看到 开始的几步操作", "无非是常规的BST插入算法", "也就是说 我们需要首先进行查找定位", "并且不妨假设这个节点的确还不存在", "接下来 我们要创建一个新的节点", "并且将它接入到当前的BST中", "接下来 才是针对AVL规则的相应处理", "具体来说 我们将从新节点的父亲开始", "不断地逐一枚举它的历代祖先", "即便这个祖先还是平衡的", "我们依然有必要考虑更新它的高度", "而一旦抵达一个不平衡的祖先", "根据我们这里枚举各代祖先的次序", "这个祖先必然是所有失衡祖先中的最低者", "因此按照我们刚才所介绍的算法", "需要在此局部做旋转调整", "而此局部所涉及的三个顶点", "无非是g", "以及它更高的那个孩子 也就是p", "以及再更高的那个孙子 也就是v", "请注意一旦发现了这样一个节点", "并且随即完成了局部的重平衡", "我们就可以直接地退出这个循环", "并且直接地退出整个算法", "你应该知道这正是由我们刚才", "所指出的那个特性所保证的", "也就是说 尽管在某个节点刚刚插入的瞬间", "可能同时有多个祖先都是处于失衡的状态", "但是一旦我们令其中最低者恢复平衡", "那么所有的失衡祖先", "都必然会统一地恢复平衡"]}, {"name": "01b-7: \tRAM模型", "block_id": "fbb702681b9a404cb3ac552ce49e65dc", "text": ["我们再来看Random Access Machine", "也就是所谓的RAM模型", "在可计算的意义上讲", "它和图灵机是完全对等的", "尽管二者之间还是有重要的区别", "那么二者之间首先的一个共同之处就是", "它们都拥有无限的空间", "当然这个在实际世界中还不能做到", "这种无限的空间", "在这里是以顺序编号的", "一组寄存器的形式给出来", "每一个寄存器换而言之", "都由一个自然数唯一的标识", "我们可以说第0号寄存器 第1号寄存器", "第2号第3号 以及诸如此类", "那么与图灵机的转化函数相对应的", "这里提供了一系列的", "大概有10种格式的可行的语句", "我们大概看一下", "首先是常数赋值语句", "也就是说 我们可以将一个常数", "赋予编号为i的那个寄存器", "我们也可以在寄存器与寄存器之间", "完成数值的复制", "具体来说", "我们可以把第j个寄存器中的数值", "赋值到第i个寄存器中", "如果这个是直接通过一个自然数", "来确定一个寄存器的话", "那么这样一种方式", "就叫做间接取址", "学过汇编的同学", "应该非常好理解这一点", "其他的同学 我相信也不难", "我们不妨在这里解释一下", "这里所谓的间接取址", "实际上就是首先根据给定的编号j", "取出编号为j的寄存器中", "所存放的整数数值", "并将这个整数作为一个编号", "再取对应寄存器的数值", "最终 将取出来的这个数值", "复制到另一个指定的", "比如说第i个寄存器中", "但这种复制的方向", "也可能颠倒过来", "接下来", "这里还支持寄存器与寄存器之间", "数值的加和减两种最基本的算数运算", "并且能够将结果", "转入第3个寄存器中", "为了构成算法", "这里也不可或缺的需要有", "条件判断语句和转向语句", "所谓条件判断语句 这里有判0", "也就是一个寄存器的数值是不是0", "包括判正", "也就是其中的数值是不是一个正数", "只要条件满足", "就会相应的转到对应的语句", "这个l呢都是顺序语句的编号", "当然也有绝对的转向", "还有一个特别的STOP语句", "也就是终止语句", "那么这个STOP语句的功能", "和图灵机中的那个停机状态h是完全对等的", "每当执行到STOP 对应的程序都会停止下来", "我们稍后再看RAM模型的一个例子", "但实际上到这里", "我们已经完全可以将RAM模型", "和图灵机模型放在一起做一个概括", "我们说二者其实都是对一般的", "计算工具进行抽象以后的简化", "这样的一个简化以后", "我们不仅可以用这种基本的简单的操作", "来描述我们的算法", "而且更重要的是", "使得我们可以因此独立于具体的环境和平台", "对具体算法的总体效率做出比较和评判", "而且这种比较评判", "相对于前面那种实测的方法", "更具有可信度", "那么为什么能这样呢", "这里关键是做了一个转换", "也就是说我们将算法所运行的时间", "转化为在上述这些基本平台上", "执行算法的过程中", "所需执行基本操作的次数", "时间 到次数", "这样就将时间的统计问题", "转换为了次数的整体求和和估算问题", "因此 我们前面所定义的那个T(n)", "也就是在求解规模为n的问题的时候", "我们所需要的时间成本", "我们就可以转化为", "为此所需要执行的基本操作的次数", "这样的好处在哪呢 有很多", "比如说 其中一点就是", "至少我们现在可以不用考虑硬件环境", "一个算法好不好 并不取决于运行的时候", "所依赖的那个CPU主频的快慢", "而取决于它本身它需要执行多少次CPU的计算", "我们说这样确实更加客观"]}, {"name": "08A3-5\t插入算法", "block_id": "f99a95d506c94fcb9df9063c50b5a786", "text": ["我们先来考察插入算法", "按照直观的思维 调用BST标准的插入算法", "然后再按照伸展树的规则 将新节点伸展至树根的位置", "然而我们发现 这种实现方法在这里显得过于迂回曲折", "因为无论如何在真正实施插入操作之前", "我们必然已经调用过一次search接口", "而我们刚刚业已重写过的search接口", "实际上已经集成了一个splay操作", "也就是说 即便查找可能失败", "在此之后 根节点也必然是_hot节点", "你应该记得 我们的新节点", "本来就应该作为_hot的左或右孩子接入树中的", "既然_hot已经在根节点处唾手可得", "我们为什么还要费尽周折的去做更复杂的操作呢", "沿着这一思路 我们不妨按照下面这种图给出的流程", "来完成伸展树的插入算法", "具体来说 首先调用重写之后的search接口", "而且不失一般性 我们的查找是失败的", "并且记失败前最终的节点为t", "也就是我们此前所说的_hot", "接下来 集成在search接口内部的那个splay操作", "自然会将这个hot推送到树根的位置 如同这个图所示", "接下来呢 我们不妨从逻辑上", "将整棵树在t这个位置上一分为二", "比如将t与它的右子树分离开", "接下来我们可以引入节点v", "并且将t以及它的后代 作为v的左子树", "而原先从t处分离出来的右子树呢", "将作为v的右子树 重新接入这棵树中", "纵观整个过程 以及最终的结果", "我们不难发现 其效果与通常的插入完全一样", "具体来说 不仅使得一个新节点", "得以顺利插入树中", "而且同样使它处于树根的位置", "就像它曾经被推送上去"]}, {"name": "03E-7\t 平均性能", "block_id": "158c9fec33784f3396a02006ea933c69", "text": ["我们刚刚看到，insertion sort", "在最好的时候只需线性的时间", "但是很可惜 在最坏的时候", "需要n平方的时间", "那么平均而言 需要多少时间呢？", "我们来对此做一概率分析", "当然 首先我们要给出一个概率假设", "也就是 采用最普通的概率假设", "所有的元素都是在某一个范围内", "按照均匀且独立的规则来取值的", "那么具体来说 在这样的假设下", "每一个新元素的插入", "需要接受多少次比较操作呢？", "为此 我们需要采用一种技术", "叫作后向分析 backward analysis", "也就是说 我们要把时间拉回到", "此前的某一个时刻", "也就是某一个元素", "比如说第r个元素", "刚刚完成插入的那样一个时刻", "也就是说 如果在此前的", "内部迭代中", "有序前缀的长度为r", "那么现在前缀的长度就是r+1", "我们由前面那个状态", "转化至后面这个状态", "是因为刚刚插入了此前的L[r]这个元素", "那么在这个过程中", "为了插入这个元素", "我们花费了多少时间？", "确切地说 进行了多少次", "元素的比较呢？", "我们说这是随机的 不知道", "我们不妨来", "设想一个类似的场景", "比如某一天", "当老师因为某些事情的耽误", "来到教室的时候 发现上课铃已经响了", "同学们都已经就座了", "这个时候 如果我不关心自己", "反过来我关心同学", "我有可能会问这么样一个问题", "同学们 你们谁", "是最后一个进入到这个教室的呢？", "如果同学们配合", "能够告诉我 那固然最好", "但有可能同学会给我开玩笑", "他们会说 邓老师 你猜？", "没错", "在这个时候 我们也需要猜", "因为最后进入到这个序列中的", "那个元素L[r]是谁 是不确定的", "而且它插在不同的位置上", "所对应的成本也是不同的", "当然 按照我们刚才的那个假设", "如果我要猜的话", "那么我可以说", "现在在场的每一位同学", "都应该有均等的概率", "作为最后的那个同学 来到这个课堂", "也就是说 至今为止已经插入的这r+1个元素", "每一个元素都有可能作为", "刚刚被插入的", "这个最后的那个元素", "而且正因为我们采用的是", "均匀独立的分布", "所以不仅它们各自都有可能", "而且它们的概率都是均等的", "对于r+1个人来说", "当然也就是r+1分之一了", "好", "为了估算刚过去的", "这样一步迭代所需要的成本", "我们不妨就将每一个元素", "作为最后一个元素", "插入所对应的成本累计起来", "并且用我们刚才所给出的这个概率", "来做加权平均", "那么不难看出", "如果最后那个元素是这个元素的话", "那么我们所需要的比较", "只需要1次", "如果是接下来的这个的话", "只需要2次", "如果是再往下的话 是3次", "一直到最终这个位置", "无非就是r次", "所以大致来说 所有这些情况", "所对应的计算成本", "构成了一个算术级数", "它们的平均值与当前", "这个前缀的长度", "也就是r 成线性关系", "这样我们就得出了", "在第r步迭代中", "我们所需要的计算成本", "现在 我们纵观整个的计算过程", "把每一步所对应的", "计算成本的期望值累加起来", "自然也就得到了总体的期望值", "大家注意 这里我们用到了", "数学期望的线性率", "如果你还不是很了解", "可以查一查相关的资料", "扼要地讲 就是", "一组随机变量总和的期望", "等于它们各自期望的总和", "无论它们是互不相关的", "还是相关的", "这一结论都是成立的", "所以由此我们可以看到", "插入排序 在这样一个意义下的", "平均复杂度", "依然是n平方的", "与它的最坏情况是同阶的", "换而言之", "虽然它有最好情况", "但通常而言 这种情况发生的概率极低"]}, {"name": "05E1-8 迭代实现（2）", "block_id": "6a7a3d05e9b149e6b435c378af25346c", "text": ["新的这个迭代算法", "需要首先实现一个标准的例程", "它的名字叫作visitAlongLeftBranch", "顾名思义 它的任务就是来实现", "我们刚才那样一个从根节点开始", "沿着这个所谓的left branch 不断下行", "依次访问沿途所有节点的这样一个过程", "如果这个起始的根节点是x", "那么我们可以看到 它要做的事情就是", "每次都只需直接访问x节点", "然后转入它的左孩子", "直到这个左孩子为空", "也就是抵达了left branch的终点", "每当我们向下前行一步", "都会相应地将X当前的右孩子", "推入到事先准备好的某一个栈中", "那么都是哪些右孩子呢？", "第一个进栈的应该是根节点的右孩子", "再往下呢 是它的左孩子的右孩子", "以及它的左孩子的左孩子的右孩子", "以及最终的末端节点的", "也就是第d个节点的右孩子", "因此如果将存放它们的那个栈画出来的话", "大致是这样一个样子", "也就是说 这是底部", "而这边是栈的开放端 顶部", "至此 我想你应该理解了", "我们这里之所以使用一个栈", "而不是一个队列的用意了", "没错 依然是后进先出的特性", "因为接下来", "我们对这一系列的右子树的遍历次序", "按照刚才的分析 应该是自底而上的", "对于栈而言 就应该是自顶而向底的", "所以我们接下来一系列的顺序Pop操作", "Pop操作以及Pop操作", "恰巧可以忠实地还原", "我们所需要的这样一种访问的次序", "那么这样的一个次序如何来兑现呢？", "我们来看一下主算法", "请记住 这个主算法", "是反复地在每一个局部调用", "visitAlongLeftBranch这个例程来实现", "这就是我们的主算法", "确实 它会反复地调用我们刚才的那个", "visitAlongLeftBranch例程", "而且传入的这个栈都是大家公用的", "每一步迭代 我们都可以认为", "是从这个栈中弹出一个当前的节点", "并且命名为x", "从语义上 我们可以理解为", "是进入了以x为根节点的那样一棵子树", "因此按照算法逻辑 应该紧接下来", "调用visitAlongLeftBranch这个例程", "对子树x的那个左侧分支进行访问", "同时 它还会将对应的一系列的右子树", "其实是它们的树根", "通过这个栈逆向地收纳起来", "仅此而已", "最终一旦栈变空", "这个算法也就随即退出"]}, {"name": "09D2-3 至多半载", "block_id": "8ea0cc793cb3441788af4f430bffd5bb", "text": ["很不幸 我们刚才所设想的坏情况竟然的确可能发生", "比如 这就是一个例子", "这些散列表的容量取做12", "不失一般性 假设就从0号桶单元开始", "连续的发生足够多次的冲突", "根据平方试探的规则", "我们不难确认各次试探的具体位置", "当然在课后你可以对此做一验算", "你会发现 我们试探的足迹只会涉及到其中的4个单元", "也就是说 尽管在此时有高达2/3比例的桶都是空的", "我们竟然没有办法找到它们", "当然你可能会抱怨这里", "并没有按照常规将表长取作为一个素数", "是的 借助数论的知识不难证明", "只要表长M是合数 这种情况就必然可能发生", "那么将表长改为素数就足够了吗", "我们再来看这样的一个例子 当然这是一个反例", "这次我们将表长取做11", "没问题 这是一个素数", "接下来呢 依然不失一般性 假设从0号桶开始", "相继的发生足够多次的冲突", "自然 我们同样可以根据平方试探的规则", "计算出所有可能抵达的桶单元编号", "尽管我们这里直接给出了结果", "但我还是建议你在课后就此做一验算", "如果不发生意外 我想你和我的结论应该是一样的", "也就是说 按照这种规则 无论试探多少次", "我们的足迹只能涉及到这11个桶中的6个而不是全部", "换而言之 即便此时有多达接近一半的桶都是空的", "我们却无法找到并利用它们", "当然情况还不是糟糕透顶", "因为我们发现毕竟前6次试探所经过的桶", "必然都是互异的 这是一个巧合吗 不是", "同样的 稍微运用一些数论的工具就不难证明", "只要表长M是素数", "平方试探的足迹就恰好会遍及其中的M/2上整个桶", "因为一般的素数M都是奇数", "所以这个比例刚刚超过50%", "没错 50%", "这恰恰是一个重要的分水岭", "这也是情况可能糟糕到的最坏程度", "而关于这一点的正面结论是", "只要我们的表长是个素数", "而且能够保持装填因子不超过50%", "就一定不会发生刚才所说的负面情况", "否则 就未必能够保证", "以下 我们就来给出证明"]}, {"name": "05E2-5 实现", "block_id": "da567264342f4adfb1eda2f0550f43a4", "text": ["与先序遍历算法类似的", "这里我们也首先需要构建一个功能子函数", "称作goAlongLeftBranch", "与此前先序遍历中的那个例程相比较", "只不过是将visitAlong改成了goAlong", "其言下之意 执行的正是刚才", "我们所分析的那个过程", "也就是在当前的节点x", "沿着左侧分支不断下行的过程中", "每遇到一个x都随即将它推入到", "总体的一个栈中", "而主算法呢", "依然引入一个全局的栈", "然后反复地迭代", "每抵达一个节点x", "我们都等效地认为进入了", "以它为根的那棵子树", "所以按照刚才的推理", "我们首先要做的就是调用", "goAlongLeftBranch这个例程", "将这棵子树所对应的左侧链", "悉数的逆序推入栈中", "然后呢 从这个栈中弹出栈顶的节点", "我们此前也分析过", "这个节点也恰好应该在这样一个时机", "轮到接受访问", "这也是为什么我们可以随即", "对它实施访问", "如果用一个图来描述这个过程的话", "就应该是当我们一旦进入到", "以x为根的某棵子树之后", "都要沿着它的左侧分支一直下行", "使x移动到这个左侧链的末端", "并随即访问这个节点", "而此后呢 如我们刚才所述", "应该将控制权或者是我们的关注点", "转向它的右孩子", "或者更准确地讲 进入到这个右孩子", "所对应的那棵右子树", "也正因为此 在接下来", "我们的确应该通过这样一句", "将关注力转向当前节点的右子树", "从而在接下来的一轮迭代中", "依然可以等效地认为是", "进入了以新的这个x为根的", "那样一棵子树", "只不过这个x实际上相对于此前的x", "是一棵右子树而已", "整个算法将不断地迭代", "直到栈在某个时刻变空", "此时所有的节点都已访问完毕", "算法自然可以顺利告终"]}, {"name": "07A-5 接口", "block_id": "873d42c1746f4baeb60897b0276365ce", "text": ["这里给出BST模板类的一种实现方式", "可以看到 所谓的BST类", "也是由此前业已实现的BinTree类", "直接派生而来", "这就意味着BinTree业已提供的很多接口", "可以直接沿用", "而BST所新引入的操作接口", "主要的无非三种", "也就是静态的查找", "以及动态的插入和删除", "实际上 因为BST存在众多的变种", "对于这三个基本的接口", "不同变种的实现方法", "也不尽相同", "因此这里不妨以virtual", "修饰这三个接口", "以便强制地要求后续的派生类", "对它们进行必要的重写", "此外 在BST的内部", "也提供了一些记录变量", "比如_hot", "以及公用的操作接口", "比如说3+4重构", "以及旋转操作", "这部分内容", "留待后续各节逐一介绍"]}, {"name": "07A-2 循关键码访问", "block_id": "e07ec82b7d314f80a7773f2027180f86", "text": ["与其它数据结构一样", "二叉搜索树也是由一组数据项", "所构成的集合", "然而相对于其它的数据结构", "二叉搜索树对其中数据项的访问方式", "却有其鲜明的特点", "具体来说", "其中每一个数据项", "都拥有各自的关键码key", "并以此为特征互相区分", "因此在这样一个数据集中", "与其说我们在定位数据项", "不如说实际上是定位关键码", "以汽车为例", "每一台汽车都通过它所拥有的车牌号", "唯一指定", "因此这样一种对数据项的访问方式", "也称作循关键码访问", "call-by-key", "当然 对于二叉搜索树而言", "这种访问方式是需要有一些先决条件的", "具体来说 关键码与关键码之间", "首先应该能够进行比较", "也就是判断孰大孰小", "其次 还应支持比对", "也就是判断两个关键码", "是否完全一致", "因此为了简化和抽象", "在接下来的讨论中", "我们不妨假设整个数据集中的数据项", "都已统一地表示和实现为词条的形式", "那么词条也就是entry", "究竟是什么呢？", "一般而言", "词条结构应该包括以下要素", "首先每一个词条的确应该", "拥有一个关键码", "而词条所包含的其它信息", "则笼统地归入一个名为value的域", "所以简明地说 每一个词条", "实际上都是由key和value", "构成的这么样一个组合", "也称作<key value> pair", "此外正如我们刚才所言", "词条与词条之间应该能够", "互相比较和比对", "如果词条结构原本并不支持这两条", "就需要像这里这样", "对相关的操作符进行重载", "可以看到", "所谓entry之间的比较和比对", "按照这种方式", "实际上都转化为了词条中", "关键码的比较和比对", "那么在所有的数据项", "都已符合这种词条的规范之后", "二叉搜索树又当如何定义", "并且组织呢？"]}, {"name": "06C-3 实现", "block_id": "71f328253ddc4712af9322128fba58f0", "text": ["以下我们就来介绍图广度优先遍历算法的", "一种描述和实现方式", "具体是这样", "可以看到 遍历的起点", "总是某个预先指定的顶点v", "既然图的广度优先遍历", "可以视作为树的层次遍历的一种推广", "所以与后者相仿", "这里依然借助一个队列结构", "也就不足为奇了", "预处理的手法也是相仿的", "首先需要令当前的这个顶点v入队", "如果说有所不同的话", "那么这里需要在v入队之前", "将它的状态由最初的undiscovered", "转化为discovered 也就是刚被发现", "接下来是一个while循环", "每次都通过dequeue()取出队首的顶点", "并且重新命名为v", "请注意 在每一个顶点刚刚出队", "并随即接受访问的同时", "我们还需要给它打上一个时间标签dTime", "你会注意到 在算法的入口处", "还有一个名为clock的引用型参数", "是的", "顾名思义 它就像是一块钟表", "在整个算法的运行过程中", "它都会忠实地给出时间的进度", "任何时候如果你希望加注当前的时间标签", "你只需要将这块表取出来", "并且读取上面的时刻", "当然bfs只是图算法的一个基本框架", "在不同的具体问题中", "你可能在这个时刻需要对当前的顶点", "做相应的处理", "我们可以笼统地认为", "这些操作就是我们所谓的", "对这个顶点的真正访问", "那么接下来 按照算法的策略", "我们需要枚举出当前节点v的所有邻居", "这可以通过这条for循环语句来实现", "这里的firstNbr以及nextNbr接口", "你应该并不陌生", "是的", "我们此前曾经介绍过它们的原理以及实现", "我们可以看到", "通过这两个接口的这样一个组合", "我们可以简捷地从v的第一个邻居开始", "不断地转向它的下一个邻居", "直至所有邻居都被枚举完毕", "而每枚举出一个新的邻居u", "我们都会根据u当前的状态", "采取不同的处理方法", "具体的处理方式留待下一页再作介绍", "那么一旦v的所有邻居都被遍历", "并且处理完毕", "v自己也将从刚才的discovered状态", "顺利地转化为visited状态", "由此可见", "经过整个的遍历搜索过程", "每一个顶点的状态都会由最初的undiscovered", "转化为discovered", "并最终转化为visited", "这样的三个状态也就构成了每一个顶点", "在它的生命期内的三部曲", "那么总有一天 这个队列会变空", "整个广度优先搜索的过程", "也就顺利结束", "那么接下来唯一仍未交待的就是", "对于枚举出来的每一个新邻居u", "都有哪些处理方式呢？"]}, {"name": "11f2-1: \t数位溢出", "block_id": "24127c532a9b4117b3bd8bc1fc2473e8", "text": ["在前一节中", "我们已经成功地完成了一次视角转换", "了解到应该如何从数学上", "将每一个串视作为一个自然数", "以下 我们就来将这一构思", "具体地兑现为一个算法", "很有意思的是", "我们在此需要用到第9章的关键技术", "散列", "我们将每一个串所对应的自然数称作为它的指纹", "fingerprint", "因为这个数相对于串 就像指纹相对于人一样", "可以用来甄别其身份", "然而我们注意到", "这样一个自然数是以字符集的规模作为进制的", "因此字符集只要不是很小", "这类指纹的数值就会变得很大", "这不能不说是个坏消息", "比如 我们知道对于ASCII字符集来说", "它的规模为128", "对于这类字符", "即便模式串的长度不是特别地长", "它对应的指纹也会长得令我们吃不消", "我们可以来做一个快速的封底估算", "128是2的7次方", "因此即便是长度为10的模式串", "它所对应的指纹也至少需要70个比特方能表示", "这就意味着", "即便在64位的计算平台上", "长度不小于10的字符串", "将无法直接表示", "而更糟糕的是 我们因此而遇到的麻烦还不止这些", "实际上 在整数的字宽已经不能继续视作为常数之后", "整数之间的运算", "也不能继续保证可在常数时间内完成", "尽管RAM模型曾经的确作过这样一个不切实际的假设", "实际上 就渐进复杂度的意义而言", "此时 每次指纹比对所需要的时间", "将仍然线性正比于串的长度", "也就是说 我们的计算效率将重新退化到蛮力算法的水准", "那么 为了破解这一难题", "你又能想到哪些高招呢"]}, {"name": "06B1-5 邻接矩阵", "block_id": "e7bd5658b86e4f9a9257fc9c4efcb38f", "text": ["好了 现在我们就可以给出", "基于邻接矩阵", "实现图结构的一种可行方式", "作为一个类GraphMatrix", "也是派生于我们此前所定义的", "Graph接口", "我们可以看到", "这里确实首先需要将顶点集", "以及边集", "首先兑现为具体的数据结构", "什么数据结构呢？", "你会注意到", "无非就是我们此前所学过的向量", "没错 可以以这幅图示意", "所谓的顶点集", "无非就是由一组顶点所构成的向量", "可以称作a vector of vertices", "在这个图中 也就是这样一个向量", "它的长度恰好等于顶点的规模", "也就是我们通常记的n", "那么边集又当如何实现呢？", "可以看到 所谓的边集", "在这里定义成是", "由一组边所构成的向量", "进而由这一组向量所构成的向量", "也就是a vector of vectors of edges", "我们再来通过这个图", "理解这种实现方式", "具体来说 也就是", "我们将一系列的边构成若干个向量", "同样 每一个顶点最多可能与", "n 个顶点相关联", "所以每一个向量的长度也是 n", "而总共呢 会有n个向量", "所有这些向量再合在一起", "构成一个向量", "所以我们也可以认为", "这是一个二维的向量", "那它是什么呢？", "恰好就是我们此前所构思的邻接矩阵", "需要强调的是", "得益于我们此前对向量", "所重载的方括号操作符", "在这里我们只需用这样一种形式", "即可便捷地指代在顶点 i 与 j 之间", "潜在的那样一条边", "我们既可以读出这条边的信息", "也可以反过来修改", "其中的某些信息"]}, {"name": "02E-4 \t再改进", "block_id": "b71a1d17d7c741cfaf38b2416ca4f0ac", "text": ["重新审视这个例子 我们会发现", "所多余出来的时间消耗", "无非是在后缀中", "对这些已就位元素的反复扫描交换", "不难理解", "这些元素都是不必扫描交换的", "可惜我们此前的那个算法版本", "未能及时地将它们分解出来", "它们实际上是可以分解出来的", "比如说 如果我们通过某一种方法", "记录在上一趟扫描交换过程中", "所进行的最后一次交换", "我们就很容易确定", "在上一趟扫描的区间中", "有一个多长的后缀", "实际上没有做过任何交换", "也就是说 它们中的元素", "都是已经就位了的", "如果能这样", "只需要将原先的右侧标志hi", "直接地指向这个新的位置", "而不是像刚才那样", "亦步亦趋地、逐个地收缩", "基于以上的分析", "不难得到一个新的改进的方法", "从结构上看 跟刚才大体类似", "依然是逐个地检查所有的相邻对", "如果是逆序的 就做交换", "如果说有不同的话", "就在于这里我们所记录的", "不再只是一个逻辑性变量", "而是一个名为last的整型 或者说是秩", "这么样一个变量", "它的初值是取作lo", "而每当需要交换", "就将这个last更新为新的位置", "我们注意到 在整个算法的过程中", "lo这个变量是持续递增的", "从来不会减少", "所以换而言之", "当它在返回的时候", "last确实名副其实地记录了", "最右侧 也就是最后一对逆序对的位置", "这样的话 我们就可以", "有效地来处理刚才那种情况", "回到刚才那个实例", "即便我们构造了一个", "足够短的乱序前缀", "再加一个非常长", "但是已经就绪了的后缀", "我们新的这个算法", "首先也会做一趟扫描交换", "当然 为此花费的时间是O(n)", "但是与刚才那个版本的不同", "在这个时候", "它会聪明地检测出", "发生的最后一次扫描交换", "绝对不会超过这个位置", "我们完全可以将", "扫描交换的右侧界桩hi", "一次性地挪到这儿", "这等效于聪明地判断出了", "此后的这些元素", "包括最后那个元素", "都是已经就位的", "从算法的流程来说", "我们的下一趟扫描交换的区间", "就不再是原先整个那个绿色的区间", "而是相对要短很多的", "这样的一个区间", "接下来的故事呢？", "等效于只是对这样", "一段区间做扫描交换", "因此我们需要花费的时间", "除了刚才的O(n)以外", "主要是对应于这样的一个更小的三角形", "如果按照刚才所设计的那个例子", "边长是根号n的话", "累计也不过是再加上一个O(n)", "与刚才这个O(n)合并", "总体不过是O(n)", "更有意思的是", "这种情况在整个排序过程中", "有可能会多次出现", "即便最初的输入向量是无序的", "我们也确实需要进行", "若干次的扫描交换", "但是当执行到某一次迭代之后", "我们有可能会发现", "当前区间的某一个后缀", "已经完全有序了", "从而按照刚才的算法", "我们会聪明地对", "这样的一个新的区间", "来做进一步的扫描交换", "接下来也可能确实又会", "经过若干次扫描交换", "同样地 又有可能在某一个后缀中", "发现所有的元素都已就位", "于是我们又会继续跳过这些元素", "从更紧凑的范围 继续执行这个算法", "可见 通过这样的一个策略", "这个算法确实可以省去", "这部分 这部分", "以及相应一些部分的时间", "我们也可以通过图形的方式", "形象地将新的这个算法版本", "与之前的原始版本", "在时间效率上做一个对比", "这个三角形 我们应该很熟悉了", "它代表的就是原始的起泡排序算法", "所需要的时间", "在新的这样的一个版本中", "这个算法所需要执行的扫描交换", "将会呈现为连续的一段", "然后再间或地跳跃到下面一段", "以及再间或地有可能会跳跃到下面一段", "换而言之 这个算法的时间成本", "将取决于这样一个一个", "若干个梯形的面积总和", "相对于此前那个梯形来说", "这种梯形的划分更加的精细", "所以它节省下来的时间", "也会在通常的情况下 相对更多", "当然在最坏的情况下", "这个算法依然是于事无补的", "起泡排序依然注定需要O(n^2)的时间"]}, {"name": "08XA1-2\t持久性", "block_id": "2a3dc1cec0b84c3f926c5dedf7f5985a", "text": ["回顾我们以前所学过的数据结构", "不论是线性的向量 列表 栈或队列", "也无论半线性的树结构 以及非线性的图结构", "它们大多呈现这么样一种特征", "每当经过一次动态的操作 使得其中的逻辑结构发生变化之后", "它都会随即完全的转入新的状态 同时将此前的状态完全的遗忘掉", "这类结构也因此称作ephemeral data structure", "也就是说 它们都是随时变化的 每一个状态只会存在于某一个瞬间", "而每一个瞬间都是朝生暮死 稍纵即逝的", "然而在实际应用中 往往可能会有更高的要求", "比如 若将数据结构比作是人", "那么它的每一个瞬间状态 都相当于人一生中某一时刻的快照", "我们或许会对他的历史档案感兴趣", "并希望能够任意调阅甚至修改某个历史时刻的档案", "因此无论静态还是动态操作 除了指定目标关键码", "还需要同时指定一个版本号", "用以说明我们是在这个数据结构的哪一份历史档案中去查找特定对象", "如果一个数据结构能够支持这种类型的需求", "就称作是persistent structures", "也就是所谓的一致性结构 或者持久性结构", "乍看起来 任意数据结构的持久化都不是那么困难的一件事", "比如一种直接了当的方法就是", "为数据结构的每一个所需的版本 都独立的保存一份快照", "同时将所有版本的入口组成一个搜索结构", "这里我们针对一棵真实的BBST 记录了它整个生命期内的5个版本", "这样 一旦指定了版本号 我们就可以转入对应的快照", "并按照常规搜索方法在其中定位需要操作的元素", "从单次访问的效率而言 我们甚至可以说这个结构还可以接受", "是的 如果我们将整个历史快照的数目记作h", "那么每次我们只需logh的时间 便可确定版本档案的入口", "接下来再花费logn的时间 在这份档案中进行定位和操作", "然而就空间而言 这种方法是断乎不可接受的", "我们可以看到 在这样的一组历史快照中", "每一个元素 无论是它 还是它 以及它", "都可能会被保存多份", "渐近的来说 n个元素中的每一个都有可能在这组档案中被保存多达h份", "这就意味着空间复杂度 将伴随着h成线性的速度增长", "我们知道 空间复杂度 自然也构成了时间复杂度的一个下限", "因此在整个历史过程中 为了生成和记录所有的快照", "我们累计所花费的时间 也会多达这样一个规模", "分摊下来 我们为了生成每一组快照", "都大致需要花费线性的时间 创建一个完整的副本", "那么我们可否就此做一改进呢", "比如除了所有元素各自所占用的空间", "我们是否能够将每一个版本所消耗的均摊空间量", "控制在logn的范围内呢", "答案是可以", "为此我们需要利用同一数据结构相邻版本之间的关联性"]}, {"name": "04C3-5\t 括号", "block_id": "068038b6abba40c7b8eec88e86e6fdc7", "text": ["在结束本节之前", "我们再最后来看一下", "栈混洗与我们上一节所讨论的", "括号匹配之间存在什么联系", "我们首先可以观察到", "n个元素的任何一个栈混洗", "都对应于中转栈S的n次push操作", "以及n次pop操作所构成的一个序列", "其实我们开篇所举的", "那个3 2 4 1的栈混洗实例", "所对应的push、pop操作序列就是这个", "如果我们将每次push都换成一个左括号", "而将每次pop对应一个右括号", "就会发现同一元素", "所对应的那对push、pop操作", "无论是它、还是它、还是它、抑或是它", "都恰好对应于一对彼此匹配的括号", "反过来 由n对括号所构成的", "任何一个合法的表达式", "实际上也可以解释为", "对n个元素进行栈混洗的一个合法的过程", "也相应地对应于某一个输出的栈混洗", "概括而言 合法的栈混洗序列", "与合法的括号匹配表达式之间", "存在一个一一对应的关系", "n个元素的栈混洗有多少种", "n对括号所能构成的", "合法表达式也就有多少种"]}, {"name": "08B2-4\t深度统一", "block_id": "6ce7d565dd69483581870a8ae939a578", "text": ["以下我们就来给出B树的严格定义", "任何B树都有一个固定的指标 也就是它的阶次", "一般的 所谓m阶B树 就是m路的平衡搜索树", "正如我们在此前的实例中所看到的的", "作为B树的最重要的特征 所有叶节点的深度都是一样的", "同时相应的所有外部节点的深度 也是一样的", "我们知道所谓的叶节点 是在树中真实存在的末端节点", "因此就宏观特征而言", "在B树中所有叶节点应该集中分布于这样一些位置", "这里还牵涉到另一个概念", "也就是所谓的外部节点 external nodes", "在此前 我们并没有严格的区分 外部节点和叶节点", "甚至在很多文献中 二者可以彼此互称", "但是在B树中 这两个概念是断乎不同的", "尽管它们之间存在着紧密的联系", "具体来说 所谓的external nodes", "就是叶节点的那些数值为空 其实并不存在的孩子", "因此 在B树中 叶节点的深度统一", "其实也就等效的蕴含着外部节点的深度统一", "也与通常的二叉搜索树不同", "B树的高度实际上是相对于外部节点而不是叶节点而言"]}, {"name": "12b1-5: 算法实现", "block_id": "ab413fa43f064571915a49ced52218d8", "text": ["在这里我们给出以上构思", "可能的一种实现方法", "我们用maj来指代", "将要确认的众数候选者", "可以看到整个算法", "的确是一个迭代过程", "在迭代的过程中", "我们需要使用一个计数器C", "它的初值被赋为0", "我们将从前向后遍历整个向量", "并考察当前的每一个元素", "如果它与当前的候选者相等", "我们就令计数器增加一个单位", "反之计数器减少一个单位", "也就是说这里的计数器将忠实的记录", "在当前的前缀中", "这个候选者与其他元素", "在出现次数上的差额", "一旦这个差额归零", "也就意味着当前对应的前缀", "可以直接减除掉", "而为了使得这个迭代", "能够继续进行下去", "我们在进入新的一段前缀之前", "我们需要随即将它的首元素", "作为新的众数候选者", "当然因为它刚出现过一次", "而其它的元素还没有出现过", "所以此时差额计数器的初值", "也自然应该设作C等于1", "当整个的数据集都已遍历过后", "最终的那个maj", "自然也就是我们所需要的众数候选者", "因为根据我们此前的判断", "如果原向量的确存在众数", "那么它只可能是这个候选者"]}, {"name": "09D2-8 泾渭分明", "block_id": "bf79aea99c124820968dac9b97173792", "text": ["还是回到我们的散列", "依然考察双向平方试探策略", "假设按照我们所给的建议", "表长M取做模4余3的一个素数", "可以证明 在这样的条件下", "任何一个试探序列的前M项步都不会发生重复和冲突", "我们采用反证法", "假设在正向试探子序列中的第a步", "与逆向试探子序列中的第b步是彼此冲突的", "当然从标号上看 它们都不会小于1", "也不会超过M/2的下整", "那么什么是冲突呢", "翻译成数论的语言也就是说", "在关于表长M模余的意义下", "负的b平方 与正的a平方彼此同余", "稍作整理也就是 a的平方与b的平方之和能够整除M", "我们将注意力就放在这个平方和上", "并将其记作n 于是M必然是n的素因子之一", "既然作为给定条件 素因子M是模4余3的", "所以根据费马双平方定理的推论", "n不仅能够被M整除 而且可以被M的平方整除", "这就意味着a平方与b平方之和至少是M平方", "然而根据b和a的取值上限", "这一关系是断乎不可能成立的"]}, {"name": "08XA1-1\t观察体验", "block_id": "887fa3bcd5904729956f51f7a9726f87", "text": ["同学们好 在接下来的这一节", "我们将结识BBST家族中的又一新成员 红黑树", "这是一种特色极其鲜明的BBST", "正如它的名字所暗示的那样 其中的节点具有颜色", "是的 这就是一棵典型的红黑树", "其中的节点 可能是红色 也可能是黑色", "二者必居其一", "而更重要的是 作为BBST家族的成员", "它也必须能够在动态变化过程中", "始终保持某种意义上的平衡", "从而使得每次查找都能够在足够短的时间内完成", "当然 在经过动态修改之后", "它的自平衡过程也应该能够足够快的完成", "这些都是红黑树的关键技术所在", "不过在具体的讨论这些技术细节之前", "或许我们应该首先来问这样一个问题", "既然在BBST家族中已经有了AVL之类的成员", "而且其渐近复杂度 已经能够达到logn的要求", "那么为何还需要设计并引用红黑树这一新的变种呢", "在BBST这个家族中 红黑树的存在意义又在哪里呢", "下面我们就首先从一个角度来回答这个问题"]}, {"name": "01XC-3: Fib()：封底估算", "block_id": "d2666b8a836b4d6c8e1d12939b218493", "text": ["没错 我们这里又碰到了指数", "不同的是 我们这次要对这个指数", "来做一次准确地估计", "反过来验证一下", "我们刚才实际", "运行这段代码的效果", "为什么是那样", "我们来看一下 在这里", "作为封底估算的一种基本技能", "也要求大家能够记下", "这样一个大概的估计式", "具体地讲 也就是Φ的指数", "也就是36次幂", "和2的25次幂是相当的", "怎么来记忆这个呢？", "我们说 很好记", "36是6的平方", "而25是5的平方", "好记吧", "基于这样的一个大致估计", "我们就可以来估计一下", "Fibonacci数的第43项", "刚才我们已经明显地", "感觉到延迟的那一项", "所需要计算的成本", "那么 根据这个来估算", "大致就等于2的30次方", "2的30次方是多少呢？", "等于2的10次方的3次方", "而2的10次方呢", "是等于10的3次方", "当然是约等于", "所以当然就是10的9次方了", "也就是说我们的计算工作量", "大概可以用10的9次方条", "基本操作指令来度量", "而前面刚刚讲过", "10的9次方就是现在主流的计算机", "一个gigahertz主频的CPU", "在一秒钟之内", "大致能够吞吐的计算量", "这也就是为什么", "当我们的计算大致接近43", "甚至更大的时候", "我们会明显地感觉到延迟", "为了更好的理解指数", "对于我们实际的计算", "延迟的那种感受", "我们再来推算一下", "这里用到另一个近似式", "也就是Φ的5次方大致就是10", "因此我们可以来估算一下", "Φ的67次方", "也就是对应我们算出", "Fibonacci数的第67项", "大概需要多少时间", "我们来看 它的计算成本", "大概是10的14方条基本指令", "为了吞吐或者执行这么多条指令", "我们需要多少时间呢？", "在同样的9次方的主频下", "我们做一次除法 或者说14减9", "应该会得到10的5次方 这么多秒", "10的5次方是多少？", "大家应该已经学会“封底估算”", "应该有这种直觉了", "前面也讲过 10的5次方", "大致就是一天", "换而言之 刚才那段程序", "如果我不中止的话", "它在算出第67项之前", "我们也许应该先下课", "大家回去休息一晚上", "第二天 我们再来看它运行的结果", "一天 仅仅对于第67项", "这个是很可怕的一件事", "当然 为了再进一步地 有所感觉", "我们不妨来 再估算一下", "多少呢？我们来看一下", "为了算出Fibonacci数的第92项", "我们大致需要多少时间", "同样地 根据刚才那个估算", "我们需要的指令的数目", "大概是10的19次方", "同样地 10的19次方", "除以10的9次方", "19减9 我们会得到", "10的10次方秒", "10的10次方秒是多少？", "我们此前刚刚介绍过", "它就对应于", "我们俗称的叫三生三世", "或者准确地讲就是三个世纪", "三个century", "大家可以看到这里确实", "远远地超过了我们的直觉", "利用这个算法", "即便是算出不超过一百项", "我们就需要用我们一生", "都难以承受之久的等待", "这说明什么呢？", "说明这个算法不好", "从严格的意义上讲", "它甚至不是一个算法", "虽然从表面上看", "它还像那么一回事"]}, {"name": "09C-7 折叠汇总", "block_id": "1868f55f007a4a43ae5ced4ff8f8ba46", "text": ["为了使得原关键码中的各数位", "对最终地址拥有更为平均的影响力", "从而实现更好的均匀性", "还有一些非常有趣的散列函数值得借鉴", "比如所谓的折叠法", "可以按照最终散列地址的宽度", "将原关键码中的各数位依次分为若干组", "并将每一组独立的视作为一个整数", "而它们的总和 就是对应的散列码", "这种方法还有一些有趣的变种", "比如原关键码中的各数位将按照交替的方向", "转换为对应的整数", "123 456 789 诸如此类", "形象的说 这就好比我们需要做一张千层饼", "为此我们首先需要将和好的面 擀成一张薄片", "前一种方法会将面继续的切成均等的一段一段", "并按次序将它们摞起来", "最后通过挤压 将它们合成一张薄饼", "而相对于真实的千层饼制作工艺", "后一种方法更为接近", "也就是以一种往复折返的方式", "同样将面折叠起来 并最终压实", "尽管同样是经过分段和对齐", "最终压实的那一步 却未必只能通过求和", "比如对于二进制 很多种位运算都具有同样的功效", "比如最常用的就是按位做异或", "在课后你不妨就此来验证这里所给的实例", "当然此类方法林林总总 你可以在课后深入研究和探讨", "至此你应该对散列函数的特征有了更具体的理解", "是的 总之大致说来", "散列函数越是随机 越是没有规律就越好", "随机 是的"]}, {"name": "09C-6 平方取中", "block_id": "ba881aeaa51f44fe8fad173e983c51fc", "text": ["散列函数是一个庞大的家族", "其中的成员形形色色 各有所长", "这也是散列技术的趣味性和魅力所在", "接下来我们不妨就来看看其中的几个典型代表", "首先是所谓的数字分析法", "这里的原则是 无论此前的关键码有多少位", "我们只从其中挑选出若干位 构成散列地址", "比如我们可以将关键码的数位间隔的分为两组", "并选择其一组成最终的散列地址", "当然 尽管这里需要分组", "但分组方式必须是事先确定的", "否则也就违背了确定性的原则", "另外 这种方法的缺陷也十分明显", "因为没有被选用的那一组数位", "对最终的散列地址没有任何的影响和贡献", "没有足够的体现均匀性的要求", "就此 可以有很多种改进的方法 比如平方取中法", "按照这种策略 我们首先要计算出关键码的平方", "并截取中间的若干数位作为散列地址", "以123为例 如果没有算错 他的平方应该是15129", "因此我们可以取居中的3位", "也就是521作为对应的散列地址", "更复杂的情况 也是按同样的方法处理", "至此你或许会有一个疑问", "这里为什么我们会倾向于保留居中的数位呢", "实际上 这正是为了使得构成原关键码的各数位", "能够对最终的散列地址有尽可能接近的影响", "我们来看这样一幅图", "它将一个数的平方运算", "分解为一系列的左移操作 以及若干次加法", "如果最终的结果是这个 从图中不难看出", "如果忽略进位 每一个数位都是由", "原关键码中的若干数位经求和得到的", "因此两侧的数位是由更少的原数位累积而得", "而越是居中的数位 则是由更多的原数位累积而得", "因此截取居中的若干位", "可以使得原关键码的各数位对最终地址的影响彼此更为接近"]}, {"name": "02C-2: 循秩访问", "block_id": "08a527ec06db4cee8ad6723d8c36b603", "text": ["我们首先讨论", "向量元素的访问", "表面上看 这并不是什么问题", "因为在向量ADT中", "已经定义了两个标准的接口", "get和put", "通过它们 我们已经可以", "自如地来读或者是写", "向量中特定的元素", "然后我们说 这两种接口", "在形式上 还不是那么简洁", "也不够直观", "回忆一下在数组中", "那种直接地访问方式", "我们就会发现", "原来那种方式", "会更加的便捷", "我们可以直接地说", "在数组中的 第多少号元素", "我们很希望能够", "向量也具有这样的特性", "可以直接通过这种形式", "从向量中取出", "或者反过来向其中写入", "第几号元素", "那么可否继续沿用", "这种下标式的方式呢？", "好消息是可以", "为此只需要对下标操作符", "这个方括号对 进行重载", "具体地 像下面所写的这样", "对于任何一个指定的Rank r", "我们只需要在内部数据区中", "取出对应的第r号元素", "此后 凡是需要引用", "向量中的某个特定的", "比如说Rank为r的这个元素", "就可以直接以这样一种", "类似于数组的形式进行引用", "请注意 这种引用", "可以作为右值 也就是说", "以这种类似数组形式进行运算", "并且将运算的结果", "向左侧赋值给某一变量", "而反过来 计算的结果", "也可以赋值给", "向量中某一个元素", "也就是作为左值", "作为左值 之所以能够实现", "得益于这个接口返回值", "是一个引用", "既然向量是源自", "并且脱胎于数组", "所以在这里继续沿用", "它那种直观而直接地访问方式", "也就不足为怪了", "在这里 我们再强调一下", "这种访问方式中", "至关重要的是“秩”", "也因此我们称之为", "循秩访问方式", "需要说明的一点是", "为了便于讲解", "我们在这门课中", "往往会采用一些简易的方式", "来处理算法可能遇到的", "意外或者是错误", "比如说在这里", "我们对于入口参数r", "并没有做过多的检查", "而是简易地 在入口处", "增设了一个断言", "用以提醒或者是要求使用者", "保证入口参数r", "能够在合理的范围之内", "那么在真正的实际应用中", "要做更为严格的处理"]}, {"name": "08XA4-6\tBB-2R", "block_id": "54986f4f13134ee2819a844772e325ed", "text": ["兄弟节点s为黑 同时它的两个孩子也都为黑的情况", "我们不妨归作为BB-2", "这种情况 又进而分为两种子情况", "它们的区别就在于 此时的父节点p究竟是红还是黑", "我们首先讨论p为红的情况", "我们称这种情况为BB-2R", "相应的 p为黑时自然也就是BB-2B", "依然沿用我们一贯的技巧", "首先将此前的红黑树 转换为对应的B树", "不出意外 依然在这个位置上发生了一次下溢", "不同之处在于 此时我们并不能实施旋转调整", "原因正如我们所看到的 此时的兄弟关键码s", "独自的构成一个超级节点", "这样一个超级节点已经处于下溢的边缘", "并不足以借出任何的关键码", "你应该还记得在B树中我们是如何处理这种情况的", "是的 合并", "从父节点中取出一个关键码", "并且以它作为粘合剂 将左和右两个节点合二为一", "修复的结果是这样", "好了 接下来我们只需要将这棵B树", "反向的变换回对应的红黑树", "就可以得到在红黑树中的一种可行调整方案", "现在 站在红黑树的角度来审视这个调整过程", "可以看到 其结果相当于r保持此前的黑色", "而s呢 将由黑转红 同时p由红转黑", "可见 在红黑树中的上述调整过程", "完全等效于在B树中某个节点通过与它的兄弟合并来消除下溢", "那么这一局部双黑缺陷的修复", "是否同时也意味着红黑树的性质能够得以在全局得到恢复呢", "细心的你可能会发现 无形中上层的节点", "已经损失了一个关键码p", "而这是否意味着在B树中接下来会再次发生下溢呢", "好消息是 不会", "原因在于 这里的关键码p是红色的", "这就意味着 在它所属的那个B树节点中", "至少还应该有一个黑色的关键码", "因此在它被借出之后 不至继而发生下溢", "因此与BB-1一样", "我们对BB2-R的修复也必然是一蹴而就的 彻底的", "好了 节点p也就是局部的子树根为红色的情况", "我们已经知道如何处理", "那么接下来 倘若节点p是黑色呢"]}, {"name": "05E1-1 转化策略", "block_id": "84d4534e385c4b18923a469fcae988e5", "text": ["同学们好，在前一节我们已经学习了", "如何实现一棵二叉树之后", "那么从这一节开始", "我们将集中讨论二叉树的相关算法", "与此前的很多问题一样", "二叉树的相关算法", "也往往需要对其中的元素按照某种次序", "来逐一访问", "然而在前面几节我们已经清晰地看到", "二叉树已经并非严格意义上的线性结构", "至少是所谓的半线性结构", "在接下来的几节乃至全书", "我们都将向大家传授一种求解问题的策略", "也就是不要从轮子造起", "而是要善于利用此前的工作成果", "就我们这一章所重点讨论的二叉树而言", "也就是我们如何才能够将这种半线性结构", "转化为此前我们已经相对而言", "研究有素的线性结构", "具体的来说也就是", "按照某种事先约定的原则", "在二叉树的所有节点之间", "定义某种明确的线性次序", "而具体的转换手法", "也就是接下来几节要介绍的遍历", "实际上 这种策略将贯穿我们整个课程", "比如 在接下来一章", "将要介绍的图结构", "是属于典型的非线性结构", "在那里 我们同样面临一个问题", "就是如何将非线性结构转化为", "又相对而言研究有素的半线性结构", "在那里 我们的处理手法", "依然是遍历"]}, {"name": "06D-5 有向图", "block_id": "7d8e23332e9d49d88f1988702ca65705", "text": ["相对于无向图", "有向图的深度优先搜索要更为复杂", "所涉及的情况也会更多", "我们不妨来看这样一个实例", "首先确认这是一幅有向图", "在这个图中", "我们将每一个顶点", "都绘制成长方形", "顶点的标识居中", "在它的左右空白处 我们将分别", "记录下它在遍历过程中", "所获得的dTime和fTime两个时间标签", "因此如果起点是A的话", "它将在dTime等于1 也就是第一秒的时刻", "被发现", "同样 我们将它转为大写", "并且将这个边框加粗 以示区别", "以下从顶点 a 出发", "经过一条有向边", "我们可以在第二秒发现", "并访问顶点B", "同样地 我们将它变为大写", "并加粗边框 以示区别", "而此时处于DISCOVERED状态的顶点a", "也需要以双线边框", "与其它顶点相区别", "以下从顶点b出发", "又可以经过一条有向边", "在第三秒发现并且处理顶点c", "虽然从表面看顶点 c", "存在若干条邻边", "但是因为这里是有向图", "实际上从c并没有发出", "任何有效的边", "因此在顶点c处", "我们不得不做一次回溯", "同样地 逆向经过刚才那条树边", "回到顶点B", "不要忘了 在此前我们需要为这个", "已经访问结束的顶点c", "记下它的fTime时间标签", "也就是3+1等于4", "再以下", "同样地 顶点b在接过控制权之后", "也会发现它的所有的邻居都已扫描", "并且处理完毕", "因此会继续沿着它所对应的那条树边", "逆向地抵达它的父亲节点 也就是A", "同样 顶点b访问结束的时刻", "是4+1 也就是5", "在顶点A再次地获得了控制权之后", "它会继续刚才没有做完的事情", "也就是继续扫描", "它的其它邻接顶点", "比如这里的顶点c 请注意", "这是我们第一次遇到的一个情况", "它的特征是我们立足当前的顶点", "会发现它有一个邻居已经处于最终的", "VISITED状态", "已经访问完毕了", "你应该还记得我们所设计的算法", "在这种情况下 我们应该进而", "分两种子情况来进行讨论", "而区分的准则", "就是dTime 时间标签", "具体来说 要看当前节点A", "与它的邻居节点c", "谁的时间标签更小", "或者等价地 谁更早被发现", "如果像这种情况所示的那样", "我们可以看到 1小于3", "这就说明 顶点A相对于它的邻居c", "是更早被发现的", "因此根据算法的规则", "我们应该将它们之间的那条有向边", "归类为FORWARD", "什么意思呢？ 向前边", "我想通过这个例子 你应该能够", "很好地理解为什么叫向前边", "没错 它的意思是说这条边", "是由遍历树中的祖先节点向前", "指向它的后代", "所以称作FORWARD EDGE", "是再形象和合适不过的了", "再以下 顶点A还有一个邻居f", "处于UNDISCOVERED的状态", "这也就是为什么在接下来的第六秒", "顶点F将接过控制权", "此后呢 它将在第7秒将控制权交给", "它的下一个邻居 也就是顶点G", "现在我们立足于顶点G", "也同样要去环顾四周", "逐一地考察它的邻居们", "我们可以看到 第一个邻居是顶点a", "请注意 此时应该属于算法的第二种情况", "这个邻居当前处于第二种状态", "也就是DISCOVERED", "根据算法的规则", "我们应该将它们之间的", "这条有向边", "归类为BACKWARD", "后向边或者叫回边", "我们也该来体会一下为什么叫回边", "你应该能看出来", "其实它等效于在遍历树中", "我们试图从一个后代", "去回连到它的祖先", "所以称之为BACKWARD", "是再形象不过的了", "同样地 一旦出现BACKWARD边", "也就同时意味着我们发现了", "至少一条回路", "这样一个性质的严格证明", "大家可以参考我们的教材", "以及习题解析", "好 再接下来 我们依然立足于", "当前的顶点G", "考察它的下一个邻居 也就是顶点c", "当然 因为我们的状态变化是不可逆的", "所以c自然依然处于", "最终的VISITED状态", "也就是说 我们又再次地遇到了", "算法的第三种情况", "同样 我们需要比较它们的", "dTime时间标签", "从而进一步地明确", "此时到底是属于", "两种子情况中的哪一种", "不难看出 7要大于3", "而不像此前1小于3", "所以此时应该是处于", "第三种情况中的", "后一种子情况", "你应该还记得", "按照我们所设计的算法规则", "此时应该将从当前顶点通往它邻居的", "那条连边 归入CROSS一类", "也就是跨边 跨越边", "为什么称作是跨越边呢？", "我们不难看出 在整个遍历树中", "这两个顶点之间", "并没有任何的祖先或后代的", "直系血缘关系", "如果要形象比喻的话", "它们只不过是姑表亲", "这样一类连接于姑表亲顶点之间的边", "首先不应该称作是FORWARD边", "其次也不应该称作是BACKWARD边", "而称作跨越边", "则是再形象和合适不过的了", "至此 g的所有邻居", "都已扫描并且处理完毕", "因此对它的访问也应随即终止", "所以它会在第八秒", "记录下它的fTime时间标签", "并且逆向地回退到它的父节点", "也就是F", "而此时的F顶点呢 所有的邻居", "也都处理完毕", "因此它依然需要回溯", "同样 在回溯之前", "也需要记下它的fTime时间标签", "也就是8+1=9", "最终的控制权", "又再次地回到顶点A的手中", "此时的顶点a", "所有的邻接顶点也都扫描", "并且处理完毕", "所以也轮到它结束自己的遍历过程", "它的fTime时间标签", "应该是9再加1", "也就是10", "综观整个过程", "我们总共用了10秒", "遍历完了由这五个顶点所构成的", "一个子图", "更确切地讲 它们构成了", "在这个图中 从顶点a出发", "可以达到的区域", "也称作可达区域", "那么图中的其余部分呢？", "比如说这里的顶点d以及e呢？"]}, {"name": "02D2-4 \t原理", "block_id": "826f56030f1344ad8b613f6c35443843", "text": ["我们来看二分查找的第一个版本", "这个版本只是为了说明原理", "从严格的意义上讲，它还不能完全地", "符合我们刚才的语义要求", "但是不要紧，我们稍候就会对它进行改进", "这个算法的原理是", "我们此前介绍过的减而治之", "也就是说，将一个比较大的问题", "在一个相对大的区间内进行查找", "转化为一个实质上更小的问题", "确切地讲，在这里", "我们将在lo和hi确定的这个区间内", "考察它的某一个点", "我们称它是mi", "这样的任何一个点", "都可以将整个的向量分为三个部分", "mi左侧的那部分", "右侧的那部分", "还有mi自己本身", "所以如果用式子表达出来", "应该就是这样三部分", "那么接下来呢", "通过最多两次比较", "就可以进一步地将这个问题转化为更小的问题", "这种比较无非三种情况", "如果目标比当前的这个mi的数值", "比如是x要小", "我们就转向左侧这个子区间", "如果比它要大", "那么我们就转向右侧这个子区间", "因为无论是这两种情况的任何一种情况", "确实我们忽略掉的那些部分", "比如说对这种情况来说，忽略的是右边", "对这种情况来说，忽略的是左边", "都是确实可以忽略掉的", "而中间的一种状态，也就是说", "如果恰好x就是等于mi", "这是再好不过的了", "因为这就是命中", "我们就随即在这个位置上直接返回", "当然，有多个解的情况怎么返回", "这是我们稍后再来解决的", "这里只是给出了个一般的情况", "为了使得整体的时间效率更好", "我们当然希望不要出现不平衡的情况", "所以这里我们采用的一种简单的策略", "就是将这个mi取作", "lo和hi之间的中点", "这样虽然不见得", "每次都能够碰到最好的情况", "但是至少能保证情况不会很糟", "确切地讲，每一次减而治之后", "问题的规模都至多是原来的一半", "或者反过来说，至少有一半会被剔除掉"]}, {"name": "03D-3\t 实现", "block_id": "b455bd5280e349e19480520cca0965aa", "text": ["以上的这样一个构思 可以具体地兑现为", "名为seletion sort这样一段代码", "请注意这个接口的语义", "我们看到 待排序的元素", "实际上是在列表中", "起始于位置p的连续n个元素", "在这幅图中 如果L是整个的列表", "那么待排序的区间", "也就是从节点p开始", "依次向后数 直到第n个节点", "请注意 这里第n个节点", "是用虚线表示的", "言下之意 我们这里依然采用了", "此前左闭右开的区间定义习惯", "相应地 这里引入了两个界桩", "head和tail", "经过入口处 预处理的这样两步", "head和tail分别对应的位置", "就是在这个图中的h以及p+n", "在接下来的循环中 head始终不变", "而tail可能会每次向前移动一个节点", "而从tail开始", "到最初的界桩之间的范围", "正是我们刚才所讲到的", "已经排序的区间", "而尚未排序的那个名为U的前缀呢", "也就是从p一直到T", "这样一个左闭右开的区间", "这也是这个算法的不变性", "从算法可以看出", "每次我们都调用一个叫作", "selectMax的接口", "从U这个区间中找到当前的最大者", "请注意 这里的n会随着", "迭代地进行 相应地下降", "从而忠实地记录前缀U的宽度", "在这个图中 被选取出来的最大节点", "我们以大M来表示", "在算法中", "我们将选取出来的这个", "大M节点摘出来", "进而插入至S区间的首节点", "也就是tail的前端", "在图中可以看到", "这相当于将挑选出来的", "这个最大的元素M移动", "到此前的T的紧邻左侧", "并且随即将T移动到新的这个节点处", "从而使有序的部分向左拓展一个单元", "这个算法将持续地迭代下去", "直到n最终缩减到平凡的情况", "从而完成整个指定区域的排序"]}, {"name": "11c6-1: \t美中不足", "block_id": "297bc371fe5545448b8c4604b9a37950", "text": ["以上 我们不仅给出了KMP算法", "同时也证明它的时间复杂度已经达到了渐进意义上的最优", "也就是最坏情况也不超过O(n)", "然而该算法目前的这个版本", "也绝非完美无缺", "接下来我们就会看到", "在某一方面 它依然存在一个细微的瑕疵", "我们要针对这一缺陷", "对它再作改进", "为了揭示其中仍然存在的问题", "我们从这样一个反例入手", "首先确认 对于这样一个模式串", "这里给出的 的确是它的next查询表", "与所有情况一样", "KMP算法首先将文本串与模式串", "在首字符位置对齐", "并启动第一轮的字符比对", "不难看出 在经过3次成功的比对之后", "算法将首次失配于这一对字符", "于是根据算法的流程", "接下来 我们应该将模式串中的这个字符", "替换为它对应的next表项所指的那个字符", "也就是2号字符", "因此接下来等效于将模式串向右侧滑动一个单位", "从而按照next表的语义", "将2号字符与刚才失配的那个文本串字符对齐", "并再做一次比对", "诚然 这次比对依然会失败", "因此接下来我们将去查询2号字符在next表中所对应的那一项", "也就是1", "从效果上看", "这依旧等价于将模式串再向右滑动一个单位", "从而以1号字符 也就是它", "或者说它 与文本串中失配的这个字符再次对齐", "并再做一次比对", "同样不难看出 这次比对也会以失败返回", "因此我们又会继而去查询这个字符 也就是这个字符所对应的next表项", "并按照这个表项的指示", "将0号字符 也就是首字符或者说它", "与文本串中刚才失配的那个字符对齐", "并随即做一次字符的比对", "再一次地 这次比对依然会以失败返回", "于是根据算法的逻辑", "我们将去查询这个字符", "也就是首字符在next表中所对应的表项", "从而将假想存在的那个通配哨兵", "与文本串中失配的字符对齐", "当然 既然是通配符", "这次比对也必然会成功", "从而算法终于得以越过这个位置", "而从下一对字符开始", "继续进行下去", "当然 我们这里的重点并不在于再次地验证一下KMP算法在这种极端情况下的正确性", "事实上 我们更加关注度的 是KMP算法在这种情况下的性能表现", "回顾刚才所展示的整个过程", "文本串中失配的那个字符", "先后与模式串中的4个字符进行了比对", "才最终在第5个 也就是通配字符处", "得以匹配", "事实上 如果说第一次比对还是有意义的话", "那么 后续的3次比对实际上都是多余的"]}, {"name": "05B-5\t长子+兄弟", "block_id": "cd3c366bab31401ea9c60bb369ce4aff", "text": ["反观刚才所出现的问题", "根源在于每一个节点的出度", "是不尽相同的", "有的是3", "有的是2", "而更多的呢", "是0", "为进行改进", "我们必须发现", "每个节点所具有的某种不变性", "我们会发现就向下的引用而言", "每一个节点只需记两个信息就够了", "第一个就是它的长子", "第二个呢", "就是每一个节点的下一个兄弟", "作为多为独生子女的年轻人", "这样一个方式可能不太好理解", "对于稍早一些兄弟姐妹较多的家庭", "那么这个策略就非常自然而然了", "在一个家庭中 如果孩子相对更多", "那么很多家庭", "所普遍采用的一种策略就是", "父母将主要的事情交办给长子", "而其它的孩子呢", "则是在大哥的带领下 依次地彼此照顾", "也就是说 父母更多的", "首先关注的是长子", "的确 从简洁性来讲", "这的确是一个非常好的方法", "也是我们在这里需要借鉴的", "我们来看这里的一个实例", "对于任何一个节点", "我们都只关心它的长子", "比如相对于R而言 就是A", "我们不再像以前那样", "保留通往所有孩子的引用", "而只是保留从R到长子的一个引用", "也就是我们说的firstChild()", "而R节点的其它的孩子呢？", "在这里的讲B和C呢？", "会依次地通过nextSibling()这个引用", "由A指向B", "再由B通过下一个", "它的nextSibling()指针指向C", "采用这种方法", "我们依然可以确认", "并且保持不同节点之间的代继关系", "也就是沿着纵向不断地向下", "代次逐渐地下降", "越往上是越高的祖先", "而nextSibling()这个引用呢", "我们可以按照这里的图示", "将它们理解为在同辈的", "兄弟之间的水平方向的引用", "请注意", "相对于此前常规的表示方法", "这种表示方法的规整性非常的突出", "我们再来看一下 对于任何一个节点", "无论是A B C或者是D E F", "它都只需简明地记录两个引用就够了", "也就是纵向的firstChild()", "以及横向的nextSibling()", "也就是说", "每个节点所需要占用的空间", "依然是常数", "而且都彼此接近", "这是此前的常规方法所无法比拟的", "这种所谓的长子兄弟法", "不仅是树的一种很好的表示方法", "而且也是对树的本质的", "一种更深刻的理解", "在此后我们介绍二叉树", "并且用二叉树来代表所有的树的时候", "我们将再次用到这样一种表示方法", "在后面 我们会看到", "对于树这样的一个全集来说", "尽管二叉树只是它的一个特殊的子集", "但是很有趣的是", "在施加了某些条件之后", "二叉树却足以来表示和实现所有的树", "而这样一种方法背后的原理", "在很大程度上", "就是基于我们这里所介绍的", "长子兄弟法"]}, {"name": "07D1-2 平衡因子", "block_id": "c256d82a167240b89982197228ea7c7e", "text": ["首先 我们来给出", "在AVL的意义下", "什么叫作适度的平衡", "凭借什么来判断一棵树", "是否是在AVL意义下的适度平衡", "我们需要用到这样一个指标", "实际上 对于二叉树中的任何一个节点v", "都可以定义它的所谓平衡因子", "balanced factor", "具体来说 也就是它的左子树高度", "与右子树高度之差", "那么根据AVL树发明者的定义", "所谓AVL树就是其中所有节点的平衡因子", "都不超过1 也不小于-1", "比如 不难验证这样一棵BST", "其实就是一棵AVL树", "当然 AVL树本身只考虑左右子树的高度", "所以只要所有节点", "能够满足全局的单调性即可", "我们并不需要关心", "它们具体的数值是多少", "所以这里不妨不再将关键码加亮显示", "而把关注力更多地集中于", "各个节点的平衡因子", "我们来校验一下", "对于第一个叶节点而言", "它的左右子树都是空", "高度均为-1", "所以这个节点的平衡因子", "自然就是-1减-1 零", "再来看第二个节点", "它的左子树高度为零", "而右子树高度为-1", "所以它的平衡因子应该为正1", "同样地 对于这个的节点来说", "它的左子树高度为-1", "而右子树的高度为零", "所以这个节点的平衡因子", "应该为-1", "类似地 对于这个节点而言", "它的左子树高度为1", "而右子树高度为0", "两项之差为正1", "最后 对于根节点来说", "它的左子树高度为1", "而右子树高度为2", "二者之差为-1", "因此 对于这样一棵BST来说", "的确 平衡因子在处处", "都上下不超过正负1", "因此它的确是一棵名副其实的AVL树", "当然从这个例子 我们也可以看出", "AVL树未必是完全二叉树", "也就是说 它未必是理想平衡", "那么反过来 如此定义的AVL树", "是否的确是适度平衡的呢？"]}, {"name": "04C2-3\t 构思", "block_id": "b66d3b4a7b4044e2a21bf9ccbd9ddee8", "text": ["一种可行的方法是", "将以上的减而治之的策略", "颠倒过来", "我们不是去试图", "减除一个表达式", "最外围的那样一对括号", "而是试图去减除其中", "相互紧邻的一对左右括号", "就像这幅图中所画的那样", "如果我们在一个表达式中", "能够发现一对彼此紧邻的左右括号", "那么在将这对括号减除之后", "剩余的部分是否匹配", "与此前的表达式是否匹配", "必然是互为充要条件的", "那么如何找到这样一对括号呢？", "另外，更重要的是", "如何使得这种简化", "能够持续地进行下去呢？", "比如说，即便我们可以", "通过一次线性的扫描", "发现这样一对括号", "并且随即将它删除", "那么在接下来的这个表达式中", "难道我们依然还需要", "重新去做线性扫描", "并且发现其中的", "某一对这样的括号吗？", "这样一个策略应该是行不通的", "因为我们不难构造出反例", "需要去反复地做线性长度的搜索", "实际上，面对这样一种情况", "正是我们这一章的主角栈", "可以大显身手的时候", "借助栈结构的算法过程原理", "可以表示为这样一幅图", "如果这是我们所使用的栈", "那么其中所包含的", "就是我们已经扫描过", "但是仍待处理的部分", "实际上，我们会看到", "其中只需保存左括号", "因此凡遇到左括号", "它都简明地令它直接入栈", "而一旦遇到右括号", "我们不仅不需要令它入栈", "而且反而应该将", "栈顶的那个左括号弹出", "你应该已经能够看到", "这样所遇到的一个右括号", "与我们栈顶所弹出的左括号", "恰好就是我们此前所说的", "那样一对彼此配对而且紧邻的括号", "正如我们刚才所说的，它们的消除", "对于整体的表达式是否括号匹配", "是没有影响的", "因此接下来，如果说", "栈中的内容以及尚未扫描的内容", "是左和右两部分的话", "那么它们的总和，其实就等效于", "刚才被删除的这对括号", "根本就没有存在", "也就是说，算法的确可以", "持续地如此往复进行下去", "如果最后一个括号", "也就是右括号被处理之后", "整个栈恰好变空", "那么就意味着", "原来的表达式是匹配的", "反之，无论到最后", "栈非空或者在中途", "某个阶段提前变空", "我们都可以判定", "原来的表达式是不匹配的"]}, {"name": "11b2-3: \t版本二", "block_id": "39b630ee36664e2b85f52eb66caca35f", "text": ["我们再来考察 蛮力匹配算法的另一个版本", "如我们刚才所说 算法的接口形式 与前一版本完全一致", "而且 这里同样地设置了i和j两个整数", "用于指示当前接受比对的字符", "当然 具体的指示方式 与前一版本略有不同", "通过这幅图 可以很清楚地看出这种新的指示方式", "具体来说 模式串中当前的字符 编号依然为j", "而在文本串中 当前字符的编号则为i+j", "参照代码可以看到", "我们的确每次都是将文本串中编号为i+j的那个字符", "与模式串中编号为j的那个字符进行比对", "并根据比对的结果确定算法的下一步走向", "相对于前一版本", "在这里 每经过一次成功的比对", "我们只需简明地令j递增", "就可便捷地指向下一对字符", "当然 这种优势只是形式上的", "实质上并没有任何改进", "因为我们注意到", "在每次真正实施比对时", "我们还需补上那次貌似省略掉的加法运算", "当然 上一版本的不变性在这里依然成立", "比如 模式串相对于文本串的对齐位置", "依然是当前这对字符各自位置的差", "具体来说 在这里 也就是i", "既然对齐位置始终都是由i指定的", "在算法的出口处以i作为返回值 也是再自然不过了", "这个返回值 与上一个版本的返回值i-j", "有着异曲同工之妙", "不难看出 无论是前一版本还是后一版本", "都忠实地体现了我们最初的蛮力策略", "那么 这一策略所对应的计算效率 究竟有多高呢"]}, {"name": "01XC-7: LCS：递归", "block_id": "420c5af2e90a45c897c04bf453a436ac", "text": ["以下我们就参照", "Kent Beck所建议的工作流程", "暂时把计算效率放在一边", "而是首先考虑得到一个", "可行的正确的LCS算法", "为此我们需要拿起递归", "这个强有力的武器", "如果把这个问题形式化一下", "我们需要考察的是", "计算长度为n+1的一个序列A", "以及长度为m+1的一个序列B", "之间的LCS", "那么这无非可以分为三种情况", "第0种情况", "也是平凡的情况", "n或者m等于-1", "这个时候 其中之一是空序列", "那么我们知道空序列的子序列", "只可能是空序列", "所以公共子序列", "也必然是空序列", "所以不妨直接把空序列", "也就是长度为零的一个序列返回", "这种情况 在我们算法中", "应该是扮演着递归基的角色", "那么一般的情况呢？", "我们说它有两种", "首先来看第一种", "这两种的区别也就在于", "我们要去比较A序列和", "B序列的最后那个字符", "也就是末字符", "如果它们相等", "那么这是第一种情况", "这时按照这里所说的", "我们可以把最后那个字符去掉", "大家注意这里是变成了圆括号", "表示是开区间", "同时把B序列的末字符抹掉", "这样得到它们各自长度", "减少一个单元的前缀", "这对前缀", "如果能够递归地求解出LCS的解", "那么再并上", "最末尾的这个公共的字符", "我们说这样就必然构成了", "原来那个问题的解", "可以用这样的一个图来表示", "也就是说 A序列的末字符", "与B序列的末字符 都是相同的", "在这个时候", "可以大胆地做一个裁切", "将二者相同的", "这个末字符都忽略掉", "保存下来", "进而递归地求解", "它们各自的那个前缀", "所构成最长公共子序列", "反过来 一旦求到了以后", "只要把X缀在其后", "就可以得到原来的解", "那么 从任务的递归方向来看", "我们也可以用这样的一个图来表示", "比如说对于这个例子而言", "就是这样一种情况", "A序列和B序列", "分别列在上下方", "在这种情况下", "它们的末字符相同", "对这个例子而言 都是A", "这个时候 我们说原问题", "当前这个问题的解是多少", "完全取决于", "它们去掉这个公共字符之后", "各自的前缀合在一起", "所构成这样的一个递归的问题", "这个问题的解", "如果能够递归求出来", "那么从长度上讲 只要加1", "也就是缀上这个公共的字符", "就得到了原问题的解", "那么这个箭头", "表示的是递归的方向", "而且这种递归 从策略上讲", "其实就是不折不扣的", "Decrease and Conquer 减而治之", "从图上也可以看出来", "相当于把这个问题", "切分成了一个平凡的子问题", "以及一个规模小于1", "但是形式完全一样的问题", "当然互补的 还有第二种情况", "也就是说 我们经过判断以后发现", "当前的序列A和B的末字符并不相等", "这个时候呢 从图上看", "可以理解为这样", "比如说 A的末字符是X", "而B的末字符是Y", "它们俩并不相等", "这个时候说明", "末字符这个位置", "肯定是不匹配的", "那么原问题的解只有两种可能", "一种就是 Y这个字符", "对整个的公共子序列没有贡献", "这个时候 我们不妨把Y切除掉", "然后呢 以Y剩下来的那个前缀", "和整个的A 去构成一个子任务", "继续递归求解", "另外呢 也需要", "对称的考虑另一种情况", "也就是X对整个", "公共子序列的匹配没有贡献", "这个时候呢 我们也需要", "对称的把A的前缀取出来", "然后和整个B序列", "构成一个新的子任务", "递归地求解", "这种情况下", "整个问题的解", "无非这样上、下两种情况", "形式化地 我们来描述", "可以认为是把A整体的保留下来", "把B的末字符抠掉", "构成一个子任务 递归求解", "或者对称地", "把整个B序列保存下来", "而把A的末字符抠掉", "构成另一个子任务", "所以我们可以看到这两个子任务", "一旦递归地获得了解", "我们最终只要在它们中间", "取一个更长的解", "就会得到原来问题的解", "所以这样一个策略", "如果用图来画的话", "继续刚才那个例子", "我们可以看到末字符当前", "一个是C 一个是T 是不等的", "这个时候呢", "按照刚才的分析", "我们应该沿着两个方向", "分别地 递归求解", "其一 要把B的末字符", "也就是T 抹除掉", "继续求解", "为此 生成的一个递归实例", "可以画在上方", "另外对称地 我们也可以", "把A序列的末字符 抹掉", "从而得到另一个子问题", "这个递归实例 从构成上讲", "只是比原来的A序列", "少了这么样一个末字符", "从这个图 也可以很清楚地看到", "原问题的解 无非是", "左边这个子问题", "或者上边这个子问题的解", "而且确切地讲 应该是", "这二者中的最长者", "归纳这三种情况", "实际上 我们已经得到了一个", "完整的递归算法", "不是吗？", "我们此前给过递归基", "然后呢", "下面通过一次对末字符的判断", "可以进而区分", "下面的非平凡的", "第一和第二种情况", "而且所有的递归都是封闭的", "因此我们把这样一段", "具体代码实现 这个任务", "交给同学们 在课后完成", "而我们转而需要分析的是", "这个算法的正确性", "以及更重要的效率", "我们会发现", "这个效率并不是很好"]}, {"name": "01b-5: \t图灵机", "block_id": "4f46d44d24ac48fea6af1e778586d5fe", "text": ["图灵机模型具有以下要件", "首先是Tape也就是带", "通常称作纸带或磁带", "这个带呢 被均匀地划分为", "一个一个的小格子 称作cell", "每一个小格子上面都标注有某个字符", "默认的初始情况下 所有的格子中", "都标记有一个特定的符号", "比如说我们这里约定是“﹟”号", "所以相应的每个格中所标的字符", "都是来自于一个字符表", "而这个字符表的长度是有限的", "还有一个要素呢", "也就是上面这个称作Head的东西", "我们一般称它作头", "或者再具体点叫读写头", "我们说在任何时刻Head", "都是对准了Tape上的某一个cell", "或者是它 或者是它 或者是它", "而整个的图灵机等会我们会看到", "它是按照一个节拍的节奏来运转的", "每经过一个节拍", "这个头都可以向左", "或者是向右移动一个单元", "转入下一个单元格", "而在对准任何一个单元格的时候", "它都可以读取出这个单元格中", "所标注的那个字符", "也可以修改", "这个单元格中所对应的字符", "正因为这个原因", "它确实应该叫作读写头", "这是它的功能", "两方面的功能 可以读也可以写", "整个图灵机 或者再具体讲", "也就是这个读写头", "在任何时候都会处于某一种状态", "处于某一个state", "当然这些状态本身只有有限种可能", "图灵机在读写头", "每经过一个节拍移动一次以后", "它都有可能从一个状态", "转入另一个状态", "当然在这个过程中需要遵照", "事先约定好的某一套规则", "那么这些规则是什么样的呢？", "我们可以看到它是以这种", "Transition Function的形式来描述的", "确切地说", "每一个这样的转换或者传递函数", "都是由五个元素确定的", "我们来解读一下", "第一个元素q 代表图灵机", "或读写头当前所处的状态", "而这个c 代表的是读写头", "当前所正对的单元里所存的字符", "我们说前两项", "可以理解为是当前的状态", "后面三项呢", "描述是它紧接着的动作", "也就是我们说的转换", "这个d 代表的是", "在当前单元格里填入的", "或者说是修改成的", "一个新的字符", "在修改完毕之后", "读写头自己可以", "向左L 或者向右R", "移动一个单元格", "同时将自己的状态由刚才的q", "转化为现在的p", "打个形象的比方", "如果读写头是一个人的话", "那么下面是他所看到的一个东西", "每一个人都处于一个状态", "那么他根据他自己当时的状态", "和它所能看到的东西", "可能会做一些决策", "并且有一些行动 然后改变状态", "比如说这是一个人", "他当时正处于饥饿状态", "那么很可能他看到的一只苹果", "那么通常情况下", "他会把这只苹果吃掉", "把这里的原字符变成空的字符", "同时在获取到这样的一个苹果之后", "他可能饥饿状态有所改善", "比如说 会进入到一种饱的状态", "在此之后 它可能会选择", "向左或者向右离开", "也就是完成一次转换", "在所有的状态中", "有一个特定的状态", "是我们约定好的", "通常用h来标记 表示是停机", "言下之意就是说", "一旦图灵机进入到h状态", "就会立即终止", "此时它所对应的计算任务", "也就相应完成"]}, {"name": "06D-1 算法", "block_id": "a53d430aa63544fab8c23d8265aebee9", "text": ["同学们好 接下来的这一节", "我们将介绍与上一节", "广度优先搜索完全对称的另一种搜索算法", "也就是深度优先搜索", "我们将会看到 相对于此前的广度优先搜索", "深度优先搜索的算法策略更为简明", "然而有趣的是", "深度优先搜索的过程更为复杂", "其功能也相对而言更为强大", "因此也成为有效解决很多实际问题的", "基本算法框架", "起始于某一顶点s的深度优先搜索过程", "可以简明地描述如下", "我们只需直接访问这个顶点", "然后在它的所有尚未访问的邻居中", "任选其一", "并且递归地以选出的顶点为基础", "继续执行DFS", "当然 一旦所有的邻居均已访问完毕", "算法也就在这个位置返回", "我们可以通过这个动画", "感受算法的具体过程", "在任何一幅图中", "我们只需确定一个搜索的起点", "然后按照刚才所描述的策略", "只需要找到它的一个邻居", "请注意 当前顶点有可能还有其它的邻居", "但是这个算法并不需要去考虑它们", "而只是任选其一", "并且将控制权交给这个新的顶点", "接下来 新的顶点一旦接过控制权", "它也会仿效这种策略", "在它的所有邻居中任选其一", "并且将控制权交给这个尚未访问的邻居", "再一次地 最新的这个顶点", "依然会效仿这种策略", "在它的所有尚未访问的邻居中去任选其一", "并将控制权再转交给这个邻居", "同样地 这个新的顶点", "也会去扫描它的所有邻居", "并试图找到一个尚未访问的", "当然如果有已经被访问过的", "对应的这条边将不会被采用", "而是以某种适当的形式加以标注", "我们在稍后将会对标注的方式", "做详细的说明", "这也是这个算法至关重要的一个方面", "以下假设这个顶点", "已经没有任何邻居尚未访问", "那么按照算法的策略", "我们将在这个位置返回 也就是回溯", "顺着此前的通路回到它的前驱顶点", "同样 如果依然没有尚未访问的邻居", "也需要在这个顶点处继续返回", "我们假设在这个顶点处", "至少还有一个尚未访问的邻居", "我们就将控制权转交给它", "以下过程类似 简单地播放一下", "最终整幅图遍历完毕", "可以看到 遍历的效果与此前的BFS类似", "我们依然会得到一棵DFS树", "也就是这些粗边所构成 原图的一棵支撑树", "而且同样地 未被这棵树所采纳的那些边", "也同样会被分类", "而且这种分类要更为细致", "那么这样一个遍历和递归的过程", "如何明确地兑现为具体的算法和代码呢？"]}, {"name": "11d2-1: 坏字符", "block_id": "cce21e536bb54ce38413b5e7bf6cdd5d", "text": ["实际上 刚才的实例中我们所展示的那样一个计算过程", "也就是所谓BM算法所采用的策略之一", "而这一策略 将我们刚才所说的教训", "称作坏字符", "在这里 我们不妨改为基于蛮力算法的第二个版本来进行改造", "也就是说 模式串中当前参与比对的如果是字符P[j]", "那么 文本串中对应的就是T[i+j]", "这幅图画出的就是这样一个一般性的场景", "请注意 当前这趟扫描", "如果的确已经抵达P[j]", "或T[i+j]", "则说明在这对字符的右侧 有一段足够长的匹配部分", "而相对于模式串而言", "这个匹配的部分是一个后缀", "既然这两个字符失配", "我们就不妨就分别将它们记作X和Y", "延续我们在刚才的分析中所采用的逻辑", "如果我们将这次失配", "当作一次教训", "那么其原因就可以解释为", "在Y这个位置", "我们本来期望是一个X", "然而这个字符Y的出现", "却使得我们在此局部获得一次完整匹配的希望成了泡影", "因此 BM算法也将这个字符Y称作坏字符", "正是因为这个坏字符的出现", "当前这个对齐位置", "也就自然地可以被排除掉了", "那么 更重要的是", "这次教训能够为我们带来什么启示呢", "具体地 能为我们后续的比对 提供什么有意义的借鉴呢", "将刚才我们所举的实例推而广之", "如果我们还希望能够在这个字符X附近", "实现一次完整的匹配", "那么作为一项必要条件", "与这个字符X对准的", "也应该至少是一个X", "是的 由刚才所举的实例推而广之", "我们也同样可以得出此时的处置方法", "具体来说 就是试图从模式串中去找出这样的一个字符X", "并且通过相应的移动", "使得这个X能与文本串中的那个X彼此对齐", "而一旦完成了这样的对齐", "我们又可以继而从最右端开始", "启动下一轮的扫描比对", "那么 对应于每一个这样的场景", "相应的位移量又应该是多少呢", "稍加观察 我们不难发现", "这个位移量", "仅取决于刚才失配的位置j", "以及对应的字符X", "在模式串中的位置", "而与文本串以及当前的对齐位置没有任何关系", "这就意味着我们可以与KMP算法一样", "通过预处理 事先计算出每种情况下对应的位移量", "也就是说 我们可以将每一个这样的字符所对应的位移量", "制成一个表", "也就是所谓的bc表", "通过再进一步的观察我们不难发现", "这个表只需记录每一个字符X在模式串中所对应的秩", "在图中 也就对应于这一段距离", "我们知道 这段前缀的长度恰好就应该是j", "而对应的位移量", "也自然就应该是", "这两段前缀的长度之差"]}, {"name": "08B1-1\t640KB", "block_id": "8f66a4a31d8a49ff81406f0d54a6a608", "text": ["同学们好 接下来我们要学习一种非常有趣", "同时也是非常有用的数据结构 也就是B树", "从严格的意义上而讲 B树并不是二分查找树", "我们很快就会看到 在物理上 B树的每一个节点都可能包含多个分支", "然而也正如我们很快就会看到的", "从逻辑上讲 它依然等效于我们此前所介绍的二分查找树", "因此我们依然将它归入高级搜索树之类", "那么首先一个自然的问题就是 既然B树也完全等效于我们此前所介绍过的BST", "那我们还有什么必要要引入并介绍它呢", "也就是说 设计和实现这种搜索树的动机何在呢", "我们将会看到 B树最初也是最主要的功能在于弥合", "不同存储级别之间在访问速度上的巨大差异", "也就是实现高效的IO", "不妨让我们穿越到30多年前 Bill Gates的一句话曾经被很多人当作笑柄", "因为他在那时曾经断言 640KB也就是dos的基本内存容量", "已经足以满足任何实际应用的需要了", "尽管这句话不免显得有些武断和短视", "但我却坚信 你在学习完B树以后 一定会认为", "这句话实际上是千真万确的真理"]}, {"name": "06B1-3 实例", "block_id": "ae24e9477645419583349c03fe51b4e3", "text": ["我们来看邻接矩阵的几个实例", "首先来看这样一幅无向图", "比如对于顶点A而言", "它与B和C相邻", "所以我们可以看到在矩阵中", "A所对应的那一行", "有B和C两个位置是1", "而对称地", "在A所对应的那一列中", "也有B和C两项为1", "那这里我们采用一个习惯", "也就是将在矩阵中", "没有明确标出的", "所谓的默认值", "都记在这个矩阵的左上角", "比如在这里就是0", "这样可以使得我们更加清晰准确地", "把握邻接矩阵", "可以看到 无向图的邻接矩阵", "的确是对称阵", "因此就存储效率而言", "存在一定的冗余性", "每一条边都被重复保存了两份", "再来看有向图", "比如其中的B到A的这条单向边", "将会记录在B所对应的那一行", "A所对应的那一列", "类似地 B到C的单向边", "也会记录于B所对应的那一行", "以及C所对应的那一列", "请注意 这两条边都是单向边", "所以在矩阵中", "并没有对称的那一项", "而A和C之间的这样一条双向边", "在矩阵中被保留两份", "进一步地 这种矩阵的表示方式", "也不难推广到带权图", "也就是所谓的网络", "为此我们只需将各边", "对应的权重记录于对应的单元"]}, {"name": "04C3-2 \t计数", "block_id": "933af8af0544432bb9eb5dd84b8e81a1", "text": ["那么对于长度为n的输入序列", "可能得到的栈混洗总共有多少种呢？", "假定输入栈A中共有n个元素", "而且它们自顶向下", "依次编号为1 2 3一直到n", "这里我们需要将注意力放在第一个元素上", "不难理解 它将首先被推入中转栈S中", "那么接下来 我们要问的问题是", "这个元素是在什么时候", "被转入到最终的栈B中呢？", "请注意 1号元素", "既然作为第1个元素被推入S中", "那么当它被弹出并进而推入栈B之后", "栈S应该成为一个空栈", "此时在栈B中", "如果包括刚推入的1号元素", "累计共有k个元素", "那么相应地 在栈A中", "就应该还留存有最靠后的n-k个元素", "由此可见 此时B中最靠底的k-1个元素", "和A中最靠底的n-k个元素", "它们的栈混洗实际上是相互独立的", "因此对应于1号元素 作为第k个元素", "被推入B中的情况", "累计而言 对应的栈混洗总数", "就应该是这两个相互独立的子序列", "所各自对应的栈混洗总数的乘积", "而对于1号元素来说", "k所有的可能取值", "所对应的混洗数的总和", "就应该恰好是我们最初", "要计算的栈混洗总数", "那么这里的k可以在什么范围内取值呢？", "首先 k可以从1开始", "也就是说 1号元素", "直接作为第1个元素被转入栈B中", "另一个极端 k也可能取值为n", "也就是说 1号元素", "作为最后一个元素被推入栈B中", "至此 我们就得到了一个", "非常典型的递推式", "如果再考虑到它的平凡情况", "也就是当只有1个元素的时候", "对应的栈混洗数自然是1", "那么就可以知道这个递推式的解", "恰好是著名的catalan数", "其数值等于2n的阶乘", "除以n+1的阶乘 再除以n的阶乘"]}, {"name": "11c6-2: \t以卵击石", "block_id": "0244137b021b4889b263827823a53828", "text": ["为了更好地理解这一结论", "我们不妨来设想这样一个场景", "我们可以将这里的字符1比作是一块石头", "没错 一块坚硬的石头", "而字符0呢", "则可以想象为是鸡蛋", "没错 鸡蛋", "而且是一筐鸡蛋", "我们的算法就犹如一个幼稚的孩子", "他想确认一下 石头和鸡蛋哪一个更硬", "因此作为学习的成本", "他需要实际地将二者做一次比对", "也就是俗称的以卵击石", "其后果是可想而知的", "如果这个孩子还不是十分幼稚的话", "经过这样一次实践", "他就应该会发现", "石头要远远地硬于鸡蛋", "因此 他应该会将筐中剩余的那些鸡蛋妥善地保管起来", "让它们离这块石头越远越好", "然而反观KMP算法在刚才这个实例中的表现", "我们就会发现 它的行为方式居然与一个非常非常幼稚的孩子极其类似", "难道不是这样吗", "如果第一次碰撞还勉强可以说是交学费的话", "那么后续的一而再 再而三 以至更多次的碰撞", "的确显得不够聪明", "事实上 从信息的角度来看", "我们一开始既然就已经掌握了这个模式串的所有信息", "那么自然就应该知道", "在这个0之前的一系列字符都是0", "所以在算法的执行过程中", "一旦发现这个0与文本串不相匹配", "那么自然地就应该知道", "后续的这些尝试必然都是徒劳的", "尽管不会铸成错误", "但毕竟会白白浪费时间", "那么 KMP算法的这个版本", "问题究竟出在哪呢"]}, {"name": "01d-5: 正确性的证明", "block_id": "11f7549d609e47a2b0c66ddb58aa2a36", "text": ["我们的第一个问题 关乎这个算法的有穷性", "也就是说这个算法 是否必然会终止", "答案首先基于这个算法所具有的这样一条不变性", "可以断言 上述这个算法", "在经过了K轮的外循环", "也就是 K轮的扫描交换之后", "全局最大的那K个元素 必然会各就各位", "来看一下下面这个图", "如果由上而下是构成整个这个序列", "也是我们整个扫描交换的执行方向", "那么 在第一趟扫描过程中", "5和2 因为逆序会交换次序变成2和5", "再接下来 5当遇到7以后 会停留下来", "因为在这个位置是构成了一个顺序对", "那么接下来的情况将是7", "一旦接过这样一个控制权以后", "它作为全局最大的元素", "必然会在接下来的每次比较中", "都大于它当时的右侧", "也就是 后边的那个元素", "从而 构成一个逆序紧邻对", "所以 7会和接下来的邻居4", "以及再接下来的新邻居6", "以及再接下来的邻居3 以至1", "统而言之 它的所有的后继依次交换", "最终效果是7 经过若干次交换", "转移至最后 而原来它的那些后继", "等效于 往前平移一位", "我们看到刚才这个断言", "对于第一趟是对的", "因为经过了K等于1 一轮的扫描交换", "最大的一个元素 也就是7", "确实是就位了", "这不奇怪", "因为7是整体的最大的元素", "所以 在扫描交换的过程中", "一旦它接过控制权", "后面的故事都是一样的", "它会胜出所有的元素 直到最终就位", "那我们看看 在接下来的第二轮循环之后", "又会怎么样呢？", "其实故事是类似的", "也就是说 在这里2和5是顺序的", "所以不用交换", "但是5和4经过一次交换以后 变成4和5", "这都不是最关键的", "我们看 最关键的是", "一直这个故事发生到", "当前最大的元素", "也就是 全局第二大的那个元素6", "接过控制权之后", "它会跟刚才一样", "胜出它的所有的有效的那些后继", "在这个例子讲的3和1", "直到它也就位", "所以推而广之", "后面接下来最大的元素5", "也会在接下来的一轮扫描交换之后就位", "同样4、3和2都会相继的就位", "因此总结一下 这条不变性确实是成立的", "另外呢 在这整个过程中", "也蕴含了一个单调性", "经过了K轮的扫描交换之后", "问题的实质的等效规模", "实际上就会减至n-k", "在我们这个图里 已经用颜色加以了标识", "所有的彩色的部分 都对应是", "当前这个算法有效的问题范围", "也就是说 我们还没有处理的范围", "而灰色的部分都可以认为是", "整个这个算法 当前的视线之外", "对于算法后续的过程", "以及整体的算法的效果", "没有影响的部分", "我们看到 如果最开始的规模是n的话", "经过了一趟以后 确实缩减为n减1", "再经过一趟以后 缩减为n减2", "以致n减3、n减4 n减5 一直下去", "所以由这两条 我们就应该可以得出结论", "这个算法必然会结束", "而且是正确的结束", "而且在终止的时候呢", "我们来考察一下这个不变性", "也就是它的最后的那个边界情况", "当k等于n的时候", "那么 不变性就可以翻译成", "经过了 n轮扫描交换之后", "最大的n个元素", "其实 也就是所有的n个元素", "必然会各就各位", "最后归纳一下 确实", "这个算法经过至多n趟扫描之后", "必然会终止", "而且会给出正确的答案", "通过挖掘 并且综合", "算法所具有的不变性和单调性", "进而证明正确性的方法", "是算法分析中的一个基本而重要的技巧", "我们希望大家能够通过这个实例融会贯通", "在其它的场合能够举一反三"]}, {"name": "12c2-3: \t逆序对", "block_id": "d27fdd2885244602b41f070acc431ae7", "text": ["现在还是回到我们的线性组合", "考察我们的待排序序列", "如果它既是g-ordered", "同时也是h-ordered", "这样的序列也称作是", "g h-ordered", "实际上这样的序列也必然会以", "G和H之和为步长是有序的", "我们可以通过这个图", "来简明的证明这一点", "在整个序列中考察任何一对", "相距g加上h的元素", "我们说它们必然是顺序", "因为我们可以找到", "居于它们中间的", "这样一个特定的元素", "这个元素到前一元素的距离为g", "而到后一元素的距离为h", "于是以这个中间元素为桥梁", "根据不等式的单项传递性", "我们自然就可以得知", "这一对间隔为g加h的元素", "也必然是顺序的", "实际上这个结论也可以进一得推广到", "g和h的任何一个线性组合", "我们仍然通过这组图来加以说明", "在这个序列中", "我们考察任何一对间距为", "这个线性组合的元素", "为了证明这一对元素之间的顺序性", "我们无非是将刚才的方法推而广之", "也就是说", "我们需要引入更多的中间桥梁", "比如这里给出的就是一种具体的方案", "我们首先以g为间隔", "连续的取出m个元素", "在这些间隔位置上的所有元素", "必然是单调非降的", "接下来我们在以h为间隔", "连续的取出n个元素", "同样的这n个元素", "也必然是单调非降的", "于是通过所有这些单项不等号的串接", "我们也就自然的证明了", "这样一对元素之间的顺序性", "由以上我们可以概括出一个结论", "也就是凡是间距", "可以表示为线性组合的", "任何一对元素必然是顺序的", "简而言之凡能表示为线性组合", "则必然顺序", "现在我们将注意力集中于序列中", "秩为i的那个元素", "如果g和h是互素的", "而且整个序列已经是", "同时关于g和h有序的", "那么相对于这个元素", "哪些元素必然是顺序的", "反过来哪些元素才有可能是逆序的", "我们说实际上可能逆序的元素不会很多", "确切的讲无非就是刚才", "关于g和h的那个x的", "也就是不能由g和h线性组合", "生成的那个最大的整数", "你能看出其中的原因吗", "没错", "对于这个区间之后的", "任何一个元素而言", "它与i的距离已经超出了", "那个最大的预值x", "所以它们之间的间隔", "也必然可以表示为g和h的线性组合", "而我们刚刚总结过", "凡是能够表示为线性组合的", "也就是顺序", "反过来这也就意味着", "i这个元素所能参与构成的逆序对", "只可能出现与这样一个范围", "而随着希尔排序的不断迭代", "这个范围也会不断的缩小", "没错", "逆序列的总数会不断持续的减少", "因此你能想到点什么吗", "没错", "插入 排序", "我们知道", "插入排序具有输入敏感性", "它的实际运行时间将线性正比于", "序列中所含逆序对的总数", "至此我们终于弄明白了", "为什么在希尔排序的底层", "我们更加倾向于使用", "插入排序算法", "实际上按照以上的优化思路", "后人针对希尔排序", "曾经涉及过许多更为优化的步长序列", "比如PS序列", "Pratt序列", "以及Sedgewick序列", "关于这些序列的详细介绍", "及其性能分析", "详见我们的教材以及习题解析"]}, {"name": "06B1-7 边操作", "block_id": "04972dc691b544dfad598a2ec77c64ea", "text": ["同样地 利用邻接矩阵", "我们也可以便捷地实现很多边的操作", "我们可以非常便捷地判定", "在两个顶点之间", "是否的确连有一条边", "是的", "既然在邻接矩阵中", "每一对顶点之间", "潜在的那条边", "都在矩阵中对应于一个单元", "因此我们只需判断这个单元", "是否有效即可", "具体来说 只要我们这里所给的", "顶点编号 i 以及 j 是合法的", "那么只需取出邻接矩阵中", "对应的那一项", "进行一次比对", "即可做出正确的判断", "而一旦判断出某条边的确存在", "我们只需取出这个单元", "所指向的数据域", "即可返回这条边所对应的信息", "类似地 只要这条边的确存在", "那么它对应的其它信息", "也可以直接返回", "比如这条边的分类状态", "以及它对应的权重等等", "那么如何在一幅图中插入一条边呢？", "我们依然需要围绕邻接矩阵来进行操作", "假设我们需要在", "顶点i与顶点j之间", "连接一条有向边", "我们假设这条边尚不存在", "于是我们只需要将", "待插入的那条边的信息", "比如它的权重等等", "封装为一个具体的边记录", "然后将这个新的边记录地址", "存入于邻接矩阵中", "对应的那个单元", "于是 反过来我们也可以说", "这个单元将指向这个新的边记录", "整个过程可以描述为这样一段代码", "我们可以看到", "首先需要经过一次检验", "以确定这条边还不存在", "于是我们可以创建这样一个边的记录", "并且将这个新记录的地址", "转交给邻接矩阵中", "对应的这个单元", "这样就完成了这条边的物理引入", "那么从逻辑上", "这幅图还要做相关信息的更新", "包括整体的边数", "要因此增加一条", "此外 作为这条边的尾部节点", "i 的出度需要递增", "而作为这条边的头部节点 j", "需要将入度增加一个单元", "相应地 为了从图中删除一条边", "我们只需将刚才边插入的过程", "颠倒过来", "也就是说 我们此时不妨假设", "从顶点 i 通往顶点 j 之间", "的确存在一条边", "因此在邻接矩阵中", "对应的那一项就非空", "而且这一项将指向一个对应的边记录", "因此为了删除这条边", "我们只需将这条边对应的记录释放", "并且归还给系统", "然后令在邻接矩阵中", "对应于这一项的引用指向空", "整个过程可以描述为这样一段代码", "首先我们假设此前经过对比", "已经确认这条边是存在的", "那么我们要做的事情", "就是通过矩阵中", "对应的这一项引用", "找到这个记录", "并且将它释放掉", "随后将这个引用置为空", "也就是从物理上完成了这条边的摘除", "以下我们只不过是需要对图", "相关的一些统计信息", "进行更新维护", "具体来说", "总体的边数因此会减少一条", "而作为边的尾部节点 i", "它的出度应该相应地减少一条", "而作为这条边的头部顶点", "也就是j", "它的入度也应该减少一个单位", "当然 从语义上我们这里要求", "在删除之后还需返回", "这条边记录中", "原来保存的信息", "这也是为什么", "在进行实质的动态操作之前", "我们首先要将这条边备份下来", "并且在完成了物理的摘除之后", "将备份信息返回"]}, {"name": "10b3-4: \t效率", "block_id": "a0cfefe8a0ae428cab8d7b8c2e502541", "text": ["纵观整个下滤调整的过程，我们所做的工作主体无非两类：", "第一类也就是所谓的“比较”，第二类则是交换。", "非常幸运的是，我们每下滤一层，", "这两类操作都只需要执行常数次，因此就渐进意义而言，整体复杂度不会超过堆的高度。", "与上滤算法一样，作为完全二叉树，这里堆的高度也绝不会超过log(n)，", "这也是整个删除算法的渐进时间复杂度。", "当然就常系数意义而言，我们依然存在改进的余地，", "比如交换操作所涉及的3log(n)次赋值语句同样可以优化为log(n)。", "最后一点需要指出的是，下滤过程中的比较操作，与上滤过程中的比较操作在模式上与成本上都有实质上的区别。", "你应该记得，在上滤过程中，每个节点只需和它唯一的那个父亲进行比较。", "也就是说，在每一层次上我们只需要一次比较。", "而下滤过程的每一步所涉及的都是一个节点以及它的两个孩子。", "为了从它们当中找出最大的那个，我们不得不做两次比较，", "当然对于二叉堆来说这还不是什么了不起的差异，", "而在稍后我们要介绍的多叉堆中，这一差异将会变得至关重要。"]}, {"name": "07B1-1 概述", "block_id": "612d0774639643e8aa947db1695df276", "text": ["同学们好", "在上一节我们学习了", "二叉搜索树的基本概念和性质", "我们看到 相对于其它的数据结构", "二叉搜索树的特征", "首先体现在它独特的元素访问方式", "也就是循关键码访问", "而所有这类访问", "无非都是通过三种", "主要的操作接口完成的", "也就是静态的查找", "以及动态的插入", "和删除", "那么在接下来的这一节", "我们就来讨论", "在这三个接口的背后", "分别应该采用什么算法", "这些算法又该如何实现", "实现的效率又将如何"]}, {"name": "11d2-2: 特殊情况", "block_id": "00655fc47bca45c988459df164b7d3ea", "text": ["当然 实际的情况要更为复杂一些", "我们不妨来看看 还有哪些特殊情况需要考虑并且处置", "首先需要考虑的一种情况就是 在模式串中有可能同时存在多个X", "那么在这种情况下", "我们究竟应该用哪个X", "来替换那个坏字符Y呢", "与KMP算法一样", "当同时存在多个候选时", "我们并不倾向于像数学上那样", "逐一地去尝试它们", "而应该在安全的前提下", "选择其一 从而使得我们不必回溯", "也就是说 如果有多个候选", "那么 我们倾向于选择其中对应的位移量尽可能小的那个", "按照刚才的分析", "任何一个字符所对应的位移量", "都与这个字符在模式串中的秩", "成反比", "因此 为了使得位移量尽可能地小", "所对应字符的秩", "就应该尽可能地大", "换而言之 当有多个候选时 我们应该首先选用其中的最靠后者", "或者等价地", "在相对于这个字符X的那个后缀中", "必须不包含任何X", "那么与此相反的另一种极端情况就是", "在模式串中 可能没有任何这样的X可供选择", "回忆一下 在我们此前所举的那个实例中 的确就有这种情况", "比如 其中文本串中的那个“道”字", "在模式串中根本就没有出现过", "你应该还记得我们当时的处置方法", "没错 我们只需将模式串完整地移过这个对齐的位置", "那么 在相应的算法描述以及代码实现的过程中", "我们又应该如何统一地来处置这种情况呢", "没错 哨兵", "与KMP算法一样", "我们可以为每一个模式串在最左侧增设一个假想的通配哨兵", "于是 所谓的将整个模式串移过这个位置", "也就等效于用这个通配的哨兵", "与刚才失配的字符对齐", "既然是个通配字符", "那么此前失配的这个字符", "在此后就可以被忽略掉", "实际上 除了以上所介绍的两种", "还有一种更为特殊的情况需要处理", "你能看出来吗", "是的 在这种情况下模式串中的确至少存在一个候选的字符X", "然而 其中最靠右的那个 位置又过于靠右", "也就是说 它所对应的那个bc表项", "或者说它的秩", "太大了", "高过了j", "以至于通过二者之差所计算出来的位移量", "居然是一个负数", "显然 这样的回溯是没有道理的", "也是不必要的", "因为作为这个算法的一条不变性", "相对于任何时候的当前对齐位置", "此前的所有对齐位置", "都已经被淘汰掉了", "因此根本没有必要再回过头去重新考虑", "既然以前的所有对齐位置", "都已被淘汰掉", "而当前的这个对齐位置", "也刚刚被否定掉了", "所以 再直接而简洁不过的处置方法就是", "将整个模式串向后移动一个字符", "并进而考察下一个对齐位置", "至此 我们已经兼顾到了可能发生的所有情况 包括特殊情况", "我们知道 KMP算法的整个策略", "完全是融入并体现于其中的next表", "而这里的BM算法 也类似", "其策略 也将最终融入并体现于bc表", "以及稍后要介绍的gs表", "那么 首先一个问题就是", "bc表 又当如何构造出来呢", "相应地 我们又需要花费多少时间呢"]}, {"name": "08XA3-1\t以曲为直", "block_id": "abf5a1bf565d4d7d8bc5a00c7b3fa0bd", "text": ["现在我们就来学习红黑树的动态调整算法", "首先是插入操作", "与理解红黑树的定义一样 这里我们也必须借助B树的模型", "才能更好的了解 相关算法的原理及其过程", "也就是说 在我们考察每一棵红黑树的时候", "在脑海中总是要有一棵对应的B树", "后者就犹如前者的影子 时时刻刻相伴相随", "与所有的BBST一样 在经过了动态变化之后", "红黑树的组成成员不仅发生了变化", "而且它们之间的拓扑连接关系 也可能发生变化", "很遗憾 这种变化通常并不容易直接理解", "为此我们需要借助B树的影子", "具体来说也就是红黑树在变换之前", "以及变换之后 所对应的那棵B树", "就像我们理解红黑树的定义一样", "我们会发现 红黑树与其对应的影子B树之间", "关系非常好理解 而且反过来 也是如此", "而更重要的是 站在新的视角来看", "前后两棵影子B树之间的关系 也将变得一目了然", "这样一种理解的方式 表面看来有些迂回", "但我们很快就会感受到 它的效率反而是最高的"]}, {"name": "04A-1\t 栈", "block_id": "6d963282582a48b08c9e8730b2515478", "text": ["同学们好", "接下来一章中的主角", "是栈和队列 这对孪生兄弟", "我们很快就会看到", "它们都是我们此前所已经熟知的", "线性序列的特例", "然而 非常有意思的是", "它们在算法以及应用中", "都扮演着非常基本而重要的角色", "在第一节中 我们将首先", "来讨论栈这种结构", "如何以ADT的形式来定义", "和规范它的接口", "以及如何借助此前", "已研究有素的序列结构", "简洁高效地加以实现", "所谓的栈结构Stack", "依然是由一组元素组成的线性序列", "与一般的序列不同", "在任何时候 我们只能够访问", "栈中的一个特定元素", "具体来说 就是其中某一端", "最末端那个元素", "而其余的元素呢", "在当前 都是禁止访问的", "因此 通常我们习惯于", "将栈旋转90度", "沿垂直方向画出", "相应地 可以访问的开放的这一端", "也就称作顶端top", "而不开放的那个盲端称作底部", "在我们日常生活中", "可以见到很多栈的例子", "比如说 在餐厅", "堆接在一起的椅子或盘子", "就是这样的一个模型", "我们任何时候取出一把椅子", "或者一个盘子", "都是在它的顶端操作", "反过来 如果要将一个椅子", "或者是盘子归入其中", "通常也只能将它摞在顶上", "相信大家 对于汉诺塔问题都不会陌生", "这个问题中的每一根柱子", "其实也就对应的是一个栈", "我们在任何时候 只能对它的顶端", "最上方的那个盘子进行操作", "当然这里附加的一个要求就是", "所有的盘子必须按照", "直径的大小单调排列", "一般意义下的栈以及它的操作", "可以由这样一组图来表示", "我们可以看到 作为一个栈", "在任何时刻 其中的元素", "的确应该构成一个线性的序列", "如果我们需要将", "某一个新的元素插入其中", "根据这里的约定", "我们只能将它作为最顶部的元素插入", "那么从效果上看", "相当于是将一个碟子", "摞在原有的一系列的碟子之上", "那么这个动作我们也形象地", "称之为push", "反过来 如果我们需要从栈中", "取出某一个元素", "那么按照这里的规定", "也只能取出当前这个顶部的元素", "这个元素被取出之后", "其余元素将依次向前递补", "我们可以看到 将会出现一个", "新的顶部元素", "这样的一个过程", "也形象地称为pop", "当然 通常的栈还会提供", "另一个辅助的接口", "也就是 我们在有的时候", "只希望查询顶部元素的数值", "而并不需要将它真正的弹出", "那么这样一个动作", "我们也形象地称之为top"]}, {"name": "05C-3 描述多叉树", "block_id": "288731203f3846a7a2987138e3006683", "text": ["好", "接下来我们来介绍", "这一节最重要的一点", "如何通过二叉树来描述多叉树", "也就是一般意义上的树", "表面上看 这是不可能的", "因为你似乎是在用一种特例", "来描述所有的情况", "然而很有意思的是 这竟然是事实", "这就犹如你可以严格的证明", "在0和1之间的实数", "与整个实轴上的实数", "同样多一样", "这里并非没有条件", "当然条件也不多", "就两条", "我们此前所介绍的", "有根以及有序", "换而言之", "凡是有根且有序的树", "都可以通过二叉树描述表示", "并进而实现", "为此我们需要回忆此前", "刚刚介绍的长子兄弟表示法", "这个方法可以用这样两幅图来示意", "我们说在原来一般性的树的表示中", "每一个节点的出度不同", "它所对应的出边", "也就需要相应的记录", "这种方法我们分析过", "它规整性非常差", "那么长子兄弟法呢", "它只要求每一个节点", "记录两个引用就够了", "首先一个是相对于它而言的", "所有孩子中的最大者", "也就是firstChild() 长子", "另一个呢 是相对于", "当前这个节点而言的下一个兄弟", "也是一个引用", "我们曾经介绍过", "为了便于理解", "我们应该将所有的firstchild()", "也就是一代与下一代之间的", "所有的引用画为垂直方向的", "这样通过高度", "就可以区分代继或者叫辈分", "而同一代的nextSibling这种引用呢", "我们建议大家画成水平的", "表示它们虽然有长幼之分", "但是从辈分上来讲 都是相同的", "它们互为兄弟", "那我要指出的是", "如果你已经懂得了长子兄弟法", "那么再进一步地将这种表示法", "转化为二叉树表示法就只差一步", "甚至说半步之遥", "哪半步呢？", "我们只需要将每一个节点", "所对应的那样一个局部", "也就是firstChild()", "和nextSibling()这样一个结构", "做一个45度角的旋转", "使之变为这样一个形式", "firstChild()和nextSibling()", "你看到什么了？", "没错 这就是一个二叉树的局部", "我们如果将这样一个原则", "施加到长子兄弟表示法中的", "任何一个局部", "就可以总体上将原来那样一个表示法", "转化为我们这里以左右相别的", "二叉树表示法", "仍然以我们这里的树为例", "再将原来这样一棵一般性的", "有根有序树", "转化为长子兄弟表示法之后", "只需对它的任何局部", "实施这样的一个45度的旋转", "就可以将它转化为", "最右侧这样一个形式", "我们可以看到", "它们之间是完全对应的", "比如说 根节点", "再比如说 根节点通往", "它的第一个孩子的这条边", "这条边经过旋转以后", "将会成为这个节点", "通往它的左孩子的那条边", "再如A这个节点", "它的下一个兄弟是B", "而在这棵树中呢", "A节点将以B作为它的右孩子", "其它的位置也是如此", "大家不妨在课后逐一地校验", "总而言之 通过这样的一个局部的变换", "我们就可以将任何一棵一般性的树", "转化为它的长子兄弟表示法", "并且进一步地转化", "并理解为是一棵二叉树", "由此可见", "如果说我们这一章的任务", "是描述并且实现以及利用树结构的话", "不如说我们只需研究并且实现二叉树", "也正是因为这样的一个原因", "尽管后者只是前者的一个特例", "我们依然将后者 也就是二叉树", "作为我们这一章的标题", "这也是为什么", "你在第一节会看到一个有趣的现象", "树反而会成为那样一个小节的标题", "好了", "二叉树结构的实现和相关的算法", "又是如何的呢？", "这正是我们接下来几节", "将要陆续讨论的"]}, {"name": "04D-2\t 实例", "block_id": "ef7e8b6f9cf041fea45fd33e51fd5ad3", "text": ["按照如上定义的操作接口", "我们来看一个队列的操作具体实例", "首先创建一个队列", "此时它是空的，一无所有", "所以empty()操作也自然地会返回true", "接下来，通过enqueue操作，插入元素5", "这里我们取右侧为队头方向", "所以作为刚入队的队尾", "就应该在最左侧", "接下来，继续enqueue，将3插入队中", "可以看到，5向前递进一步", "此时，如果我们用dequeue()操作", "试图取出队首", "就自然应该返回队首的这个5", "继续插入7以及3", "此时，如果调用front接口", "查询首元素", "返回的应该是3", "请注意，此3并非彼3", "当然，此时如果去调用empty()做判断", "肯定会报告当前的队列非空", "以下继续插入11", "此后如果我们调用size()接口", "就会得到这个队列当前的规模", "既然它有4个元素，返回的就是4", "同样地，在一个已经非空的队列中", "我们继续插入元素", "当然它会继续地非空", "后面的一些操作大同小异", "我们留给同学们在课后自己温习巩固", "那么这样一个队列结构", "又当如何具体地来实现呢？"]}, {"name": "09D1-5 懒惰删除", "block_id": "532fefe61ac6494a86928cc21c9bc9ab", "text": ["以线性试探为代表的开放定址策略在使用时", "若要支持词条的删除则需格外的小心", "我们来就此做一探讨", "按照这种策略 先后插入彼此冲突的一组词条", "都将存放在同一个查找序列中", "而更确切的讲", "它们应该按照逻辑次序构成整个查找链的一个前缀", "其中不得有任何的空桶缝隙", "因此词条的删除操作需要做额外的一些处理", "反之 如果直接将词条删除", "那么被删除的词条所留下的空桶", "就有可能将查找链切断", "从而导致在此之后的词条丢失掉", "尽管它们的确存在于散列表中 却如何也访问不到", "针对这一问题 一种简明的方法就是所谓的懒惰删除", "lazy removal", "也就是说 如果在某个桶中 此前存有一个词条", "那么在这个词条被删除之后", "我们并不是简单的将这个桶清空", "而是为其做上一个特殊的标记 比如说R", "在这样一个桶所属的每一条查找链中", "这类桶单元将根据具体情况 可能扮演两种角色", "如果是针对某一特定词条的查找", "那么在抵达这个桶时", "根据这个标志 我们就知道不应该在此中断", "而应越过它 继续查找下去", "反过来如果我们是为了插入新的词条而寻找一个空桶", "那么在首次抵达带有这样一个标志的桶之后", "就可以将它等效的视作是一个空桶", "并将待插入的新词条径直的插入其中", "应该说针对开放定址策略", "懒惰删除 不仅是不得已而为之的方法", "也甚至可以说是针对这种情况的最优方法", "因为毕竟在开放定址策略中", "每一个桶单元都同时属于多个查找链"]}, {"name": "10xa2-4:\t 实例", "block_id": "f610e07876194236bae0e9c8c8710dd4", "text": ["以下，我们就来通过一个具体的实例加深对左式堆合并算法的理解和领悟：", "假设在这里我们需要将一个规模为4的堆与另一规模为3的堆合并起来。", "首先通过比较，我们能够确认前者的树根在数值上要大于后者的树根，", "因此二者无需互换，我们分别称之为a和b。", "相应地，a的右孩子也自然就是12。", "于是按照算法，我们将原先的问题转化为a的右子堆与b堆的合并问题。", "在新的这个递归层次，我们依然需要比较两个子堆的根节点，", "因为在数值上15更大，所以我们此时应该将它们互换名称，将前者记作b，将后者记作a。", "于是，问题进而转化为这样的形式，也就是将15这个堆与12这个堆进行合并，", "既然此时的a是15，那么a的右子树也自然就是8，", "于是按照算法的流程，问题进一步转化为子堆8与子堆12的合并问题。", "同样，在经过一次数值上的比较之后，我们确认将二者互换名称，", "也就是说我们接下来应当把12作为a，把8作为b。", "此时，a的右孩子为空，", "因此在再接下来的递归层之上，将直接返回节点8，并且将8作为12的右孩子，", "也就是说在此局部应该是这样。", "请特别注意，在这层递归返回之前，还有一项特别重要的任务，你还记得吗？", "是的，还需要确认12满足左倾性，", "实际上它这个时候恰恰并不满足，因为我们注意到，它当前的左子树为空。", "当然，只要留意了这个问题，它的解决并不困难，你也应该记得是怎么处理的——", "没错，令它的左右子堆互换位置，这也就是为什么我们得到了这样一个局部结构。", "接下来，我们的递归返回到节点15，", "同样地，我们也需要确认这个节点的左倾性。", "那么此时它的两个孩子，它们的NPL值又是多少呢？", "是的，都应该是1，因此，左倾性在这个节点上并没有受到破坏，", "因此我们可以继续逆行而上，继续返回到节点的根，也就是17，", "此时的17是否满足左倾性呢？我们来查验一下它的左右孩子NPL值各是多少，你也不妨心算一下。", "没错，左孩子的NPL值是1，而右孩子的NPL值为2，", "也就是说此时的节点17恰恰违反了左倾性。", "同样地，关键在于发现问题，解决问题并不困难，在这种情况下，我们也只需经过一次对换，", "交换17的两个孩子，在节点17的左右孩子交换之后，", "这个数据结构也就整体上恢复为一个左式堆。", "不要忘了，构成这个堆的成员不多不少恰好都来自于最初待合并的两个子堆。", "也就是说，我们已经顺利地完成了这样一个合并的任务。", "当然，通过这个实例也可以验证我们最初的设计目标：", "也就是整个的合并过程的确是围绕右侧链来进行。", "因此，整个算法的时间复杂度也自然不会超过右侧链的长度，", "我们此前已经就此作出过界定，也就是说它在渐进意义下绝对不会超过log(n)，", "这个结果再好不过了。"]}, {"name": "12a2-2: 最好情况 + 最坏情况", "block_id": "3612e96a53eb48f1b0ce544000122e84", "text": ["那么整个算法的运行时间呢", "我们知道对于归并排序而言", "整个算法的运行时间", "可以保证不超过nlogn", "我们也知道其关键在于", "归并排序可以保证", "任何一对被划分出来的子任务", "在规模上都是彼此相当的", "也就是规模都接近二分之N", "因此总体的运行时间", "也就是求解两个这样的问题", "再加上为了将它们的结果合并", "所需要的线性时间", "很遗憾快速排序算法", "却不能像归并排序算法那样", "保证子任务划分时的均衡性", "实际上partition算法的", "每次划分结果", "与其说是取决于这个算法", "不如说取决于最初选定的侯选轴点", "如果侯选轴点在最终有序序列中", "所对应的秩为r", "那么经划分之后所得到的序列L的长度", "也必然就是r", "而对应的子序列G", "长度也必然为n减1再减r", "划分的结果是否均衡", "完全取决于我们的运气", "当然在最好的情况下", "我们的每次划分都是均衡的", "或者至少是接近均衡的", "于是我们自然可以达到", "最优的nlogn", "然而反过来在最坏的情况下", "有可能我们的每一次划分", "都不均衡", "甚至极不均衡", "比如最为极端的一种情况就是", "每一个侯选节点", "都是在当前而言", "最小或者最大的极值元素", "以至于在划分之后", "子序列L为空", "或者G为空", "也就是说", "在我们所划分出来的", "一对子任务中", "总是有一个规模为零", "而另一个相对于此前的规模", "只减少了一个单位", "根据这个递推式不难解出", "此时算法所需要的总体运行时间", "必然是平方量级的", "也就是说与起泡排序等低级算法", "居然性能是相当的", "当然采用一些简明的策略", "在付出足够小的代价之后", "我们的确可以在一定程度上降低", "最坏情况出现的概率", "比如我们可以采用所谓随机选取法", "也就是说不再是每次都固定的将首元素", "作为侯选轴点", "而是在整个序列中", "随机的选择其一", "另一种更为有效的分法", "是三者取中法", "也就是说我们每次都是在整个序列中", "随机的抽取三个元素", "然后将其中数值居中的那个", "作为侯选轴点", "当然无论采用什么方法", "我们也只能是在一定程度上", "降低最坏情况出现的概率", "而无法根本的杜绝最坏情况的出现", "既然如此我们接下来", "不得不回答的一个问题就是", "就基本的快速排序算法而言", "其平均性能又有多高呢"]}, {"name": "02D5-5\t 综合对比\t", "block_id": "ea53acd0c8ff4f5ba97f9d6c3dc96fb3", "text": ["好 现在到了将插值查找以及其他算法", "综合起来进行比对和考量的时候了", "我们首先来看一下", "刚才插值查找所实现的这种改进", "也就是从logn到loglogn", "虽然从数学上是一个比较大的改进", "但从实际效率来看", "却值得商榷", "比如 一个向量中的元素", "多达2的32次方", "也就是我们说的4个G", "这样一个量级", "这应该已经是不小的一个向量了", "它可以表示为2的5次方再对2做一次幂", "我们来看 对于即使是这样大的一个n", "我们取对数的话 无非是32", "而再去取一次对数话", "也不过是个5", "所以我们说 在通常的情况下", "这种算法在实际的应用中", "效率的改进 并不是那么明显", "反过来 我们说它其实还是有很多缺陷的", "比如刚才希望大家", "回去所举的那个最坏的情况", "它很容易受到一些小的扰动", "或者是干扰的“蒙骗”", "可能会在局部", "花费非常非常多的时间", "受到惩罚", "而另一值得商榷的地方 就是", "这里毕竟不像以前的", "二分查找那样只需做加法", "也不像Fibonaccian Search那样", "只需要做常规的加法和减法", "这里从某种意义上讲", "需要引入乘法和除法", "我们说这种计算", "相对而言 成本更高", "所以可行的查找算法", "也许应该将插值查找", "以及此前的那些查找算法", "各自的优势综合结合起来", "比如说我们可以看到", "插值查找更善于", "在比较大的一个宏观的范围内", "将问题的关注点", "尽可能快的缩小到一定的范围", "换句话说", "它比较擅长于处理那种极大的情况", "然后一旦到了比较小的情况", "这种容易受到干扰包括蒙骗", "尤其是乘法除法这样的一些", "我们称之为overhead 额外计算", "占得比重就会更大", "成为不可忽略的因素", "而在这个时候", "二分查找的优势就体现出来了", "所以我们说 首先应该通过插值查找", "将问题的范围缩小到足够小", "接下来再转而使用", "更加适合于中小规模数据的折半查找算法", "以及顺序查找算法", "从而得到在实际应用中", "更加完美的一个组合", "那么这一节的内容就介绍到这", "我们关于有序向量的查找", "也就此画了一个小小的句号", "接下来的两节 我们将讨论", "如何将一个无序向量转化为有序向量", "从而为我们使用此前所介绍的这些查找算法", "提供一个最最基本的条件", "保持兴趣 我们下节再见"]}, {"name": "10b2-2: \t实例", "block_id": "34eb92f28dff46279cd7b98e444a1d20", "text": ["我们来看一个简单的实例。", "不难验证，这是一个由五个词条所构成的完全二叉堆。", "上面的这棵完全二叉树是它的逻辑结构，", "而下面则是其在物理上对应的向量结构。", "可以看到，在物理上向量的首元素也就是逻辑上完全二叉树的根节点。", "根据我们的约定，它正是整个数据集中的最大者。", "接下来，假设我们需要插入一个数值为5的词条，", "按照刚才所涉及的算法，我们首先将它作为末元素加入到向量之中，", "在逻辑上这完全等效于在完全二叉树底层向右拓展了一个节点。", "可以看到，这种拓展的确没有破坏完全二叉堆的结构性，", "然而正如这个例子中的情况，新引入的这个词条有可能和它的父亲违背堆序性，", "因为5大于0。", "于是按照我们刚才所拟定的策略，令二者互换位置。", "注意，这一对换物理上实际是在向量之中进行。", "经过交换之后的结果是这样，", "可以看到局部的堆序性的确得到了恢复，同时也不致影响到其它的各个节点。", "然而新插入的这个节点上升一层后有可能会有一个新的父亲，比如这里的4。", "而且很不幸，因为5依然大于4，所以我们说在这个局部同样违反了堆序性。", "好在不要紧，因为我们可以继续沿用之前拟定的策略，令违反堆序性的两个节点互换位置，", "同样在物理上这一对换实际也是在向量之中进行的。", "经过这次交换之后，的确4和5互换了位置，", "新插入的节点5继续上升一层，这一局部的堆序性得到了恢复，", "而且同样也不致影响到其它的节点。", "而新插入的这个节点5在上升一层后已经悄然成为了这个堆的堆顶。", "它根本就没有父亲，因此堆序性在这一局部也就自然成立，", "更重要的是至此堆序性在整个完全二叉堆中处处得到满足。", "我们也就顺利地完成了这次插入操作。", "可以看到，整个插入算法的实质过程无非是令新引入的这个节点不断与它的父亲交换位置。", "每交换一次，新引入的这个节点都会上升一层。", "那么这样一个过程如何兑现为具体的代码呢？"]}, {"name": "08A3-3\t四种情况", "block_id": "461bdacba53a4ed895aa3e69e8d9ca15", "text": ["我们不妨来看其中的一种 也就是zig-zig的情况", "你应该记得 在这种情况下 v以及p都是左孩子", "我们也知道 按照Tarjan的策略", "你应该将局部这棵子树调整为下面这个样子", "具体来说 也就是g将成为p的右孩子 而p要成为v的右孩子", "请注意 这样的变换依然是一个等价变换", "局部的这3个节点 以及他们下属的4棵对应的子树", "在中序遍历意义上的次序 将保持不变", "将他们沿垂直方向 都投影到水平线上 就可以验证这一点", "这里采用的方法 与此前的3+4重构 非常类似", "我们不妨忽略具体的旋转过程 而代之以直接拼接的方式", "也就是说 我们需要将p的右孩子 当作g的左孩子", "这个效果 可以由这一句来完成", "那么下一句呢？", "它的作用是将v的右孩子 也就是这个X 转作p的左孩子", "而这一句呢 其效果是将g作为p的右孩子", "而最后这句的效果 又当如何理解呢？", "我们将此留给大家 在课后完成", "当然你课后的作业 还包括针对另外的3种情况", "通过自行阅读我们提供的代码 加以验证"]}, {"name": "03B-2\t 查找", "block_id": "2f3da7746daa44a195e0b1690f6d824c", "text": ["再来考察无序列表的查找算法", "具体地 这里将这个算法的接口语义", "定义为在当前的列表L中", "以位置为p的某一个特定节点为基准", "在它的n个真前驱中", "也就是不包括它自己在内的n个前驱中", "找到某个可能存在的", "数值为特定值的节点", "仿照向量的查找算法", "我们从p这个位置出发", "从后向前 将每个节点逐一取出", "并与目标元素进行比对", "一旦发现相等", "也就是我们所说的命中 即可停止", "这样一个过程 也可以准确地描述为这段代码", "在当前这个列表中 以p这个节点为基准", "在它的n个真前驱中 查找可能存在的", "数值为e的某个节点", "那么具体地 我们也确实是从p出发", "不断地沿着predecessor这个引用", "逐步向前", "每次都取出当前节点的数据域", "并且与目标进行比对", "一旦发现命中 随即返回", "当然这是成功的情况", "如果我们整个迭代部署n已经耗尽", "抵达这个位置", "那就意味着 在这样的一个区间里", "不存在我们所需要的那个节点", "因此我们返回NULL 以作标记", "请注意", "无论是成功的情况所返回的p", "还是这个NULL", "都是我们此前所定义的一个节点位置", "这么一个Position", "请注意一种特殊的情况", "也就是 我们的目标节点不仅存在", "而且可能有多个", "那么在这个时候", "根据刚才我们所给的这个算法", "它会首先停止于相对而言", "最靠后的那个节点", "我们说这是自然的", "因为这正是我们的语义所要求的一个细节", "那么在最坏的情况下", "当然这个算法必须一直迭代到", "最末尾这个位置", "累计的宽度 我们刚才讲过是n", "所以相应的复杂度也就是", "最坏情况下O(n)", "细心的同学可能会非常留意", "我们这里的三个参数的次序", "比如说其中的n和p", "为什么我们这里将n放在p的前端呢？", "实际上 这是为了让我们更方便地了解", "这个算法的功能语义", "我们来看一下", "当你使用这样一个方式来调用", "这个接口的时候", "你就很容易理解它是在p的n个前驱中", "去进行查找", "换而言之", "我们完全可以重载另一个接口", "它的不同之处就在于", "p和n的位置恰好交换", "这种交换意味着什么呢？", "我想你应该能猜得出来", "没错", "就是在p的n个后继中", "去查找特定的某一个元素"]}, {"name": "05A-6 连通+无环", "block_id": "c60ec8083d2d4027ae2857d62268e22c", "text": ["在一幅图中，如果任何两个点之间", "都可以通过某一条路径彼此相连", "我们就称它为连通图", "connected graph", "不难理解", "连通图中的边不能太少", "那么反过来 边如果太多呢？", "就更容易出现我们刚才所说的环路", "实际上 不包含任何环路的图", "也称作acyclic graph 无环图", "那么这里所说的连通性以及无环性", "和树有什么关系呢？", "不仅有关系 而且非常的密切", "确切地讲 所谓的树", "其实就是在无环与连通之间", "达到一个平衡的一种特定的图", "因为无环 所以它的边数不会太大", "反之 正因为它又是连通的", "所以它的边数又不能太少", "在保证连通的前提下", "它的边数能够达到最少", "而在杜绝环路的前提下", "它又能够使用尽可能多的边", "当然这些都属于图论中的基本结论", "在这里 我们只是直接引用", "而不再进行严格的证明", "作为以上性质的一个自然的推论", "我们可以得知", "在一棵树中 任何一个节点v", "与树根之间都存在", "而且仅存在唯一的一条通路", "因此在记录这条路径的时候", "我们往往也将根节点直接地省略掉", "转而记作这样的形式", "这个推论相当重要", "既然任何一个点到根节点之间", "都存在唯一的一条通路", "那么每一个点也就因此拥有了一个", "唯一的指标 也就是这条路径的长度", "比如在这样的一棵树中", "如果根是0号点的话", "那么相对于这个点", "那条路径就是这个", "我们可以看到 这条路径的长度是1", "所以这个节点所拥有的指标", "也自然就是1", "同样地 对于这个顶点来说", "它所对应的路径", "应该就是这样一条", "可以看到 这条路径的长度是2", "所以就是为什么", "它拥有的指标是2", "再类似地 这个节点", "所对应的那条唯一的通路应该是这样", "可以看到 这条路径的长度为3", "所以这也是为什么", "它拥有一个数值为3的指标", "不难看出 按照这样的一个规则", "的确可以对一棵树中的", "每一个顶点都赋予一个确定的指标", "请注意 每个节点能够获得", "这样一个指标的前提", "其实只有一个", "也就是 在这样一棵树中", "我们指定了某一个特定的节点作为根", "一旦指定了根", "其它的节点都将获得一个确定的指标", "而进一步的呢", "通过这样的一个指标", "我们可以将所有的顶点划分为", "不同的几类", "如此所得的同一类顶点", "所具有的指标都是相等的", "所以也称为等价类"]}, {"name": "11b2-1: \t构思", "block_id": "2730bf78f706467281231ea57c66b300", "text": ["好 在接下来的这节 我们就来介绍所谓的蛮力串匹配算法", "顾名思义 这类算法的思路与策略 都是直截了当的 非常直观且易于理解", "但是反过来 这个名字也暗示着 它的效率是非常低下的", "不过 这类算法 也有它的存在价值", "它们可以帮助你理解串匹配的计算过程", "同时 也为我们后续的改进 提供了一个起点与参照", "我们这里所说的蛮力算法 在思路上的确是直截了当的", "我们不难发现 所谓的匹配成功 必然是相对于某一个对齐位置而言的", "这样的对齐位置 充其量不会超过文本串的长度 也就是n", "因此 如果不在意计算的成本", "我们只需逐一地尝试并核对每一个对齐位置", "也自然就可以解决 串匹配的问题", "而这样最自然的一种方式 莫过于自前向后", "以单个儿字符为间隔", "依次地将模式串与文本串对齐 并进行核对", "我们来看这样一个实例", "在一个相对更长的文本串中 查找一个长度为4的模式串", "按照刚才所说的策略 我们首先要将二者的首字符彼此对齐", "然后将模式串中的每一个字符 分别与主串中对应的字符进行比对", "如果这样的比对依然也是自左向右的话", "于是我们就会发现 二者最前端的两个字符 都是匹配的", "也就是 1对1 0对0", "然而很不幸 接下来却是1对0", "我们称之为失配", "显然 只要有一对儿字符是失配的", "那么整体就不可能完全匹配", "因此 这也就意味着 当前的这个对齐位置是可以排除掉的", "因此接下来 我们需要尝试下一个对齐位置", "就效果而言 这等同于文本串保持不动 而模式串向右侧滑动一个字符", "一旦这样对齐之后 我们就会随即启动一轮逐个字符的比对", "我们可以看到 当前的这一轮比对 会失配于首字符处", "这也意味着第二个对齐位置也可排除", "于是接下来 我们可以将模式串继续向后滑动一个字符", "从而尝试下一个对齐的位置", "在接下来的这轮比对中 依然存在失配", "因此 这个对齐位置 也会被淘汰掉", "接下来 我们再进而尝试下一个对齐位置", "新的一轮比对在经过了一次成功之后 依然遇到了一次失配", "这也意味着 这个对齐位置 也是可以排除的", "于是接下来 我们再次地向后移动模式串 并尝试新的一个对齐位置", "非常幸运 在这样一个对齐位置 所有的字符都是匹配的", "这也意味着 当前的这个对齐位置 就是一个成功的匹配", "如果我们暂且不关心这个算法的效率", "它的正确性是显而易见的", "那么 这样的一个计算过程 应该如何地表述为代码呢"]}, {"name": "04C5-1 \t简化", "block_id": "a6ced6b102524a1da100907180bc2ea0", "text": ["同学们好", "接下来的这一节 我们介绍逆波兰表达式", "所谓的逆波兰表达式", "Reverse Polish Notation", "得名于发明这种记号的", "女数理逻辑学家的祖国", "这是一种对逻辑谓词的简便记法", "而在我们所关心的表达式计算方面", "它居然有意想不到的效果", "在我们通常的所谓中缀表达式中", "运算符之间的优先级关系", "无非是通过两种形式来定义的", "其一就是约定俗成", "比如说 加减要低于乘除", "而乘除要低于乘方", "乘方要低于阶乘", "诸如此类", "而另一类呢 则是借助于括号", "来显式地强制指定", "由此可见 这种运算优先级的定义方式", "是十分混乱的", "也导致我们相应的求值算法过于复杂", "虽然我们极尽我们的所能", "的确写出了这样的一个", "相对完善的求值算法", "但是我们也看到 其中的逻辑过于复杂", "在一些十分强调效率的场合", "这种复杂的逻辑是断乎不可取的", "另外这样复杂的逻辑", "也给我们的程序调试", "和算法的正确性证明", "造成了不必要的麻烦", "那么RPN是个什么样的东西呢?", "它又能为我们在这方面", "带来什么样的一些收益呢?", "我们先来获得一些感性上的认识", "我们所熟知的任何一个中缀表达式", "都可以在理论上", "简化为这样的一个RPN的形式", "虽然我们现在初步还看得不是很明白", "但是我们已经注意到 它的特点就是", "其中已经无形中没有了括号", "没错 这是RPN最最重要的一个特征", "它不再借助括号来强制指定优先级", "那我们另一种指定优先级的方式", "也就是约定俗成的呢？", "在这里也一并被摒弃掉了", "那么我们凭什么来确定", "运算符之间的优先级关系呢？", "其实你不难理解", "所谓的优先级关系", "无非就是不同的运算符", "到底谁当下应该执行", "谁当下还不到执行的时机", "而RPN将这样一个优先级", "直接地简化和转化为", "这些运算符在这个RPN表达式的序列中", "所出现的次序", "谁先优先出现 谁就优先计算", "反之亦然"]}, {"name": "04C5-2\t 体验", "block_id": "2ab204dad6ea4cec97e6b7f1c9c66765", "text": ["来看这样一个具体的实例", "这里就是我们需要求值的RPN表达式", "我们需要什么工具呢？", "我们只需要这样一个辅助栈", "那整个求值算法的逻辑呢？", "说无非两种情况", "一种就是这种以白色表示的", "所谓的操作数", "我们待会儿会看到", "在整个求值算法的过程中", "对这些操作数的处理都是非常简便的", "直接令它们入栈", "每遇到一个就随即让它入栈", "每遇到一个就随即让它入栈", "诸如此类", "那么反过来 操作符呢？", "正如刚才我们所预告的", "在这里我们并不需要", "麻烦地去判断它们之间的运算次序", "而是简明地采用与数理操作数类似的策略", "也就是凡遇到一个操作符 无论是谁", "我们都随即执行相应的运算", "那运算的对象呢？", "也就是参与运算的运算数呢？", "我们说这里的原则也非常简单", "你需要几个操作数", "就在这个操作数暂存的栈中", "从顶部取出几个", "当然不要忘了", "运算的结果还要", "像我们此前所遵从的习惯一样", "要把它回填入栈中", "作为新的栈顶", "准备好了？", "好吧", "那我们现在就来开始", "你的第一个RPN求值过程", "首先 我们遇到的是一个操作数", "如我们刚才所言", "在这种情况下 只需令它简单地入栈", "接下来 我们把关注点", "集中到接下来的这个字符", "我们可以看到是一个运算符阶乘号", "刚才讲过 对于阶乘号 我们的处理原则", "也非常的简单", "只需立即着手 执行对应的这个运算", "我们刚才也讲过 所需要的操作数", "可以直接向这个栈中去索取", "作为一目的运算符", "阶乘只需要一个操作数参与", "因此我们只需要把这个操作数取出来", "并且实施阶乘运算 得到1", "再把这个结果1回填回去", "大致是这样一个过程", "也就是弹出运算", "再把结果回填", "就这么简单", "我们可以看到 接下来我们的焦点", "又转向了下一个字符", "也是一个操作数", "所以令它进栈", "变成新的栈顶", "接下来 再考虑下一个", "我们会发现又是一个操作符", "这个操作符", "也可以立即执行计算", "只不过加法是所谓的二目运算符", "所以我们需要在这里取出1、2两个", "执行加法运算", "当然还别忘了 把它的结果 也就是1+1=2", "再回填回去", "再接下来 焦点又落在了一个操作数上", "我们简单地让它入栈", "成为新的栈顶", "再接下来 依然是一个操作数", "我们如法炮制 请君入瓮", "好 我们再次遇到了操作符", "好了", "我想你已经有经验了", "我们每碰到一个运算符", "都可以大胆地直接实施对应的计算", "也就是说 我们需要去计算栈顶3的阶乘", "结果你应该能知道的", "我们将它们分别地弹出", "然后再将计算的结果6 重新地纳回站内", "好", "以下 4入栈", "遇到减号 随即执行减法", "请注意", "我们这里执行的应该是6减去4", "而不是错误地倒过来", "所以接下来6、4相减得2", "纳回栈中", "好", "再接下来 操作数5也同样地简明地入栈", "接下来是乘方", "那么是谁的乘方呢？", "自然是 2的5次方了", "我们心算一下结果", "然后过程是分别地弹出", "计算出结果", "再将结果 也就是32 重新纳回栈中", "再接下来的减法 不要忘了 是2减去32", "所以应该是负的30", "以下6、7组成的一个两位数67", "也将被纳入栈中", "好", "既然下一个是乘法运算符", "我们就立即执行它", "这个数比较大", "或许你需要一个计算器", "但是我们已经把它算好了", "再接下来是减法", "两项相减", "当然再接下来的8 作为操作数", "也是直接入栈", "以下再执行一次减法", "离我们的目标不远了", "当我们把最后一个操作数9推入栈中以后", "会发现最后一个运算符是加号", "我们执行最后一次有效的计算", "得到一个结果是2013", "请注意 与我们的中缀表达式求值算法类似", "只要原来的表达式是语法正确的", "当然现在是指RPN的语法正确的", "那么 当这个表达式完全处理完毕之后", "在我们的辅助栈中", "应该存有一个而且只有唯一的一个元素", "而这个元素", "就是刚才我们需要计算的", "RPN表达式的最终数值", "我相信每一个初次见到RPN求值算法的人", "都会被它的简洁性和高效性所折服", "如果存在某一个不确定数字的表达式", "比如说某一个代数表达式", "并且需要经常地反复调用", "那么你不妨将它转化为一个RPN的形式", "这样的话一旦其中每一个变量的数值确定", "我们就可以套用刚才的RPN求值算法", "快速地简明地将它对应的数值计算出来", "因此作为一种重要的预处理", "将任何一个中缀表达式转化为RPN表达式", "在效率上讲 是非常值得的", "磨刀不误砍柴工", "那么这种从中缀表达式到RPN的转换", "又当如何完成呢？"]}, {"name": "08XA2-6\t平衡性", "block_id": "c4e91a0186164ff3942bd43704a0363f", "text": ["既然我们已经看到 红黑树与4阶B树彼此等价", "那么由B树的平衡性也不难理解红黑树的平衡性", "如果你愿意花费一些时间", "我们这里不妨更为严谨的来证明这一点", "某种意义上讲 给出这种证明是值得的", "因为它可以帮助我们更好的理解红黑树", "为此我们只需证明由n个内部节点所构成的任何一棵红黑树", "其高度在渐近意义下都不超过logn", "当然与所有的BST一样 拥有n个内部节点的红黑树", "也必然同时拥有恰好n+1个外部节点", "具体的 我们只需证明这个串联的不等式", "或者更准确的讲 我们只需证明右侧的这个不等号", "因为左侧的这个 是任何BST都自然而然满足的", "假设这就是一个红黑树 按照规则", "在从根节点出发 通往任何一个外部节点的沿途", "所经过的黑节点总数 必然总是一样的", "比如就在这棵红黑树中 如果忽略掉人为引入的外部节点", "那么每一条这样的路径上所包含的黑节点应该恰好为6个", "也就是说 任何一条这样的极长通路上", "所含黑节点的总数都应该是6", "此时我们就称这棵红黑树的黑高度为6", "尽管加上3个红色的节点 它的高度可以达到9", "我们知道 所谓的树高", "也就是全树中最深节点所对应那条通路的长度", "而在红黑树中 任何一条通路上", "尽管可能出现相邻的黑节点", "却不允许出现相邻的红色节点", "进一步的 这就意味着", "在每一条这样的通路上 红色节点都不到一半", "而黑色节点都至少占一半", "因此红黑树的高度 必然不会超过其黑高度的2倍", "那么这里的黑高度 又当如何度量呢", "你应该还记得提升变换 没错正是提升变换", "我们知道经过提升变换之后", "每一棵红黑树都对应于一棵4阶的B树", "在这样一棵B树中 所有的外部节点 都像这个那样", "平齐的分布于底层", "而其中的每一个内部节点", "都是由此前的某个黑父亲以及他的红孩子构成", "因此此前红黑树中的每一条路径", "也相应的会在B树中对应于一条路径", "原先这条路径上有多少个黑节点", "在B树中对应的那条路径就有多长", "这就意味着 这棵B树的高度", "应该不多不少恰好正是此前那棵红黑树的黑高度", "没错 B树的高度 恰恰正是其对应的红黑树的黑高度", "而为了度量一棵红黑树的黑高度", "我们只需去度量其对应的那棵B树的高度即可", "那么B树的高度应该如何度量呢", "我们在此前已经做过介绍", "这里我们只需将结果拿过来 也就是这个"]}, {"name": "05D-1 BinNode类", "block_id": "6620df2456314eaab8a92961dab2ac35", "text": ["同学们好", "在此前的几节 我们先后学习了", "树的概念", "了解了树的特点", "并且懂得了如何来表示一棵树", "具体来说 这里最重要的方法", "就是借助二叉树", "来表示任何一棵有根有序树", "所以接下来我们就要来具体讨论", "如何在C++语言中", "实现一棵二叉树", "二叉树的基本组成单位是二叉树节点", "称作Binary Nodes 或简称BinNode", "每一个BinNode的逻辑组成", "可以用这样一幅图来表示", "我们可以看到", "每一个BinNode节点", "首先应该有一个data域", "也就是记录它携带的信息", "这个是整个BinNode节点的", "核心的要素", "当然孤立的BinNode是没有任何意义的", "因此作为一个整体的结构", "它也应该配备相应的引用域", "分别指向左右孩子以及父亲", "此外呢 作为在树中的一个特定元素", "它也需要记录一些重要的指标", "比如说在这里最最重要的指标", "就是height 高度", "那么我们也后面会看到 二叉树", "尤其是基于二叉树实现的", "各种二叉搜索树", "将会有各种各样不同的指标", "比如说对于红黑树而言", "那么可能就会有所谓的颜色的区别", "对于左式堆而言", "也有所谓的npl指标", "诸如此类地", "所以也需要为它们留有余地", "每个节点都是通过引用", "去指向其它的节点", "反过来 每个节点也通过引用", "被其它的节点所指向", "我们笼统地称每个节点", "所占据的这个空间为一个位置", "就像我们在列表中一样", "对应于一个Position", "因此我们为了在概念上进行统一", "不妨就将指向BinNode节点的", "这样一种类型就称为", "BinNodePosi节点位置", "以下我们就可以来真正的定义", "名为BinNode的这样一个开放的类", "按图索骥", "我们可以看到", "确实每一个BinNode节点", "都配有parent、lChild", "和rChild三个引用", "也包括data域", "以及刚才我们所说的", "height之类的指标", "这里也给出了BinNode", "所需要提供的一些基本的操作接口", "包括size（） 返回它的规模", "也就是包括它在内所有后代的总数", "也包括一些它与其它的节点相互作用", "使得整个二叉树在拓扑结构上", "发生变化的一些操作接口", "比如说insertAsLC", "或者是right Child（也即：insertAsRC）", "将某一个特定的数值生成为一个节点", "并且作为当前节点的", "左或右孩子接入其中", "另外还有一个接口是非常重要的", "这个名为succ()", "也就是后继的接口", "与我们在线性结构中一样", "它返回的是当前节点", "在我们稍后要介绍的", "中序遍历的意义下的直接后继", "稍后我们还会就此详作解释", "当然对于树型结构而言", "最重要的莫过于它的基本操作", "也就是遍历", "在这里我们将针对四种", "最最基本的遍历", "分别提供一个对应的接口", "我们后面会看到很多算法", "实际上都可以解释", "并且实现为这样的遍历的模式"]}, {"name": "05B-1 表示法", "block_id": "d9c6f352e9b04976893867f024219bc0", "text": ["同学们好", "上一节我们介绍了树的基本概念", "那么这一节呢", "我们将来讨论在计算机中", "如何从逻辑上来表示一棵树", "从抽象数据类型的角度来看", "树结构应该提供大致如下这些接口", "首先作为整棵树的入口", "我们需要能够方便的定位它的根节点", "其次对于任何一个节点", "我们也应该能够便捷地找到它的父节点", "以及反过来", "去找到它的所有的孩子中的一个特定的", "我们这里约定是长子firstChild", "既然兄弟节点之间", "已经定义了一个良好的次序", "所以这里也需要有一个接口", "来返回任何一个节点的下一个兄弟", "当然这里还需要提供一些动态的修改操作", "比如说将某一个数值", "作为另一个节点的第i个孩子插入其中", "或者反过来将某一个节点的第i个孩子", "如果存在的话 删除掉", "此外 对于树的算法而言", "非常重要的一种算法模式就是遍历", "所以这里也应该提供足够丰富的遍历接口", "当然现在来谈论这些接口的实现", "还为时过早", "我们确实首先要来了解一下", "如何从逻辑上表示一棵树"]}, {"name": "06C-8 最短路径", "block_id": "d196cc88837c47968b519c77ca3da021", "text": ["最后，我们来讨论BFS搜索的", "一个非常有趣同时又是", "非常本质的特性", "所谓的最短距离性", "回顾此前所介绍的树结构", "相对于树根节点", "任何一个节点v都对应于一条唯一的通路", "这条路径的长度称作顶点v的深度", "于是我们可以进而对所有的顶点", "自上而下按照它们的深度", "进行等价类划分", "在每一个等价类中的所有顶点", "所具有的深度指标都是彼此相等的", "而树的层次遍历也可以认为是", "按照这一指标非降的次序", "将所有的顶点逐一枚举出来", "那么这样一个遍历的过程", "是否也可以转化为图结构的遍历过程呢？", "表面看来似乎不太容易", "因为此时与树结构极不相同的就是", "从起始顶点s出发", "可能有多条路径都最后通往同一个顶点", "而且可能出现分叉", "然而这样一个问题不难解决", "实际上我们只需考察", "顶点之间的最短通路", "并且将这两个顶点之间的距离", "取作这条最短通路的长度", "而在起始顶点相对固定的情况下", "我们甚至可以将s在这个记号中省掉", "直接简称之为顶点v所对应的距离", "巧合的是 图的BFS搜索", "与树的层次遍历一样", "都具有这样一种单调性", "也就是说 BFS所给出的顶点序列", "按照这样到起点的距离", "也是按照非降次单调排列的", "所有顶点被发现并访问的过程", "可以由这样一个动画显示", "从起点s出发", "所有的顶点按照它们到起点s的距离", "成批地被发现并进而接受访问", "直到最终所有的顶点都被访问完毕", "在我们最终所生成的BFS树中", "每个顶点与s之间的那条通路", "恰好就是在原图中", "这两个顶点之间的那条最短通路", "关于这一性质及结论的严格证明", "可参考教材所配套习题解析中的", "习题6-7"]}, {"name": "02D2-5 \t实现", "block_id": "cda035de3ead4058bcbda23bf657433f", "text": ["我们来看这个算法的具体实现", "主体是个while循环", "每一次我们都来判断", "当前这个区间是否有效", "如果依然是有效的", "我们如刚才所言，会取出lo和hi的中点", "同样右移一位，等效于除2", "接下来，我们来判断", "e是否是小于当前这个mi", "如果是小于这个点，就要向左侧去深入", "就是将hi这个标志挪到mi这个位置上来", "从而把我们的关注力挪到左侧这个区间", "对称地，如果反过来", "e要大于mi这个点", "那么对称的操作就是将", "lo挪到mi的右侧", "这也是为什么用mi+1来更新lo", "好，如果既不是这种情况也不是这种情况", "那么我们就可以断定", "两个数之间，如果谁也不比谁大", "那么它们只能是相等", "这也就是我们所说的成功的情况", "这个时候，我们直接地返回这个数值", "所以前两种情况", "都会继续地while循环，迭代下去", "那么出口是在这", "直到最后整个这个区间", "缩减到已经非法", "这个时候，我们就可以断定", "查找是失败的", "所以这里我们也是沿用最早的习惯", "先简明地返回-1", "我们说了，这个实际上还是不够的", "稍后，我们再来解决这个问题", "那么这里我们也提醒大家", "编写程序的一个小的习惯", "可以帮助你更好地思考问题并且写出算法", "更重要的是，可以让你的代码更加好理解", "同时也减少一些不必要的失误", "大家可以注意到", "我们这里头统一地都用了小于号", "为什么我们不写成e大于A[mi]？", "固然可以那么写，但是那样写不容易理解", "我们这里的这种写法呢，非常好理解", "我们建议大家更多地用小于号", "而不是大于号", "因为小于号的左右的次序", "和我们通常所画的这样的一个", "从小到大的次序是吻合的", "所以这样的解读", "既可以认为是e小于mi", "也可以认为是e存在于", "当前这个分界点mi的左侧", "所以我们这样顺着读下来", "当然我们就应该深入到前半段", "也就是左半段去", "相应地呢，我们应该修改右侧的界桩", "同样接下来，这个解读也是这样", "与其说是mi小于e", "不如更直观地说是", "我们的目标e", "是处于mi这个分界点的右侧", "所以我们应该深入到右半段", "也就是后半段去继续搜索", "相应的动作也就是去修改", "左侧的那个界桩"]}, {"name": "05B-4 父亲+孩子 ", "block_id": "5ea880583fca4072ad5a7c654dc26054", "text": ["我想你不难想到", "其实刚才两个方向的优势", "是可以兼而有之的", "为此可以将刚才的", "那两个线性的序列组合起来", "也就是说 对于同一个节点", "我们不仅要保留它的parent域", "同时还要保留它的children", "这样的一个引用", "这样的话 如果是要去查找父亲", "就在parent这一列中进行查找 O（1）的时间", "如果要是去查找孩子", "那么就在children所指向的", "小的数据集中再去查找", "如果是长子", "那么可以在O（1）的时间内直接返回", "如果是其它的孩子 也大不了遍历", "它所对应的这个孩子列表", "我们说了", "它的长度充其量不过对应这个节点的出度", "所以这样的一个实现方法", "终于将两个方面的需求同时兼顾了", "不过", "如果我们对这种实现方法", "再做进一步地推敲 就会发现", "依然存在美中不足", "可以看到", "在这里 每一个节点的children引用", "所指向的那个数据集", "在规模上有可能相差极其悬殊", "我们讲过 每一个小的数据集的长度", "都恰好是这个节点所对应的出度", "而所有这些出度数的总和", "无非就是整体的边数", "我们此前曾经分析过", "它恰好等于n-1 与n是同阶的", "也就是说平均而言", "所有这些小的数据集的规模", "也刚刚就是O（1）的样子", "而我们这种组织方式", "有的时候需要长达O（n）的一个数据集", "我们需要找到一些新的办法", "更加规范 并相应也更简洁和高效"]}, {"name": "04C4-3\t 实例", "block_id": "1fd9752d9b174687827c9df05f78711d", "text": ["来看这样一个实例", "待计算的表达式水平地罗列于此", "同时我们还需要引入一个", "用于计算的辅助栈", "以下我们逐次地扫描", "并且处理这个表达式中的各个字符", "如果是数字 就进栈", "如果是运算符", "在尚未判定它已经拥有", "足够高的优先权", "可以立即计算之前", "我们也暂时将它纳入栈中", "同样地 运算数也入栈", "接下来 我们遇到了乘号", "由此可见", "刚才我们没有", "贸然执行加法运算是对的", "同样 对于乘号来说", "它也不能判定现在已经足够计算", "至少现在是这样", "所以我们也依然将它纳入栈中", "好 接下来的操作数", "我们这里都统一采用简明的策略", "直接入栈", "情况等到", "减号出现的时候 发生了转机", "因为相对于这时候", "最靠顶端的运算符乘号", "新遇到的这个运算符优先级更低", "反过来 乘号就到了可以计算的时候", "因此取出这个乘号", "以及它相应的操作数", "完成一次计算", "并且将计算的结果重新纳回栈中", "接下来 继续比较当前运算符", "以及栈顶部的", "其实也是现在唯一的那个运算符加号", "我们会发现它们彼此相当", "但是因为加号出现在前", "所以加号终于等到了", "可以执行的时机", "因此将它取出 使用对应的操作数", "得到正确的结果并且纳入栈中", "此时减号才可以随后入栈", "再接下来遇到1 同样它也入栈", "接下来 我们遇到了一种不同的情况", "也就是出现了", "另一个紧随其后的数字", "我们说 这对应于当前这个运算数", "是一个多位数", "因此我们要做的事情", "是将原来的这个数弹出", "乘以10之后 再加上新的这个数位", "并且重新纳回栈中", "从而正确地解析出", "原来的这个两位数的数值", "再接下来 我们遇到了除号", "相对于除法 减法的", "优先级还不足够高", "所以减法还没有到执行的时候", "因此随后除号入栈", "接下来的运算数5也入栈", "最终我们抵达", "整个表达式的末尾标志\\0", "此时我们可以判断出", "除法的运算 实际已经到达", "因此我们会执行这样一个除法", "并且将数值重新纳回栈中", "同样 对于终止服务\\0来说", "任何的栈顶操作符", "实际上都到了可以执行的时机", "所以再接下来", "这个减号也会进而执行", "其实 即使此后栈中", "还有其它的运算符", "都将依次执行", "只要这个表达式是合法的", "最终在栈内唯一的那个元素", "就是我们所要得到的结果", "相对于此前那种纸面操作", "这样一个过程", "更加接近于机器", "能够自动实现的层次", "然而我们说", "离我们最终的目标还有差距", "原因在于我们每次在栈顶", "检出这个可以计算的子表达式", "无论是2乘3 还是10除以5", "都不是那么自然", "那么诀窍在哪呢？", "在于将运算符和运算数分别对待", "也就是说 我们需要2个而不是1个栈"]}, {"name": "05E4-3 实例", "block_id": "d7a429b364ae45e28ded458799da521c", "text": ["以下我们就通过这样一个具体的实例", "来加深对以上层次遍历过程的理解", "我们的遍历起始于", "当前这棵树的根节点A", "按照刚才的算法设计", "我们需要引入一个队列", "作为初始化 我们首先要令根节点A入队", "为了便于此后的对比", "我们此时不妨为这个队列拍张照片", "以下将进入主体的while循环", "你应该记得 每次循环都会通过dequeue()", "取出队首的节点并且对它进行访问", "此时呢 对应的就是节点A", "因此接下来deque()", "并且随即访问A", "请注意 在这个瞬间 队列是空的", "同样地 为了便于日后对比", "也在此时留下一张照片", "在进入下一步迭代之前", "我们需要左顾右盼", "我们发现刚被访问的节点A", "只有一个左孩子B", "因此需要令它入队", "然后才进入下一步迭代", "同样地 也需要留下一张照片", "接下来的这步迭代中", "我们依然需要通过一次dequeue()操作", "取出队首节点", "在此时 对应的就是B", "并且对它进行访问", "依然留张照片", "好 接下来站在节点B处", "我们依然要左顾右盼", "发现左右孩子都在", "因此我们需要令它们入队", "请注意 我们这里入队的次序", "是左先右后", "你应该还记得 在此前先序遍历的", "第一个迭代版本中", "我们同样借助了一个栈", "而且在每个节点刚被访问完之后", "也同样需要左顾右盼", "并且令它的左孩子和右孩子", "如果它们有的话 入栈", "你应该还记得那个时候", "我们的次序是右先左后", "与这里的左先右后相对比", "你不难理解", "因为此前使用的栈具有先进后出的性质", "而这里的队列恰好是先进先出", "所以我们并不需要", "像此前的先序遍历那样", "在缓存孩子节点的时候", "需要将它们的次序颠倒", "因此这里的左孩子C和D", "应该先后入队", "同样 我们这里留张照片以备日后对比", "接下来 进入到下一步迭代dequeue()", "取出并且随即访问队首的节点C", "同样地 这里也有一个过门", "左顾右盼", "只不过遗憾地发现", "它们都是空的", "所以并没有任何实质的动作", "从而紧接着转入下一次迭代", "当然在此之前", "我们依然需要留张照片", "好了 接下来", "下一步迭代", "依然是dequeue()", "取出队首节点并且随即访问", "好", "在此时刻", "同样 留张照片", "接下来 左顾右盼以后", "发现它的左孩子、右孩子E和F都在", "依次令它们入队", "从而再进入下一步迭代", "依然需要做一次dequeue()操作", "并且再次地留张照片", "下一步迭代 我们依然需要做dequeue()操作", "取出队首的节点 也就是E", "并且访问", "好", "同样地 我们也需要留张照片", "以下站在E这个位置", "我们依然需要左顾右盼", "我们发现只有右侧的孩子G", "同样地 令G入队", "这个时候的照片是这样", "好 下一步迭代", "依然是从dequeue()操作开始的", "取出队首的F", "并且轮到它接受访问", "为此 我们也留一张照片", "此时的队中的状态是这样", "再接下来 站在F的位置左顾右盼", "结果与刚才的C是一样的", "只是过门 没有任何实质的动作", "所以进入下一步迭代", "这一步迭代依然是从dequeue()开始的", "也就是取出队首的节点G", "并随即访问", "此时继续留一张当时的照片", "接下来 站在G这个位置", "经过同样地左顾右盼", "我们会发现", "并没有任何实质的工作需要做", "因此我们就直接进入下一步迭代", "而此时我们的队列恰好已经变空", "这就意味着整个这棵树的层次遍历", "已经完成", "算法可以顺利地退出", "在事后 我们通过这样一组照片", "可以忠实地还原整个的过程", "并体味在此过程中整个数据结构", "以及算法状态的演化过程"]}, {"name": "03E-5\t 实现", "block_id": "82338388c5f047d88232c9cd6ba8e1e8", "text": ["好 接下来我们就将刚才的构思", "兑现为具体的代码", "可以看到 insertion sort算法", "需要提供两个参数 p和n", "它们联合地定义了", "所需要排序的区间范围", "也就是 从位置p开始连续n个元素", "算法的主体是一个for循环", "需要指出的是", "这个循环控制变量r", "就是我们已经排序的那个前缀的长度", "也就是说 在初始的情况下", "如果我们所要排序的区间", "是以p为起点", "以及包括p在内的", "接下来的n个节点", "有序的前缀 在最初的时候", "可以假想为是这样一个", "宽度为零的区间", "那么在迭代进行过程中", "更一般的场景 应该是这样", "经过一段时间的迭代之后", "有序的部分会得到一定的生长", "使得长度r不再是零", "无序部分则会相应地后退", "缩短到一定的范围", "也就是n减掉r", "然而不变的是", "p依然是s和u这两段的分界点", "更确切地说 它依然是u的首节点", "如果比喻一下的话", "节点p总是代表着", "我们接下来抓到需要插入的那张牌", "而最初的时候呢", "它无非就是我们所抓到的第一张牌", "现在我们可以看出", "所谓的s部分", "实际上 就是", "以p作为右侧哨兵界桩", "长度为r的那个区间", "因此接下来我们调用", "早已设计好的search接口", "在这样一个区间中", "去查找p这样一个元素", "就确实应该返回一个在s中", "所谓合适的位置", "不大于新抓到这张牌的", "最靠后的那张牌的位置", "既然如此 紧接着下来", "紧随于这样一个返回的位置之后", "将新抓到的这张牌", "insert after也就是插在它之后", "自然也就可以完成新的元素的归入", "此后有序的部分 向前迈进一步", "而无序的部分则会相应地", "向后缩减一个单位", "当然还需要令p转向它的直接后继", "注意 我们在有哨兵帮助的前提下", "这一句是安全的", "不会出现任何的纰漏", "好 然后再转过身来", "将后移以后节点p的前驱", "实际上 也就是刚才的它自己", "通过remove接口删除掉", "也就是说 一次插入", "再对应于自己的一次销毁", "整体地完成了p的转移过程", "整个算法过程中", "除了输入的列表自己本身以外", "只需要o(1)的额外辅助空间", "所以这种算法我们也称它叫", "in-place algorithm 就地的算法", "我们也提醒同学们去回顾一下", "我们这里原来所涉及的search接口", "以及remove接口的语义", "尤其是search接口", "正因为当时我们对它的语义", "和接口进行了严格地、周密地设计", "才使得现在我们的算法实现", "变得非常的简明直观"]}, {"name": "03C-2\t 唯一化·实现", "block_id": "a3861b18748545e2afc1a81319f2830d", "text": ["好", "现在我们就可以来看看", "刚才那个算法思路", "如何兑现为一段具体的代码", "首先是处理平凡的情况", "也就是说 我们要确保这个列表", "至少包含两个元素", "我们所关注的总是当前节点p", "这个节点从首节点开始", "同时 还有另一个辅助的引用q", "指向p的后继", "以下是一个循环", "每一次我们都令q", "指向p的直接后继", "随后将二者作一比对", "如果相同", "我们就调用remove接口", "将q删除掉", "这种情况可能执行多次", "它的总体效果是", "将与p雷同的所有的节点都剔除掉", "反过来 一旦遇到", "一个与p不同的后继节点", "那么就意味着抵达了", "下一个区段的首节点", "这个时候 我们就可以直接将注意力", "转向这个下一个区段的首节点", "也就是q", "此后呢", "发生的情况", "将与刚才那样一轮迭代完全相同", "也就是说", "q作为它所属的那个区段的首节点", "将会被保留下来", "而所有与之雷同的那些后继", "都将被剔除掉", "直到进入到下一个区段", "而且同样地 这个区段的首节点", "也将会保留下来", "它的雷同后继们也将会被删除掉", "整个这样一个过程将迭代地进行", "直到最终q试图越过边界", "这个时候 整个算法也就宣告结束", "纵观整个算法过程", "主体的复杂度来源是这个while", "而且可以看到 每经过一步迭代", "p都会转入一个新的节点", "所以整个迭代", "至多经过线性步就会停止", "这也是这个算法的总体时间复杂", "相对于无序列表", "这也是一个很大的改进"]}, {"name": "03C-3\t 查找", "block_id": "e88c8a077218468a9c1b98918cda19ea", "text": ["我们刚看到 有序列表的去重操作", "可以相对于无序列表而言 更快地进行", "那么其它的操作呢？", "比如我们最最关心的查找呢？", "我们不妨来看一下", "首先我们这里定义的语义也是类似的", "也就是 在某个有序列表内", "以某个节点p为基准", "在它的n个真前驱中 查找目标e", "而且同样地 这里我们也要求返回的是", "不大于e的最后那个节点", "可以看到 这个算法也是一个循环", "具体来说", "我们要令p从最初的位置开始", "每一次我们都要通过", "predecessor这个引用", "找到并且转向p的直接前驱", "并且将这个节点的数据域取出", "与目标作一对比", "一旦发现第一个不大于目标的节点", "就随即终止", "我们发现 这个算法与无序列表", "居然没有太多的差异", "因为同样 它在最好情况下也是常数", "比如在开始的位置就发现命中目标", "反过来 最坏也可能多达O(n)", "也就是说 一直查找到最后", "才得出是否命中的结论", "在整个查找范围", "也就是p之前的n个前驱中", "每一个元素对应的查找成本", "将呈算数级数趋势变化", "总体而言是线性", "这样一个结论多少会令我们沮丧", "因为尽管我们这里已经将列表中的元素", "按顺序进行了重新组织", "但是查找的效率居然没有实质的改进", "我们说 这并不是我们实现不当", "而根本的原因在于", "列表的循位置访问这种方式", "这种访问方式", "与向量的循秩访问有着本质的差异", "至此我们也不妨来", "将这两种方式作一对比", "正如我们此前所说的Vector这种结构", "在访问数据的时候", "所依据的实际上是秩rank", "而列表结构呢", "它所依据的是位置position", "你应该还记得 我们在此前", "所介绍过的计算模型", "实际上 对于RAM模型来说", "它所对应的其实就是循秩访问的方式", "不是吗？", "对于RAM模型来说 每给出一个编号i", "都可以在O(1)的时间内", "找到对应的寄存器 读取其中的数值", "或者对其进行修改", "再来看我们的图灵机模型", "虽然我们的纸带长度无限", "但在任何时候", "我们所能够操纵的只是其中", "某一个特定的单元", "而且更重要的是 在接下来", "我们只可能向左或者向右移动一格", "如果我们的确需要访问一个", "相距很远的单元", "我们将不得不亦步亦趋地", "逐步地通过多步的迭代", "才能够抵达目标", "不难发现 这正是我们所说的", "call-by-position", "而不是RAM那种call-by-rank"]}, {"name": "03E-1\t 经验", "block_id": "ec77c133d44849af8902c56956f03da0", "text": ["同学们好", "我们这一节继续以列表为例", "介绍插入排序算法", "这并不是什么新算法", "因为我们每个人实际上都曾使用过它", "难道不是吗？", "回想一下 你应该玩儿过牌", "你如果不是一个顶级高手的话", "非常可能和我一样", "有一个职业的习惯", "就是将每一张抓来的牌", "都按次序地排放好", "虽然这样很可能给对方", "提供一些额外的信息", "使得你的牌运总是莫名其妙的极差", "来看一下这样的一个过程", "假设这是你的牌桌", "在任何时候 你已经拿到的牌", "都会按照刚才我们所说的习惯", "依次排列整齐 就像这样", "这里为了直观", "我们用牌的高度来示意它的大小", "好 在下一轮发牌中", "你或许会得到这样一张牌", "为了继续使得你手中的牌按顺序排列", "我想 你应该做的事情是", "以这个牌为基准", "去查找一个适当的位置", "用你的眼睛这样一个过程", "用一秒钟就能反应过来", "随后 你会自然地将这个牌", "插入在这样一个位置", "此后稍事整理", "应该是这样一番图景", "也就是说 原先比它更大的牌", "将保留在原处", "新拿到的这张牌将会插入在", "刚才所确定的那个对应的位置上", "而此前曾经拿到并且", "比这张牌要更小的牌呢？", "会顺次向前移动一个单元", "在每次这样的过程中", "我们所做的工作无非两步", "第一步", "就是由这条绿色的线所标明的", "我们要去做一个定位", "接下来的动作", "实际上是两个更小的步骤的组合", "首先 将更小的牌向左移动", "以腾出一个空余位置", "以及将新获得的这张牌", "插入于空出的位置", "整个过程 无非这样的两大步 三小步", "其中最重要的特征就是2b", "这样的一个插入的动作", "这也是这个算法叫作插入排序的原因"]}, {"name": "11c2-3: \t实例", "block_id": "1cb587d492b94ee28bf1411db959cb6a", "text": ["由上可见", "KMP算法的核心 就在于那张查询表next", "在分析这张表的具体原理及其构造过程之前", "我们不妨先通过一个实例", "来切实领会这张表的精妙之处", "考察这个由10个字符所构成的模式串", "这里 我们直接给出其对应的查询表", "请关注其中倒数第3个字符l", "它所对应的秩为j=7", "而在查询表中 它所对应的next值为3", "下面 我们就来看看这个表项3所对应的含义及其功能", "假定这就是主串", "如果的确轮到这个表项来发挥作用", "那么就意味着在当前这一轮比对中", "此前的7个字符都应该是成功的", "也就是说 此时的场景必然是这样", "具体来说也就是 模式串中的这个字符l与文本串中某个不是l的字符比对失败", "此时 针对这种情况", "KMP算法将会如何处置呢", "为便于对比效果", "在处置之前 我们不妨先为模式串拍摄一张快照", "就像这样", "现在 我们手动来执行一下KMP算法", "首先 当前的j为7", "指向模式串中的这个字符l", "接下来 KMP将在查询表中取出对应的那一项", "并用它来更新j", "我们刚才已经看到", "这个表项就是3", "这就意味着 接下来KMP将会用秩为3的那个字符 也就是n", "来取代刚才的l", "并继续与文本串中此前失配的那个字符对齐", "就像这样", "此时 我们不妨为模式串再拍摄一张快照", "对比前后两张快照", "我们会发现 其效果等同于模式串向后移动了4个字符", "不难看出", "这个4是来自于7和3的差", "从另一个角度来看", "这也等效于KMP聪明地排除掉了3个不必要的对齐位置", "是的 这3个位置都是无需对齐的", "因为它们都不具备足以对齐的必要条件", "比如 它们所对应的首字符都不是模式串的首字符c", "而反过来", "KMP通过next表选择了字符n", "从某种意义上讲是非常合理的", "没错 它使得相对于n而言的这个前缀", "依然与主串是匹配的", "具体来说 c依然对应于c h依然对应于h 而i也依然对应于i", "是的 通过这样一个实例", "我们的确已经能够感受到 KMP算法及其中next表的精妙之处", "但严格地来说 在这种精妙的背后", "究竟是什么样的原理呢"]}, {"name": "03B-3\t 插入与复制", "block_id": "f9edd711bd8741f18a32381b5d3c9f17", "text": ["再来考察列表的插入算法", "那么这里呢 我们只以insert Before为例", "其余的呢 功能以及实现都类似", "我们就不耽误时间了", "顾名思义 所谓的insert Before", "就是在当前的列表中", "以某个位置p为基准", "在它的前方 也就是作为它的前驱", "插入一个新的节点", "而且这个节点的数值应该是", "我们指定的e", "我们可以看到 实际上它是通过", "转而由p作为一个节点的对象", "所支持的一个叫作", "insert as predecessor", "这么样一个接口来实现的", "而这个接口是怎么实现的呢？", "我们可以看到", "它会首先生成这么样一个节点", "这个节点的数值呢 为e", "而这个节点的前驱呢 恰好就是", "当前这个节点的前驱", "也就是这个位置", "而这个新生成出来的节点的后继呢", "恰好就是this", "就是当前这个节点", "所以这样一句 不仅创建了一个", "数值为e的节点", "而且完成了这个节点", "到当前这个列表的正确的连接", "当然还有很多工作要做", "接下来 做进一步的调整", "也就是 既然新的这个节点", "已经以当前节点作为后继", "那么当前节点也就应该以", "新的这个节点", "作为前驱", "反之 新的这个节点", "既然以原来的那个前驱为前驱", "那么原来的这个前驱也就应该", "以新的这个节点为后继", "至此完成了新节点的插入操作", "需要注意的是 这样一种操作", "只是在局部进行", "我们可以看到 只牵涉到局部的这样", "两三个节点", "与其它的节点没有关系", "我们形象地比喻下的话", "这就像一个微创手术", "这个微创的好处就在于", "它的复杂度是常数的", "而这一点与向量是迥然不同的", "细心的同学可能会", "考虑到一些特殊的情况", "比如说 如果当前这个节点是首节点", "以至于它的前驱根本就不存在", "那么这个时候这种操作难道不会出问题吗？", "我们说不会出问题", "大家应该记得", "我们在此前设立过哨兵", "就是说 即便当前这个节点是首节点", "它的前驱在内部依然是存在的", "也就是header", "而这个时候的这种操作依然是安全的", "有的时候 我们也需要", "以某个已有的列表为蓝本", "通过复制来创建一个新的列表", "我们来看相应的这个算法", "可见 这里被复制的节点范围是", "从某一个列表的位置p开始", "随后地连续n个节点", "所以因此 相应的算法也就是", "首先我们创建一个空的列表", "这个我们在上一节曾经介绍过", "只包含内部的头尾哨兵节点", "不包含任何实质的节点", "接下来 我们不断地将当前这个p处", "所指的那个节点的元素取出来", "把它作为当前列表的末节点插入其中", "每做完这样一个新节点的引入", "我们都会将注意力转向", "当前这个节点的后继", "如此往复", "直到这个区间中的所有n个节点", "都被复制过来", "那么这个insertAsLast", "怎么来实现呢？", "大家应该回想得起来", "我们所有对外可见的最后那个节点", "叫作last 也就是末节点", "但是我们这里还同样配备了一个哨兵节点", "叫作trailer", "所以可见 所谓的insertAsLast", "其实就是insertBefore什么呢？", "trailer", "insertBefore我们刚刚介绍过"]}, {"name": "07A-1 纵览", "block_id": "18112ab153d34c0d8a2eb7dba6b76a97", "text": ["同学们好", "在接下来的第7 第8两章", "我们讨论的主题将集中在二叉搜索树上", "同样 这也是我们整个学习过程中的", "又一重要里程碑", "它将标志着我们对数据结构的理解", "进入到一个更深的层次", "回顾我们在第二 第三章作为基础", "所介绍的两类基本数据结构", "也就是向量和列表", "虽然它们都已经可以解决相当多的问题", "然而对于进一步的算法设计要求来说", "它们都显得力不从心", "也正因为此 我们长久以来", "追求的一个目标就是", "如何将二者的优势结合起来", "其实在第五章", "我们已经做了这方面的尝试", "我们通过对一维列表的拓展", "引入了所谓的树结构", "或者二叉树结构", "我们曾经介绍过", "从思路上讲 二叉树结构", "可以认为是二维的列表", "可以看作是列表在维度上的一种扩充", "那么所谓二叉搜索树", "也就是binary search tree呢", "它首先在形式上继承了二叉树", "也就是列表结构的特点", "同时也巧妙地借鉴了向量", "或者更准确地讲", "有序向量的特点和优势", "相对而言", "后一方面的借鉴更为重要", "如果此前对列表结构的借鉴", "只是外表的形式", "那么这种对有序向量特点的借鉴", "才是一种质的提高", "这也是BST相对于其它的数据结构", "最为传神的部分", "实际上 BST中所有这些传神的部分", "都集中体现在其中的一个子集", "也就是平衡二叉搜索树", "balanced binary search tree", "简称BBST", "经过前人的不断发明和总结", "BBST已经成为了一个庞大的家族", "在接下来的两章中", "我们将选取其中最具代表性的", "几个变种 向大家逐一介绍", "作为整个这部分内容的一个铺垫", "我们在这一节中将回答以下几个问题", "也就是二叉搜索树是什么", "它有什么特点", "以及它所提供的接口形式", "和具体的功能语义"]}, {"name": "08B5-3\t合并", "block_id": "d5153df331d04d318232bb66d6d9e08c", "text": ["好 我们现在就来考察这样一种情况", "这也是我们需要考察的最后一种情况", "也就是说 发生下溢的节点 在经过左顾右盼以后发现", "无论是它的左兄弟还是右兄弟 都或者不存在", "或者所包含的关键码还不足够多 以致于不足以借出一个", "当然 情况还不至于糟糕透顶", "因为左右兄弟中 还至少存在其一", "不失一般性 假设下溢节点V的左兄弟至少是存在的", "尽管它不足以借出任何关键码", "当然 此时处于下溢临界状态的节点L", "应该恰好拥有m/2-1个关键码", "细加观察 不难发现一个现象", "此时无论是V 还是L 关键码数都非常的少", "这三者的总和也没有超出B树关于", "单个节点中所含关键码总数所设定的那个上限", "具体来说 也就是m-1", "顺着这个思路 我们不难得到一种修正此处下溢的方法", "具体来说 也就是从父节点中将这个分隔的关键码y取出来", "并且就以这个关键码作为粘合剂", "将刚才的V以及它的左兄弟L 合并起来", "成为一个新的节点", "在这个新的节点中 尽管表面看来 所含的关键码很多", "但是正如我们刚才所分析的 其总数也不至超出m-1", "因此 它必然是一个合法的节点", "而相应的 原先节点V所发生的下溢 也在无形之中被排解掉了", "在此之后 原先关键码y所对应的两个分支 也应该合并起来", "并指向这个新生成的大节点", "同样 我们需要验证一样 至此 这个局部乃至全树", "都依然保持中序遍历意义上的顺序性", "当然 在某一种情况下 故事依然没有完结", "什么情况呢？", "细心的你 可能已经注意到了", "经过这样的处理之后 父节点无形之中损失了一个关键码", "我们可以等效的认为 刚才是从父节点中删除了这个关键码", "因此 在这个父节点处 可能相继地发生一次下溢", "不难理解 这也是故事得以延续", "使得我们必须做进一步处理的唯一可能", "那么果真发生情况 又当如何处理呢", "可以送给你四个字 如法炮制", "没错 借助旋转以及合并 这两种手段", "我们足以处理每一次新发生的上溢（口误，应为下溢）", "当然 这里的好消息依然是 即便会继续发生上溢", "它的高度 相对于此前的那次上溢 也必然会有所提升", "也就是说 整个过程具有单调性", "因此 整个调整的过程或者在中途停止", "或者充其量抵达树根", "也就是说 如果全树高度为h", "那么整个修复下溢的过程 累计迭代步数也不超过O(h)", "这也是我们所预期的好结果"]}, {"name": "08A2-3 子孙同侧", "block_id": "6659ad7606eb41ebac2786fc32d4254d", "text": ["实际上 那另一只神奇的眼睛", "只有在zig-zig或zag-zag的情况下才会发光", "不妨只考虑其中的一种 比如zig-zig情况", "也就是节点v和他的父亲p都是左孩子的情况", "在这里为了便于对比", "我们不妨将这祖孙三代逐层伸展调整结果先画出来", "也就是v首先经过父节点p的一次zig旋转上升一层", "进而在通过祖父节点g的一次zig旋转再上升一层", "我们已经对此非常熟悉 整个过程平淡无奇", "我们刚才也讲过 它会导致最坏情况", "我们再来看看 Tarjan所点出的那只眼睛", "或者说他所建议的调整方法", "这里关键中的关键是 我们需要首先越级", "从祖父而不是父节点来开始旋转", "具体来说 经过祖父节点的一次顺时针zig旋转", "节点p以及v 都会上升一层", "接下来呢 进而对这棵局部子树新的树根", "也就是p再做一次zig顺时针旋转", "从而使得v能够继续上升一层", "成为这棵局部子树的树根", "将新的这种调整方法的结果", "与此前的逐层调整方法结果做一对比", "坦诚的讲第一次看到Tarjan", "为这条龙所点上的这只眼睛的时候", "我并没有察觉到它有什么与众不同之处", "现在的你 或许也是这样", "没错 各种的奥妙的确不易察觉 因为从效果来看", "二者无非都是将v这个节点提升了两层而已", "然而他们毕竟在局部拓扑结构上 还是有微妙的差异", "更重要的是 这种局部的微妙差异 将导致全局的不同", "而且那种不同将是根本性的 颠覆性的"]}, {"name": "03B-4\t 删除与析构", "block_id": "1a3dc83585094a9c9c386ef4605ad5ce", "text": ["再来看 如何从列表中删除一个", "指定的节点呢？", "这个remove接口名为p的这个参数", "实际上就指示了待删除的那个节点", "可以看到 首先我们需要", "将这个节点的数据域取出 作一备份", "以便在最终能够顺利地将它返回", "而删除节点之后", "整个列表在这个局部的", "拓扑连接关系的调整", "则是由这样两句来完成的", "我们通过下面这几幅图", "来理解一下这个过程", "第一句的效果可以认为是", "将p现在的后继当作", "p现在的前驱的后继", "我们可以看到 这样等同于", "将后继的这个引用直接跳过了p", "而第二句的过程以及效果", "与前一句完全对称", "具体来说 也就是将p现在的前驱", "作为p的现在后继的前驱", "我们可以看到 这样两句的实质的作用", "可以理解为是 将这个局部的后继引用", "以及前驱的引用都跳过节点p", "也就是说 p可以认为", "与原来那个列表", "已经在拓扑上隔离开了", "所以当我们将p", "直接地通过delete操作删除", "并归还系统之后", "我们才在拓扑上等效于", "就是这样的一个情况", "而这种情况稍加整理就可以得到", "上面这个图d的这种情况", "我们可以看到 相对于最初的a而言", "确实这个指定的节点p", "被顺利地在这个局部删除了", "同样地 我们应该注意到", "这个操作也是属于微创手术型的", "整个这个过程只牵涉到局部的三个节点", "其余的节点没有任何的影响", "由此我们也可以再次确认", "这样的一个算法与插入算法一样", "都是常数的", "如何销毁一个已有的列表呢？", "整个过程分为两步", "首先 我们要将对外可见的所有节点", "逐一删除", "当所有对外可见的节点都被删除之后", "我们再将内部的两个哨兵", "也就是header以及trailer给释放了", "所以整个这个算法分为两级", "析构方法 首先调用一个名为clear的过程", "将所有的可见节点删除", "接下来再将header和trailer删除掉", "那么clear具体是怎么实现的呢？", "我们可以来看一下", "实质的工作也就是反复的删除", "header的后继", "其实也就是当前的首元素", "累计删除多少次呢？", "对外可见的节点有多少个", "我们就执行多少次"]}, {"name": "02D5-2 \t实例", "block_id": "1778f8b090bf4810bcf5cd874d873363", "text": ["这是一个由19个整数构成的向量", "我们首先确认一下 它确实是单调的", "现在假设我们要在其中搜索50", "确认这时候的lo是0", "hi这里为了插值方便 不再取哨兵", "直接指向末元素 第18号元素", "那么按照我们刚才所介绍的方法", "经过一次插值之后", "mi等于9.3", "当然它必须是个整数", "所以我们进而取整 变成9", "也就是说 我们将在其中取出第9号元素", "也就是46 来进行比较", "我们经过一次比较会发现", "目标元素50 如果要存在的话", "必然存在于46的右侧", "换而言之 46的左侧 包括46本身", "都可以排除在我们的视野之外", "也就是说 我们接下来", "可以令lo转向10号元素", "这边全部忽略掉", "有效的减而治之", "接下来 在新的lo 也就是10", "以及原先保留下来的hi 18之间", "继续进行插值", "我们说经过这样一轮插值我们会发现", "下一轴点 近似的应该取做10.2", "同样的我们也取整 它应该是10", "那么10是谁呢？", "我们会发现 恰恰就是它自己", "这时候我们会发现 目标同样要比49大", "换而言之 应该把49的左侧", "其实这时候是空的 包括49本身", "排除在视野之外", "也就是说 我们应该进而考察lo=11的情况", "好 这是我们第三次尝试", "同样经过一次插值", "近似的轴点应取做10.8", "或作为整数就是10", "我们这时候知道", "10已经排除在我们的视野之外了", "换而言之这是查找失败的情况", "所以返回一个失败的标志", "从刚才的这个例子我们也可以看得出来", "对于这样一个长度为19的有序向量", "我们只用了3次比较就给出了答案", "而在通常的二分查找中", "这是做不到的", "所以我们已经看到", "它在某些情况下确实很快", "但是它总是能很快吗？", "包括这种很快到底定性是多大呢？", "我们需要做一个严格的界定", "首先一个不好的消息是", "插值查找在某些情况下", "效率其实会很低", "比如说 可能退化为", "与平凡的顺序查找没有什么区别", "大家可以去构造具体的实例", "我们这里给一个提示", "在这种情况下", "我们此前所做的那种假设", "也就是均匀独立的分布 不满足", "或者至少在某些部分不满足", "以致在全局或某些局部", "出现一些所谓的病态分布", "我们把这个留给大家", "在课后自己独立完成", "当然 插值查找的最好情况", "也是不言而喻的", "和其他的查找差不多 也就是说", "有可能我们在某次", "甚至在第一次猜测的时候", "就直接命中", "那么这种呢 我们不再考虑", "我们转而在考虑一般的情况", "也就是平均而言 会怎么样"]}, {"name": "08A2-1\t双层伸展", "block_id": "6ffd039dbf3844a794e48a11a331d4fb", "text": ["为伸展树这条龙点上那只传神之眼的", "是著名计算机科学家Tarjan", "他的这一点睛之笔 可以概括为", "不再是逐层的去进行伸展", "而是将它改变为两层两层的进行", "具体来说 我们需要反复考察 当前正在伸展的节点v", "它的父亲p 以及祖父g", "并且根据这祖松三代的相对位置", "经过至多两次旋转 使得v能够一次性的上升两层", "当然他们可能的相对位置 无非这里所罗列的四种", "也就是zig-zig zag-zag", "以及zig-zag和zag-zig"]}, {"name": "09D2-7 双平方定理", "block_id": "e25d276eb45842138da40f67340d77e5", "text": ["以上 针对双向平方试探法 我们所给的建议是", "将表长M取做形如4k+3的素数", "为了证明这个歌建议的有效性和必要性", "我们需要用到所谓的双平方定理", "整个精妙的定理 出自著名的费马之手", "在这个定理中 费马指出 任何一个素数p", "若能表示为一对整数的平方和 其充要条件是", "这个素数关于4的模余应该是1 而不是3", "当然 相关的结论 也可以推广到一般的整数", "为此我们需要借助这个恒等式", "通过一些基本的代数变换 不难证明这一点", "当然你不妨先通过这个实例 做一验证", "这个恒等式告诉我们什么呢", "它告诉我们 如果有两个自然数", "分别可以表示为一对自然数的平方和", "那么它们的乘积 也可以表示为一对自然数的平方和", "由以上恒等式不难推知 任何一个自然数n", "若能分解为一对整数的平方和", "当且仅当在它的素因数分解式中", "每一个模4余3的素因子 本身都是偶数次方", "我们来看一个实例 比如考察810", "与所有的自然数一样 它也有一个唯一的素因数分解式", "其中只有3是模4余3的 而且它是4次方", "符合偶数的要求", "我们现在就来看看 如何借助下面恒等式", "将他表示为一对整数的平方和", "首先那个令人讨厌的2 同样可以分解为1和1的平方和", "而3的4次方呢 本身就是9的平方", "而5呢 根据费马定理 它必然可以分解", "具体的可以分解为1的平方加上2的平方", "这样我们就向前迈了一步", "接下来考察这个乘积 由我们的恒等式", "可以进一步的得到1的平方加上1的平方", "再乘以9的平方以及18的平方", "现在只需套用刚才的恒等式 就可进一步的得到", "9+18 也就是27的平方", "再加上9与18的差 也就是9的平方", "没错 810 确实可以分解为这样的平方和形式"]}, {"name": "01b-6: 图灵机实例", "block_id": "add98f08e2a544099a9bf0060225f0fe", "text": ["好我们来看图灵机的", "一个具体的实例", "也就是说如何利用图灵机", "来完成非负整数加1的功能", "这里的非负整数我们统一约定", "是以二进制形式", "在纸带上用若干个单元", "统一表示的", "稍加观察我们会发现", "这里至关重要的要点", "是在其中的这样一个比特", "也就是从右向左", "从最低位向更高位 数", "所能发现的 所能遇到的", "第一个零比特", "既然它是零比特", "那么它后面 如果有的话", "后面的那些比特", "都应该是1", "而我们要完成这项工作", "实际上只需做这么样一件事", "就是将这个比特后续的", "所有那些1 翻转为零", "而原先最低位的这个零", "翻转为1", "好 基于这样的一个算法构思", "我们不难得出", "由如下转换函数 转换规则", "所构成的一个图灵机", "我们来看它的每一条", "转换函数意味着什么", "我们先来看第一条", "这里处理的是当前图灵机", "所处的是左箭头的状态", "同时它当前所对的", "那个单元里的字符是1", "这是什么样一个状态呢？", "我们说正如这个图所示的这样状态", "也就是说在最初的时候", "我们初始认为它是这样的向左状态", "而这个时候 它所对的字符是1", "按照我们刚才的规则", "这个1如果有的话 应该翻转为零", "翻转完之后呢", "我们说图灵机的读写头", "应该向左侧移动一步", "好 在移动之后呢", "我们说读写头 或者说图灵机", "应该继续保持原来的向左的状态", "所以我们说 这样一条规则", "有可能多次使用", "它所起的作用", "概括而言就是", "扫描作为最低位那个零的", "后缀的那些1比特", "将它们逐个的翻转为零", "而在这个过程中", "保持图灵机向左的", "这样一个状态 一直前行", "正如我们原来分析预料的那样", "一般情况下 会碰到一个零比特", "在这个时候我们说", "第二条规则就生效了", "也就是说", "一直向左行进的时候", "如果我们终于不再碰到的是1", "而第一次碰到的零", "这个时候它要做的就是", "将这个零翻转为1", "然后是原来一直向左的读写头开始向右", "也就是完成了一次转向掉头", "这个过程可以用这个图来表示", "也就是说", "当通过第一条传递函数", "这个读写头一路前行", "直到碰到这个零之后", "也就是这个状态", "它就会基于第二条规则", "转化为向右的状态", "然后将刚才那个零比特转化为1", "注意在此之前", "原来的那些1比特", "都已经转化为了", "相应的零比特", "好 接下来", "我们实际上只需要", "将这个读写头", "完整的送回到", "原来这个位置", "并停机就可以了", "对这个磁带上头的所有的单元", "已经没有必要", "进行进一步的修改了", "我们把后续复位动作", "所对应的指令的分析", "这个任务交给大家在课后完成", "那么我们这里也要强调一点", "表面看当我们做到这个的时候", "实际上相对于输入", "已经完成了加1操作的基本要求", "为什么我们还需要", "做后续的一些动作", "把这个读写头复位到", "最初的位置呢？", "我们说 这是因为", "它有可能本身以后会成为", "一个算法的一部分", "而那个算法", "在每次调用使用它之前", "都会对它当时所处的整体状态", "有一个严格的规范要求", "它是非常有必要复位的", "这种形式不仅在图灵机有", "而且在后面我们所说的", "各种更高级模型中", "同样会存在", "甚至成为软件开发过程中", "大家相互合作时候的一个准则", "我们称这个叫作规范", "我们在后续的几章会看到", "这种规范更多的是", "以接口的形式给出来的", "在这里 我们也首先看到了", "这种接口的影子"]}, {"name": "07B2-2 插入：实现", "block_id": "1293e46c2a1b4a1ab507b4e7d0c6364a", "text": ["BST的插入算法可以具体地实现如下", "首先要针对目标进行一次查找", "而且按照约定", "我们这里会忽略掉雷同的元素", "也就是说 我们的算法的确会终止于_hot", "而返回一个名为x 数值为空的引用", "所以接下来只需创建一个", "关键码为e的新节点", "并且将_hot作为它的父亲", "没错 创建一个以e为关键码的新节点", "并且以_hot作为父亲", "同时我们还要通过这个赋值语句", "令x不再为空 而是改为指向", "这个新创建的节点", "至此就完成了新创建的这个节点", "与原树的正确连接", "当然接下来 我们还需要更新这棵树的规模", "以及新节点历代祖先的高度", "这段代码虽然简单", "但其实它可以处理各种边界的情况", "限于时间关系 我们对此不做讨论", "请你在课后对照各种可能的边界情况", "验证这个算法的正确性", "那么如此实现的insert接口", "累计的时间复杂度是多少呢？", "不难看出 时间消耗主要集中在两个方面", "也就是search以及updateHeightAbove", "而且这二者在最坏情况下", "都不会超过整个树的高度", "因此总体而言", "这个算法的复杂度不过O(h)"]}, {"name": "05E4-1 次序", "block_id": "942b7f607c3e4606a78c321b57e97383", "text": ["同学们好", "这一节我们介绍最后一种", "典型的二叉树遍历算法", "也就是层次遍历", "回顾一下 在本章的开篇", "我们就曾约定", "我们讨论的都是所谓的有根有序树", "也就是说 我们这里讨论的", "任何一棵二叉树", "都被指定了一个特殊的节点", "我们称之为根节点", "由此就可以在垂直方向", "按照深度将所有节点划分为", "若干个等价类", "因此我们可以认为", "所谓的有根性", "其实对应的就是这样一个", "垂直方向的次序", "那么进一步地 位于同一深度", "也属于同一等价类内部的", "所有节点", "又当如何定义次序呢？", "我们介绍过", "所有的同辈节点", "的确 也可以分出次序", "比如对于二叉树", "完全可以通过左右的明确定义", "给出同辈节点之间的相对次序", "因此我们可以认为", "所谓的有序", "也恰好给出了", "沿水平方向的一个次序", "因此按照垂直方向和水平方向的次序", "我们可以完全可以在所有的节点之间", "定义一个整体的次序", "并进而对它进行遍历", "具体来说 我们将自高向低", "而在每一层自左向右", "逐一地访问树中的每一个节点", "如此定义的遍历策略及过程", "也就是我们这一节的主题:层次遍历", "那么这样一个遍历策略", "究竟应该如何具体的实现", "并落实为代码呢？", "为此我们又需要", "使用什么样的数据结构呢？", "回顾此前所介绍的三种典型遍历策略", "无论是先序、中序 抑或是后序", "都不能保证所有的节点", "严格地按照深度次序", "来接受访问", "在这三种遍历策略中", "都有后代先于祖先被访问的现象", "也就是所谓的逆序", "为此正如我们所看到的", "在实现这些遍历策略的时候", "我们无论是隐式的 还是显式的", "都需要借助栈结构", "而反过来 在层次遍历中", "正如我们刚才所定义的", "所有节点都将严格地按照深度次序", "由高至低 接受访问", "也就是说 这里严格地满足顺序性", "因此我们不难理解", "在这样一种场合", "与栈完全对称的那种数据结构", "也就是队列", "将会大显身手"]}, {"name": "05A-1 动机", "block_id": "0c8cbdd4485541fcaf10453b989a8826", "text": ["同学们好", "我们接下来的这一章", "将以树作为主题", "在此前我们所介绍的两种", "主要的数据结构", "也就是向量以及列表", "从分类上讲 都属于所谓的线性结构", "而我们很快就会看到", "树结构并不是严格的线性结构", "因此这一章将是我们这门课的", "又一里程碑", "在进入这样一个新的阶段之前", "或许我们应该首先来", "回答一个问题", "此前所介绍的向量以及列表", "难道的确不够用吗？", "没错 是这样的", "我们来考察一下这两种结构", "我们此前所要求的 也是我们此后", "将要要求的典型的几类操作", "第一类也就是所谓的静态操作", "以查找作为代表；而第二类呢", "是动态操作 也就是典型的", "插入或者是删除", "我们此前看到过", "向量的查找操作效率非常高", "比如说以典型的二分查找为例", "可以做到logn的效率", "然而遗憾的是 向量的动态操作", "无论是插入和删除", "在最坏情况以至平均情况", "都非常的差", "具体来说 需要线性的时间", "而同时我们也注意到列表呈现出一种", "完全对称的特性", "也就是说 如果希望在列表中进行查找", "无论是有序组织的 还是无序组织的", "性能在最坏情况下以至平均情况下", "也都是线性的", "这种效率非常低", "得益于列表的寻位置访问的方式", "一旦我们能够给定一个具体的操作位置", "对于列表的动态操作", "都将只是在局部进行", "换而言之 它只需要O(1)的时间", "由此可见 无论是向量还是列表", "都没有办法兼顾静态和动态操作的", "同时高效性", "而如何将二者的优势结合起来", "也将是我们接下来要讨论的", "一个重点话题", "联想到本章的主题", "我想大家不难猜出来 我们的解法", "恰好就是在树这种数据结构", "没错", "树这种数据结构可以认为是", "将二者的优点融合起来", "我们将会看到 它可以理解为是", "列表的列表", "也可以认为是二维的列表", "也正因为这个原因", "可以认为树型结构", "既不是我们此前所讲的", "狭义的线性结构", "同时它也带有一定的线性特征", "为了与稍后非线性的图结构相区别", "我们不妨称树型结构为半线性结构", "那么接下来 我们首先来了解一下", "什么是树", "当然如果你对这种概念", "以及相关的一些术语", "已经非常了解", "可以直接跳过接下来的一节"]}, {"name": "11b2-4: \t性能", "block_id": "41afd769ac3546228cd514142e2a5da9", "text": ["以下 我们就分别从最好和最坏情况两个角度", "对蛮力算法的计算效率作一评估", "首先 最好情况显而易见", "也就是我们在第一个对齐位置只经过一轮比对之后", "就能确定整体匹配", "在这种情况下 我们累计只需进行m次比对", "因此整体消耗的时间 可以度量为O(m)", "与文本串的长度n无关", "相对而言 最坏情况要复杂很多", "可以想象 在最坏情况下 我们可能需要尝试所有的对齐位置", "而且 在每一个对齐位置 情况都糟糕透顶", "具体来说 我们都需要经过m-1次成功的比对", "并失败于最后一次比对", "从而在每一个对齐位置 我们都需要付出 m次比对的成本", "因此 累计的成本 应该是这两项的乘积", "考虑到 在通常的情况下n要远远大于m", "所以借助大O记号 可以更为简明地度量为O(nm)", "如果考虑到无论n或者m都要远远大于常数", "那么 这样一个复杂度 的确是不能令我们满意的", "当然 至此你可能会怀疑 以上所设想的最坏情况 的确会发生吗", "坏消息是很不幸 的确可能发生", "比如 这就是一种最坏情况", "此时的文本串和模式串类似", "二者都是除了末字符为1 其余的字符都为0", "不难发现 在任何一个对齐位置的故事 都是一样的", "每次对齐之后", "我们都会经过连续的m-1次成功的比对", "并最终失败于最后一次比对", "当然 这类最坏情况的出现概率 受到很多因素的影响", "在通常的情况下 其中最主要的一个因素 莫过于字母表自身的大小", "我们注意到 此类蛮力算法的效率之所以很低", "其原因可以理解为它不足以处理这类大量的局部匹配", "而字母表越小 可出现字母的种类也就越少", "相应地 局部匹配的概率也就更高", "因此 也相对更有可能导致最坏的情况", "另一方面 最坏情况下的效率之所以极低", "也可以理解为蛮力算法没有能够有效地避免这类局部的匹配", "从而每次都是直到最终", "才会发觉此前所获得的一系列局部匹配都是徒劳的", "在这种极端的情况下 局部匹配的次数 取决于模式串的长度m", "因此m越大 最坏情况所带来的后果也更为严重", "然而反过来 一个好消息是", "蛮力算法也并非如它的名字所暗示的那样百无一用", "实际上 正如我们在习题解析中所补充证明的", "随着字母表规模的扩大", "以上最坏情况出现的概率将急剧下降", "以至平均而言 在每一对齐位置", "我们都大致只需常数次比对", "这就意味着 就期望的意义而言", "蛮力算法的时间复杂度可以接近甚至达到线性", "当然 我们并不满足于此", "而是期望能够将这个前提条件抹掉", "从而得到一个堂堂正正的", "即便在最坏情况下也只需运行线性时间的算法", "而更好的消息是 这类算法的确存在", "比如 我们接下来就要介绍的著名的KMP算法"]}, {"name": "04C5-3\t 手工", "block_id": "f642d14abb9e4f58bf1e07fd8c0327a8", "text": ["我们先来学习所谓的手工转换法", "为此 我们或许需要假定", "自己是从别的星球来的外星人", "也就是说 根本就不知道地球人", "是怎么约定中缀表达式中", "不同运算符的优先级关系的", "但是有一条 我们知道括号是很有用的", "通过括号 即使我是来自于外星的", "也可以明确的定义 在每一个表达式中", "每一个运算符的先后运算关系", "虽然这样会显得有点罗嗦", "没错", "我们确实刚开始的时候", "需要把这个事情弄复杂", "正像有一句名言所说的那样", "如欲取之 必先予之", "虽然我们接下来 要尽可能地去增加括号", "但是我们最终的目的", "却是希望将所有的括号都予以消除", "就以这个表达式为例", "首先我们需要显式的", "添加一系列必要的括号", "使得确实每一个运算符的运算次序", "都可以毫无含糊地被来自于", "任何一个星球的人所理解", "为了校核方便", "我们这里使用了圆括号", "方括号和大括号", "此时的每一对括号", "实际上都唯一的对应于某一个操作符", "比如这一对括号所帮助界定的", "就是阶乘运算的优先级", "而这对括号呢 所界定的", "应该就是乘法运算的优先级", "而再往外的这一对括号", "所界定的当然也就是加法运算", "如果你还愿意再继续举例", "我们可以看到这对圆括号", "实际上帮助界定的", "就是这个减号的运算次序", "接下来 我们要将每一个运算符", "后移到适当的位置上去", "什么位置呢？", "也就是帮助界定它的那对括号中的", "右括号的紧邻右侧", "所以 这个减号将会被移到", "它所对应的那个右括号的右侧", "这个加号也将会被后移到", "它所对应的那个右括号的紧邻右侧", "这个乘号也是如此", "阶乘号也是如此", "请大家特别留意这一点", "比如说 在这个例子中", "我们就发现有这么样一个现象", "在如此将运算符分别后移之后", "它们未必保持此前的相对次序", "这也很好理解", "因为正如刚才我们所说的", "在RPN中", "这些运算符将按照它们", "自左向右的次序来真正执行", "而在原表达式中", "显然 并不是所有的运算符", "都有这样左先右后的次序", "好", "如果说这一步是予之的话", "那么我们就可以取之了", "也就是说 我们可以将", "所有的括号都统统抹去", "它们的历史使命已经完成", "留下来的将是原来的那样一组操作数", "以及重新调整位置之后的操作符", "它们合并起来", "就是原来那个中缀表达式", "所对应的逆波兰表达式", "这里有一个非常重要的特征", "我们刚才讲过", "经过这样的转换之后", "运算符之间的相对次序是有可能颠倒", "至少是改变的", "但是运算数的相对次序", "是绝对不会改变的", "因为从刚才这个转换的过程", "我们可以看得到", "它们根本就没有动过窝", "原来待在什么位置", "依然待在什么位置", "即便是在经过重新整理之后", "它们的相对次序也是不变的", "现在你应该明白了", "邓老师在举这些例子的时候", "为什么总是爱举0 1 2 3 一直到9了吧？", "没错", "这是在帮助你理解", "并且记忆这样一个重要的规律", "我再强调一遍", "所有的操作数 在RPN中的相对次序", "与它们在中缀表达式中的次序", "总是保持一致的", "不会变化", "在这样的例子中", "原先是单调的", "此后依然是单调的", "反之亦然", "那么 这样一个手工转换的过程", "如何具体地实现为一个算法呢？", "其实这个问题你不应该来问我", "我们早就学过了", "难道不是吗？"]}, {"name": "12b1-3: 从频繁数到众数", "block_id": "56a2670949b34ce4b0a360a9982e757e", "text": ["然而很遗憾", "在我们尚未介绍高效的中位数算法之前", "我们以上的设想很难兑现", "因此或许我们应该转而去寻找", "其它关于众数的必要条件", "比如频繁数", "顾名思义所谓的频繁数", "也就是在一组数据中出现次数最多的元素", "很自然的众数应该是频繁数的一个特例", "根据定义它的出现次数不仅最多", "而且多于其它元素的总和", "因此如果我们能够像在Excel中那样", "拥有一个现成的频繁数调用接口", "那我们也自然可以用它", "来替换刚才的中位数", "从而同样得到一个众数的选取算法", "然而再一次的坏消息是", "频繁数的算法依然难以兼顾", "此前我们在时间和空间上所设定的目标", "因此再进一步的", "我们需要进而去寻找某种足够用", "但又更为松驰的", "同时计算成本也足够低的必要条件", "如果能够找到这样的必要条件", "以及对应的算法", "我们也同样可以自然的得到一个", "关于众数的选取算法", "那么这样一种必要条件是否存在呢", "如果存在具体的又是什么呢"]}, {"name": "04A-2\t 实例", "block_id": "6772819ff2964f76b3d045e717b5d33e", "text": ["接下来，让我们通过一个具体的实例", "来了解栈结构各种接口的准确功能", "以及它们组合之后所能达到的效果", "首先 通过构造函数", "我们可以创建一个初始为空的栈", "因此接下来 如果我们调用empty来检查", "它就会返回true", "报告说 这个栈确实为空", "再接下来 我们执行push 插入5", "那么我们将看到 栈中拥有了第一个元素5", "请注意 这里栈底是在右侧", "而栈的顶部是在左侧", "也就是说 栈生长的方向是自右向左", "因此再接下来 如果通过push插入3", "那么就会在5的顶端 生成一个新的元素3", "如果继而我们再执行pop操作", "那么按照此前的约定", "顶部的元素3将会被删除掉", "并且作为返回值交给上层的调用者", "好 再以下我们连续地通过两次的push", "依次地插入7和3", "此时 如果我们调用top接口", "那么它就会返回当前的顶部元素3", "当然 因为此时的栈中已经有3个元素", "所以如果继而我们调用empty去检查的话", "它会报告false", "也就是说 栈这个时候并不是空的", "再接下来 我们通过push插入11", "同样 新的这个11将会出现在栈顶", "此时如果我们再调用size接口", "那么它就会返回当前栈中元素的个数", "也就是4", "好 接下来继续通过push插入6", "它会被安置在栈的顶部", "同样 这个时候如果再去检查empty的话", "依然会报告false", "好 再接下来 我们再push7", "7同样会被插入并且安置在栈的顶部", "以下 我们将连续地执行两次pop", "根据我们此前对这种功能的约定", "当前的栈顶7以及接下来的栈顶6", "将会被依次弹出", "请留意这里7和6", "这两个元素的入栈和出栈的次序", "我们可以看出 相对而言", "更后进入栈的元素7反而会更早的出栈", "这也是栈结构的一个非常独特的性质", "也就是所谓的last in first out", "后进先出", "在后面我们将会看到 正是因为这种特性", "使得它在很多算法中可以大显身手", "那么 在对栈结构的ADT接口有了解之后", "我们自然就要进而考虑下一个问题", "也就是 如何来具体地实现", "具有这样一些功能接口的栈结构呢？"]}, {"name": "01a-6\t: 好算法", "block_id": "0a9f7e9606d64d16b3fa49469532e501", "text": ["什么是一个好的算法", "或者说是一个好的计算过程", "这件事并不容易回答", "我们也可能从不同的侧面", "听到过不同的回答", "比如说 它必须是刚才说的正确的", "它应该有足够的能力来处理", "各种规模的 包括可能是一些特殊", "也可能是一些一般性的问题实例", "也可能是退化的 或正常的输入", "以及所有合法的那些输入", "我们说这确实是好的算法的一方面", "但是很遗憾", "这不是我们这里最在意的", "也可能有的人会提到", "我们不光是要对合法的输入能处理", "对不合法的输入 也需要能够处理", "也就是所谓的需要健壮", "很遗憾 这部分", "也不是我们这里最强调的", "虽然我们在做题的时候", "在完成一个数据结构的时候", "要考虑这些", "但首先考虑的并不是这些", "还有一部分呢 是说", "一个好的程序或者好算法", "需要是可读的", "这个也是很重要的一个方面", "虽然也不是我们最重要的方面", "但是我们要强调这一点", "所谓的程序 是你作为人", "去指挥计算机的途径", "也是你和计算机相互沟通的一个渠道", "我们说这很重要", "是对的 但不完全是这样", "我们说还有一方面", "也就是说 程序语言", "实际上像自然语言一样", "它也是人与人之间打交道的", "一个很重要的部分", "所以可读性是非常强调的一条", "也就是说 你所设计出来的算法", "在形式上 必须是结构清晰的", "所有的变量 和有些有语义的对象的命名", "都应该是准确的", "同时还应该准备足够多的注释", "包括文档等等", "这个很重要", "但是还不是最重要的", "那我们这里头 最最重要的", "到底是什么呢？", "我们说最最重要的", "其实就是这样两个字 效率", "也就是说 我们需要不仅能够", "指挥计算机进行计算", "而且希望计算的速度要尽可能的快", "同时消耗的资源", "比如说空间的资源", "要尽可能的少", "既要马儿跑", "又要马儿不吃草", "做不到", "我们这里所努力的方向是", "既要马儿快快跑", "又要马儿吃得少", "有一个很著名的公式 大家都应该听过", "也就是说 算法和数据结构的结合", "就可以得到解决问题的程序", "那正如我们刚才所说的", "程序未必能够有效地进行计算", "所以这里 狗尾续貂", "对这个公式略做一点大胆的修改", "我们说在算法和数据结构", "这两个因素都兼具之后", "我们还需要使得它具有效率", "当然前提是", "使得这两部分不是一般的", "简单的堆砌", "而是能够有机地融合 结合", "只有在这样的情况下", "我们才能够写出", "高效的程序和算法", "从而高效率地", "来完成计算这样一个过程", "这也正是我们在这一节里", "希望告诉大家的", "几个重要概念及观念"]}, {"name": "10b4-3: \t自下而上的下滤：算法", "block_id": "87c9f70f263e42ec846ea6c1bb1c620a", "text": ["为了得到改进的建堆算法，我们需要来考察这样一个典型的场景：", "假设已经有了两个初始的堆H_0与H_1，", "而它们的堆顶r_0与r_1分别作为p的左孩子与右孩子。", "对于这样一种情况，在这种情况下，", "我们应当如何迅速地将这两个堆合并起来，从而构成一个更大的堆呢？", "实际上这并不是什么新问题。你能看得出来吗？", "是的，完全二叉堆的delMax算法。", "在那个算法当中，我们首先需要将最大元，也就是堆顶摘除掉，然后用向量中当前的末元素来取而代之", "是的，我们就来考察刚刚取而代之的那个时刻。在那样一个时刻，难道不恰好就是我们所说的这样一个场景吗？", "我们来验证一下，作为此前完全二叉堆的一部分，它们依旧处处满足堆序性和结构性。", "因此，它们都各自成为一个堆。同时，它们也是新的这个根节点的子堆。", "如果你能看透这一点，也就自然能得到相应的调整算法。", "没错，我们只需套用此前delMax算法的后半部分，具体来说，就是对这个新的根节点做一次下滤：", "当然，下滤的方向可能有两个：或者沿着左路的分支进入左侧的子堆，或者沿着右路的分支进入右侧的子堆。", "无论如何，一旦节点p的下滤得以完成，原先的两个子堆也自然地完成了合并。", "将这种处理手法推而广之并反复使用，我们就可以得到一个效率更高的批量建堆。", "这个算法出自Floyd之手，该算法处理节点的次序与此前的蛮力算法恰好相反，", "也就是说，在树中应该是自下而上、自右而左逐个处理。", "而对于每一个节点，我们都只需做一趟下滤，", "当然，对叶子节点而言，下滤并没有实际的意义，因此这个算法只需考虑所有的内部节点。", "相应地，第一个接受处理的也应当是最后一个内部节点。", "如果全堆的规模为n，那么最末尾的内部节点在向量中的秩就应当是floor(n/2)-1。", "我们刚才已经看到，对每一个内部节点实施的下滤", "其实质效果等同于将左右子堆合并起来，因此这样一个自下而上，逐个下滤的过程", "也就等效于各子堆逐层向上合并，规模不断增加的过程。", "因此最终当根节点的下滤也完成之后，所有节点也自然在整体上构成了一个完全二叉堆。"]}, {"name": "08A2-2\t子孙异侧", "block_id": "32cf4a0e71f04265ae9a2aebd3abc2a5", "text": ["我们先来看所谓之字形的情况", "也就是zig-zag或者是zag-zig", "比如这就是一种", "具体来说 节点v是左孩子 而他的父亲p却是右孩子", "此时 我们的改进策略是", "首先围绕着节点p做一次顺时针的旋转", "从而得到中间这种状态", "可以看到 v确实上升了一层", "接下来呢 我们再进而围绕着此前的祖父g", "做一次逆时针的zag旋转", "从而将这一局部子树转化为这样一种拓扑结构", "可以看到 最终的效果是", "节点v抵达了此前祖父的高度", "因此整个过程的实质调整效果", "可以理解为是v上升了两层", "然而经过仔细观察 细心的你或许会发现", "这样一种调整方法并没有什么稀罕之处", "因为它与我们此前所介绍的", "AVL树的双旋调整是完全等效的", "难道不是吗?", "一个zig 再加上一个zag", "无论是过程还是最终的结果", "而且进一步的对比你会发现 这样一个调整过程", "实际上与刚才的逐层调整 也没有任何实质的区别", "难道不是吗?", "首先对父节点做旋转 进而对祖父节点进行旋转", "难道这不就是逐层伸展的另一种等效描述形式吗?", "换汤不换药", "是的 如果你能观察到这些现象 那非常好", "因为这的确就是事实", "那条龙已经具有一只眼睛", "而真正的差别在于另一只眼睛"]}, {"name": "10xa2-1: LeftHeap模板类", "block_id": "bcd3546d973f43a3b2fdc2694bbcc5b0", "text": ["接下来的这一节，我们就来讨论左式堆的合并算法，", "在给出具体的算法之前，我们首先要给出左式堆模板类的定义。", "比如这就是一种可能的实现方式，可以看到，我们这里再次利用了C++的多重继承，", "只不过与完全二叉堆不同，既然左式堆不再满足结构性，", "所有元素在物理上也不可能再保持紧密的排列，因此继续从向量进行派生已经不合时宜，", "而实际上在这样的场合中，灵活改用树形结构作为派生的基类则是一种更高效的方法。", "同样地，这里依然需要以优先级队列接口为“神”，", "而取代向量的二叉树则扮演着“形”的角色。", "既然同样地派生自PQ，左式堆也自然地应该提供优先级队列的三个标准接口，", "而根据这里的实现方式，最大元总是始终对应于根节点。", "因此为了取出最大元，我们只需将根节点的数据域返回即可。", "接下来我们就可以通过外部函数的形式给出将两个左式堆合并的具体算法。"]}, {"name": "11C3-3: \t通配哨兵", "block_id": "80425617549e4cdf85c26d2fd44b566e", "text": ["至此 严谨的你或许会有一个疑问", "这里的候选者集合N(P,j)", "一定是非空的吗", "因为对于一个空集而言", "无论是选取最大元还是选取任何一个元素 都是无从谈起的", "然而实际上 这种担心是不必要的", "在这里我们注意到", "只要j是正数", "那么这个集合就必然包含0", "然而遗憾的是j有可能恰好就是0", "当然 此时P[j]所对应的前缀P[0,j)也自然是空串", "而我们知道 对于空串而言", "所谓的真前缀和真后缀都是不可能存在的", "也就是说 此时的候选集合 的确是一个空集", "为了修补这一漏洞", "KMP算法所给出的建议是", "统一将next表中的第0项置为-1", "那么 如何来理解这个-1呢", "一种形象而有效的理解方式就是", "为每一个模式串在首字符的前端 也就是等效于秩为-1的位置", "增设一个哨兵", "当然 与所有假想的哨兵一样", "这个哨兵并不需要真实地存在", "但是在逻辑上", "这个哨兵却等效于一个与所有字符都通配的字符", "你应该还记得我们在介绍KMP主算法时所搁置起来的一个问题", "也就是其中那个if语句所对应的条件式", "你应该记得 除了常规的字符比对逻辑", "KMP还增设了另一个并列的逻辑", "也就是j是否小于0", "现在 你应该恍然大悟了吧", "是的 在正常的情况下", "所谓的j<0无非就是一种情况", "也就是说 在刚刚过去的那一轮比对中 我们失败于首字符P[0]", "于是 按照我们刚才所建议的那种理解方式", "KMP将用这个假想的通配符 去与文本串中失配的那个T[i]继续比对", "既然是通配符", "所以接下来的第一次比对必然会成功", "也正因为此 我们可以将j<0的条件 在语义上与字符的成功比对等效起来", "也就是说 这个合成的逻辑判断式", "在语义上完全等效于一次成功的比对", "由此可见 巧妙地引入和设置哨兵", "在程序和算法设计过程中", "是一种非常高明的处理手法", "KMP就是这方面的一个典型范例", "概括而言 这种手法的高明之处主要体现在两个方面", "首先 在代码实现上 可以使得算法的描述更为简洁", "其次 通过相应地建立一种假想的模型", "反过来 也可以使得我们对算法的理解更为统一和深入", "我们知道 包括伽利略在内的许多著名物理学家", "都擅长于在头脑中进行所谓的虚拟实验", "而实际上 计算机科学中的这种假象模式", "与物理学中的虚拟实验", "有着异曲同工之妙", "至此 我们已经对KMP所使用的那个next查询表", "有了足够深刻的认识", "那么接下来一个问题自然就是", "从计算的角度来看", "这样一份查询表又当如何构造出来呢", "为此 我们又需要花费多少成本呢"]}, {"name": "01c-1: 主流长远", "block_id": "a7389b5205234b00873eadf9d0b0d802", "text": ["接下来的这节我们将重点讨论大O记号", "如果将我们在上一节所引入和介绍的计算模型", "比作一杆公正的直尺", "那么大O记号 就相当于是这杆直尺上的刻度", "非常有意思的是", "在这里我们并不需要一味地强调", "这种刻度的精细程度", "而是 在定性和定量之间", "达到一个适度的折中", "使得我们可以用更短的时间更迅速地", "抓住DSA性能方面的要害和主要的方面", "我们很快就会体会到", "作为一种强大的工具", "大O记号对于复杂度分析而言", "是多么地至关重要", "关于科学记号 在科学本身的发展过程中", "所具有的这样的一种特殊的重要的作用", "很多人都曾经注意到过", "比如Alan Turing就曾经指出", "对于数学而言 最最急需的", "与其说是 一个又一个的新发现的定理", "不如说是", "尽早发现和设计出来的good notations", "也就是好的记号", "大O记号好的方面在哪呢？", "我们可以概括为", "中国古代诗人陶渊明的一句话", "陶渊明在评价自己的时候", "曾经说过自己是好读书的一类", "但是他很注意一点 不求甚解", "这里我们说所的不求甚解", "并不是说不去求解", "而是说 反过来", "我们不要过多的拘泥于问题的细节", "和一些琐碎的部分", "换而言之 我们在考察一个东西", "比如说DSA的时候", "应该像考察一个人一样", "应该更多的看中它的长远", "也就是说 要看中DSA的潜力如何", "比如在处理更大规模问题的时候", "它应该是如何的", "第二 也像考察一个人一样", "我们不要过多地 纠结于它的细微不足", "而应该更多的看到它主要的方面 也就是主流", "非常有意思", "陶渊明的这种见解", "和我们将要介绍的大O记号的思路", "居然不谋而合", "回到最初的问题", "也就是说 随着计算问题规模的不断增长", "相应的计算成本会如何地增长", "那么这里我们更多地关心的是足够大规模的问题", "而且考察的是 计算成本的总体增长趋势", "因此 我们更倾向于采用所谓的Asymptotic analysis", "也就是渐近地分析方法", "具体来说就是", "我们要考察当问题的规模大于大于2", "也就是足够大之后", "相应地规模为n的问题", "需要多少计算的时间", "在这里我们上节曾经介绍过", "可以转化为平台上的基本操作的次数", "以及存储单元相应需要的规模", "后者我们说通常可以不考虑", "这方面可以参考我们的教科书和习题解析", "用一张图来表示 也就是这样", "如果我们用横轴表示问题的规模", "用纵轴来表示相应地计算成本", "那么 数据结构和算法具体的任何一个组合", "都可以得到这样一条曲线", "那么 我们所关心的并不是这条曲线", "局部的、细微的 包括暂时的一些趋势", "而是看它的主要的、长远的变化的趋势"]}, {"name": "08XA4-5\t反观回味", "block_id": "b6218dde29f9418980173dc03f39ea2b", "text": ["首先将原先的这棵红黑树转换为等效的4阶B树", "可以看到 双黑缺陷的确对应于一次下溢", "此时所幸的是 发生下溢的这个节点", "拥有一个足够富有的兄弟", "以至于可以通过某种方式 简明的消除下溢", "什么方式呢", "是的 旋转", "具体来说 下溢节点将从父亲那借得一个关键码", "而父亲呢 再进而向它的那个兄弟", "转借入一个关键码 以填补空缺", "经过这样的旋转", "可以看到下溢节点的确得到了修复", "接下来 我们只需将经过修复之后所得的这棵B树", "重新变换回它所对应的那棵红黑树", "与我们此前直接在红黑树上所做的变换操作", "恰好完全等效", "请注意 这种修复是彻底的", "因为尽管损失了一个关键码 但同时又补充了一个", "一进一出 彼此抵消", "而且新的这个关键码 会依然继承它前任的颜色", "因此 绝对不会在其他位置进而造成双黑", "从这个意义上讲 这种情况 也是相对更简单的", "这种简单性体现在", "这里还至少存在足以做旋转调整的余地", "也就是说 兄弟节点还足够富有", "或者再等价的在红黑树上", "这个兄弟节点s 至少拥有一条虚边", "或者说 至少有一个红孩子", "因此反过来 更为困难的情况自然也就是", "s的两个孩子都同时为黑", "此时 我们又当如何应对呢"]}, {"name": "11f1-2: 凡物皆数", "block_id": "86ad885cd76f4d7e98d77925ca5bfa0b", "text": ["是的 凡物皆数", "关于自然的本源", "这是很多人所秉持的一种信念", "在我看来 其中最坚定的信奉者", "同时也是最高明的实践者", "莫过于哥德尔", "比如 为了证明伟大的不完备定理", "他发明了一种简洁而强大的编号方式", "来对逻辑系统中几乎所有的组成部分", "统一以自然数来做标识", "这种编号 是基于素数序列来完成的", "我们知道 素数虽然是无限的", "但同时也是可数的", "因此 我们可以用p(k)来指代第k个素数", "比如前几个 都众所周知", "首先是2", "第2个是3", "第3个是5", "第4个为7 以及第5个是11 诸如此类", "那么哥德尔敏锐地发现", "任何一个有限维度的自然数向量", "按照某种法则", "都会唯一地对应于某个自然数", "比如 我们来考察这样一个由整数构成的8维向量", "它的各个分量依次为", "3 1 4 1 5 9 2 6", "我们现在来找出它所对应的那个自然数", "既然是8维 所以我们要首先要搬出前8个素数", "也就是2 3 5 7 11 13 17 19", "这8个素数将分别与向量的8个分量一一配对", "第1个分量为3", "所以我们相应地将它转换为第1个素数 2的3+1也就是4次方", "第2个分量为1", "所以我们也将它转化为第2个素数 3的1+1也就是2次方", "第3个分量是4", "所以我们也将它转化为第3个素数 5的4+1也就是5次方", "以下依次类推", "我们可以得到第4个素数的1+1次方", "第5个素数的5+1次方", "第6个素数的9+1次方", "第7个素数的2+1次方", "以及最后 第8个素数的6+1次方", "显然 这8个因子的乘积", "依然应该是一个自然数", "也就是说", "如此 我们的确可以将任何一个向量 转化为一个自然数", "而这种转换方法还具有一个更为精妙 更为神奇的特征", "根据如此得出的一个自然数", "我们还可以反过来忠实地还原此前的向量", "我想 点破了这层窗户纸之后", "你应该能够独立地看出", "这种还原的方法", "对吧"]}, {"name": "02B-2\t动态空间管理", "block_id": "4a41bc766ec0443591dc46b6c6a1062b", "text": ["当然 我们最开始", "给出的这个方案", "不见得是最好的", "但是 不妨把它作为", "我们改进的起点", "就策略而言", "我们实际上需要把刚才", "所采用的静态空间管理策略", "改变为所谓的动态管理策略", "这种策略 某种意义上讲", "是在模仿蝉这种动物的做法", "也就是说 像蝉那样", "每经过一段时间", "因为身体的生长", "使得自己的外壳", "已经无法容纳自身", "就会蜕掉原来的外壳", "并且代之以一个新的外壳", "是的 我们如果把", "这种策略翻译过来", "就是 如果在某个时刻", "某一个向量即将发生上溢", "那么我们就像蝉那样", "适当地扩大内部数组的容量", "使之足以容纳新的元素", "按照这样一种策略", "向量的生命期", "可以大致由这样一组图来表示", "最开始的时候", "向量所存放的有效元素", "还不是很多", "还不致于出现上溢的情况", "这时候可以从容应对", "但是剩余的空间", "有可能会逐步地被占用", "直到某一个关键时刻", "也就是 在这个时刻", "内部数组", "有可能已经饱和", "这个时候 它存在一个风险", "也就是说 再插入一个元素的话", "就会导致上溢", "那么在这个时候", "我们可以模仿蝉", "蜕掉原来的外壳", "为此 我们可以动态的", "申请另一个外壳", "也就是 另一段存放空间", "当然它的大小", "应该比原来的有所增长", "接下来 我们要把", "原先已经存放好的", "那些有效元素", "逐一地按次序地复制过来", "从而使得它们 对外界而言", "依然保持原貌", "而在这个时候", "新多出来的这些空间", "就足够用以存放", "新需要插入的元素", "而原来所占用的空间", "将在此之后被释放", "并且归还给系统", "上述这样一个", "完整的调整过程", "可以描述并且实现", "为这样一段c++的代码", "首先我们要判断一下", "现在是否的确处于", "即将发生上溢的临界状态", "那么它的标志就是_size", "是否还继续严格地小于", "_capacity", "如果是 还不存在上溢的风险", "可以直接返回", "所以这里隐含着有一个else", "也就是说 接下来", "我们的_size虽然不见得", "一定大于_capacity", "但是至少会出现", "等于_capacity的情况", "在这个时候 就要像", "刚才所说的那样", "模仿蝉去蜕掉原来的壳", "那么不同的在于", "我们首先的要将原来的那个数据域", "做一个备份", "接下来呢 以原先的容量", "大家注意 这里", "是左移一位 相当于加倍", "以原先的容量", "加倍的 一个新的容量", "来申请一段动态空间", "并且将这段空间交由原来的", "也就是我们通用的那个", "element来指示", "接下来要做的事情是复制", "对 从原先的", "那个数据域中 逐一地取出各项", "并且将其转移至新的", "这个数据域中对应的位置", "在整体赋值完之后", "原先的这个空间", "已经没有任何存在的意义了", "所以通过delete操作", "将它释放", "可以看到这段代码", "确实忠实的实现了", "上一页扩容算法（的）构思", "其实 对于尚未封装的数组", "同样可以采用上述的", "这样的一个策略", "那么对于向量而言", "这里调整又有什么优势呢？", "我们说这种优势", "体现在向量整体的封装性上", "因为我们都知道", "在对于一般的数组而言", "如果它经过了动态的", "重新分配地址", "那么原先指向它内部的", "某些元素的一些指针", "就有可能会出现无效", "也就是说 虽然它能指向一个地址", "但其中并没有存放", "我们所需要的数值", "那我们看到 对于向量而言", "经过了这样的封装以后 就安全了", "我们不会出现这种情况", "因为无论是此前此后", "我们在访问", "某一个具体的元素的时候", "在内部都是通过", "element这个统一的指示器", "来标识空间的起点", "所以从这一点 我们也可以看出", "进行封装以后的一个好处", "当然 最大的困惑", "也许在这里", "这里采用了", "一个容量加倍的策略", "为什么一定要用", "这样的一个策略呢？", "用其它的策略是不是也可行呢？", "能够适当地增加", "内部数组的容量不就足够了吗？"]}, {"name": "04C4-5\t 算法细节", "block_id": "f9248f6394c246109156ef776d875723", "text": ["不同情况的处理方法", "可以由这样一段代码描述并实现", "首先如果栈顶运算符的优先级", "低于当前的运算符", "比如运算符的栈顶位置是一个加号", "而我们的表达式", "当前扫描到的位置却是乘号", "那么就属于这样的一种情况", "在这样的情况下", "栈顶的运算符", "还没有等到应该执行的时机", "因此就需要将当前的运算符乘号", "推入运算符栈中", "同时将目光", "转向表达式中的下一个字符", "再来考虑相反的情况", "也就是栈顶运算符的优先级", "相对于当前运算符更高", "比如颠倒过来 栈顶是一个乘号", "而当前运算符是一个加号", "这就意味着此时", "栈顶运算符的执行时机已到", "因此这个分支的实质动作", "也就是执行相应的运算", "我们来看一下", "首先要从操作符栈中", "弹出当前的栈顶操作符", "如果它是阶乘", "也就是我们这里所纳入的", "唯一的一个一元运算符", "我们就从操作数栈中", "弹出栈顶一个元素", "并且与这样一个阶乘运算符", "去执行相应的运算", "而计算的结果呢", "我们还需重新将它", "推回到操作数栈中去", "当然 除此之外的", "在我们这里都是二目运算符", "因此我们需要从操作数栈中", "弹出一个 两个操作数", "并且将这两个操作数交给", "当前的这个运算符 执行对应的运算", "还要将运算所得的结果", "重新纳回操作数栈中去", "仍以刚才这个情形为例", "假设当前的栈顶运算符是乘号", "高于当前的加号这个运算符", "那么就应该从运算数栈中", "取出顶端的两个元素", "比如2和3 执行相应的乘法运算", "并且将运算的结果重新纳回栈中", "崇尚简洁的同学 或许会注意到", "我们这里对应于第一个运算数", "以及第二个运算数", "所引入的两个局部变量", "从某种意义上讲 似乎是多余的", "因为我们可以把整个这样的", "一个计算过程", "写成这样更为紧凑的一个形式", "弹出一个运算数 再弹出一个运算数", "然后", "对应于相应的运算符 执行相应的计算", "并随即将计算的结果推回运算数栈中", "那么问题是我们这里为什么没有", "采用这样一种更为简洁紧凑的形式呢？", "我们将这个作为大家在课后的", "思考以及讨论的题目", "最后 我们再来考察优先级相等的情况", "为此或许我们应该首先来温习一下", "刚才所定义的那张优先级表", "纵观这张表", "我们会发现 只有两处会出现等号", "第一处当前的栈顶是左括号", "而当前的字符却是右括号", "不难看出 只要原表达式是语法正确的", "这个右（注意：应该是左）括号肯定是在", "此前某个位置出现", "而且恰好与这个右括号彼此匹配", "在原来的表达式中", "它们的任务或者使命", "只不过是为了强制地界定", "介乎它们之间的", "那样一个子表达式的优先级", "在这个子表达式中", "可能会有各种运算符", "但在经过一系列的运算之后", "可能它们都相继执行过", "并且逐个消失", "等效于它们从来就没有存在过", "而当这样一对括号", "重新彼此相逢的时候", "子表达式已经完全计算和处理完毕", "此时它所对应的无非是一个数字", "也就是说 这对括号的", "历史使命已经完成", "现在到了它们联手退出舞台的时候了", "基于以上的分析", "我们就不难理解", "对于这种情况的处理方法了", "具体来说 只需简洁地", "将运算符栈中的当前运算符", "比如说左括号 弹出", "同时在表达式中", "我们也忽略掉", "与之对应的那个右括号", "而将注意力转向下一个字符", "那么另一种情况", "也就是表达式末尾结束标志\\0字符", "也应该如此来处理吗？", "没错 的确应该这样处理", "不要忘了 在我们开始计算之前", "我们首先已经将\\0推入栈中", "作为一个铺垫", "如果将这个铺垫的\\0", "视作是一个左括号", "那么作为整个表达式", "结束标志的那个\\0", "自然也就对应一个右括号", "如此看来 有朝一日一旦它们相逢", "也就完全等效于", "一对匹配的括号相逢", "所以我们采用刚才的那种方式", "将前者直接弹出", "从而使得栈清空", "并且同时将注意力", "跳过最后的这个字符", "也是再恰当不过的"]}, {"name": "09D1-4 线性试探", "block_id": "db10aa1c2def43fd95c122184cb1faa7", "text": ["查找链的第一种组织方法 就是所谓的线性试探", "具体来说 所谓的Linear probing", "就是一旦发生冲突之后 我们会转而去试探它的后继", "后继的后继 以及后继的后继的后继 诸如此类", "同样的 最终可能会因为发现目标而报告成功", "或者因为抵达某个空桶 而说明查找失败", "可以看到 在如此形式的散列表中", "除了数据词条 无需任何附加空间", "而更重要的是 每一查找链都集中在某一局部", "因此系统的缓存作用将得到充分的发挥", "而对于大规模的数据集 如此更可以有效的减少IO", "当然这种策略 同样也具有它的弱点", "其中重要的一点就是 为了消除以往的冲突", "可能会导致后续发生更多的冲突", "来看这样一个实例", "考察一个长度为7的散列表", "假设我们需要插入的是0、1、2、3和7这样5个词条", "如果就按照这种顺序依次插入", "那么首先是0就位 1就位 2和3也相继就位", "为了插入最后的7 我们首先去试探0号单元", "结果发现它非空 为了排解这一冲突", "我们会转而试探它的后继 也就是1号单元", "情况一样 进而去试探2号 3号单元", "直到最终在4号单元发现一个空桶", "从而将7 安置在这个桶中", "在这个散列表的生命期内", "发生冲突的只有一个词条 也就是7", "现在再来看另一插入次序", "比如将7调整到最前端 首先插入它", "我们依然开始于一个空的散列表", "按照约定的次序 首先将7安置在0号桶", "没有冲突 既然0号单元已被占用", "所以接下来插入0必然发生一次冲突", "并经过一次试探 最终将0安置在1号单元", "至此1号桶也会被占用", "因此接下来词条1的插入也会发生一次冲突", "并最终将它安置在2号桶", "这样的故事还会发生多次", "具体的也需要在这个位置发现一次冲突之后", "才将词条2 存入到3号桶", "最后 依然要经过一次冲突", "才能将词条3存入4号桶", "在整个这样的过程中", "词条0、词条1、2和3都发生了冲突", "前后对比不难发现", "后一种插入序列所对应的很多冲突", "本来的确是可以不必发生的"]}, {"name": "02B-3\t 递增式扩容", "block_id": "e1fb3362da7c4762a9a45dcaa4ea1174", "text": ["实际上 情况并不那么简单", "我们不妨以其中的", "一种典型的策略来做一个对比", "来看这样一种", "似乎非常可行的策略", "具体来说 就是每当发现", "当前的内部数组即将发生上溢", "我们并不是对它进行容量的加倍", "而只是在原来的容量的基础上", "追加一个固定的数额", "因为这样已经够用了", "所以貌似还不错", "我们甚至可以", "只需修改此前那个算法中的一行", "就可以简明地实现这种策略", "具体来说 就是将", "原来的_capacity乘2", "变成_capacity", "追加一个固定的数额", "我们管它叫作INCREMENT", "或者简记作大I", "那么这种策略可行不可行呢？", "我们说最终效率说了算", "我们要来看看它的效率", "对于这种策略而言", "它的一种其实还不见得", "是不容易出现的情况", "但是确实是最坏的情况", "我们来看看", "在初始容量为空的一个向量中", "如果我们连续地执行", "足够多次插入操作", "比如说n次操作", "而且n足够大以致于", "如果按刚才的", "INCREMEMT 大I来分组的话", "它至少可以分成m组", "那么不难理解", "在第一个元素插入的时候", "它就需要扩容", "也就是说 追加大I这么多容量", "接下来 在插入", "第I+1个元素的时候", "也需要扩容", "并且把它扩成两倍的I", "再接下来 2I+1个元素", "插入的时候", "它就需要扩容到3I", "一直这么下去", "也就是说 每经过I次插入操作", "它都需要进行一次扩容", "那么在这n个元素", "插入这个向量的整个过程中", "我们消耗在扩容方面的时间", "累计有多少呢？", "我们刚才看了", "总共大概要做m次扩容", "每次扩容所需要的时间成本", "大致是I  2I  3I一直到mI（注：应该是（m－1）I）", "如果你愿意去把它累加起来也可以", "那么如果你记得", "我原来教过你的诀窍", "那么就更自然了", "因为我们说过", "这是一个算数级数", "它的总和和它的末项", "是成平方关系的", "而它的末项 从阶次来看", "是和 n 是等阶的", "注意 这里的我们的 I 是一个常数", "所以是等阶的", "所以总体而言", "我们消耗在扩容方面的时间", "累计将多达 n 平方", "如果我们将这些", "扩容的时间成本", "分摊到这（n次插入操作）", "我们就会发现", "每一次（插入操作）", "我们都需要花费O（n）的时间", "这个时间多还是不多呢？", "我们说是很多的", "至少我们有办法", "可以使得它变得更少", "所以我们回过头来 再来看", "我们刚才所建议采用的", "那种加倍策略"]}, {"name": "02D3-2\t 实现", "block_id": "66f10999b76a4409ba26e581e9670655", "text": ["fibonacci查找", "大致可以实现为这样一段代码", "可以注意到", "它的接口还是完全一样的", "而且在其中的这个循环", "大致来说，也是类似地", "具体来说，每次我们都要来判断", "以保证当前的lo和hi", "构成一个合法的区间", "如果有朝一日，", "这个区间能够收缩到非法", "那也就意味着，查找是失败的", "这个跟我们此前的版本A是一样的", "那么在内部呢", "最重要的是要来确定", "当前的这个mi", "也就是这个pivot，这个轴点", "按照此前所说的算法", "我们每次都要取出来fibonacci数的下一项", "然后把这个数减1", "所以大家可以看到", "在这里我们有一个fibonacci类", "这个类呢，提供一个接口", "使得我们能够不断地取它的前一项", "当然还有我们这里没有用到", "实际上也提供了的", "它的后继一项", "无论如何，它总能返回", "恰好是前面一个适当的一个项", "这个项就是刚才我们说的那个切分点", "以这样的一个切分点来切分", "此后的这三句和我们此前所讲过的", "二分查找别无二致，完全一样", "所以我们也可以看出来", "所谓的fibonacci search", "和binary search的区别", "并不在于算法的这个大体的策略", "其实本质上讲只在于", "这个pivot，也就这个middle point", "是怎么取的", "如果是按平均来取，就是binary search", "如果是按照刚才所说的黄金分割点来取", "那么就是fibonacci search"]}, {"name": "06D-3 细节", "block_id": "1cf8544b9f9a41f19d512b064781a5d3", "text": ["以下我们就给出", "对于不同状态邻居节点的处理方法", "可以看到 无非三种情况", "如果邻接顶点", "是处于最初的UNDISCOVERED状态", "那么就与BFS一样", "意味着我们的支撑树", "在这个位置可以进一步地拓展", "为此我们要将从v", "通往u的那样一条边", "引入到遍历树中", "相应地 在遍历树中顶点u", "就将以顶点v为父亲", "相应地 此后的控制权", "也就转移到了新的这个邻居u", "因此根据此前所约定的算法策略", "我们就应该以这个新的顶点u为基准", "继续递归地执行深度优先搜索", "另一种可能的情况是", "下一个邻接顶点u是处于第二种状态", "也就是DISCOVERED", "此时的处理方法是", "将v和u之间的那条连边", "标记为backward 回向边", "或者简称回边", "最后一种可能是", "我们所遇到的下一个邻接顶点 u", "已经被访问完毕", "也就是处于最终的VISITED状态", "这种情况又可以继续细分为", "两种小的情况", "而判别的依据是要看", "顶点v和顶点u的", "dTime时间标签孰大孰小", "也就是看它们谁更早被发现", "如果是v更早被发现", "那么我们就将v到u的这条边", "标记为FORWARD", "也就是前向边 或者叫向前边", "反过来 如果是u更早被发现", "那么v到u的这条边", "就将会标记成CROSS", "交叉边或者是跨越边", "整个算法至此已经封闭", "以下我们需要通过一些实例", "来体会整个算法的过程以及走向", "并进而确立它的正确性"]}, {"name": "01c-3: 高效解", "block_id": "dd5e1be602f243efa8dfcc038168162b", "text": ["在大O记号定义的这杆直尺上", "到底有哪些刻度呢？", "我们首先来看，第一个刻度", "也就是所谓的常数复杂度", "我们把它记作O(1)", "哪些是常数复杂度呢？", "我们说常数，包括较大的常数", "以及常数按照通常的四则混合运算", "经过运算以后得到的常数", "甚至常数的更高阶的一些运算的结果", "从理论上讲，我们也依然认为是常数", "尽管像这个，比如2000的2000次方", "在实际中，已经是大的不能再大的一个数", "是不能被忽略的", "如果有算法 能够达到这样的复杂度", "我们说这是再好不过的了", "否则 什么都不用做", "就得到计算结果", "我们说那是不可能的", "那是不劳而获", "从代码段的形式上来看", "哪些算法，是符合这种复杂度呢？", "我们说如果一段代码中不含", "显式的或者隐式的循环", "具体来讲，就是由分支判断构成的代码体", "那么，它必然是顺序执行的", "总体而言 它必然是O（1）的复杂度", "那么反之呢？", "我们说情况并不那么简单", "有很多时候，虽然它从形式这样讲", "包含循环", "但是未必会造成更大的复杂度", "有的时候，虽然既有条件判断，也有转向", "表面看，是有一个转向的可能", "但也许因为语义上的某种限制", "其实，它转向的目标是根本不可能达到的", "还有一些呢 也同样会出现这种情况", "比如说，隐式的循环，也就是所谓的递归", "也会出现类似的情况", "这些问题 在这里我们不再展开地介绍", "有兴趣的同学，同样可以去参考我们的教材", "以及习题解析", "在那里有较为详细的介绍", "接下来的一个刻度", "是所谓的对数或者叫对数多项式复杂度", "我们先来看对数", "也就是说n，问题的规模的对数", "很有意思的是 我们在这里，", "往往不再标明具体的底数 为什么呢？", "因为在底数为常数的情况下", "其实具体是多少，在这里是无所谓的", "我们来看一下这其中的原因", "如果有一个表示原来是以a作为底数的", "我们完全可以通过这样的一个等价变换", "把它变换成，以b作为底数的", "而为此所作的调整", "无非是在前面乘了这么样一个", "log以a为底b的对数", "那么我们刚才讲过a和b都是常数", "所以经过混合运算以后也是常数", "我们说过在big-O", "甚至严格地讲，在θ的意义上讲", "这个常系数都是可以忽略掉的", "所以我们说，具体到底是a还是b", "其实是无所谓的", "只要它们都是常数", "与其如此，我们不如干脆就把它们忽略掉", "不再具体标明", "相应地呢", "还有，我们另一个特征就是", "如果这个n，也就是问题的规模", "本身是呈一个幂指数的形式", "它有一个常数次方", "我们说这个在log n的掩盖下", "也是可以忽略掉的", "原因也很简单", "在高中就应该学过这个", "n的肩膀上这个c是可以等价地", "挪到log前边去，变成一个常系数", "没错，又是常系数", "所以它也是可以被忽略掉的", "当然，对数本身也可以呈现出多项式的形式", "比如说对数的若干次方，构成一项", "然后可能另一个次方，多少次项", "那么在这种情况下", "我们同样可以参照刚才", "big-O的那种处理的方法", "把低次的项 相对来说是", "常系数的那些项都忽略掉", "从而同样可以得到一个简明的", "log的多项形式", "所以我们把这个叫poly-log function", "这类算法，我们说也是非常高效", "因为从渐近地意义上讲", "我们可以证明，对于任何一个多项式", "哪怕是次数很低，", "只要它是正数，一个次数c", "logn都是可以在大O记号的意义下", "被n的c次方所掩盖的", "所以它应该是，低于任何多项式的一个复杂度", "从这个意义上讲 它本身", "应该是无限地接近于O(1)的", "所以这种算法", "也是完全或者足以令我们满意的"]}, {"name": "03A-2\t 从向量到列表", "block_id": "9a3c6db07648419da6e39116d29b8f53", "text": ["列表结构的基本组成单位称作节点node", "不同的节点之间呢 在物理上", "未必是像向量那样彼此毗邻", "实际上 它们之间的物理位置", "没有任何规律可循", "因此必须要通过指针", "或者是引用构成元素之间的彼此联接", "但是有一点 作为线性结构", "它还必须在逻辑上保持是一个线性的序列", "也就是说", "如果把其中的元素罗列出来的话", "可以使节点与非负整数一一地对应", "前后毗邻的节点互称为前驱predecessor", "或者是后继successor", "这样一个序列中 除了第一个元素之外", "各个元素都有唯一的前驱", "对称地 除了最后一个元素", "每一个元素都有唯一的一个后继", "而没有前驱和后继的那两个特定的元素", "在我们这里也分别地给它", "命以一个特定的名字", "叫作首节点以及末节点", "我们来看一个例子", "对于任何一个列表而言", "首先都有一个入口的位置", "所有的元素确实可以从入口开始", "沿着它们之间的 我们称作叫作引用", "依次地从相对的前驱转向后继", "以及后继的后继", "直到最终的末节点", "虽然在逻辑上", "它们是这样的一个排列的次序", "但是在物理上却远远不是", "但是我们说 这样不妨碍它们定义", "并且实现这样的一个次序", "比如说 从某一个位置出发", "我们可以找到它的物理位置并且访问它", "接下来 我们可以顺着它的后继的引用", "找到它的后继", "以及再顺着后继的引用 找到后继的后继", "乃至后继的后继的后继", "诸如此类", "直到最终抵达末节点", "从而退出这个列表"]}, {"name": "12c1-5: \tShell序列", "block_id": "9d44a6d25c17451eb9a976409b4e1e2a", "text": ["我们在这里结识的第一个步长序列", "就出自于希尔排序的发明者", "Shell本人之手", "我们接下来就会看到", "这个序列存在很多缺点", "尽管从某种意义上来看", "它非常优美", "因为我们注意到", "它的每一项都整齐划一的是", "2的k次方的形式", "也就是说每一项都是前一项的两倍", "那么这个序列的缺点", "就集中体现在它在最坏情况下", "可能会导致n平方量级的运行时间", "为此我们可以构造这样一个", "具体的实例", "我们首先来考察", "两个整数区间", "也就是0到2的n减1次方", "以及2的n减1次方", "到2的n次方", "其中包含的整数都是2的N减1次方个", "只不过在数值上前者更小", "而后者更大", "接下来我们将这两组整数", "分别的打乱次序", "并相应的构成两个字序列A以及B", "然后我们按照ABAB交错的形式", "将它们会合为一个完整的序列", "比如对于n等于4而言", "这就是一个可能的生成序列", "可以看到它是有两个", "规模都为八的子序列交错构成的", "子序列A中的元素", "都被安置在秩为奇数的位置", "而对称的子序列B中的元素", "都被安放在秩为偶数的位置", "现在我们假设就采用希尔的序列", "来对它进行排序", "我们考察算法的倒数第二步", "也就是以二为间隔的", "那轮排序刚刚结束的时候", "我们可以断言", "此时序列的组成必然是这样", "也就是说原先来自于子序列A中的", "那些元素", "依然占据着秩为奇数的位置", "而且这八个元素的相对次序", "已经是完全有序的", "同时对称的原先来自于子序列", "B中的那些元素", "也必然仍就占据着", "秩为偶数的那些位置", "而且仅就这八个元素而言", "它们之间的相对次序也已经是有序的", "这两个字序列在这个时刻的有序性", "并不难理解", "在刚刚过去的这一论排序中", "这两个子序列", "恰好各自就是独立成为一列", "因此所谓的2-sorting", "其实就是对这两列分别进行排序", "所以它们的结果自然应该是", "各自有序的", "当然刚才我们所指出的另一个现象", "更会引发我们的好奇", "也就是说无论我们此前", "经历过多少趟的排序交换", "来自于子序列A和子序列B中的元素", "始终都是分别占据着", "秩为奇数和偶数的位置", "二者泾渭分明没有任何的元素互换", "为此我们需要反观希尔序列", "我们注意到在这个序列中", "除了第一项其余各项都是偶数", "没错  偶数", "这就意味着在这些项", "所对应的每一个重组的", "二维矩阵中同属一列的元素", "或者都来自于集合A", "或者都来自于B", "自然不会发生A与B之间的元素互换了", "因此直到执行完2-sorting之后", "这两个序列必然都是井水不犯河水", "互补相扰", "然而这恰恰正是问题所在", "对于这样的序列", "在接下来的最后一趟排序", "也就是one-sorting中", "我们必然需要付出高昂的代价", "因为在这个序列中", "依然包含着大量的逆序对", "我们不妨只统计B中的元素", "所参与构成的逆序对", "首先是全局最大的15", "它与其后的七", "就构成了一个逆序对", "接下来再考察4大的14", "不难看出", "它与6和7构成了两个逆序对", "再接下来是13", "它与5 6 7  总共构成了", "三个逆序对", "以下类推元素12", "将与4 5 6 7总共构成四个逆序对", "我想你已经看出其中的规律了", "没错", "B中的各元素所参与构成的逆序对数", "恰好构成一个算术级数", "没错算术级数", "我想经过这门课的学习", "你现在应该有了一个直觉的反馈", "是的", "这样一个算术级数对应的将是", "平方量级的运行成本", "也就是说算法的效率", "已经退化为个与起泡排序相当了", "当然在这里我们并不满足于", "仅仅指出希尔排序的缺点", "而更重要的是", "我们需要探究导致这种缺陷的根源", "让我们将目光再次投回到希尔序列", "我们会发现与其说", "其中大量的元素都是偶数", "不如更一般的说", "其中的各项并非互素", "因此每一轮的排序", "都有大量的精力浪费于", "对前一抡排序工作的重复之上", "是的", "相邻项要尽可能的互素", "这样我们也就拿到了", "打开新方法大门的钥匙"]}, {"name": "07D1-5 失衡+复衡", "block_id": "fd52aca7476040cdb9861efd4267aabd", "text": ["考察这样一个实例", "首先请关注中间的这棵BST", "不难发现 它其实就是", "我们在开篇所举的那个AVL树实例", "只不过在这里我们将数字的关键码", "统一替换为了字母", "接下来 我们假设需要插入M", "那么按照BST的常规算法", "经过适当的搜索", "我们可以确定应该将M", "作为K的右孩子接入到这棵树中", "然而我们随后会发现", "M的介入", "虽然不致引起它的父亲K的失衡", "却导致它的祖父N因此失衡", "更糟糕的是", "它的曾祖父 也就是R", "也会因为它的插入", "而导致失衡", "而作为一个极端的例子", "这里使得它的更高层祖先", "也会因为它的插入而失衡", "总而言之 在一棵AVL树中", "插入一个节点之后", "有可能会导致若干个祖先失衡", "当然你大可放心", "除了祖先之外的其它节点", "是不可能失衡的", "其背后的原因在于", "对于非新插入节点", "祖先的那些节点而言", "无论是它们的高度", "还是它们孩子的高度", "都不会因为新节点的插入而有所变化", "所以它们各自的平衡因子", "也都将维持原状", "如果此前是平衡的", "那么它们就不可能变成失衡", "好", "我们再来看另一个方向的操作", "假设在原先的这棵AVL树中", "我们删除了某一个节点", "比如Y", "那么类似地 我们也会发现", "Y的删除会导致它此前的", "那个父节点R发生失衡", "你会发现 除了R之外", "Y此前的其余祖先 比如说G", "并未失衡", "这只是一种巧合", "或者是我们没有考虑到", "最坏的情况吗？", "我们说不是这样的", "因为对于删除操作来说", "在摘除节点之后的瞬间", "至多只有一个节点会失衡", "这背后是什么原因呢？", "不妨假设 在某个节点被摘除之后", "的确会引起它的某个", "甚至某些祖先发生失衡", "我们可以证明", "其实其中只有一个祖先会失衡", "为此我们不妨考察", "其中高度最低的那个失衡祖先", "我们会发现", "这个祖先尽管失衡了", "它的高度却必然保持原样", "这背后的原因在于", "如果这个节点的失衡的确是因为", "它的某个后代被摘除了", "那么这个后代在此前", "也必然属于它那个相对更短的分支", "而它的高度则是由它", "相对更长的那些分支所决定的", "因此这个节点的删除", "并不致于引起这个祖先高度的变化", "而既然这个祖先的高度不致于变化", "那么相对于更高的祖先而言", "它们在计算平衡因子时", "结果也应该与", "未删除节点之前是一样的", "换而言之 它们也必然是平衡的", "所以概括而言", "如果在一棵AVL树中", "删除某个节点之后", "的确引起祖先的失衡", "那么这种失衡的祖先", "充其量不过只有一个", "没错", "在某个节点删除之后的瞬间", "至多只有一个祖先失衡", "而反过来 我们却刚刚看到", "一个节点的插入", "却有可能引起几乎所有的祖先", "同时失衡", "那么我们是否可以说", "相对而言", "AVL树的删除操作", "要比插入操作更为简单呢？", "实际情况 恰恰相反", "如果我们将插入操作和删除操作", "比喻为孩子", "那么插入操作是这样一种孩子", "他有可能在某个时候", "会闯下一连串的祸", "但这个孩子还至少是一个好孩子", "因为他能够痛改前非", "我们很快就会看到", "一旦他能够改正其中的一个错误", "那么其它的一连串错误", "也都会自然地烟消云散", "而反过来 删除操作呢", "虽然不能称作是一个坏孩子", "但是他至少是一个不长记性", "不吸取教训的孩子", "我们很快就会看到", "尽管这个孩子在每一次", "只会闯下一个祸", "但是每当你帮助他", "改正了这个错误之后", "他转眼就会忘掉这件事", "并且很快又会在另一个位置", "犯下同一样的错误", "而且这个孩子的记忆力糟糕之极", "即便你有足够的耐心", "帮助他改正下一个错误", "接下来转眼之间", "他又有可能在另一个位置", "再次犯下同样的错误", "因此相对而言", "插入操作实际上要更为简便一些", "而删除操作要复杂不少", "因此接下来", "我们不妨从插入操作入手"]}, {"name": "07B1-4 查找：实现", "block_id": "da556885e1a14d929ad5c36a991ad456", "text": ["以下我们就给出BST查找算法的", "一种实现方式", "可以看到 对外的标准search接口", "实际上在内部是调用了", "名为SearchIn的一个功能来实现的", "而作为一个更为基本的算法", "SearchIn可以实现如下", "具体来说", "也就是在以v为根的当前子树中", "去查找某一个特定的关键码e", "作为一个递归函数", "首先给出了递归基", "比如 如果当前子树已经为空", "就可以直接返回失败", "否则 如果当前根节点", "与目标关键码正好相等", "也就意味着查找成功", "无论如何 在这种情况下", "我们都可以直接返回", "而在一般的情况下", "也就是子树非空", "同时也没有在子树的树根处命中", "我们就继续递归地深入查找", "而查找的范围在经过一次比较之后", "可以相应地确定为究竟是左子树", "还是右子树", "不难看出", "这个算法每递归一次", "当前节点v 都会下降一层", "因此这个算法", "在最坏情况下的递归深度", "也不会超过树的高度", "这也是这个算法", "所对应的时间复杂度"]}, {"name": "03E-2 \t构思", "block_id": "97e2f4a763814304a6ba97e441bd2e3e", "text": ["我们来对刚才这个", "大家都习以为常的算法", "做一个更加形式化的描述和界定", "具体来说 在这个算法的整个过程中", "我们始终将输入序列视作两个部分", "其中的前缀部分", "长度为r 是所谓有序的", "而后缀部分 也就是长度为n-r的", "这样的一段 名为Unsorted", "也就是说 至今为止它还是无序的", "当然在初始的状态下", "Sorted的那部分长度是0", "这样一个空序列自然有序", "接下来 是个迭代的过程", "在每一次迭代中", "我们的注意力都集中在", "当前秩为r的这个元素e", "这个元素就相当于你在发牌的过程中", "新得到的一张牌", "我们的任务是要将这张新拿到的牌", "插入到我们手中已有的牌中去", "并且使得它们继续整体有序", "当然它的规模 也会相应地增加一个单位", "如下面这个图所示", "我们确实可以在原来Sorted那个序列中", "找到一个合适的位置", "并且将这个前缀中适当的一个后缀", "向后移动一个单元 腾出一个空缺", "并且将e纳入其中", "我们可以看到", "在经过这样的处理之后", "新的这个前缀继续地保持有序", "同时长度相对于此前", "增加了一个单位", "请留意 这里标记边界的记号", "此前的圆括号代表开区间", "而方括号代表闭区间", "由此 我们也可以看到", "这个算法所显然具有的一个不变性", "也就是说 无论r", "随着迭代地进行 如何递增", "由它界定的前缀必然始终有序", "直到最终", "当r足以覆盖整个序列的时候", "L也就整体有序", "我们的排序任务即告完成"]}, {"name": "07D2-2 插入：双旋", "block_id": "631514220a5545c59b305959f2f3c276", "text": ["比如这就是祖孙三代", "呈现一种之字形形式的可能", "具体来说", "节点p是节点g的右孩子", "而节点v却是节点p的左孩子", "这样一种情况也称作zig-zag", "当然还有对称的zag-zig", "其方法和过程完全对称", "我们这里不妨依然以zig-zag为例", "那么 请注意 这里我们所谓的g", "依然是所有失衡祖先中", "最低的那个", "而且节点g的高度", "也不致于太低", "它至少是新插入节点x的祖父", "当然 x本身有可能就是v", "在这种情况下 我们要进行一轮", "共两次的等价变换", "我们也称这种组合为双旋", "我们不妨通过下面这个动画来看一下", "这种情况下双旋的执行过程", "首先 我们要围绕着节点p", "做一次顺时针的zig旋转", "整个过程与刚才相仿", "我们重新来温习一遍", "好", "至此zig旋转即告完成", "那么接下来", "我们还需要围绕着节点g", "做一次逆时针的zag旋转", "就单独这次旋转来说", "与我们刚才的过程完全一样", "我们不妨通过动画来重温一遍", "至此 这步zag旋转也告完成", "这样我们实际上已经完成了", "这一局部的重平衡化", "为了能够更清楚地看到这一点", "我们不妨同样地", "对这一结果稍事整理", "现在你应该看得很清楚了", "在此局部的这棵子树", "的确已经恢复了平衡", "那么同样地 g以上", "有可能此前也是失衡的那些祖先呢", "我们说它们依然会一揽子地", "统一恢复平衡", "其背后的原因", "与刚才单旋的情况如出一辙", "我们把这一点的验证", "留给同学们在课后完成", "最后 正如我们刚才已经指出的", "这两种情况", "以及它的对称情况", "完全覆盖了", "插入操作失衡调整的所有情况", "因此就算法而言", "我们已经做了足够的分析和交代", "那么这样一组调整的算法", "如何具体的兑现为代码呢？"]}, {"name": "11d1-1: \t不对称性", "block_id": "b60ccc2580204004aab23a805b078868", "text": ["上一节所介绍的KMP算法", "计算时间在最坏情况下也可以保证不超过线性", "这的确是一个好消息", "然而 倘若我们因此就停下继续优化的脚步", "那就大错特错了", "实际上 串匹配问题与一般的搜索问题的确有着本质的区别", "在我们此前所讨论的所有搜索算法中", "每次比对 都是一种一对一的模式", "也就是一个目标 与另一个候选者", "判定二者是否相等", "的确只需常数的时间", "而现在 虽然基本的数据对象是单个的字符", "而所谓的串匹配", "则是相对于由若干个字符在局部组成的一个片段而言的", "也就是说 是由多个字符对多个字符", "二者匹配 当且仅当每一对字符彼此相等", "然而需要特别注意的是", "反过来 一旦发现有一对字符不等", "我们就立即可以判断串失配", "由此可见 从计算成本的角度来看", "判定一对串是否相等", "与判定它们是否不等", "并不是完全一样的", "我们接下来将要介绍的BM算法", "就充分地利用了这一性质", "从而使得串匹配的效率得以进一步地提高", "实际上 这一算法同时采用了两种策略", "在接下来的这一节", "我们首先来讨论所谓的坏字符策略"]}, {"name": "11a-2: \t术语", "block_id": "59fb3e686ddb43d181427dc84340c424", "text": ["为了便于接下来的讨论", "我们首先来统一关于串的一些术语和记法", "一般地 如果一个名为S的字符串 由n个字符构成", "我们就将所有的字符 从前至后 编号为0至n-1", "并按照我们的惯例 记作S[0,n)", "而串中秩为k的字符 也相应地记作S[k]", "于是我们就可以定义 什么叫做两个字符串相等", "有两个条件 首先是它们的长度相等", "其次 所有的字符 也必须捉对地相等", "也就是说 二者必须一模一样", "接下来的一个重要概念是子串 sub-string", "对于任何一个字符串S而言", "由i和k所指定的那个子串 也就是从秩为i的那个字符开始 连续的k个字符", "以这幅图为例", "如果整体为字符串S 那么这里所指的子串 也就是其中的这样一段", "可以看到 其中字符的秩 介于i与i+k之间", "接下来 所谓的前缀 prefix 是子串的一个特例", "具体来说 所谓长度为k的前缀 也就是起始于首字符的前k个字符", "对称地 我们也可以定义所谓的后缀 suffix", "具体地 所谓长度为k的后缀 也就是终止于末元素的最靠后的k个字符", "不难验证 所谓起始于i 长度为k的子串", "也就是在长度为i+k的前缀中 长度为k的后缀", "当然 这些定义中所涉及的所有参数 都是合法的", "为了节省时间 我们将不再每次都专门地对此作说明", "当然 有一种边界情况在此需要专门说明", "也就是说 串长n有可能是0", "此时 我们也称之为空串", "请注意 空串与由空格组成的串 并不是一回事儿", "空串 有别于其他各种串的特征 就是它的长度为0", "为了简化后续的讨论 我们不妨在此统一约定", "空串是任何串的子串 也是任何串的前缀与后缀", "同时 作为另外一种边界的情况", "我们也统一约定 任何串也是它自身的子串 以及前缀和后缀", "反过来 长度严格小于原串的子串、前缀与后缀 也称作真子串、真前缀与真后缀"]}, {"name": "04C4-4\t 算法框架", "block_id": "5a535d85316e4967ba78006269d24728", "text": ["我们的表达式求值算法", "主体框架如下", "可以看到 这里确实引入了两个栈", "分别用于存放运算数以及运算符", "所以基于我们此前", "所实现的stack模板类", "用float和char作为模板参数", "就可以便捷地", "同时使用两种类型的栈", "接下来 作为预处理铺垫", "我们要将表达式的结束标志\\0字符", "首先推入操作符栈", "接下来 算法的主体", "只不过是一个while循环", "每一次迭代不过两个分支", "分别处理当前的字符为操作数", "或运算符的情况", "既然是个语法正确的表达式", "所以判定的依据就是", "当前的字符是否是digit数字", "如果是 就意味着", "我们遇到了一个操作数", "当然这个操作数可能是多位的", "因此我们要调用readNumber函数", "将其完整地读入", "并且存入操作数栈中", "所以操作数的处理", "相对而言是更为简便的", "那么else 也就是操作符的处理", "却需要进一步地做不同情况的处理", "而处理的原则就是要看", "我们当前所遇到的这个运算符", "与运算符栈顶元素之间", "谁的优先次序更高", "具体的处理方法 我们稍后再说", "如何才能简明地判定", "两个操作符之间的优先级次序", "我们采用的是一种制表的方式", "这样一张逻辑上的二维表格", "每一列都对应于当前运算符的", "某种可能的情况", "而每一行呢 则对应于操作符栈中", "栈顶操作符的某一种情况", "可以看到 除了常用的", "加减乘除四则运算", "这里作为扩充", "我们还引入了乘方以及阶乘运算", "当然还包括我们用于", "强制指定优先级次序的括号", "甚至表达式末尾结束标志\\0", "这里也作为一个运算符 同样地对待", "纵观这张二维表格", "运算符之间的次序无非四种可能", "第一种是前者小于后者", "第二种是前者大于后者", "以及二者优先级相当", "另外还包括一种空字符的状态", "那么对于这样不同的几种情况", "我们应当如何来分别处理呢？"]}, {"name": "05E1-2 遍历规则", "block_id": "67f2a402c6674ab599da8cfc7247973e", "text": ["为了能够按照某种次序", "对树中的每一个节点都恰好访问一次", "任何一个局部的子树", "无非可以分为树根", "它的左子树L和它的右子树R三部分", "只要根节点的访问", "以及左右子树的遍历次序", "能够明确确定", "那么在整体上就必然导致一个", "明确的线性次序", "的确 只要在处处遵照这样的一个原则", "我们就可以导出几种典型的遍历算法", "也就是所谓的先序、中序以及后序", "它们的区别其实就在于", "局部的根节点究竟是按什么次序来访问的", "如果是先于左右子树 那么就是先序", "如果是介于左右子树之间", "那么就是中序", "如果是位于左右子树的遍历之后", "那么也就是后序", "这样一个次序可以用下面这组图", "来更加形象的表示", "可以看到 所谓的preorder traversal", "也就是先序遍历", "在进入任何一棵子树的时候", "都是首先访问它的根节点", "进而将控制权转交给左子树", "也就是说,我们需要递归地", "对左子树进行遍历", "此后再将控制权转交给右子树", "同样,递归地对右子树进行遍历", "此后我们才将控制权", "转交给适当的某一位祖先", "而inorder traversal中序遍历", "在任何一个局部", "都是倾向于先去遍历左子树", "然后再将控制权转交给根节点", "并进而访问这个根节点", "接下来 再将控制权转交给右子树", "并递归地完成右子树的遍历", "最终 再将控制权转交给适当的祖先", "而后序遍历也是类似", "在任何一个局部的子树", "都是首先倾向于去遍历左子树", "接下来 再遍历右子树", "当左右子树都已遍历完毕", "才会轮到当前的树根节点", "此后再将控制权交还给适当的祖先", "至于层次或者广度遍历", "我们将在后序的一节中 专门来讨论", "接下来 我们首先关注并讨论先序遍历", "我们来看看这种遍历将如何得来实现", "尤其是如何高效的实现"]}, {"name": "05A-4 有序树", "block_id": "67bde2491144422f95d3b5292c514405", "text": ["一系列的有根树", "通过刚才那种方式", "组合成一棵更大的树之后", "相对于新的树根", "此前各棵子树的树根就称作孩子", "按整体的是它的孩子们", "反过来 新的树根r", "也就是这些节点的父亲", "不难理解 在有根性的条件下", "这种父与子之间的关系", "可以毫不含糊的明确定义", "然而接下来的问题是", "如果形象地 同一父亲的所有孩子", "彼此互称是兄弟sibling的话", "那么它们之间的长幼关系", "又如何确定呢？", "这也是计算机科学所处理的树", "与数学所讨论的树之间的", "又一重大区别", "也就是说 我们这里需要", "在所有的兄弟之间定义某种长幼次序", "任何一个节点r", "所拥有的孩子的数目", "也称作它的度数degree", "那么在一棵树中", "顶点的数目、各个顶点的度数", "以及边的数目之间", "又存在什么关系呢？", "关于这一点", "我们可以通过归纳证明", "一个非常重要的结论", "也就是说 任何一棵树中", "所含的边数应该恰好等于", "其中所有顶点的度数之和", "同时也恰好等于顶点总数减1", "这个结论之所以重要", "并不在于它的细微之处", "而是在于它告诉我们", "任何一棵树中的边数", "与其中顶点的数目是同阶的", "也就是说 一棵树的总体规模", "如果可以度量为其中的点数", "再加上边数", "那么从渐近的意义上讲", "这个规模也是和其中的顶点数", "或者是边数同阶的", "也正因为这个原因", "在此后我们相关的算法中", "讨论到时间复杂度的时候", "我们都是以顶点的数目n", "作为对应的参照", "好了", "回到刚才参与构成这棵", "更大的树的那些子树", "它们拥有一个共同的父亲", "所以反过来讲", "它们彼此互称兄弟", "sibling是再自然不过了", "问题在于父与子之间的关系", "按照刚才的定义是非常明确的", "那么兄弟与兄弟之间的关系呢？", "这一点非常重要", "也可以说 这也是我们在计算机中实现", "并且维护的树结构", "与数学中所讨论的一般性的树", "之间的又一区别", "具体来说", "我们要将同一个节点的所有孩子编号", "使得它们具有这种意义上的某一个次序", "凡是如此 在兄弟之间", "也定义了明确次序的树", "我们也称之为有序树"]}, {"name": "02D4-5\t 正确性", "block_id": "bd60ae6ed17a47868fc70bc2f8f248a6", "text": ["我们首先通过这幅图", "来具体地了解一下", "这个版本C的工作过程", "其实最主要的是，它的每次迭代的过程", "每次迭代的场景都是类似的", "由这个a图来表示", "也就是说，在整个这个向量的区间内", "我们关注的是某一个特定的", "从lo到hi的一个查找区间", "在每次在这个区间里", "我们都考虑这个middle point，这个x", "我们以它为界，经过一次比较以后", "有可能会发现目标元素更小", "所以就深入到如图b所示的", "左侧的这个子区间", "或者对称地，因为目标元素更大", "我们深入到右侧的这个区间", "正如我们刚才已经看到的", "左侧子区间和右侧的子区间", "都没有覆盖这个middle point", "而且对这个middle point", "我们也没有做显式地判断", "所以这也是为什么我们刚才", "有理由怀疑", "它有可能是这个算法的一个疏忽", "我们来证明这样一个模式", "实际上是安全的", "为此同样用我们的两种技巧", "第一就是给出这个算法的不变性", "其次我们要给出它的一个单调性", "好在这里头，单调性一目了然", "我们就不再说明", "我们更主要的是来说明它的不变性", "我们断言按照刚才这个版本C", "如果我们查找的目标关键码是e", "那么在算法的任何一次迭代中", "零到lo区间内的所有的元素", "都不大于e", "而hi到n区间内的所有的元素", "都是严格地大于e", "我们说这是这个算法的一个不变性", "当然后一半的这个条件", "也就等效于", "就是秩为hi的这个元素", "如果它存在的话，包括它也是哨兵", "它总是在所有的严格大于e的", "那些元素中的最小者", "或者最靠左侧者", "这个不变性为什么是成立的呢？", "我们先来看在初始的时候", "lo是等于整个区间的左端点，也就是零的", "而hi呢", "是等于右侧的界桩", "也就是这个哨兵n的", "这个时候无论是0、lo", "还是hi、n这两个区间其实都是空的", "对于空的对象而言", "任何命题都是成立的", "再看一般的情况", "也就是说，根据数学归纳法", "我们可以假设这个不变性", "一直保持到如图a所示的这样一个情况", "也就是说", "零到lo这个区间确实是不大于e的", "而hi到n这个区间", "确实是严格大于e的", "而中间这段区间呢", "都是未定的", "但是我们说", "通过一次迭代之后", "这个性质依然能保持", "因为无非就是两种情况", "第一种情况，也就是深入左侧这个分支的情况", "我们说，如果真的是深入这个左侧分支的话", "那么必然，此前的那一句判断", "也就是，e小于这个a中的mi", "这个元素肯定返回的是True", "那么这说明什么呢？", "说明在此后我们将hi", "更新为mi", "从而使得右侧的这段区间", "向左拓展是安全的", "因为确实可以断定", "这个整个区间内的这些元素", "都是严格地大于e的", "因为它们其中最小的那个元素", "也就是这个mi", "经过刚才地判断，都大于e", "更不用说其它的了", "单调序列的特点", "而零到lo呢，保持不变", "所以我们说，这种情况是没有问题的", "我们再来看第二种情况", "也就是这样一个测试是以False返回的", "那么这个时候", "对应地，也就是否命题", "我们也可以说", "按照我们这里习惯", "把小的和大的尽可能地用", "小于和小于等于号来表示", "也跟左右吻合", "也可以断定就是说", "这个时候的e实际上是不小于mi的", "那么换而言之，mi这个元素", "和此前的零到Lo之间的元素都是一样的", "它们都不大于e", "既然它作为从零", "一直到mi这个整个区间中的", "最大的元素", "它都不大于e", "换而言之，整个这样一个区间", "都是不大于e的", "而我们在这种情况下，做的事情是什么呢？", "我们做的情况是", "使得左侧的边界等于mi+1", "实际上就相当于将未定的区间范围", "缩小到了这样一个范围", "我们可以看到", "这样一个左侧区间向右拓展的动作", "在刚才不变性的意义上讲，依然是安全的", "因为它使得不变性得到了延续", "所以换而言之", "经过一次迭代以后", "无论是向左还是向右的深入", "我们这里断言的这个不变性都是成立的", "而单调性是显而易见的", "直到最后会出现一个情况", "什么情况呢？", "就是整个区间的宽度变成零", "这个时候的图景", "我们如果画出来的话", "应该是这样的", "这是整个的原始的搜索空间", "我们经过不断地压缩、压缩、压缩之后", "将搜索的范围缩小到一个", "宽度为零的一个区间", "而这样一个宽度为零的区间", "与其说是个区间", "不如说是一个分界", "它严格地将整个区间分为了左右两部分", "我们刚才说了，由不变性", "左侧这部分依然是不大于e", "而右侧这部分是严格地大于e", "所以这个时候我们只需要返回", "从命中的角度讲", "左侧这个区间的", "最右端的那个元素就可以了", "这个元素是多少呢？", "这个元素实际上在最后那个瞬间", "应该是等于lo-1", "因为它的邻居才是这个时候的lo", "这也就是为什么", "我们在算法的最终返回之前", "要做一次减减lo的操作", "所以这样的话", "我们就得到了一个", "从功能上、从语义上、从性能上", "都近乎完美的算法", "我们称它是版本C"]}, {"name": "11c4-2: \t算法", "block_id": "095945c616544f8a800e94510d387069", "text": ["在这里 我们需要牢牢抓住的要领", "依然是next表项的那个必要条件 也就是前缀的自相似性", "刚才 为了估算出next表的第j+1项", "我们曾经尝试过在第j项的基础上去加1", "因为根据刚才所建立的充要条件", "只要P[j]与它的继任者是相等的", "那么的确可以简明地通过加1得到下一项", "那么即便P[j]与它的继任者不相等", "这个必要条件依然可以适用", "也就是说 在这种情况下为了估算出next表的第j+1项", "下一个值得尝试的位置 依然需要满足自相似的必要条件", "那么 对应的这个前缀的长度", "也自然就应该是在此前长度的基础上 再去取一次对应的next表项", "也就是说 从前缀长度的变化趋势来看", "如果此前是将j替换为next[j]", "那么接下来 就应该将next[j]替换为next[next[j]]", "当然 如果仍有必要", "我们还应该将next[next[j]]替换为next[next[next[j]]]", "这个过程有可能会持续多步", "一旦遇到这样一个相等的替代者", "就可以在它所对应的这个前缀长度的基础上再累进一个单位", "即可得到next表的下一项", "概括而言 在估算next表下一项的过程中", "我们应该按照这样一个序列依次尝试", "请注意 因为next表项对应的都是真前缀与真后缀的长度", "所以 对于任何一个j而言", "其对应的next表项都会严格地小于它自己", "这就意味着上述这个序列必然是严格递减的", "整个儿算法迟早会收敛并终止", "当然 最终的结局有可能是非常极端的", "也就是说 有可能会一直尝试到0号位置", "在这个图中 也就相当于模式串经过多次的位移 最终居然越过了i+1本身", "按照通常的理解 此时会出现问题", "因为接下来与P[j]进行比对的那个字符根本就无从谈起", "而事实上这正是我们的哨兵能够大显身手的又一个场合", "你应该记得这个假想的哨兵是一个通配的字符", "所以作为假想的继任者", "它必然在逻辑上也可等效为与P[j]相等", "因此 即使整个计算过程到了这步田地", "也必然会因为这次逻辑上的判等通过而随即终止", "而且此时next表中对应的下一项", "就应该是在-1的基础上再加1 也就是取作0", "作为巩固练习", "请你在课后自行验证一下", "在这种情况下将next表的下一项视作0 的确是合理的", "至此 只要纵观整个儿计算的过程", "我们就不难发现这实质上就是模式串自己与自己不断匹配的过程", "因此 只需基于KMP主算法的框架 略作修改", "也自然就可以导出next表的递推计算算法", "二者的区别实际上无外乎一点", "也就是 新的这个算法需要实时地输出next表的下一项"]}, {"name": "06D-4 无向图", "block_id": "14cb413934544bbca03304387bbe60a1", "text": ["我们首先来看一个无向图的实例", "在此我们首先要准备一张表", "其中的每一行", "分别对应于图中的某一顶点", "可以看到 每一行都有三列", "分别是这个顶点的标识", "也就是对应的字母", "以及它的dTime", "和fTime两个时间标签", "我们假设在时钟指向第一秒的时候", "a节点被发现并且接受访问", "于是我们将它在图中加粗", "并且将这个字母转为大写字母", "以表示它是当前节点", "可以看到", "它的dTime时间标签已经更新", "那么在接下来的for循环中", "我们将立足于顶点A 环顾四周", "试图找到第一个尚未发现的邻居", "不妨假设就是b", "于是在接下来的第二秒", "节点b将会被发现", "同样 我们对它做加粗", "并且大写的处理", "自然 从刚才的顶点a", "通往现在的顶点B之间的那条边", "也将会被采纳并且保留下来", "最终作为遍历树的有机组成部分", "好 此后在第三秒发现C", "在第四秒会发现F", "以及在第五秒会发现H", "再以下 在第六秒发现G", "在这一过程中所经过的所有的边", "都将作为树边被保留下来", "再以下 在第七秒 顶点J将会被发现", "此时出现了算法的一个转折", "我们发现J没有任何有效的邻居", "更不用说尚未访问的邻居了", "因此将会从顶点j沿着此前的树边", "回退到顶点G", "这样的一个过程也就是", "所谓的回溯 back-track", "不要忘了 在j被访问完毕的时刻", "我们也需要将对应的时间标签记录下来", "也就是第八秒", "再以下 我们将在第九秒", "发现并且访问顶点I", "并且在第十秒发现并访问顶点D", "接下来立足于顶点D 我们会发现", "它有一条边通往顶点g", "请注意 此时的顶点g", "是处于DISCOVERED状态", "也就是说 在我们的分支中", "这是属于第二种情况", "因此从顶点D通往顶点g的这条边", "将会被标记为\"回边\" BACKWARD", "同理 从顶点D通往顶点a的那条边", "也将被标记为BACKWARD", "在标记完由顶点d发出的所有边之后", "我们依然需要顺着此前的树边回退", "抵达顶点I", "不要忘了 在回退的同时", "我们还应该更新顶点d的fTime时间标签", "同理接下来 在顶点i处", "依然需要做一次回退", "对应的时刻是第12秒", "当我们重新回到顶点G的时候", "会发现还有一条边尚未标记", "既然是从当前的顶点G通往一个", "当前处于DISCOVERED状态的顶点", "那么这条边也应该属于BACKWARD类型", "好 在接下来的第13秒", "g也将回溯到它的父亲 也就是H顶点", "H顶点继续在第14秒回溯到它的父亲", "也就是顶点F", "而顶点f也会在", "接下来的第15秒", "回溯到它的父亲 也就是C", "而c呢 也会在接下来的第16秒", "回溯到它的父亲B", "此时立足于当前的顶点B", "我们会发现还有一个", "处于初始状态的顶点e", "因此顶点E", "将在接下来的第17秒", "被发现并且访问", "再接下来", "立足当前的顶点E", "我们会发现 它可以通往", "目前处于DISCOVERED的状态的顶点a", "所以相应的这条连边", "也依然是一条回向边", "当所有的出边都已标记", "并且处理之后", "我们需要在第18秒", "从顶点e 回退到顶点B", "并且继而在第19秒", "从顶点b回退到顶点A", "最终在第20秒", "顶点a也完成了对自己的访问", "因为我们已经回到了最初的起点", "所以整个遍历过程", "也就因此宣告结束"]}, {"name": "04C4-2\t 构思", "block_id": "13f8196524f14d4385f218a8d0370f42", "text": ["其实，在这些工具背后", "所蕴含的算法都大同小异", "你应该还记得我们的括号匹配算法", "对于任何的一个表达式", "我们总是试图在其中找到", "一对彼此紧邻", "也因此相互配对的括号", "我们的算法原理是", "将这样一对括号删去", "从而在剩余表达式与原先表达式", "在是否匹配上互为", "充要条件的前提下", "使得问题的规模", "也就是括号的对数 有所减少", "这也就是我们所说的decrease and conquer策略", "在这里 我们依然要在表达式中", "寻找一个能够优先计算的子串", "并且对它进行计算", "然后将计算所得的数值", "重新放置在这个位置上", "经过如此的转换之后", "新的表达式的数值", "与原表达式的数值保持一致", "同时如果我们将一个", "表达式的复杂度", "定义为其中包含的运算符的数目", "那么这样一个过程", "依然可以视作是一个", "减而治之的过程", "也就是说 这个算法具有单调性", "最终将消除掉所有的运算符", "从而得到最终的数值", "我们来看一个具体的实例", "最初的表达式列在最底层", "总共包含1个 2个", "3个 4个运算符", "在所有这些运算符中 我们可以发现", "乘号是可以优先计算的", "也就是说 这个乘号随同两个运算数", "以及表示优先级的一对括号", "整体地可以认为是我们刚才所说的", "一个局部可以优先计算的子表达式", "既然这个表达式可以运算", "我们不妨对它进行求值", "并且在整个表达式中", "将这个可以优先计算的子表达式", "替代为它所对应的数值", "我们可以看到", "经过这样一步转换之后", "问题的规模", "也就是表达式中的运算符", "减少了一个单位", "接下来 我们可以", "继续考察这个表达式", "并且同样可以找到一个", "可以优先计算的运算符乘方", "因此同样地 取出这个运算符", "所需要的两个操作数", "对这个子表达式进行求值", "并且代之以计算出的数值", "以下同理", "我们继续找到一个", "可以优先计算的子表达式", "对应的运算符以及运算数", "并且同样地 代之以它所对应的数值", "直到最后", "只剩唯一的一个运算符", "可以直截了当地进行运算", "并且把结果作为最终的输出返回", "从而完成整体的表达式求值", "这样一个计算过程", "虽然在纸面上简便易行", "但是如果面对比较长", "甚至非常长的表达式", "就将碰到很大的困难", "这个困难就在于我们很难", "至少现在是很难定位当前", "可以计算的那个运算符", "如果我们以一种线性扫描的次序", "来处理这个表达式", "每当扫到一个运算符的时候", "都未必能够确认", "它已经是可以计算的", "也就是说 我们的计算次序", "未必与扫描的次序完全一致", "如图所示 对于这样的一类问题", "一种行之有效的办法", "就是借助栈结构", "是的 我们只需将所有", "已经扫描过的部分", "保存为一个栈", "在所有已经扫描过的部分中", "有一些是已经经过判断以后", "能够及时处理的", "也就是经过判断", "能够在局部具有足够高的优先级", "并且已经计算过的部分", "而已经扫描过", "但是还不足以判断能够计算的部分", "将通过这个栈被缓冲起来", "而我们的策略就是蚕食似地逐步地", "将尚未扫描的部分扫描并且处理掉"]}, {"name": "07B3-2 删除：单分支", "block_id": "9838a86878014daa9f0ee8fe5171cc0d", "text": ["我们先来考虑第一种情况", "这也是相对而言更为简单的一种情况", "它的特征是我们经过查找", "所确定的那个目标节点x", "至多只有一个孩子", "或者反过来 它至少有某棵子树是空的", "比如在这样一棵BST中", "如果我们试图删除其中的69", "那么经过逐层地不断深入", "我们最终的确可以定位到69", "而且我们会发现69", "至多只有一个孩子", "此时我们只需将这个节点", "大胆地删除掉", "并且取而代之以它那个非空的孩子", "在这里 也就是64", "不难验证 经过这样的处理之后", "整棵BST依然是一棵名副其实的BST", "因此接下来 我们不妨将", "这种情况下的处理方法", "整理并且实现为具体的代码", "比如这就是一种可能的实现方式", "在这个名为removeAt的算法中", "我们要删除的对象是以x指示的那个节点", "请注意 在此前经过搜索所确定的hot", "也会作为参数传入", "接下来我们需要进行判断", "如果x的左孩子并不存在", "那么 我们只需直接用它的右孩子", "来代替它", "对称地 如果当前节点没有右孩子", "我们也可以直接用它的左孩子", "来顶替它的位置", "这也就是我们刚才所说的", "第一种情况", "需要特别指出的是", "其实这两种情况还涵盖了一个", "非常特殊的情况", "也就是左右孩子可能同时为空", "针对这种特殊的情况", "在课后你不妨重新体会这段代码", "并且验证它依然是能够正确处理", "经过这样的替换操作之后", "新近提升一层的节点", "还需要与它此前的祖父完成直接的连接", "这也是以下这两句所完成的任务", "至此 情况一的处理已经完全结束", "当然接下来", "比较棘手的是互补的那种情况", "也就是尽管删除的目标存在", "但是它的左右孩子同时存在", "情况一的策略在这种情况下", "无法直接套用", "那么面对这种情况", "我们又当如何处置呢？"]}, {"name": "10xa1-2:\t堆之合并", "block_id": "bf43a93f779d4bb2bb7bdd7b4ebb6374", "text": ["引入左式堆的动机非常直接了当，一言以蔽之，也就是为了能够有效地完成堆合并。", "具体地，对于任何的堆A与堆B，我们如何才能快速地将它们合二为一？", "稍加思索，你可能会认为这并不是什么问题，因为借助业已掌握的方法，我们完全可以实现这个过程。", "然而很遗憾，回到我们这门课程的核心，也就是计算效率，", "我们会发现已有的方法都不足用。", "比如，你可能会在两个堆中选择更大的那个作为基础，", "然后将另一个堆中的元素逐一取出并加入到前者当中，", "当更小的那个堆缩减为空时，也就自然完成了整体的合并，", "整个算法的描述也异常简练，实际上主体的操作完全可以汇总为这样一句，", "然而我们很快就会看到这个算法的效率是很低的，为此我们不妨将两个堆的规模分别记作n和m，", "并且不失一般性地假设前者不小于后者，于是整个算法共需迭代m次，", "在每次迭代中为了从b中摘除最大元，我们需要花费log(m)的时间，", "而为了将这个元素汇入到a中，我们又需要花费log(n+m)的时间，", "总体而言我们大约需要mlog(n)的时间，", "至此我相信你也会对这个效率不甚满意——是的，因为它的确存在改进的空间和可能。", "是的，你可能会想起Floyd批量建堆算法，", "实际上更为高效的一种办法就是将这两个堆中的元素首先简单地混合起来，", "然后借助Floyd算法将这n+m个元素整理为一个完全二叉堆，", "你应该会记得，Floyd算法只需线性时间，这一算法的效率明显优于此前的那个算法。", "然而即使是这个线性的效率，也依然不能令我们满意。你能看出我们不满意的原因吗？", "没错，作为Floyd算法的输入在默认情况下，所有的元素都是无序排列的。", "然而现在却并非如此，事实上它们被分成了两组，", "而且我们也已经分别知道了它们内部的偏序关系，", "很遗憾刚才这个线性的算法却没有利用到我们业已掌握的这些信息。", "因此从这一角度出发，我们完全有理由相信应该会存在更为高效的数据结构及相应的算法。", "事实上，左式堆正是问题的答案。"]}, {"name": "02E-2\t 改进", "block_id": "74f81d3b802d4b5386fc05d5c7f74ce0", "text": ["对于当前区间lo和hi之间的", "每一对相邻元素", "这里与此前的基本版本一样", "也需要做一个比对", "如果像这个if条件所判断的那样", "它们是逆序的", "我们就将二者交换位置", "这个新的版本不同的关键之处在于", "我们这里提供了一个标志", "记录这个if判断语句曾经成立过", "这个标志的初值设为true", "而它的命名和它的语义", "恰好是吻合的 sorted 有序的", "我们这里类似于无罪推论", "首先认为它是不存在无序元素的", "也就是整体是有序的", "接下来 一旦发现一对逆序的元素", "随即将它标志为false", "按照这样的一个逻辑", "在最终返回sorted的时候", "它就恰好反映了", "在此前的这趟扫描过程中", "是否曾经发现过逆序元素", "或等价地 当前这个区间", "是否已经完全有序了", "而这个标志将在主程序中", "作为while循环的控制条件", "在sorted返回true的时候", "这个因为取了非", "while的继续条件不再满足", "从而及时地终止 节省时间", "这种改进在时间成本上的体现", "可以用这样一幅图来表示", "在此前原始的版本中 是机械的", "从头到尾执行各次扫描交换", "它所需要的时间", "可以认为由一趟扫描交换", "接着另一趟扫描交换", "以及再接着一趟扫描交换", "持续进行 直到最终一个不漏", "整体运行时间确实可以度量为", "一个三角形的面积", "那么新的这个算法呢？", "它固然要做第一趟扫描交换", "也许还需要进行一次扫描交换", "也许还会进行若干次扫描交换", "但是正像我们刚才所说的", "在某些情况下", "它有可能会发现", "不光此后的部分已经有序了", "而且这个前缀也已经完全有序了", "所以在这个时候", "它会及时地跳转到最后", "聪明地绕过这些", "完全可以绕过的计算量", "因此与刚才那样对比", "新的这个算法所执行的计算量", "可以度量为这样一个梯形", "而不是原来的三角形", "也就是说 很多情况下", "我们都可以节省一定的", "甚至是相当多的时间", "不过我们对这个算法的改进", "并不满足于此", "因为我们发现在一些其它", "或者说在更多的情况下", "这个算法依然存在继续改进的空间"]}, {"name": "06A-2 无向+有向", "block_id": "5cd6f825f9a740278cec6ddd795d7270", "text": ["根据所允许的边不同", "我们还可以对图", "进行进一步的类型划分", "比如在通常的情况下", "我们并不在意", "构成一条边的两个顶点u和v", "具体谁先谁后", "在这种情况下", "我们就称之为", "undirected edge 无向边", "如果在一幅图中 所有的边都是无向的", "我们也就称它叫undirected graph 无向图", "比如这就是一个无向图", "我们可以看到其中的四条边", "都是方向无所谓的", "反过来 有些边的两个顶点", "是有方向区别的", "比如在这样一幅图中", "从A指向C的这条边", "与从C指向A的这条边是不同的", "比如从B指向A的这条边", "它的起点B称作是它的尾tail", "而它的终点A则称作是它的头head", "如果在一幅图中", "所有的边都是这种directed edge", "那么我们就称它叫作directed graph", "或者简称作digraph", "当然 在有些情况下", "图中的边有的是有向的", "而另一部分呢", "却可能是无向的", "那么这样一种图", "我们也称之为混合图", "在我们这门课中", "注意力主要集中在有向图上", "原因很简单", "因为通过有向图", "我们完全可以表示", "并且实现无向图以及混合图", "这里的技巧是", "我们可以将任何一条无向边", "比如说这里的A C", "转化为彼此对称的一对有向边", "因此我们接下来", "所介绍的图的实现以及图的算法", "都是围绕有向图来展开的"]}, {"name": "07B1-2 查找：算法", "block_id": "534cd7404056475db70e14c024cc24a7", "text": ["作为最基本的操作接口", "首当其冲自然是查找", "那么如何在一棵BST中", "查找特定的关键码呢？", "我们来看一个具体的实例", "首先你不妨暂停一下", "按照上节所推荐的方法验证", "这的确是一棵BST", "每一次查找都是从根节点开始的", "假设我们要查找22", "那么首先将目标关键码22", "与根节点处所对应的关键码16", "做一比较", "不难看出", "22相对于16更大", "那么这样一个判断结果", "意味着什么呢？", "你应该还记得", "BST所处处具有的顺序性", "是的 对于根节点而言", "它的左后代都不可能比它更大", "而当前的查找目标", "却比它更大", "这就意味着根节点的", "整棵左子树都可以被忽略掉", "反过来 如果树中", "的确存有目标关键码22", "那么它也必然位于右子树中", "因此接下来 我们将相应地", "转入这棵右子树", "具体地 也就是将控制权", "交给这棵子树的树根25", "同样地", "每当进入一棵子树", "我们都要将目标关键码", "与当前的子树根节点进行比较", "经过这次比较我们发现", "目标关键码22", "相对于子树根节点要更小", "那么这意味着什么呢？", "同样地 根据顺序性", "节点25的所有右后代", "都不会比25小", "都不可能等于目标关键码22", "因此这些节点同样可以被忽略掉", "反过来 如果目标关键码", "的确存在于这棵子树中", "那么它也只能存在于其中的左子树中", "这也就是为什么", "我们接下来要顺藤摸瓜", "转入25的左子树", "也就是将控制权", "交给这棵子树的根节点19", "在进入这棵子树之后", "我们同样要将目标关键码22", "与这棵子树的树根19进行比较", "并可以相应地忽略掉", "它的所有左后代", "虽然现在只有一个", "而将查找的范围缩小到", "这个根节点的右子树", "最后一步", "在相应地进入到这棵右子树之后", "我们同样要将这棵子树的根节点22", "与目标节点进行比较", "并终于发现二者相等", "至此 这次查找", "也就相应地以成功而告终", "现在请你留意观察", "在下方列出的这样一个序列", "你应该看得出来", "这就是这棵BST的中序遍历序列", "好的", "现在你假想地认为", "它就是一个向量", "当然根据全局的单调性", "它必然是一个有序向量", "以下我们将重放一遍", "在这棵BST中刚才的搜索过程", "我们不妨一起来体味一下", "这样一个搜索的过程", "在下方的有序向量中", "对应于怎样的一个过程"]}, {"name": "08A1-5\t实例", "block_id": "a55344b0947a47c18c1f12bb8fc4d99c", "text": ["我们来看具体的实例 这是一棵BST", "假设我们需要访问333", "那么按照刚才的策略 我们需要在此后", "通过一系列的zig和zag旋转 将它转移到树根的位置", "我们来看看具体的过程", "从333开始 首先我们注意到它是右孩子", "所以要找到它的父节点 285", "并且做一个逆时针的zag旋转", "这样333就上升了一层", "接下来 它依然是右孩子", "所以我们同样需要找到它的父亲 也就是021", "并且对021做一次zag旋转", "此时333已经成为一个左孩子", "我们需要对他目前的父亲 也就是448", "做一次顺时针的zig旋转", "同样333的高度 因此上升一层", "这个过程将如此继续下去", "也就是我们进而对新的父亲468", "做一次相应的顺时针旋转", "以及对最后一个父亲641 做一个顺时针的旋转", "可以看到不出意外 333经过若干次zig和zag旋转的组合", "最终抵达了树根", "从而使得接下来对它的访问 可以几乎只需常数的时间", "如果将节点的这样一种调整过程 连贯的来看", "我们就会发现 这个节点逐层上升的过程", "是一个左右摇摆 不断伸展的过程", "所以我们也称这种过程为伸展 splay"]}, {"name": "12a1-4: 单调性 + 不变性", "block_id": "b3b65e47939f4974aecf699d1d8d23eb", "text": ["以下就让我们通过这样一组插图", "更为细致的考察和理解", "轴点构造算法的原理及其具体过程", "在这个过程中我们需要把握", "两条核心的不变性", "首先正如我们此前所言", "从数值上来看", "子序列l中的元素都不超过轴点候选", "同时子序列g中的元素", "也都不小于轴点候选", "其次对于子序列u而言", "它的首元素和末元素", "总是交替的在逻辑上可以视作为", "空闲单元", "我们首先来验证初始状态", "比如在初始状态下", "无论l或g都是空的", "所以第一条自然满足", "同样在出使条件下U的首元素", "已经作为轴点的候选被取出备份", "因此它的确可以认为是空闲的", "再来考察一般情况下的U", "它的首元素为lo而末元素为hi", "不是一般性假设此时的lo是空闲的", "于是我们就可以尝试着", "向左侧拓展子序列g", "具体来说只要当前U的末元素", "也就是hi在数值上不小于候选轴点", "我们就可以简明的", "通过令hi递减一个单位", "从而将元素hi归入到子序列g中", "接下来如果新的末元素", "依然满足这样的条件", "我们就继续将它归入到g中", "直到某个时刻末元素hi", "不再满足这个条件", "也就是说此时的元素hi", "在数值上会严格的小于候选轴点", "没错严格小于候选轴点", "这不正是子序列l", "所对应的入选条件吗", "因此在这种情况下", "我们不妨将末元素hi", "转移致当前仍然空闲的单元lo中", "尽管因此单元lo将不再是空闲的", "但相应的hi", "所腾出的那个单元", "又会随即变成空闲的", "也就是说U所具有的不变性", "依然成立", "我们接下来的处理方向", "将与刚才恰好颠倒过来", "也就是说我们会进而去考察", "U的首元素", "只要这个元素在数值上不超过候选轴点", "我们就可以同样简明的", "令lo递增一个单位", "从而将这个首元素归入到子序列L中", "子序列L也会因此向后端拓展一个单元", "以下同理只要首元素在数值上", "依然不超过侯选轴点", "我们都会同样的将它归入到子序列L中", "这样的情况出现多少次", "子序列L就会向后拓展多少个单元", "子序列L的这种拓展", "会在什么时候终止呢", "没错", "也就是接下来的首元素lo", "在数值上不再是继续的", "不超过侯选轴点", "而这意味着什么呢", "没错", "这意味着此时的首元素lo", "完全符合子序列g的入选条件", "因此我们不妨将它转移到", "当前仍是空闲的那个单元hi中", "而此后呢尽管单元hi不再是空闲的", "但是随着刚才那个元素的移出", "单元lo又随即变成是空闲的了", "也就是说U的不变性依然成立", "当然在经过以上的拓展之后", "无论是子序列L还是子序列G", "在数值上也依然保持不变性", "至此整个算法经历了一个完整的周期", "经过这样的一个周期", "不仅不变性依然保持", "而且更重要的是", "我们可以注意到这里的单调性", "更准确的讲是子序列长度的单调性", "因为我们看到子序列L和G的长度", "都有所增加", "同时相应的子序列U的长度", "却在无形中缩短了", "因此当最终子序列U", "退化为只有一个单元时", "也就是霍尔爵士所设想的", "算法终止之前的临界状态", "到那个时候我们只需将侯选轴点", "植入于唯一的这个空闲单元", "它就会成为一个名副其实的轴点", "同时我们也完成了", "对原序列的一次快速划分", "整个partition算法也可顺利结束"]}, {"name": "01E-8\t 二分递归：Max2", "block_id": "c379adadf9514ca28c9aef9cc0524e41", "text": ["减而治之和分而治之", "都是我们算法设计中的", "强有力武器", "然而很遗憾", "我们前面所举的例子", "因为过于简单", "这两个方法的优势", "并没有得到体现", "当然在后续的", "章节的学习的过程中", "我们可以很清楚地看到这一点", "在此呢", "我们不妨再举一个例子", "来稍微看一下", "至少在算法复杂度的常系数方面", "在采用了分而治之的策略以后", "是有可能有所改进的", "我们来看这样一个问题", "叫Max2 意思就是说", "我们能否在一个", "给定的数组区间中", "找出最大的两个元素", "比如说 我们习惯认为", "x1是最大的 x2是次大的", "当然在退化的情况下", "它们两个可能本身就是相等的", "但是一般而言", "前者是不会小于后者的", "这里呢 采用了", "Python的习惯 也就是", "我们用lo和hi来表示", "这个有效的区间", "而且分别用方括号和圆括号", "来表示这个区间的", "左边界和右边界", "究竟是闭的 还是开的", "所以准确地讲", "这里包含的元素是lo", "如果还有足够长的话", "以及lo+1 lo+2", "一直到最后的一个", "并不是hi 而是hi-1", "所以 从图示来讲呢", "我们一般以后 会画成这样", "一个是lo 一直包括后面的", "lo+1 lo+2这种彩色的部分", "一直到最后这个", "你可以认为是hi－1", "这个hi呢", "并不是我们有效部分", "甚至它可能根本就不存在", "但是我们在算法设计", "和分析的时候呢", "不妨把它加在这", "后面会看到 这是我们", "常用的一种技巧和手段", "它可以使得我们思考更加简便", "也可以使得我们对程序的理解", "更加的准确和精炼", "那么这个算法本身并不难", "我们这里考量的呢", "是要求在整个这个算法过程中", "进行元素比较操作的次数", "就是比较大小操作的这样的次数", "需要尽可能的少", "比如说", "这就是一个最简明的算法", "我们看一下", "它大概是由三趟循环构成", "第一趟循环", "是x1从lo开始 不断地到hi", "逐个地扫描", "扫描什么呢？", "我们通过这样一个比较", "每次都对x1", "如果有必要做一个更新", "使得它总是保存着", "或者是指向当前", "最大的那个元素", "所以经过这样第一个循环之后", "我们说x1", "必然会在某个位置被发现", "比如说在这", "接下来呢", "后面的两轮循环", "实际上是分别在x1的", "所有的前驱中", "以及它的后缀中进行扫描", "从而用相同的策略找出", "在除了x1以外的", "那些元素中的最大值", "当然也就是全局的次大值", "我们可以看到这里的比较的方法", "都是一样的", "这里就不再赘述", "我们这里关心的是", "它所需要的", "刚才我们说的 比较次数", "多少次比较呢？", "我们可以关注这里头的小于号", "这就是比较操作", "它们的次数是多少呢？", "第一轮循环", "总共要比较n-1次", "后面两轮的长度 或长或短", "但是它们的总数很好判断出来", "其实就是在原来的", "n-1次比较中", "除去了已经被挑选出来的", "最大的元素x1", "所以应该是n-2", "所以我们累计起来", "比较操作的总数应该是（2n－3）", "而且这样一个算法", "无论输入是如何组成的", "它都需要做固定次数的循环", "确切地讲", "总数也是固定的（2n－3）", "好情况和最坏情况都是一样的", "那么能不能更少呢？", "我们来试图", "从一个方面进行改进", "我们的改进思路", "可以用这样一张图来表示", "同样是刚才的n个元素", "我们可以维护x1和x2两个指针", "分别指向当前最大和次大的元素", "我们整个的算法过程呢", "只是一趟扫描", "在经过了初始化之后", "在这个扫描过程中", "当扫到第i个元素的时候", "我们都首先", "将它和x2进行比较", "如果它比x2大", "再进而跟x1做比较", "这样的话 我们就有可能会用", "这个第i个元素来更新x2", "甚至更新x1", "在很多情况下", "我们希望第i个元素", "是小于x2的", "在这样的情况下", "x1和x2是保持不变的", "从而减少一次比较", "这样的一个过程", "我们可以用", "这段代码来具体的实现", "我们可以来看一下", "第一行 可以认为是一个初始化", "因为它首先将x1指向lo", "将x2指向lo+1", "也就是 最开始的前面两个元素", "并且对它们做一次比较判断", "如果它们按照刚才的", "那个约定是逆序的", "我们就将它们交换好了", "所以经过这样初始化以后", "可以确认x1和x2", "确实是当前已经扫描过的范围", "也就是前两个元素中的", "最大者和次大者", "而接下来呢 这样一个循环", "确实像刚才所说的那样", "会从第三个元素开始 逐一地递增", "每当指向一个元素Ai以后", "我们都首先将Ai拿出来", "和x2做比较", "而只有当它胜出了x2之后", "我们才会将x2更新为i", "并且进而用这个更新的数值去和", "最大的那个元素x1做比较", "并且在确实有必要的时候", "才将二者交换位置", "从而实现当前最大元素", "和次大元素的更新", "同样提醒同学们注意", "这里的两个隐藏的配对的", "else else语句", "它们虽然是看不见的", "但是它们的语义意味着什么", "希望同学们要能够了解", "好了 关于这个算法的正确性", "我们就分析到这", "接下来 我们最主要的是", "要来分析 这样的一个算法的性能", "或者复杂度 是否有所改进", "我们可以来看一下", "同样 如果只关注", "比较的次数的话", "这个比较是确定的 是一次", "可以暂时放在一边", "最重要的是", "这个循环中间的比较次数", "这个时候 循环的长度是n-2", "但是每步循环的内部", "所需执行的比较次数却是不定的", "这里有好和坏两种情况", "最好的情况只执行这一次", "就通过刚才所说的那个隐含的else", "我们可以认为它是一个continue", "直接又接着去执行下一次循环去了", "而在最坏的情况下呢", "有可能执行完了这一次", "并且命中了if这个条件", "从而进入到下一个if判断", "换句话说 在最坏的情况下", "我们每次循环", "需要进行地不是一次", "而是两次比较", "所以我们把这个归纳下来", "说 在最好的情况下", "除了最初的初始化", "需要一次比较之外", "剩下的（n－2）步", "各自只需要一次比较", "累计而言 总共不过n－1次比较", "我们说这个非常好", "比我们刚才的2n－3", "有很大的改进", "几乎少了一半", "但是我们刚才也说到了", "在最坏的情况下", "每次循环的内部 实际上", "需要执行两次比较", "我们可以看到", "这样一合计以后", "结果和刚才是完全一样的", "换而言之 就最坏情况而言", "这样的一个算法", "这样一个结果", "并没有实质的改进", "那么能否从实质上", "对这样的一个算法进行改进", "使得它即便在最坏的情况下", "也严格地少于2n－3次比较呢", "我们说可以", "为此我们就需要用到", "刚才介绍的分而治之的策略"]}, {"name": "01d-3: 循环", "block_id": "7db46e0f4fb04d5693a7b383af7ba31c", "text": ["借助上述关于级数的一些结论", "如何来具体分析代码段中所涉及的", "循环操作的复杂度呢？", "我们来看几个实例", "这是一个典型的二重循环", "外循环 控制变量i 是从0到n不断的累加", "内循环 控制变量j 从0到n不断的累加", "这是一个比较简单的二重循环", "具体的就体现为", "两个控制变量 相互之间没有耦合", "内循环 每一次执行的 都是长度为n的一个循环", "而外循环 要求内循环也反复地要迭代n趟", "从数值上看 它是n个n累加起来", "可以理解成 是一个常数的数列", "它的数值就是n平方", "当然 我们可以记下这种计算的结果", "但是 在今后要将这个", "变成自己的一个直观的反馈", "在这里 我们推荐给大家看这样一个图", "这是一个二维的矩形", "i 外循环的控制变量", "和j 也就是内循环的控制变量", "构成对应的两个维度", "这个矩形中的每一个点", "都对应于内部这个O（1）的 操作的一次执行", "而整个这个二重循环", "其实就等效于 这个矩形被填充的过程", "因此 我们可以建立这么样一个联系", "也就是 整个这段代码体的时间复杂度", "就等于这个矩形的面积", "从这个意义上讲 我们可以很清楚的看出来", "确实它是平方量级的", "我们再来看一个 略微有点变化的例子", "这个对应于一个算术级数", "我们刚刚讲过 作为算术级数", "它的总和 取决于它的末项的平方：O(n^2)", "我们也可以注意到 尽管在形式上", "相对于上例 有一些变化", "但是 就复杂度而言", "二者在渐近意义上讲 是完全相同的", "这样一个典型的循环模式", "也希望同学们 在头脑中形成这样一个图景", "使得你以后能够不仅很好的理解最终的结果", "甚至可以把它强记下来", "我们来看一下 整个这个过程", "依然是可以表述为一个二维图形", "外循环的控制变量i 依然是从0一直变化到n", "而内循环的控制变量j 将是像我们刚才所分析的那样", "呈一个算术级数 不断线性递增的规律", "所以总体而言", "刚才我们的结论依然是成立的", "这段代码所需要执行的时间", "应该等于这个被填充的三角形总体的面积", "从图形可以很清楚地看的出来", "相对于上例", "这个图形的面积 虽然只有一半", "但是 从渐近的阶次而言", "二者是完全相等 都是平方的量级", "下一个实例 是在上一个实例的基础上", "继续做了一些变化", "我们看到 内部循环的控制变量j", "增长的步长 将不再是简单的1", "而是一个更大的数 比如说两千左右", "这样的一个变化 对整体的算法复杂度", "在渐近的意义而言 又有多少影响呢？", "不难理解 整个这个过程", "对于内循环各趟的长度而言", "依然会构成一个算术级数", "我们固然可以沿用刚才的那些方法", "但是我们说 现在 也许你不必再这样做了", "因为 我们可以在头脑里参照刚才那种方法", "画出这样一个二维的图景 可以看到", "外部循环的控制变量i 依然是从0变化到n", "这就意味着 内循环必然执行n趟", "而每一趟的长度呢 不再是简单的从0到i", "因为 现在它的步长更大了", "等效于每一趟内循环的累计长度", "都相对于上面那个例子", "缩减到固定的2013分之一", "这也相当于把坐标轴做了这样一个压缩", "从这里 我们可以看的出来 这个面积", "确实依然可以用来度量整体这段代码的复杂度", "而这段的面积 虽然貌似缩小了", "但这只是一个常系数的缩小", "这个两千左右分之一 一个常系数", "并不足以影响整个这段代码的渐近时间复杂度", "它依然是n平方", "进一步 再来看这样一个例子", "我们看到 在以上实例的基础上做了一些调整", "那么 最重要的就是在这儿", "我们看到 外循环的控制变量i", "不再是按刚才那样 是线性的增长", "而是每次都做了一个左移移位的操作", "这等效于乘以2", "也就是说它每次都是加倍", "换而言之 内循环的长度i 将以2为倍数", "呈现出一个几何级数的形式", "当然 它的最大值是由n决定的", "我们固然 也可以用代数的形式 对它进行估算", "但是 我们也推荐大家", "用刚才那种直观的几何的方式", "把这样的一个复杂度的图景 给它绘制出来", "当它在你头脑里浮现的时候", "你已经知道 它的复杂度是多少了", "你可以很快的得出结论", "这个更为复杂一些的实例", "我们留给大家", "请大家在课后 对照这里所给的直观图示", "以及代数推导过程 对结果进行验证", "实际上 在我们的习题解析中", "还有更多的实例"]}, {"name": "09B-6 冲突", "block_id": "fc9ccf40098a4c8894155a051c49fda1", "text": ["再次回到刚才电话号码薄的实例", "散列表的长度依然 散列函数也保持不变", "于是 刚才的3个电话号码 也将保持同样的映射", "现在假设还同时需要存放第4个电话号码", "如果你的计算器在手边", "不妨将它关于90001做一个整除取模的运算", "你会发现什么呢", "是的 这个电话号码居然也会被映射到51304这个位置", "这类情况也称作散列冲突 hash collision", "也就是说2个不同的关键码", "有可能会被映射到同一个桶单元", "一山要容两虎 这是很难做到的", "当然 适当的将装填因子降低", "或者等效的说将散列表取得更长", "的确能够在一定程度上降低这种情况发生的概率", "但是很遗憾 这类冲突几乎是不能杜绝的", "对散列函数稍加观察 就不难发现这背后的原因", "因为所谓的散列函数", "可以理解为是将来自于更大的一个定义域R中的元素", "映射到相对而言远远更小的一个取值域", "形象的说 我们有很多很多的鸽子", "但是只有寥寥无几的笼子", "根据鸽巢原理 这种冲突必然是无法彻底避免", "当然 好消息是 只要策略和方法得当", "我们完全可以将此类冲突的概率控制在一个足够低的范围", "为此我们既要研究散列函数的设计方法", "更要研究在冲突已然发生时 如何有效的排解"]}, {"name": "07D3-3 删除：实现", "block_id": "556f47c8c6fa4eb7807f4219a6de0e23", "text": ["这里我们就给出AVL树节点删除算法", "一种可能的实现", "开始的几步只不过是BST常规的", "节点删除算法", "具体来说 我们要进行一次搜索", "并且不妨假设目标节点的确存在", "于是我们调用removeAt例程", "将这个节点物理地摘除掉", "接下来 我们依然是通过一个for循环", "遍历被删除节点的历代祖先", "请特别注意 我们的起点", "是被删除节点的父亲", "而不是像插入操作那样", "可以直接从它的祖父开始", "那么在整个遍历的过程中", "我们每发现一个失衡的祖先g", "都要对这个祖先做一轮适当地旋转调整", "而旋转所涉及到的三个节点依然是g", "以及它更高的那个孩子 也就是p", "以及再往下更高的那个孙子v", "而且无论是否失衡或者做过旋转调整", "我们都有必要更新这个祖先的高度", "可以看出 在最坏情况下", "的确需要做logn次", "你不妨将此前插入操作的控制逻辑", "与此处做一对比", "的确 这里没有可以", "提前终止遍历过程的窍门", "因为在最坏情况下", "我们的确需要无一遗漏地", "处理所有的各代祖先", "此后 我们才能够顺利地结束算法", "并且返回", "至此 你可能会发现", "对于这里的旋转操作", "我们还没有给出它的具体实现方法", "它的确是按照我们刚才所推荐的", "单旋和双旋那种方式来实现的吗？", "很有趣的是 答案是否定的"]}, {"name": "01b-2: \t问题规模", "block_id": "9140466faf3a432b851aa9dab8c90768", "text": ["我们这里所谓的测量或者测度", "实际上是算法分析的范畴", "具体来说 所谓的算法分析", "主要的有两个方面", "第一证明一个DSA是正确的", "当然这件事情不是那么简单", "其中用到的很多工具和方法", "都不是那么一目了然", "但是这并不是我们这门课", "最最主要的一个方面", "尽管我们会在后面结合具体的DSA", "给大家做一些具体的方法的介绍", "但是系统的学习", "将留待算法分析的相关理论里深入了解", "而在这里我们首先关注的是", "算法分析的另一个方面", "也就是我们前面所说过的性能方面", "这里如果倒过来看", "就是所谓的成本", "具体来说 分为两个部分", "也就是所谓的时间成本和空间成本", "正如我们在稍后会解释的一个原因", "在这里 我们不妨首先采用都比较公认", "和普遍应用的一个方法", "也就是暂时把空间忽略掉", "而把注意力更多的集中在时间方面", "所以我们的问题归纳一下的话就是", "如果我们关注一个DSA的时间成本", "我们应该如何来度量它", "如果这种度量", "涉及到两个或者多个DSA", "那么它们之间又该如何进行比较", "我们的思路 首先是从建模开始", "不妨定义这么样一个数学上的描述", "也就是说 如果我们采用", "名字叫A的这么样一个算法", "求解某一个问题具体的一个实例", "一个instance", "如果把它的名字叫作P的话", "那么它所需要的计算的时间成本", "就会被记成TA(P)", "比如说我们前面讲过的三等分问题", "可能我们用的那个算法", "就是欧几里得的尺规作图法", "那么 那个具体的实例呢", "也可能就是我们在前面的那章", "片子里所放的那个问题", "当然也可能很不一样", "那个输入也就是那条线段", "有可能是不同长度的", "也可能是不同的方向", "总而言之对任何一个具体的实例P", "我们都可以从数学上", "记下这么样一个量", "如果我们能够真正地获得", "这么样一个度量值的话", "当然我们就可以来对算法进行比较", "但是很遗憾 纯粹从数学上", "所做的这样一个定义", "其实意义不大", "为什么呢？", "因为同样一个问题", "它所能够出现的实例", "是非常非常非常多的", "通常情况下都是无数的", "所以我们不可能把目光注意到", "这样一个一个的具体实例上去", "任何一个具体的实例都存在", "以偏概全的问题", "它不可能使我们获得对这个问题", "所对应的这个算法一个总体的认识", "所以我们必须进行归纳和概括", "那么如何归纳和概括呢？", "数学给我们提供了常用的", "也是非常有效的方法", "就是划分等价类", "一般来说", "需要对任何一个问题无数的实例", "进行一定的粗分类", "并且就某一类谈它的计算成本", "那么怎么分类呢", "我们这里观察到", "大家普遍能接受的", "定性的一个结论", "虽然它不见得总是成立", "但是它大多数时候都是成立的", "也就是说任何一个问题", "它的计算成本", "实际上是和对应的", "那个实例的规模相关的", "一般来说还是正相关的", "我再强调一次", "这里说的都是往往一般", "并不是说所有的时候都这样", "在我们的习题集中", "大家可以比较轻易地构造出一些反例", "但这不影响我们这里基本的一个判断", "也就是说大体来说是这样的", "比如说回到前面三等分的那个问题", "如果我们把分成多少段 这个段数", "作为问题输入的规模", "那么应该很自然的能理解", "随着你要求分的段数越多", "这个问题的计算成本和代价", "也会相应的更高", "所以概括起来而言", "问题规模越接近", "它们所对应的计算成本", "也会相应地彼此接近", "而随着规模的增加", "计算成本通常也会呈上升的趋势"]}, {"name": "03E-4 \t实例", "block_id": "ac86b310f8624a688f124f5074b7d737", "text": ["为了获得更具体的感受", "我们不妨来看这个例子", "考察这样一个由七个元素", "比如说七张牌", "所构成的一个待排序的序列", "初始时 有序的前缀是一个空串", "不包含任何元素", "而无序的后缀包含所有的元素", "按照我们刚才所设计的算法流程", "我们每次都将注意力放在后缀的首元素", "在这个情况下 就是5上面", "这是我们所拿到的第一张牌", "所以简明地将它排放在这", "好 再接下来 我们的注意力依然放在", "未排序部分的首元素上 也就是2", "接下来 我们要在这个非空的", "有序序列中去进行查找", "并且发现它应该插在5的前面", "这也就是为什么", "这个元素会转移过来", "并且插入在与5紧临的位置上", "再接下来 注意力依然放在", "后缀的首元素上", "尽管这个时候无序后缀", "已经又缩短了一个单位", "经过一次查找 我们会发现", "应该将它插在", "紧临于5的右侧这个位置上", "好 接下来", "我们只不过是反复地故伎重演", "对于接下来的这个4", "我们会发现", "应该将它插入在这个位置上", "接下来 获得的这张六个点的牌", "它应该插在这个位置上", "再接下来 3", "将会被插在2和4之间", "而最后一张1将会直接插在2的左侧", "与选择排序类似", "整个算法也是一个减而治之的过程", "也就是说 待处理的无序后缀部分", "会随着迭代地进行", "呈线性速度地递减", "如果这是此消的话", "那么有序的部分", "就会随着迭代地进行", "不断地增加 也就是彼涨", "此消彼涨", "直到最终有序的部分覆盖整个序列"]}, {"name": "07D1-1 AVL=BBST", "block_id": "06015feb09d243debd0dcbdfde1240f8", "text": ["同学们好", "作为二叉搜索树这一章的最后一节", "我们来介绍最为经典的一种", "平衡二叉搜索树", "也就是AVL树", "回顾此前的几节", "我们首先介绍的是", "二叉查找树BST", "然而我们也看到", "尽管从同时兼顾高效的静态操作", "和动态操作的角度讲", "BST相对此前", "简单的向量和列表", "已经具有某种优势和潜质", "但是毕竟它并不能保证这一点", "其原因在于 它的高度", "无论是从平均情况 还是最坏情况", "都不能保证做到足够的低", "具体来说 也就是做到logn以下", "当然 在BST中的确存在", "这么一种特殊的类型", "也就是所谓的", "Complete Binary Tree", "完全二叉树", "它的高度可以达到严格的最小", "也就是logn", "然而 相对于整体的BST", "这类BST的数量极少", "而且我们如果需要将任何一棵树", "转化为一棵完全二叉树", "所需要的成本也太高", "也正因为此", "我们的建议是", "或许应该适当地放松", "所谓平衡的标准", "也就是说 我们只需考察某一类", "在渐近意义下不超过", "O(logn)高度的树即可", "而这样一类树", "也就是我们所说的", "平衡二叉搜索树", "Balanced Binary Search Tree", "BBST", "比如我们这一节将要介绍的AVL树", "就是在这种意义下的一种BBST", "以AVL树为代表的这些BBST", "首先并没有放弃渐近意义", "logn的复杂度底线", "同时正因为它已经适度地", "放松了平衡的标准", "所以通过精巧地设计", "它们都可以具有这样一种属性", "具体来说", "对于任何一棵这样意义下的BBST", "在其生命期内", "即便在某次操作之后", "它不再满足BBST的条件", "也就是说 游离到BBST这个范畴之外", "我们也可以通过上节所介绍的等价变换", "迅速地将其重新转化为", "一棵等价的BBST", "也就是说 可以通过极小的代价", "就使之重新归入BBST的范畴", "而这种极小的代价是多少呢？", "不出你的意料 依然是不超过logn", "令刚刚失衡的搜索树", "重新恢复为一棵BBST的过程", "也称作重平衡rebalance", "而对于包括AVL树在内的", "各种BBST而言", "其核心的技巧 无非两条", "第一 如何来界定一种", "适度的平衡标准", "其次 则是一整套重平衡的技巧和算法", "以下我们就以AVL树为例", "具体地讲解如何完成这两项任务"]}, {"name": "02C-6\t 查找", "block_id": "bcdb26ef4d8e495182acfb36c5ef57c1", "text": ["再来讨论查找操作", "也就是说，按照某种特定的条件", "从向量中找出特定的元素", "那么这里呢，我们需要", "澄清两个概念", "一个是叫作判等", "一个叫作比较", "也就是，对于任何的两个元素", "我们来判断它们是否是相等", "或者是来比较一下", "它们之间谁大谁小", "这两个操作", "并不是所有的类型都天然支持的", "所以这里我们做一个假设", "或者向量中元素的类型", "是基本类型", "或者向量元素这个类", "已经重载了", "对应的判等的操作符", "或者是比较的操作符", "我们说所谓的无序向量", "可以一般性地认为", "它只支持判等操作", "而对于有序向量", "要求要更高一点", "它还需要支持其中的元素", "能够相互比较大小", "无论如何", "我们先做这样的一个假设", "当然，在我们具体实现对应", "元素的类型的时候", "也要按照这样的一个假设", "来事先做好准备工作", "比如说，在我们稍后", "会介绍一种统一的", "Entry词条这么一类", "它本身就是满足这些要求的", "在这里呢，我们不妨把它", "作为一个假设", "无序向量的查找过程", "可以描述为这样一幅图", "如果查找的区间范围，视野范围", "是 lo 到 hi 的话", "我们就从 hi 出发", "逆向地、逐一地取出", "向量中的各个元素", "与目标元素进行比对", "如果不相等，就忽略它", "并且进而考察它的前驱", "所以整个的工作会", "亦步亦趋地", "逐个地遍历向量中的所有的元素", "那么经过这样一个", "逆向地扫描的过程", "我们很有可能在中间的某一步", "找到特定的", "我们所需要的那个目标", "也就是查找成功", "如果一直持续到最后", "我们在试图越过这个lo", "也就这个合法的", "最左侧的边界的时候", "就可以断定", "整个查找是失败的", "我们来看一下这样一个算法", "如何体现为具体的代码", "可以看到，其中最重要的是", "这个while循环", "如刚才所言，确实它是从hi出发", "每次都去通过减减", "指向下一个元素", "只要这个元素相对于lo", "也就是左边的界桩而言，还没有越界", "它就是一个当前视野内的", "合法元素", "我们就将它取出来", "并且与目标进行比较", "如果不相等，这个循环", "会持续地进行下去", "循环退出的条件是什么呢？", "既然这个地方是and", "所以反过来，or，有两种", "一种是我们确实在某一个位置", "发现了这样的元素", "这个叫作成功命中", "否则的话呢", "还有一种情况", "就是一直持续到最后", "我们实际上已经越过了", "这个 lo 的有效范围", "这个时候 hi", "经过足够多次减法之后", "已经明确地小于了 lo", "这个时候也同样需要", "返回对应的这个秩", "我们提醒大家注意", "无论是刚才所说的哪种情况", "这里返回的", "其实都是最终停止的那个位置", "有可能是合法的一个位置", "也可能是刚刚越过左边界的", "那个非法的位置", "无论如何都返回这个位置", "而具体判别是否成功呢", "我们把这个判断", "交给上层的调用者", "因为它通过这个秩是否是合法", "就可以判断查找是否成功", "而且，如果是成功的话", "这样一个秩", "将可以被高层的算法", "进一步地利用", "由此，我们也可以看出", "这个算法的复杂度", "有很大的变化空间", "在最好的情况下", "可能一进来", "在第一个元素位置上", "就顺利地命中", "所以这个时候呢", "复杂度，我们知道", "应该叫作常数O(1)", "但是在最坏的情况", "比如说一直持续到比较后", "才发现这个元素", "甚至一直持续到最终", "也没有发现我们的目标元素", "为此在这个过程中", "我们需要扫描的元素", "可能会与整个", "这个向量的规模相当", "也就是O(n)", "这样一种在最好和最坏情况下", "相差极其悬殊的算法", "叫作输入敏感的算法", "input-sensitive", "也就是说", "它的复杂度，具体是多少", "与输入时候数据的配置", "非常非常的相关", "紧密的相关"]}, {"name": "11a-3: \tADT", "block_id": "58aad75f02d7447d80d801180631bb8c", "text": ["从抽象数据类型的角度 串应该提供哪些功能接口呢", "首先 应该能够随时获取它的长度", "也就是当前串中所包含的字符总数", "另外 对于任意给定的秩 也需要能够直接返回对应的那个字符", "也就是说 只要i小于串长n 那么就应该返回其中秩为i的那个字符", "以下sub-string、prefix和suffix这三个接口的功能、语义 与我们刚才的定义完全吻合", "也就是分别取出串中对应的子串、前缀以及后缀", "此外还需要有一个串接的功能 也就是将某个指定的串T 作为后缀 与当前的字符串S连接起来", "再接下来 是判等接口", "它的功能 正对应于我们刚才所介绍的相等", "对于任意指定的字符串T 这个接口可以判断T是否与当前的字符串S彼此相等", "作为判等接口的一般化推广 索引接口indexOf具有更强的功能", "具体来说 对于任意指定的一个长度为m的字符串P", "这个接口可以告诉我们 在当前的字符串S中", "是否存在某个子串与P完全相等", "实际上 本章接下来的绝大部分篇幅", "都将用于讨论如何高效地实现这个接口"]}, {"name": " 12a1-5: 实例", "block_id": "369bc34fc7a841289c10e21d41e2ee43", "text": ["以下我们就来通过这个具体的实例", "体会partition算法的具体过程", "这里的待排序序列由十个元素构成", "在初始状态下子序列U", "也就是整个序列", "按照通常的习惯", "我们将首元素6取作待培养的侯选轴点", "在将它取出备份之后", "对应的单元在逻辑上", "可以视作为是空闲的", "因此接下来", "我们首先要尝试着去拓展子序列G", "虽然此时它还是空", "为此我们总是要考察U的末元素", "也就是此时的7", "我们发现这个元素的确大于侯选的轴点6", "因此它的确可以归入子序列G", "子序列G拥有了第一个元素", "而子序列U", "则相应的减少了一个元素", "然而接下来子序列G的拓展", "却不得不止步于新的末元素", "因为我们注意到", "这个元素的数值为1", "要严格的小于侯选轴点6", "还记得我们刚才为此设计的处理方法吗", "没错", "既然此时的这个末元素更小", "我们也就自然的可以将它归入到", "子序列L中", "为此我们只需将它转移至", "当前仍为空闲的首单元", "接下来在拥有了第一个元素之后", "子序列L也会试图继续向右拓展", "很幸运我们发现接下来的首元素3", "也要小于侯选轴点", "这就意味着我们同样可以将它归入到", "子序列L中", "然而接下来子序列L的拓展", "也会止步于新的首元素", "因为我们发现新的这个首元素", "在数值上是要大于侯选轴点", "请放心 对于这种情况我们的算法", "依然足以处理 难道不是吗", "既然这个元素在数值上要超过侯选轴点", "所以它也自然可以归入于子序列G中", "而此时紧邻于子序列G的左侧", "恰好有一个空闲单元", "因此接下来我们只需将这个更大的元素", "转移至这个空闲的单元", "如此子序列G向前拓展了一个单元", "而子序列U也相应的减少了一个单元", "同时在这个元素被转移之后", "腾出来的首单元", "又可继而被视作为一个空闲单元", "也就是说算法的不变性依然保持", "以下同理", "子序列G的拓展会止步于元素5b", "于是我们不妨就将这个元素转移至", "当前空闲的首单元处", "并转而去尝试拓展子序列L", "随后在依次加入了元素2和5a之后", "子序列L的拓展也会止步于元素9", "再一次的我们可以将这个元素转移至", "当前为空的末单元", "并在接下来转而去尝试拓展子序列G", "很遗憾我们的尝试依然终止于", "更小的元素4", "因此我们必须将它转移至", "当前为空的首单元", "至此整个子序列U的长度", "已经退化为1", "因此我们只需将侯选的元素6", "植入于其中", "这个元素", "也就成为了一个名副其实的轴点", "作为验证你可以逐个的检查一下", "在这个元素之前的所有元素", "的确都不比它大", "而在它之后的所有的元素", "也的确都不比它小"]}, {"name": "05A-5 路径+环路", "block_id": "603a354968164ee9863115f9e06b4d43", "text": ["以上我们只是从", "递归嵌套的角度定义了树", "这种定义虽然非常简明", "但是毕竟不是那么直观", "因为我们并没有看到树结构", "相对于一般的图结构而言", "在拓扑上到底有什么不同", "有什么特征", "那么接下来 我们将从连通性", "和无环性两个角度", "来揭示树结构的特性", "在包括树结构在内的任何一幅图中", "如果存在k+1个节点", "它们通过k条边依次相连", "就称它们构成了一条路径", "或者有的时候也叫通路", "比如在这样一幅图中", "从0点开始通过一条边可以通往1", "1再通过另一条边可以通往2", "2再通过一条边抵达3 诸如此类地", "如果这样一个连接关系", "可以一直持续到编号为k的顶点", "那么我们就称整个这样一个连接关系", "构成了一条通路", "而这样的一条通路", "也因此具有一个名为长度的指标", "具体来说 就是参与", "构成它的边的数目k", "请注意 在早期的一些文献中", "更多地会以顶点的数目", "作为长度度量的依据", "在这里 我们选用边的数目", "在后面我们将会看到", "这样一种定义方式", "相对而言 会使得我们的算法描述", "以及理解更加的简明", "当然 在所有路径中", "也有可能有这么样一种特殊的形式", "也就是其中的某个顶点", "一般而言 是为首的那个", "以及最末尾的那个", "很有可能彼此短路", "就是同一个顶点", "不难看出", "这个路径在拓扑上", "已经构成了一个循环", "我们也因此称之为环路loop"]}, {"name": "08XA3-5\tRR-2", "block_id": "01bf53b791884ee38f1fa86a0711c448", "text": ["再来看互补的另一种情况", "也就是叔父节点u不是黑的 而是红的", "同样的 不失一般性 这里也只给出了两种情况", "忽略掉对称的另两种情况", "那么当叔父节点u是红色的时候", "x和p所构成的双红缺陷又当如何解释呢", "我们同样借助提升变换", "将所有指向红色节点的虚边收缩起来", "于是从B树的角度来看 局部的这4个节点", "将合并为一个包含4个关键码的超级节点", "没错 4个关键码 对应于5个分支", "看出问题了？是的 无论是它 还是它", "这样的超级节点在4阶B树中都是非法的", "而用B树的语言来说 它们之所以非法", "是因为它们刚刚发生上溢", "因此 与其说我们是在红黑树中修复双红缺陷", "不如说是在对应的4阶B树中修复上溢缺陷", "这二者完全是一回事", "你应该还记得在B树中如何修复上溢", "是的 我们需要在出现问题节点中找到居中的那个关键码", "并且以它为界 将原先的大节点", "分裂为左右两个新的节点", "而居中分界的这个关键码 则应被取出来", "上移并插入到父节点中的适当位置", "这样一个转换的过程", "只不过是在B树中一个再平常不过的上溢缺陷修复过程罢了", "因此 非常易于理解", "而将此前的红黑树 转换为对应的4阶B树呢", "从提升变换的角度来看 也非常好理解", "同样的 从变换之后的B树 到变换之后的红黑树", "从提升变换的角度 也非常易于理解", "总而言之 这样一个迂回的过程", "要比我们试图直接去理解红黑树的调整过程反过来更为简明", "概括来说 从红黑树的角度 对于这种情况", "我们只需将节点p由红转黑 同时节点g由黑转红", "而从B树的角度来看呢", "则等效于对一个刚刚发生上溢的节点实施一次分裂操作", "同时 居中的关键码被提升并加入到父节点之后将转为红色", "请注意 经过如此调整之后", "尽管上溢的这个节点的确得到了修复", "然而故事未必就此结束 我们注意到在这里", "居中的关键码将会被提升一层并加入至父节点中", "所以到现在为止的效果", "也可以等同的视作为在这个父节点中", "插入了一个新的关键码", "当然在g的左或右 至少应该有一个黑色的关键码", "但遗憾的是 也有可能有一个红色的邻居", "而后一种情况 则会导致在此处再次发生双红缺陷", "不过好消息是 即便在这个位置上会再次出现双红缺陷", "也不外乎是我们以上所介绍的两种情况", "因此我们也大可套用以上所介绍的方法 来解决新的问题", "而另一个好消息是 即便会出现这样的问题", "问题所发生的位置 也会逐层的上升", "因此 整个双红缺陷向上蔓延的过程迟早会终止", "充其量不会高于树根", "最后需要强调的一点是", "尽管这一调整过程 从B树的角度来看", "的确发生了拓扑结构的变化", "但是从红黑树的角度来看", "除了若干节点的颜色会发生变化", "全树的拓扑连接关系并没有任何变化", "也就是说 尽管重染色操作的次数可能会高达logn", "但拓扑结构的变化 却依然控制在常数的范围"]}, {"name": "05B-3 孩子", "block_id": "6dceda10e91146ab83a3e20f3f1ee3c0", "text": ["既然这里矛盾的焦点在于", "如何找到每一个节点的孩子", "那么我们不妨对于任何一个节点", "都将它的孩子汇聚起来", "构成一个更小的数据集", "顺着这种思路", "我们可以大致采用这种可行的方法", "也就是将所有的节点", "汇聚为一个序列 像刚才那样", "不同的在于这里", "还需要为每一个节点", "准备一个名为children的引用", "而这个引用所指向的 就是", "我们刚才所说的 由它的所有的孩子", "构成的一个小的数据集", "当然 如果你愿意的话", "可以将每一个这样的小的数据集", "无论是它", "还是它", "分别地组织为", "一个我们此前已经熟知的序列", "比如说向量 或者像这个图示上", "所画的那样是列表", "比如对于R这个节点而言", "它所对应的孩子", "应该按照这里的记录是0 1 2", "那么0 1 2是什么意思呢？", "我们可以猜出来 就应该是", "它的孩子在整个这个序列中的秩", "具体来说 也就是0对应于A", "1对应于B和2对应于C", "所以0 1 2实际上恰好对应的", "就是R的三个孩子A B C", "同理 对于F这个节点来说", "它的孩子记录项对应的是7 8 9", "查表可以看出 其实也就是7对应的是G", "8对应的是H和9对应的是K", "换而言之 F这个节点的孩子", "应该恰好就像原来这棵树上", "是G H和K", "由此我们可见", "每当我们需要查找某一个节点的孩子", "现在我们只需要从对应的这个节点", "比如说F所对应的children这个引用出发", "找到对应的那个数据集", "并且在比如说", "这样的一个列表中 依次地查找", "直到找到所需要的那个孩子", "由此可见", "无论是从空间的角度", "还是从时间的角度", "任何一个节点所需要的计算量", "都线性正比于它的孩子的数目", "也就是它的度数", "那么这样的一个实现效率", "还是可以接受的", "然而另一方面的问题又在于", "我们现在自然解决了向下的查找问题", "而刚才父节点表示法", "向上的查找优势却丧失殆尽", "不难发现 为了查找某一个节点的父亲", "我们又不得不去遍历整个线性序列", "并且逐一地翻看它所对应的孩子记录", "在最坏的情况下", "我们有可能需要到最后一个节点的", "最后一个孩子处才命中自己", "从而验证自己是对应的", "这个节点的孩子"]}, {"name": "09B-1 从服务到电话", "block_id": "86c18cd6ff2c42adb9d6809d0d64ce0a", "text": ["同学们好 从今天开始我们进入到新的一章 词典", "我们将学习实现词典adt的重要技术 也就是散列", "我们将看到散列实际上并不是一种简单的技术", "从某种意义上讲 它甚至是一种思想", "是的 散列是一种赖以高效组织数据", "并实现相关算法的重要思想", "接下来我们就会看到 在这种思想背后的原理", "是多么的直观和简单", "我们的故事要从服务电话说起", "当你需要获得某个公司或者部门的服务", "你应该如何通过电话来找到他们呢", "查电话簿 没错这是一种司空见惯的方法", "不过如果你手头没有电话簿 或者电话簿太厚", "以至于你没有足够的耐心去查阅", "有当如何呢", "作为一个公司 应该明白", "有相当多的客户都是因为这种纠结而流失掉的", "因此反过来一家优秀的公司", "应该为它的服务取一个更加便于记忆的电话号码", "对此 你有什么建议？", "你或许会说 那不妨就取8个8 或者8个6", "或者12345678", "这些解决方案尽管也勉强可行", "但是如果从突出公司和服务个性的角度来看", "这类方法都是不够的", "下面我们不妨来看", "更有经验的公司是如何巧妙的解决这个问题的", "比如你如果需要致电ibm公司", "就它的服务或产品进行咨询 那么你就可以拨打这个电话", "没错 就是这个电话 或者这个电话", "没错 就是这个和这个电话", "如果你是第一次在这些公司的首页上看到这类电话", "你或许会有所质疑 因为它并不像你直观理解的那样", "给出了一个完全由数字组成的电话号码", "但是我想你很快就会习惯并且喜欢这种方式", "并且由此对这类公司留下深刻而友好的印象", "实际上你只要掏出你的电话", "留意一下键盘", "或许在此之前 对于每一个键你只留意了其中的阿拉伯数字", "而实际上呢 当下大部分的键盘都是这种形式", "其中的每个键上 除了有一个阿拉伯数字", "同时还拥有若干个英文字母", "我们可以理解为 这样的一个键既可能对应于一个数字", "也可能同时对应于若干个字母", "也就是说 由数字和字母混搭构成的电话号码也是可行的", "比如这里的ibm 4you对应的拨号过程就是ibm 4you", "请留意体会这种方式的巧妙之处"]}, {"name": "04C4−6A\t 实例A", "block_id": "a55ff5ea8b8d4085bfcdd0b9fd9d451e", "text": ["好，让我们来通过一个实例", "具体了解如何利用栈结构", "实现中缀表达式的求值", "这是我们待求值的中缀表达式", "在我们算法中", "需要用到一个操作符栈", "以及一个操作数栈", "而且如我们所约定的", "在最开始的时候", "我们首先要将表达式的结束字符\\0", "在这里以＄表示", "首先铺垫在操作符栈中", "以下只不过是一个", "线性扫描的迭代过程", "我们首先将注意力放在", "第一个字符，也就是左括号上", "作为一个操作符", "它需要与操作符栈的", "当前栈顶\\0进行比较", "查阅优先级表会发现", "是一个小于号", "这等效于左括号优先级比\\0要更高", "因此按照算法的流程，我们应该将", "这个优先级更高的操作符", "推入操作符栈中", "暂时缓存起来，也就是这样", "此后我们随即", "将注意力转向下一个字符", "我们看到这是一个操作数", "这种处理我们讲过是非常简明的", "也就是直接令这个操作数", "进到操作数栈中去", "对应的结果应该是这样", "同样地，接下来", "把注意力放到下一个字符", "运算符加号", "同样地，它要与当前的栈顶", "也就是左括号比较优先级", "如果你手头有那张优先级表的话", "会发现依然是一个小于号", "所以我们的处理手法是一样的", "再一次令当前的这个操作符", "进到操作符栈中去", "做一次push操作", "同时将注意力转向下一个字符", "又是一个操作数", "所以依然非常简明，将它", "push到它所对应的操作数栈中去", "也就是变成这样", "同样，我们将注意力转向下一个字符", "这是一个运算符", "在我们这里约定", "它代表的是乘方", "同样，查阅优先级表", "乘方相对于当前的栈顶加法", "优先级更高", "所以依然是简明的push操作", "接下来，我们关注的下一个字符", "依然是一个操作数", "同样，让它进到操作数栈中去", "下一个字符是阶乘运算符", "同样，经过查表会发现", "阶乘的优先级更高", "所以还是我们刚才", "所说的那种处理手法", "也就是令新遇到的这个", "阶乘运算符入栈", "好，再接下来，我们又碰到一个", "运算符减号", "查表会发现", "第一次碰到了另一种情况", "也就是大于号", "换而言之，这个时候是反过来", "栈顶运算符的优先级", "相对于当前这个运算符要更高", "我们讲过，这意味着，此前缓存在栈中的", "这个栈顶运算符已经等到了", "它可以执行的时机", "因此阶乘号将被弹出，3也将被弹出", "而它们的运算结果6", "将重新回到栈中", "结果应该是这样", "请注意，这个时候我们的关注力", "依然在刚才仍未处理完的", "减法运算符上", "这个当前的减法运算符", "依然要与新的栈顶运算符", "也就是乘方号，继续比较优先级的次序", "那么我们查表会发现", "依然是一个刚才那样的大于号", "同样，这意味着此前缓存", "和保留起来的这个乘方运算符，也等到了", "它可以执行的时机", "因此接下来，它也需要从操作数栈中", "去索取对应数目，也就是两个运算数", "并且执行乘方运算", "所以接下来，应该是乘方号出栈", "6和2也会出栈", "而它们运算的结果", "2的6次方将会重新纳入到", "操作数栈中", "注意，我们依然停留在", "仍未处理完毕的减法运算符上", "因此接下来，继续将它", "与新栈顶运算符加法", "进行优先级的比较", "再一次地查表，同样是一个大于号", "也就是说，此前所缓存起来的加法运算", "已经等到了应该执行的时机", "因此加法运算符将会出栈", "而同时，操作数栈中的", "64和1也会相继出栈", "并且执行加法运算", "它们的和，也就是65，将会重新入栈", "也就是这样", "我们注意到关注点仍然停留在减法上", "因此再一次地，我们仍需要", "将减法运算符", "与栈顶的左括号运算符", "进行优先级的比较", "我们会发现它又重新回到了", "小于的情况", "也就是说，这等效于", "减法运算符的优先级更高", "因此按照算法设计的流程", "这个时候应该令", "当前的这个运算符入栈", "转入这样的一个状态", "接下来，我们关注的位置处", "又重新是一个操作数", "这是非常简明的一种情况", "我们说过，所有的操作数遇到之后", "都是直接令它进入到操作数栈中去", "因此我们接下来会转入到", "这样一个状态"]}, {"name": "11c6-4\t后车之鉴", "block_id": "f6f3e7e042ee4d27856f982ce245582b", "text": ["基于以上分析和结论", "我们不难得出改进之后的next表构造算法", "新的这个版本与此前的版本几乎完全一致", "实质的差别仅在于if分支中的这个赋值语句", "你应该记得 在这个分支 我们此前总是简单地用t 直接地赋予next表的下一项", "而在这里 则附加上了一个新的条件", "可以看到 在新的版本中", "只有在替换的字符与原先的字符本身不等的情况下", "我们才沿用以前的方式进行赋值", "而反过来 如果替换的字符与此前那个字符依然相等", "我们则要改用另一种方法", "具体来说 也就是用更早前所算出的t所对应的next表项", "来赋予下一个next表项", "各中的原因 你应该能够体会", "是的 正如我们此前所举的那个例子", "此时的P[t]与P[j]都是相同的鸡蛋", "因此 如果只是简单地进行赋值", "那么在后续的匹配过程中", "就难免会一错再错"]}, {"name": "09B-5 散列", "block_id": "0c2ec1be719f4cf282756265ff3d3323", "text": ["再次回到清华大学电话簿的那个实例", "假设这就是我们所使用的散列表", "可以看到散列表的长度 在这里取做90001", "这里的取值的确符合我们的设计原理", "也就是一方面要在数量级上远远的小于10的8次方", "同时相对于我们实际需要存放的记录数", "也就是大致25K 表长既能够足够大", "同时又在数量级上保持同阶", "经过这样的压缩 空间利用率将上升至至少为1/4", "再来看散列函数", "对于任何一个关键码", "该散列函数都将它映射为它相对于表长M的整数模余", "也就是说任何一个8位的电话号码", "都将经过相对于90001的乘除被映射至相应的余数", "我们来看几个具体的实例", "你不妨先掏出计算器 以备待会的验算之需", "首先来看中间这个电话号码", "根据它 在经过对90001的整数取模", "就可以得到散列表中的一个桶", "而这个桶呢 则正确的指向了机主所对应的词条", "下边这个电话号码也是如此", "根据它经过对90001的取模 同样可以找到桶单元", "而根据这个桶单元 也同样可以找到机主所对应的词条记录", "事实上 只要这个电话号码的确属于清华大学", "按照这样的一个算法 的确都可以获得相应的机主信息", "至此我们已经基本上圆满的实现了这个应用需求", "难道不是吗", "从每一个电话号码 到对应的机主信息", "只需要常数的时间", "而空间效率呢 按照刚才的估算也足以令人满意", "特别的 对于散列表而言", "其空间效率主要取决于N与M的比值", "这一比值 也称作装填因子 load factor", "通常也简记作λ", "是的就目前而言 我们的解决方法的确几乎完美", "然而这里的故事依然没有结束"]}, {"name": "08XA4-3\t双黑缺陷", "block_id": "4000c08115534128acbaf191557e527e", "text": ["然而遗憾的是 有可能被删除的节点", "以及它的替代者在此前都是黑色的", "这种情况我们也称之为双黑 double-black", "此时对于这两个节点所属的那条路径而言", "黑长度必然会缩减一个单位", "从而必然违背红黑树的第四条规则", "而且不幸的是 上述简明的方法 也不再有效", "再给出新的方法之前", "我们不妨从另一个角度来体会一下", "问题究竟出在哪", "什么角度呢 没错 B树", "可以看到 如果x和r都是黑色的", "那么在对应的4阶B树中 x将独自成为一个超级节点", "于是在唯一的这个关键码被删除之后", "这个节点也就自然的发生了下溢", "因此 以下我们的调整算法", "与其说是在红黑树中修复双黑缺陷", "不如说是在B树中修复下溢缺陷", "如此 只需借助此前B树的下溢修复算法", "就可以得到红黑树双黑修复的相应算法", "为此我们需要考察两个节点", "首先是删除之后 节点r的父亲p", "当然 在删除之前p也就是x的父亲", "此外我们还需要在原树中考察节点r的兄弟", "我们称之为s", "以下我们就分4种情况分别处置"]}, {"name": "08xa2-7: \t接口定义", "block_id": "77da00a4923c444d92eda6785e432aae", "text": ["以下 我们就借助C++语言来给出红黑树的接口定义", "就外部的公共操作接口而言", "依然无非是静态的查找操作以及动态的插入和删除操作", "其中红黑树的查找与常规BST的查找完全一样", "因此这个接口可以直接沿用", "而为了保证能够始终遵守定义规则", "红黑树的插入和删除过程", "往往还需要进行拓扑上的连接关系调整", "因此这两个动态接口都需要做适当的重写", "而为了帮助实现相应的拓扑结构调整", "这里还提供了两个内部的操作接口", "而这两个内部接口所使用的算法", "也正是我们接下来将要讨论的重点", "当然 红黑树也需要动态记录并维护自己的高度信息", "需要指出的是 对于红黑树而言", "这里的高度所指的并不是常规意义下的高度 而是黑高度", "相应的 我们也需要重写高度更新的算法", "具体的 也需要从左孩子和右孩子中", "取出更大的那个高度 并以此作为基础", "而只有在当前节点为黑时", "它的高度才需要在此前的基础上再累进一个单位"]}, {"name": "07B1-5 查找：语义", "block_id": "5bb40d9f39864a55963181484196b68f", "text": ["最后我们再来考察这里的hot参数", "作为一个引用型的参数", "它总是在这个算法被首次调用时", "统一地初始化为", "初值为NULL的内部变量_hot", "因此在随后算法的执行过程中", "对这个参数的修改", "实质上也就是对内部变量_hot的修改", "我们可以看到 对_hot的修改", "总是发生在每一次试图深入递归之前", "具体来说 _hot会记下", "此前刚刚接受访问的那个非空的节点", "那么总体而言 _hot最终将会指向谁呢？", "它所对应的语义又是什么呢？", "为便于search接口更加简洁", "也更加准确地被其它的算法使用", "有必要对它的接口语义予以明确的定义", "这体现在两个方面", "首先这个接口的返回值在不同的情况下", "分别对应于什么", "其次经过这个算法的反复更新", "hot变量的最终取值在各种情况下", "又对应于什么", "这些语义可以通过这个图来表示", "实际上 也无非就是查找成功", "以及查找失败 这两种情况", "我们知道 返回值本身也是引用类型的", "这里约定在查找成功时返回的引用", "将指向一个真实存在的节点", "而且这个节点恰好与目标关键码相等", "而在查找失败时 返回的引用", "将指向一个空节点", "这里所说的空节点", "是指首先它的数值为NULL", "但正因为它是一个引用", "更确切地讲", "此时所返回的那个数值为NULL的引用", "实际上就是我们在整个查找的过程中", "最后一步所试图转入的", "那个数值为空的分支", "它指向查找路径末端节点", "当前仍不存在的某一个孩子", "而_hot呢 在查找成功时 它将指向", "命中返回节点的父亲", "而在失败的时候 它将指向", "我们在整个查找过程中", "最后访问的一个真实存在的节点", "那么如何从语义上", "将这两种情况下的返回值", "以及_hot变量 统一起来呢？", "一种简明的方法就是引入哨兵", "是的 在查找失败的时候", "我们可以在末端节点试图转向的", "那个数值当前为空的引用处", "增加一个假想的哨兵", "而且可以进一步地假想着将它的关键码", "就设置为我们查找的目标", "当然不难验证 如果此时我们的确", "在这个位置增加一个这样的真实的节点", "那么全树依然将是一棵合法的BST", "而更有意义的是", "在引入了这样一个假想的哨兵之后", "我们就可以从语义上", "将两种情况统一起来", "具体来说也就是", "无论成功与否 我们的返回值", "总是等效地指向命中节点", "尽管在失败的情况下", "这个命中的节点只是假想的", "而非真实存在的", "而在如此引入了一个假想的哨兵之后", "_hot也可以认为总是指向", "命中节点的父亲", "那么基于这样一个语义明确的search接口", "插入以及删除等算法", "又当如何具体实现呢？"]}, {"name": "03E-6\t 性能分析", "block_id": "5346a848f366456d82a5bd3ccce9310e", "text": ["那么以上insertion sort算法的性能如何呢？", "我们来对此做一分析", "首先来看一种最好的情况", "这里我们已经把场景给设计好了", "也就是说 如果比作是抓牌的过程的话", "那么所有的牌都是按照完全", "或者至少是几乎有序的次序抵达的", "因此 你的理牌过程大概是这样的", "最开始 来的是一张最小的牌", "接下来的第二张牌呢", "至少不会比它更小", "第三张也是如此 第四张、第五张", "以及后边若干张 也几乎都是这样", "为什么说这是最好的情况呢？", "因为每当有一张新牌到达", "我们向前搜索的过程", "只需做一次比较", "即可确定应该将这张新的牌", "插入于当前的最后位置", "一次比较 零次交换", "每张牌所需要的时间都是一个单位", "累计而言 当然也就是线性了", "看好了 线性", "为什么需要大家看好呢？", "因为我们要和此前所讲的", "selection sort 做对比", "大家应该还记得", "那个算法的复杂度是n平方", "而且是θ(n平方) 它的意思是说", "没有最好情况 当然也没有最坏情况", "在所有的情况下", "它都需要n的平方这么多时间", "这又是插入排序和选择排序的一大区别", "当然相应地 也有最坏的情况", "不难设想 这种场景就是", "所有的牌完全按照颠倒的次序", "也就是逆序来给出", "所以即便在任何时候", "你已经将手里的牌从小到大", "排列成了一个有序的部分", "却保不齐下面来的一张牌", "会比此前的所有的牌都更小", "以致于你必须逐个经过比对之后", "才能够确定应该将它插入在最前方的位置", "这样为了插入每一张牌", "我们所需要经过的搜索", "都需要走过漫漫的一条长路", "它的长度就是当前你迭代的次数所界定的", "每个元素都需要这样", "整体构成一个算术级数", "我们讲过 它的总和应该又回到了n的平方", "这里有一个插曲", "有的同学可能会敏锐地注意到", "噢 你这里为什么要这样", "亦步亦趋地进行查找呢？", "你没有注意到吗？", "这个地方已经是有序了的", "在一个有序的序列中进行查找", "你为什么不采用", "我们此前所说的二分查找呢？", "那么我的回答是", "噢 那对不起 如果是那样的话", "那我们就不能用列表了", "你或许会说", "那我们就用Vector呗", "啊 事实上也只有Vector", "能够支持这种call-by-rank的方式了", "嗯 没错", "但是我说 这依然存在问题", "你如果想深入思考", "不妨在这暂停一下", "一、二、三", "是的 我想聪明的你", "已经发现了问题所在", "的确 如果我们改用向量", "来组织整个序列", "包括这个有序的序列", "固然可以将这样一个查找的过程加快", "具体来说 只需logn的时间", "或者说logn次比较", "就可以确定一个位置", "即便在最坏的情况下", "我们可以将原来的线性次比较", "减少为logn次", "但是很遗憾", "在此后", "我们为了将新的这个元素", "真正地从物理上插入于这样的一个序列", "注意 这个时候已经是一个向量", "我们不得不将它所有的后继", "也就是原来整个这个序列", "整体地向后移动一个单位", "这意味着什么呢？", "这意味着我们的交换操作次数", "将变成O(n)", "也就是说 原来只需一次交换", "现在却需要进行O(n)次", "采用列表结构", "此前两项累计是O(n)", "以致整体是O(n平方)", "而现在呢 采用新方案", "虽然比较的次数能够降至logn", "但是总体所花的时间却依然是n", "所以就最坏情况而言", "改用向量结构", "对于这种算法的改进 于事无补"]}, {"name": "03E-3 \t对比", "block_id": "229ca888a7894c84b74d3c7490ac426a", "text": ["如果你还能回想起", "我们上一节所介绍的selection sort", "或许你会觉得insertion sort", "和它完全是一码事情", "然而我要告诉你的是", "它们是截然不同的两种算法", "我们在后面会看得更仔细", "在这里 我们不妨首先来看一下", "二者在整体策略上的区别", "第一个区别", "这里有序部分和无序部分的次序左右颠倒", "在selection sort中 有序部分是后缀", "而无序的部分才是前缀", "当然 这还不是什么最重要的区别", "回忆一下 在选择排序中", "我们不仅将整个序列分成", "有序的后缀部分", "以及无序的前缀部分", "而且始终保持一个不变性 也就是", "无序的前缀部分中所有的元素", "都不能够超过有序部分的最小值", "换句话说 从取值上看", "它们应该被包围在", "这样的一个绿色矩形中", "现在对称地 反观插入排序", "我们会发现 这里并没有做类似的限定", "不存在这样一个限制框", "也就是说 无序部分元素的取值", "可以任意 可能小于有序部分", "也可能大于", "这就像发牌的过程一样", "有可能你接下来拿到的是最小的牌", "也可能是一张猫", "后面的牌将会有多大", "与你此前所拿到的牌 没有任何关系"]}, {"name": "01XC-2: Fib()：递推方程", "block_id": "49b3d61ff7814811b069251f0081462f", "text": ["我们首先采用递推分析的方法", "也就是说 将整个计算的复杂度", "整理表达为这样一个递推关系", "我们来解读一下", "如果说计算", "第n项Fibonacci数的成本是T（n）", "那么按照刚才的算法", "就相当于 首先花T（n-1）的时间", "计算出第n-1项", "再花T（n-2）的时间", "计算出第n-2项", "最后再花一个O(1)的时间", "干什么呢？", "其实就对应于这个加法", "也就是说 我们要在O(1)的时间内", "将前两个Fibonacci数合并", "得到新的这个Fibonacci数", "所以这个递推式", "是非常自然的", "那么当然也包括它的边界条件", "也就是 对于第0项和第1项", "分别地都是O(1)的时间直接返回", "为了求解这样一个递推式", "我们不妨令S（n）等于", "T（n）再加上1以后 除二", "那么相应的S（0）以及S（1）", "作为边界条件 也可以换算过来", "我们注意到非常巧合", "S（0）恰好是等于", "Fibonacci数的第一项", "而S的第一项", "恰好等于Fibonacci数的第二项", "嗯？我们大概看出点儿端倪来了", "因为更一般地", "根据上面的定义", "我们也不难验证", "S（n）也应该是等于", "S的第n-1项", "和S的第n-2项之和", "从形式上看 S（n）和", "Fibonacci数是完全一样的", "那么根据边界条件", "我们可以综合起来理解为", "S（n）实际上就是", "Fibonacci数往后倒推了一项", "基于这样的理解", "我们不难得出结论", "也就是说 S的第n项", "和Fibonacci数的第n+1项", "实际上就是一回事", "那么Fibonacci数的第n+1项", "或者一般讲 第n项的通项公式", "大家在很多课程里", "应该都已经学过了", "从渐近的复杂度的意义上讲", "它大致主体的 是这个Φ的n次方", "而Φ是多少呢？", "就是那个黄金分割数", "具体的就是（1+√5）/2", "大致是1.618", "所以由此我们可以得到一个结论", "原来的我们所需要计算的T（n）", "根据刚才S 换算回去", "无非就是大致两倍的S（n）而已", "在数量级上 并不会引起什么变化", "换而言之", "我们计算Fibonacci数的递归算法", "它的时间成本", "本身也呈现出一个", "Fibonacci数的形式", "它的量级也是Φ的n次方", "我们说Φ虽然比2略小一点儿", "但是它严格地比1大", "所以依然是一个指数", "没错 我们这里又碰到了指数"]}, {"name": "12c1-3: \t循秩访问", "block_id": "387464e5f05d4647aece10b365792b73", "text": ["通过刚才的实例", "相信你对希尔排序的整个过程", "已经有了足够的了解", "那么这样的一个计算过程", "又当如何实现呢", "实际上如果需要真正的实现", "这样一个完整的计算过程", "我们还有一些技术细节需要讨论", "比如我们首先碰到的一个技术问题就是", "矩阵的重排", "难道为此我们需要真的去引入一个二维的", "向量结构吗", "其实大可不必", "如果输入序列本来就是以", "一维向量的形式给出的", "那么我们只需在这样一个", "一维向量上进行操作就足够了", "我们注意到在每一步", "具体的迭代中矩阵当前的宽度", "都可以视作为一个常数W", "因此按照这幅图所示的方式", "我们只需从逻辑上而不是物理上", "完成矩阵的重排就够了", "因为对于任何一个特定的矩阵宽度", "在这个矩阵中的任何一个元素", "在原序列中所对应的址", "都是可以直接换算出来的", "准确的讲在这个矩阵中", "位于第K行第J列的元素", "其在原序列中所对应的址无非就是", "i再加上K乘以W", "因此尽管刚才以及接下来", "我们在讲解时都倾向于", "使用一个二维矩阵", "但请你务必牢牢记住", "在物理上它始终都无非就是那个", "输入的一维向量而已", "而我们之所以能够做到这样", "这要归功于向量寻址访问的特性"]}, {"name": "02D5-4\t 字宽折半", "block_id": "98510e58cf1d4caf84a8c2337dbeb063", "text": ["对于这个例子而言", "我们同样可以来估算", "如果向量的长度", "或者这个区间的宽度是n的话", "考虑这个n", "按照二进制打印出来以后的位宽", "那么是多少呢", "我们知道 就是log", "这里隐含的2为底 logn", "那么每一次将它变为根号n", "从数值上讲 是变为二次跟", "从二进制的打印宽度来看", "我们说变成了什么呢", "没错 其实就是变成了", "1/2的原来那么多宽度", "换而言之 每一次开方", "从数值上讲 虽然是取二次跟", "但是从它的宽度来讲", "其实同步的是使宽度变成了原来的1/2", "没错 变成了它的1/2", "所以换而言之", "这个方向是根号再套根号", "一直套 套下去", "而这里呢 实际上就相当于", "对它的宽度 不断的取1/2", "再取1/2一直下去", "这样的过程 从n的数位宽度来说", "是一个不断折半的过程", "所以从这里我们也可以看出来", "我们此前的所谓的二分查找", "如果是对的n的数值每次折半的话", "那么这里的插值查找", "实际上就是对", "n的二进制位宽度来做二分查找", "此前我们讲过", "二分查找所需要的迭代次数", "是与它的初始值呈一个对数关系的", "所以那个时候我们会得到logn", "而这里的迭代 依然总共需要log步", "只不过它的参数", "也就是这个log里头的这个参数", "取得是这个最初的初值", "也就是logn", "所以这样的话", "我们很形象的 很直观的就可以解释", "为什么如果每次是开根号的话", "我们最终需要的步数是loglogn", "从今以后 也许你应该", "学会忘掉这些复杂的", "虽然是精确的数学", "而改用这种宏观的", "大趋势的 把握本质的习惯"]}, {"name": "04D-3\t 实现", "block_id": "4ad468ebb249412eb08e807f134bd48d", "text": ["我们这里给出一种实现方法", "好消息是 并不需要从轮子开始造起", "与栈同理", "既然队列也是属于序列", "自然可以利用我们此前已经实现的", "最基本的向量以及列表结构", "直接派生而得", "比如这里选用列表来实现队列", "具体的代码如下", "可以看到 所谓的Queue", "也就是队列模板类", "的确是以public的形式", "继承自我们此前已经实现完善的list", "所以因此同样地 一些标准接口", "像size()或者是empty()等等", "都可以直接沿用", "我们不必再重写了", "其实某种意义上而言", "插入和删除等动态操作也是如此", "只不过因为这里操作位置受限", "而且名字也进行了更换", "所以我们有必要重新定义一下", "而且定义的方法非常的简明", "我们可以看到 所谓的enqueue", "其实就是将当前的元素", "作为末元素插入", "与其说是队列", "不如说是列表当中", "如果你有点淡忘了", "建议你去温习一下insertAsLast这个接口", "从功能上看", "如果我们是通过一个列表来模拟队列的话", "我们这里的习惯", "将顶端认为是前端front", "相应地 将底端取作尾端", "那么insertAsLast就是将一个新的元素", "作为最后那个元素插入其中", "这种方式非常自然", "我们再来看删除操作dequeue()", "可以看到 这里无非是去找到", "当前的首元素 first element", "从位置来看 也就是这个元素", "first接口将按照语义", "返回这个节点的position", "而当我们用这个position", "交给remove接口的时候", "它就会顺利地将这个节点删除掉", "当然 这里我们保证了", "这个队列当前是非空的", "对这一点的核对", "我们交给程序员来完成", "既然我们的前端取作这个位置", "所以首元素首当其冲的", "也就是我们需要查询的那个front元素", "因此我们将first node的data域", "直接返回也是再自然不过了", "由此可见", "这种基于以前的工作", "来进一步完成新的任务的思路", "是非常高明的", "不仅使得我们的工作可以快速推进", "而且使得整个工作的系统性和安全性", "都能得到保障", "那么更好的消息是", "我们如果稍做考察的话会发现", "如此实现的", "无论是enqueue dequeue还是front", "这些接口都能够在常数的时间内完成", "O(1)的时间", "这也是不能再好的消息了", "你应该还记得 我们在基于向量", "以public的形式派生出来的stack模板类", "对于vector的方向选择是非常敏感的", "我们更倾向于使用vector的首端", "作为栈结构的底端 或者说叫盲端", "而所有的动态操作 包括push", "以及pop 都在另一端", "也就是vector的末端来进行", "我们当时曾经做过分析", "这样前后颠倒过来", "虽然还勉强可行", "但是在效率上", "却会有天壤之别", "那么当我们基于List", "来实现Queue的时候", "是否也需要注意这个禁忌呢？", "如果将两个方向颠倒过来", "又会如何呢？", "我们将这个问题作为这一节的思考题"]}, {"name": "07A-3 有序性", "block_id": "70bb8531395a41fcbf32022fe956f64c", "text": ["在接下来的讨论中", "为了简洁起见", "我们都将二叉搜索树", "Binary Search Tree", "简称作BST", "那么既然二叉搜索树", "首先是二叉树", "其中的基本组成单位", "也就是节点", "而且每个节点中都各自存有", "一个词条", "另外我们刚才也讲过", "每一个词条", "也都唯一的对应于某一个关键码", "因此同样是为了便于叙述和讲解", "在此后只要不致引起混淆", "我们往往会将节点 词条以及关键码", "这三个概念直接等同起来", "相互指代", "而不加严格地区分", "那么相对于一般的Binary Tree", "BST究竟有什么特点和特征呢？", "概括起来只有一条", "也就是处处满足顺序性", "所谓顺序性具体来说就是", "相对于某一个节点V而言", "如果它的左后代存在", "那么所有的左后代", "都不致比它更大", "对称地 如果它的右后代存在", "那么所有的右后代", "都不致比它更小", "来看两个反例", "首先这样一棵树", "并非二叉搜索树", "因为很明显", "相对于这个节点而言", "它已经拥有三个孩子", "不再是二叉树", "更谈不上是二叉搜索树", "再来看这样一个反例", "我们可以看到", "相对于节点3而言", "它的某一个右后代", "也就是2", "要比它严格地更小", "这一点违反了BST的基本要求", "所以它并非一棵BST", "尽管相对于其它的节点而言", "顺序性的确都是满足的", "因此如果我们将这个关键码2", "适当地替换为一个稍大的关键码", "比如说7", "那么就可以使之成为一棵名副其实的BST", "当然BST还有很多边界情况", "比如只含单个节点的二叉树", "必然是BST", "类似地", "即便其中只包含一个单分支", "只要它在此局部满足顺序性", "那么依然可以称作是一棵BST", "关于顺序性 这样一个定义", "是非常简明而且准确的", "你或许可能会尝试着", "对这样一种定义", "略做调整", "比如像这样", "将后代替换为孩子", "那么这种定义与标准的定义", "是否是等效的呢？", "同学们不妨在课后做一思考", "如果你认为它是等效的", "不妨尝试地给出一个证明", "如果不是 给出一个反例", "再进一步地", "依然是出于简化的考虑", "我们还需补充另一条强制的规定", "也就是在树中所存的词条", "不得彼此重复", "这样我们所有的不小于", "都可以直接简化为大于", "而所有的不大于都可以", "直接简化为小于", "然而这种假设", "在实际应用中极不自然", "同时在算法设计方面", "也是无需回避的一个问题", "实际上我们完全可以", "在接下来所要介绍的方法的基础上", "略做扩充", "使得BST能够支持同时存在的", "多个雷同词条", "在教材所配套的习题解析中", "对相关的技术进行了介绍", "同学们不妨在课后独立地阅读", "相关的几道习题", "最后回过头来重新审视", "如上所定义的顺序性", "不难发现", "这只是一个局部性的特征", "那么这样一种局部性的特征", "对于BST整体而言", "又意味着什么呢？"]}, {"name": "03A-3\t 从秩到位置", "block_id": "f264ec2dbc03471aae7c76db79326e32", "text": ["我们知道向量的特点", "在于它所特有的那种循秩访问的方式", "也就是说 根据任何一个元素的秩", "它都可以借助这么样一个", "简单的线性表达式", "在常数的时间内", "找到这个元素所存放的物理地址", "并且进而对它进行访问", "如果要比喻下的话", "这种方式很像是 此前更流行的", "邮递员来投寄邮件的那种做法", "比如说 在某个城市", "某个区的某个街道", "如果所有的住户", "我们认为他们构成一个向量的话", "那么邮递员可以根据门牌号", "直接地换算出", "这个住户在这个街道上", "具体的地理位置", "这种方式的诱人之处", "在于它的效率非常的高", "那么这种方法可否被列表所沿用呢？", "列表既然与向量一样", "是同属于线性结构的", "当然它也存在秩的概念", "正像我们刚才所说的", "其中的每一个元素", "都确实在逻辑上", "具有一个序号 也就是秩", "所以从理论上讲", "确实可以通过这个秩进行定位", "比如说 我们可以记下", "rank到底是多少", "然后从头出发", "不断地沿着后继引用", "向前走rank r那么多步", "最终抵达你所需要查找的那个元素", "然而此时和向量的情况已经大不相同", "继续沿用这种循秩访问的方式", "成本会很高", "不难看出 刚才这样的一种", "循序访问的机械方式", "所需要的成本实际上是和秩有关系的", "秩越大 相应的访问成本也就越高", "而不是保持一个常数", "实际上 在这种场合", "或者这种情形下", "我们在设计相应的算法时", "应该尽可能地摒弃掉循秩访问的方式", "而是改为所谓的循位置访问的方式", "也就是call by position", "因为这个时候我们可以认为", "列表中的任何一个元素", "在物理上都是由一个抽象的位置", "也就是position来指定的", "相应地 我们也就可以把", "整个问题尽可能地转化为", "在这些节点与节点", "尤其是相邻节点之间的", "相互引用、相互访问", "这么样的一个过程", "从而发挥列表这种结构的优势", "避免它的短处", "这样一种访问方式", "可以用人际网络来很好地形容和比喻", "比如说 我们如果要找到某个人", "往往不是直接能够得到他的住址", "而是通过一些人际之间两两的关系", "比如说 朋友的亲戚以及亲戚的同事", "或者同事的战友", "以及战友的", "没准是邻居或者是同学", "直到最后才能够找到", "你所要找到的数据对象", "接下来 我们就来讲解", "如何具体地实现这样一种结构"]}, {"name": "01d-7: 封底估算-2", "block_id": "343926b55453457ebb2b1f0b6367a81d", "text": ["无论费米还是埃拉托斯特尼", "无论是物理学", "还是几何学 包括测地学", "之所以能成功运用这种方法", "关键都在于它们", "善于抓住问题的主要方面", "从而简捷地得出", "这个问题的总体的规律", "我们说这种方法", "可以很自然地运用到", "我们复杂度的分析过程中", "当然对象变成了时间", "因此我们对很多的时间量", "从今天开始就要建立起", "直接的概念", "有哪些概念呢？", "第一个就是关于一天", "我们说我们的基本计算单位", "当然是秒", "我们的CPU在一秒钟", "现在gigahertz", "大概是10的9次方次运算", "那么一天有多少秒呢？", "我们这里要换算一次", "并且把它记下来", "我们说大概是24小时", "乘以60分钟乘60秒", "那么技巧就是", "把24小时", "要放大估算为25", "把六六三千六放大成大概是4000", "这个时候 我们就看得出来端倪了", "大概是 1后面接5个零", "所以我们从此要建立一个概念", "一天大概就是10的5次方秒", "那么我们的一生呢？", "当然希望各位都是长命百岁", "我们不妨用一个世纪来估算", "100年 每年360天", "大概是三万多天", "如果这么样换算的话", "大概是3乘以10的9次方秒", "在清华 我们都有一个宏伟的目标", "要为祖国健康的工作50年", "那么这50年是多少呢？", "从今天开始我们应该有一个概念了", "大概1.6乘以10的9次方", "而无论这个 还是这个", "我们说都不是很好记忆", "那么怎么好记忆呢？", "今天的人们更喜欢用", "三生三世这样的词来形容长久", "那么这个准确地讲 又是多少呢？", "我们说大概近似为300年", "那么恰好大致是", "10的10次方秒", "这是个非常好记的数值", "所以我们以后要记住", "所谓的三生三世", "其实对应的就是", "10的10次方秒", "所以串起来 我们说", "在三生三世中的一天", "其实就相当于", "在一天中的一秒", "这个概念 我们要从此建立起来", "我们也知道现代物理学", "所估算出的宇宙大爆炸至今", "也就是宇宙的寿命", "大概是10的21次方秒", "所以相对而言", "在整个宇宙生命中的三生三世", "其实就相当于", "在三生三世中的0.1秒", "我们来看封底估算的", "一个具体实例 也就是", "如果我们承担一个任务", "要对全国人口普查的数据进行排序", "这个时候的任务的规模", "十几亿人口", "我们大致归算为十亿", "也就是10的9次方", "那么我们将可以", "怎么来完成这个任务呢？", "我们有两方面的选择", "一方面是在硬件机器上", "不断地做改进", "一方面是在算法上做改进", "我们分别来看一下", "先来考虑用普通的PC机", "也就是诸位用的", "台式机和笔记本电脑", "目前主流的频率", "大概都是10的9次方", "我们大致地认为它在一秒钟之内", "可以进行的浮点", "包括通常的整数运算吧", "我们估算为10的9次方次", "那么如果采用我们刚刚介绍的", "Bubble sort 就是起泡排序", "会怎么样呢？", "我们刚才说了", "它的复杂度是平方", "所以是10的9次方再平方", "应该是10的18次方", "这样的一个计算量", "这两个做一除法 就会得到", "大致需要10的9次方秒", "10的9次方秒是多少呢？", "我们刚刚估算过", "一个世纪大概是", "3乘以10的9次方秒", "而10的9次方秒大概就是", "三分之一个世纪", "也就是约30年", "我们再来看看", "如果改用比较高性能的机器", "比如天河1A", "这也是一度成为世界上", "计算速度最快的机器", "它的计算能力是千万亿次", "我们大致认为是一个P（peta）", "具体来说 就是10的15次方", "那么如果估算一下的话", "这边是10的18次方", "除以10的15次方", "我们说 还需要大概一千秒", "一千秒什么概念呢？", "大致是20分钟", "所以通过硬件的改进", "我们可以将这个问题", "从30年改进为20分钟", "这个硬件的改进", "确实有相当的效果", "但是我们再来看另一个维度", "如果我们改用不同的算法", "比如说 稍候要介绍的", "Merge sort 也就是归并排序", "那么它的复杂度是nlogn", "所以除了这个10的9次方以外", "它还要附属的乘上去一个", "10的9次方的对数", "这样乘下来呢", "是大概等于3乘以10的10次方", "而这个地方是10的9次方", "经过一个简单的估算 就会发现", "实际上用这种算法", "即使是用普通的PC机", "我们也只需要30秒", "没错 30秒", "和刚才的一千秒比起来", "小很多", "如果你既要用这样的", "一个高明的算法", "同时用这样一个", "更好的机器来计算的话", "那么完成这个任务", "大致只需要零点几个毫秒", "所以从这里我们也可以", "看出来算法的威力", "我们再看一遍", "通过硬件的改进", "我们是将30年缩短为20分钟", "而通过算法的改进", "我们可以将30年缩短为", "不足一分钟 只有半分钟", "从这里 我们也可以看出来", "算法改进的威力是多么的巨大", "我们的数据结构", "研究这样一类问题", "那么它的意义更是可想而知", "我们更是有必要把这门课", "学好 掌握好"]}, {"name": "03D-6\t 性能", "block_id": "44bbc65877e44a3ca79b1f7f3577ad14", "text": ["好", "到了可以清点一下成果的时候了", "新的这个排序算法", "总体性能如何？", "我们注意到", "整个这个算法依然是由", "n次迭代来完成的", "在每一步迭代中", "尽管我们的移动操作", "也就是remove和insert组合起来的效果", "是可以做到只需O(1)的时间", "但是正如我们在前面刚看到的", "挑选出最大元的操作", "却不得不遍历整个未排序的那个前缀", "换而言之 这个算法在每次迭代中", "花费于挑选最大元的工作量", "又再次体现为算数级数的形式", "所以总体而言", "它依然需要花费n平方的时间", "而且这种花费的时间是确定的", "无论最大元位置如何", "都没有最好或最快情况", "因此这里还是θ(n平方)", "那么难道说", "我们费尽了这么多心思", "居然和起泡排序的效果是一样的？", "我们说 这里还是有所区别", "而且是有很大的区别的", "因为就这里所涉及的两类操作", "也就是节点的移动", "以及大小比较而言", "前者在实际效果", "也就是常系数的意义下", "要复杂的多得多", "需要花费远远更多的时间", "因此这里能够对移动次数做改进", "使得每一趟扫描所需要的移动操作", "从原来的n降至1", "实际上 是一个非常了不起的改进", "那么比较操作呢", "同样可以进一步地改进", "只不过目前来谈这种改进", "还为时尚早", "等到后面的第十章", "我们将会看到", "借助精巧的数据结构", "selectMax可以在logn", "而不是n的时间内完成"]}, {"name": "10b1-3: \t形具神备", "block_id": "919cc1c079b6447fb58bbf9a4a562877", "text": ["在这里，我们借助C++语言的多重继承特性，", "将向量模板类与优先级队列接口有机地融合起来，", "从而定义出完全二叉堆模板类。", "这就是具体的实现方法：", "可以看到，这里的PQ_ComplHeap以公开的模式同时继承了PriorityQueue和Vector的特性，", "也就是说，在物理上，它自然就拥有了一个名为elements的可扩充数组。", "另外一方面，作为PriorityQueue的一个派生类，", "它也自然应该提供我们此前所介绍的三种标准接口。", "此外，还提供一个批量构造的接口，", "这些接口的实现方法我们都将在稍后逐一介绍。", "当然，这些对外操作接口的实现还需要依赖若干内部的功能接口。", "我们也会在稍后相应地介绍它们。", "至此，我们已经在物理上的向量和逻辑的优先级队列之间初步地建立起了联系。", "然而为了使得这种联系具有神采，我们还需要做另一方面的工作。"]}, {"name": "09D2-5 双蜓点水", "block_id": "56adcc794510476382b4ab8c9b5e694e", "text": ["如果需要进一步的提高装填因子", "不妨可以考虑将常规的平方试探扩展为所谓的双向平方试探", "具体来说 一旦发生冲突", "则交替的向前向后以递增的平方数为间隔逐一的试探", "整个试探过程 以及对应的试探链", "可以由这幅图来表示", "假设最初的散列映射位置在这", "接下来如果从这个位置开始 持续的发生冲突", "那么第一个试探的位置应该是这", "如果依然冲突 那么下一个试探的位置应该是这里", "第三次试探的位置 在这里", "第四次在这儿 依此类推", "如果将双向试探的位置罗列出来 大致应该是这样", "从居中的0号单元开始 向后转入相对而言的1号桶", "再转向-1号桶 再转向+4号桶 再转向-4号桶", "以及+9号桶 -9号桶 依此类推", "当然具体的桶单元编号还需对M取模", "对于此前那个长度为11的散列表而言", "这种方法非常有效", "因为如果像这样将各次试探的位置具体列出来", "我们就会发现", "前11次试探的位置不多不少恰好覆盖了0到10这11个桶", "也就是说 只要装填因子还没有达到100% 仍有空桶", "那么按照这种方式进行试探 就一定能找到一个空桶", "你也不难发现 对于其他的一些素数表长也有这种好现象", "比如考察长度为7的散列表", "可以看到 如果也是采用双向平方探测", "那么前7次试探的位置 也恰好覆盖了0到6这7个单元", "尽管已经看到了 这样的两个好的实例", "我们还是有理由怀疑其中存在着运气的成分", "我们知道此时的查找链", "实际上是由正向和逆向两个子查找链依此交错而构成", "在讨论单向平方探测时 我们已经证明", "在正向的子查找链中 前M/2上整的位置必然彼此互异", "而由对称性 逆向的子查找链", "也应该在内部具有这样的性质", "那么在这两个子查找链之间 除了公共的起点0", "是否还有其他公共的单元呢", "如果没有 那么它们的总长 就应该恰好是M", "也就是说 它们的并集将完整的覆盖所有的桶", "我们刚才已经看到在M=11时 情况的确如此", "正向的查找链与逆向查找链之间没有任何公共元素", "而M=7时 情况也是如此", "然而正如我们刚才所担忧的那样 情况并非总是如此", "比如M=13时 我们会在两个子查找链中同时发现4 9 3等等", "而在做过进一步的观察之后", "你甚至会发现此时的正向子查找链与逆向子查找链", "居然是由同样的6个数组成的", "我们也不难找的更多这样的反例", "最简单的莫如M=5 你会发现", "它的正向子查找链与逆向子查找链也是由同样的两个数组成", "以下这些实例告诉我们 对于双向平方试探法而言", "采用某些素数表长 可以行之有效", "而采用另外一些素数的表长 却非常糟糕", "那么同样是素数 这两种类型之间 有什么区别呢", "我们在相应的设计散列表时 又该如何取舍呢"]}, {"name": "04C2-5\t 反思", "block_id": "500f3848da2a4ca981e8b2a5da24d89f", "text": ["为更好的理解刚才的算法过程", "我们不妨来看一个具体的实例", "假设这是一个待判别的表达式", "我们借助一个栈结构", "来逐个地检查各个字符", "首先是第一个字符", "我们可以看到，它是个左括号", "所以按照刚才的逻辑", "(也许)直接地入栈", "同样，接下来的这个左括号也是如此", "当我们第一次碰到", "一个右括号的时候", "按照程序的另一个分支", "弹出当前的栈顶", "也就是与它紧邻", "并且匹配的那个左括号", "再接下来，左括号入栈", "左括号入栈", "右括号出栈 右括号出栈", "左括号入栈 右括号出栈", "一直到最后一步", "右括号出栈", "最终栈变空", "从而可以判定", "原表达式是整体匹配的", "整个算法流程非常的简明", "而在纵观这个实例之后", "或许你应该能", "发现点什么特别的地方", "没错", "实际上，你会质疑", "我们为什么要使用栈呢？", "就这样一个特定的问题而言", "只需借助一个简明的整数计数器", "就足以完成刚才的算法任务", "难道不是吗？", "我们来看一下", "算法之初", "我们将这个计数器设置为0", "接下来，每当遇到一个左括号", "我们就令这个计数器加1", "再遇到左括号继续加1", "而反之，如果遇到的是右括号", "我们就令它减1", "所以加1 加1 减1", "加1 加1 减1", "减1 加1 减1 减1", "最终只要这个计数器能够回到0", "就同样意味着这个表达式是匹配的", "而在算法的过程中", "如果我们试图", "将这个计数器变为一个负数", "或者在最终它不能够回到0", "我们都可以断定表达式是失配的", "这并不是什么巧合", "实际上，如果你注意到", "这个计数器所反映的就是", "刚才我们所使用的那个栈", "在任何时刻的规模", "就不难理解其中的必然性了", "那么既然如此", "我们为什么不使用", "更加简明的计数器", "而要使用更为复杂的栈结构呢？"]}, {"name": "08XA3-3\t算法框架", "block_id": "f9cac356acbb49c5b6d63b09435f79f5", "text": ["整个插入操作的算法过程 可以描述如下", "首先调用BST的标准查找接口进行一次定位", "不妨假设目标尚不存在", "于是我们就可以创建一个节点x", "将新的关键码存入其中 并且将其作为_hot的孩子", "所以x的确是一个末端的叶节点", "当然与每一个新生成的节点一样", "这个x此时也首先被初始化为红色", "接下来我们要调用内部的solveDoubleRed算法接口", "检查是否因为x的引入而出现了双红缺陷", "如果是则修复它 最后别忘了返回新插入的节点", "那么这个solveDoubleRed", "又将如何具体的分情况来解除双红缺陷呢"]}, {"name": "08XA4-7\tBB-2B", "block_id": "ef5a8a94c32b4532bf40ce5074bebe42", "text": ["兄弟节点s为黑色 同时2个孩子均为黑", "而且局部的子树根p也为黑的情况", "我们统一编号为BB-2B", "同样的 站在B树的角度来看 此时依然会发生一次下溢", "而且同样只能通过兄弟节点的合并来加以消除", "而与BB-2R的不同之处在于", "此时的关键码p是独自成为一个超级节点", "因此当这个唯一的关键码p被借出之后", "此前的父节点 将注定随即发生一次下溢", "也就是说 在这种情况下双黑缺陷有可能会向上传播一层", "而且不难构造这种实例", "有可能会继续的再进而上升一层", "以至更为极端的持续的上升下去 直到最后的树根", "尽管我们可以一如既往的沿用相应的调整方法来进行调整", "并且的确能够保证这个调整过程会在至多logn步之后结束", "但是你不免会有些担心 担心什么呢", "是的 重构操作", "难道于说 在这样的一个过程中", "重构操作也有可能会执行到多达logn次吗", "当然 现在我们也同样的只需回到红黑树", "就可以形象的来理解和记忆此前略显复杂的调整方法", "需要再次强调的是 经过这样的调整", "红黑树的拓扑结构并没有发生任何的实质变化", "也就是说 整个调整过程所执行的重构操作", "不超过常数这么样一个要求 依然有可能落实", "以下 我们只剩下最后一种情况", "也就是兄弟节点s 有可能不是黑色 而是红色"]}, {"name": "05C-1 二叉树", "block_id": "f18d44f7f2ff46159047e23d697d7445", "text": ["同学们好", "我们这一节介绍树的一种特殊", "但又不失代表性的特例", "也就是二叉树", "所谓的二叉树binary tree", "也就是其中每个节点的度数", "不超过2的", "这样一种树", "最多两个分支 两叉", "所以叫二叉树", "因此在任何一个局部", "每一个节点最多只有两个孩子", "所以不妨以左和右区分它们", "同样地 对应的两棵子树", "也可以以左、右相称", "我们称作相对于某个节点r而言的", "左孩子、左子树", "或者相对于r而言的", "右孩子和右子树", "请注意 这里我们实际上", "已经隐含了树的有序性", "一般来说 我们的习惯是", "认为左在先 右在后", "相应地 我们也可以将", "每一个节点的左孩子", "确实画在它的左边", "将它的右孩子以及它的右后代", "也都画在这个节点的右侧", "不难看出", "这样一种所谓的二叉树", "肯定是整个树的一种特例", "但是饶有趣味的是 我们很快就会看到", "在有根性以及有序性", "能够保证的前提下", "二叉树却足以描述所有的树", "既然在这样的树中", "每个节点的出度至多为2", "此前我们按照深度", "对所有的节点划分的等价类", "从规模上看 就构成了一个", "以2为倍数的几何级数", "相应地 第k个等价类", "也就是所有深度为k的节点", "也自然不会超过2的k次方个", "而整个树的总体规模呢", "也自然满足这样的一个上界", "也就是最后一个等价类", "最后一层的两倍", "当然反过来 这个下界", "也是比较好理解的", "因为对于一棵高度为h的树来说", "至少在每一层上有一个节点", "果真如此的话", "这棵树也就退化成了", "由每一层为1的那个节点", "所构成的一个单链条", "反过来 除了叶子节点以外", "如果所有的节点的度数都是2", "那么每一个等价类", "都会达到它的最大的饱和状态", "从而构成一棵特殊的树", "我们称之为满树", "比如下方以h为根的这样一棵树", "总体的就构成一棵满树", "我们可以看到满树的特征", "就是在同样的高度下", "它可以使得其中的顶点数达到最大", "也就是饱和状态", "满树 full binary tree", "由此也可见", "一棵二叉树在横向上的宽度", "与它在纵向上的高度", "是呈一个指数的关系的", "宽度是高度的指数", "我们讲过指数意味着爆炸", "意味着剧烈的增长", "所以如果节点的总数固定", "那么宽度大致与它还相当", "但是高度却会增长的非常的缓慢", "反过来 呈一个对数的形式", "所以我们希望这个图景", "大家应该能记下来", "也就是说 对于一棵二叉树而言", "它非常倾向于涨宽", "它的涨宽的速度更快", "就像一只兔子一样 跑得很快", "而它的高度呢", "如果我们控制得当的话", "会增长的异常的缓慢", "相对而言 就像一只乌龟一样", "兔子和乌龟速度有天壤之别", "这也是我们稍后", "引入二叉搜索树的重要理论基础"]}, {"name": "10b2-3: \t实现", "block_id": "9af006e0808142e194166a75ff8d17d4", "text": ["在这里我们给出完全二叉堆插入算法的一种可行实现方式：", "首先，将待插入的词条接入向量之中，", "为此我们所借用的是向量的插入接口。", "你应该记得，在默认的情况下，这个接口会将新元素视为末元素插入其中。", "既然是末元素，新插入的这个词条在向量中对应的秩就应该是n-1，", "因此接下来我们可以调用percolateUp算法完成对新节点的上滤调整。", "percolateUp算法可以实现如下：", "迭代式的上滤调整过程是以while循环来实现的。", "如果当前词条的秩为i，我们首先要检查它的父亲是否存在，", "也就是说i是否已经成为堆顶。", "倘若词条i的确成为了堆顶，这个循环就会立即退出，算法也随即终止。", "不失一般性，如果i的父亲存在，我们就记为j，", "接下来通过一次比对，我们就可以看出这对父子节点是否逆序。", "一旦它们不再逆序，这个循环也会随即退出，", "否则如果的确在这个位置违反堆序性，就按照刚才的算法将两个元素互换位置，", "同时更新新节点的秩，也为下一步的迭代做好准备。", "这个算法的正确性不难验证，接下来的问题便是这个算法需要运行多少时间呢？", "对应的时间复杂度是否能达到我们所预期的目标呢？"]}, {"name": "11c4-1: \t递推", "block_id": "0a7be33ba80642cdb300cd6a5c58f617", "text": ["接下来的这节 我们就来讨论next查询表的构造算法", "我们将会看到 非常有意思的是 next表的构造过程与KMP主算法的流程在本质上是完全一样的", "在这里 我们不妨采用递推策略", "我们只需回答这样一个一般性的问题即可", "也就是说由低至高 如果我们已经构造到了next表的第j项", "那么接下来又当如何进而构造出j+1项", "在此 我们需要再次重温next表的定义", "也就是说 这个表中所谓的第j项", "也就是在模式串长度为j的那个前缀中", "自我匹配的真前缀与真后缀的最大长度", "由此 我们自然就可得知", "在数值上 next表中的任何一项", "相对于此前的那项", "至多只可能增长一个单位", "通过反证法 这一点不难得到", "具体的证明细节 留给你在课后完成", "进一步地 这个不等式取等号的充要条件是", "在模式串P中", "编号为j的字符与它按照next表的继任者彼此相等", "比如在这幅图中", "P[j]就是这个字符", "而它的继任者则为这个字符", "根据next表的定义", "以这条线为界 P的这个前缀与它的这个子串必然是完全匹配的", "因此如果P[j]与它的继承者也是相等的", "这种自匹配的长度自然就会增加一个单位", "因此在这种情况下", "next表中的第j+1项 也自然地就应该在此前第j项的基础上再递增一个单位", "这样 我们也就证明了这个充要条件“当”的那个方向", "为了进而再证明“仅当”", "我们只需考察P[j]与它的替代者不相等的情况", "比如后者为Y", "此时 在这个长度为j+1的前缀中", "任何一对自匹配的真前缀和真后缀", "也必然蕴含着在此前长度为j的那个前缀中自匹配的一对真前缀和真后缀", "而且新的那对真前缀和真后缀的长度 也必然相对于此前那对 要增加一个单位", "而由于next表中的各项都是对应于自匹配的最大长度", "因此 新的自匹配长度绝对不可能超过此前的自匹配长度", "那么倘若P[j]果真与它的继任者不等", "我们又该如何计算出next表中的下一项呢"]}, {"name": "03X\tD 习题辅导：LightHouse", "block_id": "52598911818c415fae7a5006896c15b5", "text": ["同学们好", "我们的第一次编程作业", "也就是PA1布置之后", "很多同学都完成的不错", "但是其中的lightHouse一题", "也有很多同学至今不得要领", "所以我们这里专门制作一个专辑", "就此做一提示", "非常好 已经有很多同学", "能够将这道题与我们所介绍的", "逆序对 也就是inversion联系起来", "确实如此", "如果将所有的灯塔按照X方向", "排一顺序的话", "那么就可以很清晰地看到", "任意两座灯塔", "彼此能够照亮", "当且仅当它们不构成一个逆序对", "当然 如果你愿意把它叫作顺序对 也可以", "因此从这样的一个角度", "这道题的实质就是在", "已经排序的一组序列中", "计算出逆序对的总数", "不难理解 在最坏情况下", "n座灯塔中的任何两座", "都不能彼此照亮", "也就是构成一个逆序对", "因此 如果我们是逐一去进行比对的话", "那么在最坏的情况下", "时间复杂度将会达到平方", "经过简单地封底估算", "你应该会知道", "这样必然会超时的", "那我们推荐的解法之一", "就是采用divide and conquer", "分而治之的策略", "具体来说 我们始终", "将任何一个序列一分为二", "分别递归地计算出", "它们各自内部所含的逆序对数", "再进而且求出它们之间的元素", "彼此所能构成的逆序对数", "两类逆序对的总和", "也就是我们所需要计算的结果", "为此 一种可行的方法就是", "套用我们的归并排序算法", "也就是说 算法所处理的", "只不过是这样一种标准的场景", "具体来说 整个序列", "是由前后两部分构成的", "而且它们都已经各自按顺序排列", "当然 我们还需要对", "排序算法的框架略做调整", "为此我们先来", "默写一下这个算法的主要框架", "应该是mergesort 整个的一个V", "其中的步骤 大概是", "首先 按照我们的说法", "要系上安全绳 在必要的时候", "直接返回退出 这是递归基", "接下来 分而治之", "对左侧的向量 mergesort", "以及同样地 对右侧的子向量mergesort", "最终通过merge", "将这两个向量合并进来", "修改的第一项是从语义上", "也就是说 我们不仅要完成排序", "同时还应完成一个对逆序对的计数", "所以这个时候的mergesort", "我们不防称它是inversions inside", "也就是说 计算向量V内部", "所含的逆序对数", "相应地 内部这两次调用", "也将替换成这样一个名字invInside", "既然这里计算的是inversion的数目", "所以我们的返回值类型", "也应该变成int", "另外相应地 我们的二路归并", "也就是merge 也应该从语义上", "调整为计算VL与VR之间", "元素所能构成的逆序对数", "所以我们不妨把这个算法的名字", "改为number of inversions between", "与归并排序算法一样", "这里实质的工作", "其实就是在于这个between", "回到这幅图", "VL和VR", "如果依然沿用我们的习惯", "将每一个inversion都记帐在", "位置居后的那个元素上", "VR中的任何一个元素j", "能够与VL中的哪些元素构成逆序对呢？", "从这个图中 大家已经看得非常清楚了", "也就是沿着这条水平线到这个交点", "如果这个交点是VL中的第i个元素", "那么能够参与构成逆序对的元素", "恰好就是从第i个元素开始的", "所有后继元素", "那么对于任何一个VRj", "如何来确定VLi呢？", "这是我们这个算法的最后一步", "我们把这个留给大家补充完成", "为此你需要对", "归并排序算法的流程和原理", "有足够深刻的理解"]}, {"name": "12c1-1: \t策略", "block_id": "e4951dbb55a34230ac4ada90a08893e7", "text": ["同学们好。", "在本章的最后一节也是这门课程的最后一节", "我们来学习一种非常别致的排序算法", "也就是希尔排序", "希尔排序算法既有着悠久的历史", "同时也仍然不失活力", "该算法的别致之处在于", "它不再是将输入", "视作为一个一维的序列", "而是将其视作为一个二维的矩阵", "并且试图对矩阵的每一列", "分别进行排序", "如果矩阵当前的宽度为w", "那么我们就将所有这w列", "各自的排序总称为w-sorting", "实际上每一次Shellsort排序的过程", "都是由若干个宽度不同的", "W-sorting构成的", "如果矩阵的每一列都已经过排序", "我们就称之为w-ordered", "实际上矩阵最开始比较宽", "w比较大", "此后Shellsort会逐步的压缩矩阵", "使之越来越高越来越窄", "每压缩一次都随机执行一趟", "对应的w-sorting", "从而使之变成W-ordered", "我们也可以通过这样的一组图", "来说明这一过程", "比如这可能就是最初的那个矩阵", "相应的比较宽比较矮", "那么在执行完对应的Wk-sorting之后", "Shellsort会对这个矩阵进行重组", "使之成为一个相对更窄", "但同时更高的矩阵", "接下来对应于新的这个宽度", "WK减1也会做一趟逐列的排序", "而在此之后", "Shellsort又会对它进行重组", "使之变成这样一个更加的窄", "更加高的矩阵", "这个过程将持续的进行下去", "总之矩阵会变得越来越高越来越窄", "直到最终变成只有一列", "同样的对最后这个矩阵", "我们也需要来做一次对应的", "W-sorting", "只不过此时的W等于1", "所以我们也称之为one-sorting", "可以看到整个Shellsort的过程", "使用了一系列的宽度", "也就是WK Wk减1", "以及一直到W3 W2和W1", "这些宽度和在一起", "构成了所谓的步长序列", "step sequence", "当然这些矩阵宽度被使用的次序", "恰好与它们在序列中的次序相反", "然而无论如何", "它们都必须是逐个单调递减的", "没错在算法的执行过程中", "我们所采用的矩阵宽度", "会逐步的递减", "所以希尔排序算法", "也称作为递减增量法", "请注意我们这里的步长序列h", "实际上除了我们刚才所说的单调性", "以及它的首项必须为一", "我们对它暂时还没有更多的要求", "是的", "这种序列有很多种可能的选择", "采用不同的步长序列", "Shellsort的性能也会有所不同", "实际上Shellsort只是一个框架", "你采用什么样的步长序列", "就会得到什么样的算法", "从这个意义上讲Shellsort", "就像一个播放机", "你往里头放入什么样的CD", "它就会播放什么样的音乐", "因此我们宁愿说Shellsort是一个算法", "不如说它是一类算法", "我们注意到既然任何步长序列", "都要求首项W1等于1", "所以任何Shellsort", "都是以one-sorting结束的", "而任何一次这样的one-sorting", "其实也就相当于全局的排序", "因此最终的输出结果", "也必然是正确的排序序列", "因此这个算法的正确性", "是毫无疑问的", "当然至此你可能会有一个疑问", "既然无论如何", "最终都要做一次one-sorting", "那么此前的这些排序又有什么意义呢", "是的", "这正是Shellsort的奥妙所在", "不过现在回答这个问题", "还为时尚早", "接下来我们不妨通过一个具体的实例", "首先来切实的感受一下", "希尔排序的执行过程"]}, {"name": "07D4-1 ”3+4“重构", "block_id": "30af53becca74243a19839cc6cfb2705", "text": ["实际上 以上针对AVL树", "插入操作和删除操作", "所介绍的单旋式和双旋式调整技巧", "无非是为了帮助你形成对算法的理解", "而在真正的实现时", "我们大可不必机械地如此理解", "这样一个过程可以比喻为玩魔方", "是的 你需要在规则的允许下", "通过巧妙的旋转组合", "使之转入某种特定的状态", "比如六面各自同色", "那么你是否去过魔方的组装车间？", "你会发现那里的工人", "可不是按照你这样的规则", "在那儿进行这样的旋转", "实际上 它们无非是将魔方的", "一个又一个组件直接地拼接为一个魔方", "工人们之所以这么做", "是因为它们最大也是唯一的目标是", "尽快地以最高的效率完成魔方的组装", "我们这里呢 也不妨借助这一策略", "因为对于AVL树的重平衡化而言", "我们最终在乎的并不是所谓的技巧", "而是在于这个过程的效率", "我们来看一下", "如何将魔方组装工人的那种策略", "用到我们这个问题上", "具体来说 我们依然假设g", "就是当前最低的那个失衡祖先", "并且同样地沿着那个最长的分支", "去考察g p v这祖孙三代", "以下我们并不急于对它们进行旋转", "而是首先做重命名", "也就是说", "按照它们在中序遍历序列中的次序", "自小到大", "重新命名为a b以及c", "对照我们此前所讲的各种情况", "无论是Zig-zag zag-zig", "Zig-zig或者是zag-zag", "你会发现在它们以下", "无非是最多4棵子树", "那么我们也需要对这4棵子树做重命名", "而且命名的规则", "同样是参照中序遍历的次序", "也就是T0至最小的那棵树", "T1是次小的 T2是较大的 T3是最大", "此时 如果我们依然按照中序遍历的次序", "将这两个序列混合起来", "就可以得到一个长度为7的序列", "在这个序列中 三个节点a b c", "必然是镶嵌于这4棵子树之间", "实际上 无论是哪种具体的情况", "经过这样的重命名之后", "按照中序遍历的次序", "必然是从T0到a 再从a到T1", "再从T1到b 然后从b到T2", "再从T2到c 最终由c到T3", "你应该不会觉得奇怪", "因为这恰恰就是BST所谓的单调性", "在这样一棵局部子树的具体体现", "在调整之前 即便这棵子树是失衡的", "它也依然是一棵BST", "所以这个单调性应该自然满足", "而在调整之后 尽管它已经恢复了平衡", "但是这个单调性也依然需要保持", "因此 我们可以统一地将这三个顶点abc", "以及这4棵子树", "按照这样一个拓扑关系直接地拼接起来", "具体来说 以a和c", "分别作为b的左和右孩子", "而T0和T1将作为a的左和右子树", "T2和T3分别作为c的左和右子树", "这样一种拼接是针对于三个节点", "以及下属4棵子树而言的", "所以也称作3+4重构", "在此 你不妨稍作暂停", "并对照此前所介绍的各种情况", "以及相应的调整算法", "应该会发现 无论是插入还是删除", "无论是单旋 还是双旋", "最终的效果都应该是这样一种形式", "这也犹如无论魔方的最初状态如何", "也无论你所设计的旋转方案具体如何", "最终必然应该达到", "你心目中早已设计好的一个结局", "对于魔方而言 一般都是六面各自同色", "而对于我们的BBST而言", "则是在此局部地重新平衡", "按照这样的一个思路", "我们可以更为概括", "而且更为深入地来理解并且记忆", "以上各种情况的处理手法", "而更好的消息是 按照这样一种理解", "我们也可以更加简明 更加高效", "而且更加安全鲁棒地来实现相应的重构算法"]}, {"name": "06C-1 化繁为简", "block_id": "1001207810824c37af0cff45b80f2732", "text": ["同学们好", "此前几节我们已经介绍过图的基本概念", "以及它在计算机中的表示与实现方法", "从这一节起 我们将转入图相关的算法", "实际上我们首先所介绍的", "与其说是图的算法 不如说是构造", "一系列图算法的若干种典型的", "算法策略或框架", "那么这是一种什么样的框架呢？", "从思路上 依然是化繁为简", "回忆一下", "在我们此前介绍如何处理半线性结构", "也就是以树为典型代表的结构时", "我们所采取的策略也是化繁为简", "也就是说 我们希望基于此前", "相对而言更加研究有素的基本数据结构", "比如序列 你应该记得", "我们当时化繁就简最主要的手段", "就是遍历", "是的 通过遍历我们可以将", "任何一个非线性结构", "顺利地转化为线性结构", "具体来说 任何一棵二叉树", "都可以转化为相应的遍历序列", "前者所对应的很多问题都可以", "对应地转化为后者", "那么在处理图这样的完全", "非线性结构时", "我们依然需要在宏观上借鉴这种思路", "也就是说 我们依然需要构建几种", "典型的遍历模式", "完成从非线性结构到半线性结构的转换", "也就是将任何一幅图转化为对应的树", "或者严格讲支撑树", "相应地 只要我们的搜索策略", "设计并且应用得当", "与图对应的很多算法问题", "都可以相应地转化为树的算法问题", "由此可见 从线性结构到半线性结构", "进而到线性结构", "我们所采用的总体策略是一以贯之的", "因此我们这里最主要的任务", "首先就是如何来设计", "并且构建这样相应的遍历算法", "当然在图中所进行的这样一种遍历过程", "更多地体现为针对某种目标的查找过程", "所以我们也更加地倾向于称之为", "搜索 search", "那么接下来的这一节", "我们首先讨论的就是广度优先搜索"]}, {"name": "02 E-1\t构思", "block_id": "edcb1f86982b4b759b43b7a0a17d3008", "text": ["欢迎同学们回来", "在此前的几节 我们已经看到", "相对于无序向量", "有序向量会显示出更多的优势", "比如它的去重操作以及查找操作", "都可以更快速地完成", "我们在后面会看到更多的例子", "然而我们遗留下一个问题", "就是如何将一个无序的向量", "转化为有序的向量", "这也就是用到我们所谓的排序算法", "那么接下来的这两节", "我们就针对向量", "来介绍两种典型的排序算法", "也就是起泡排序以及归并排序", "我们先来看起泡排序", "实际上 这门课将讨论多种排序的算法", "比如说 在这一节", "我们将要讨论的是起泡排序", "在下一节 我们将介绍的是归并排序", "而在课程的习题以及其它的章节中", "我们还将涉及到其它的一些排序的算法", "这些排序算法在这里都统一地纳入", "一个名为sort的标准接口", "那么在内部呢", "我们这里为了测试方便", "同样采用了此前所采用的方法", "我们会随机地在这样", "几种排序算法中选择其一", "首先来考察起泡排序", "这个算法 我们并不陌生", "大家应该记得 在第一章", "我们曾经以这个算法为例", "介绍过如何证明算法的正确性", "这里呢 按照刚才统一定义的形式", "将它整理为一个名为bubbleSort的算法接口", "当然我们很快就会看到", "这并不是我们在第一章", "所介绍那个版本的简单重复", "回顾一下 这个算法实际上", "可以认为是通过调用", "一个名为bubble的过程", "迭代地来进行", "在每一迭代过程中", "都会考察当前介于", "lo和hi之间的所有相邻元素", "只要有一对相邻元素是逆序的", "就将它们交换", "所以整个这样的一个过程呢", "也称作扫描交换", "大家也应该还记得这个算法的不变性", "具体来说 如果最初的这个向量", "是一个无序向量的话", "那么每经过这样一趟对bubble的调用", "都会有一个新的元素就位", "比如说 对于第一次而言", "就是全局最大的那个元素", "这里用红色来表示就位的元素", "那么当然互补地 其它的部分", "也就是接下来要考察的问题的范围", "就会相应地缩小一个单元", "这也是减而治之", "再接下来", "有序的部分会继续地拓展", "而无序的部分会继续地缩减", "整个呈现为一个", "不断此消 绿色的这部分", "和彼涨 红色的这部分", "这样一个过程", "直到什么时候呢？", "直到无序的部分只剩下一个元素", "不难看出 每一趟对bubble的调用", "所需要的时间都线性正比于", "绿色无序部分的宽度", "整体地呈现为一个算术级数的形式", "所以它的总体量", "与它的末项成平方关系", "然而这里我们", "并不满足于这样的结果", "至少在很多情况下", "都是有可能改进的", "我们可以看到", "这里的红色部分", "确实必然是有序的", "但是绿色的部分未必都是无序的", "事实上比如说", "我们以这个时候为例", "有可能其中会有一部分元素", "甚至所有的元素都是有序的", "为了记忆 不妨考虑", "西瓜这样一个例子", "皮是绿的", "但是打开它 就会发现", "其实它的内部是红的", "我们所谓绿色的无序的部分", "确实有可能出现这种情况", "那么 我们如何尽早地", "判定出这种情况", "从而提前结束这个算法呢？", "这里依赖的准则", "与算法最初的判定准则是一样的", "也就是说", "一个向量包括一个区间", "如果是完全有序的", "当且仅当其中任何一对相邻的元素", "都是彼此顺序的", "而实际上", "在刚刚进行完的前一次迭代中", "我们在某种意义上讲", "已经做过这种类似的检查了", "由此我们可以得出一个改进的策略", "我们在每一次扫描交换的过程中", "不妨记录一下", "是否曾经真的存在逆序元素", "那我们也知道 如果存在的话", "它的充要条件是", "在此前做过一次交换", "所以我们只要来记录一下", "在当下这趟扫描交换过程中", "是否曾经做过至少一次扫描交换", "如果没有做过", "那么后续的各趟", "其实都可以省略掉", "从而在实际的运行时间上", "有可能会有所减少", "甚至大大减少", "是的 这是一个很好的策略", "我们不妨把这个策略", "整理为这样一段代码"]}, {"name": "08B3-6\t最小高度", "block_id": "d45f2fb4264f477cb3db957e47c36b5c", "text": ["采用类似的方法 我们也可以对B树的高度给出一个下界", "我们的问题完全对称 当阶次规模确定时 B树的高度最小不过多少", "同样的 为了使全树的高度最低", "每个内部节点所包含的关键码 就应该尽可能的多", "形象的说 他们都应该尽可能的胖", "当然这种胖必须符合B树的规则", "也就是说 分支数不得超过m", "因此尽管根节点只能有1个 但它却可能拥有m个孩子", "而这m个孩子呢 可能又分别各自拥有m个孩子", "以至m平方个孙子 如此类推", "接下来 同样来考察外部节点所在的最后一层", "由上类推 我们可以得到外部节点数的一个上限", "而另一个方面 此前的这个恒等式也依然成立", "至此只需忽略掉起临时桥梁的nh 并略作调整", "即可得到这样的一个不等式", "在渐近的意义下 这个下界依然是log以m为底N的对数", "同样的 为了体验阶次数m对计算成本的影响", "我们不妨以256阶B树为例 经过简单的估算不难发现", "相对于规模相仿的BBST 256阶B树的高度尽管有所下降", "但是充其量不过下降到1/8", "是的 1/8 你应该记得", "B树的高度上界在O的意义下也渐近的应该是log以m为底N的对数", "综合起来 我们可以得知 当关键码总数固定时", "B树高度的上下浮动范围是非常有限的", "或者等效的说 其高度几乎不发生变化", "此前我们也曾估算过 相对于同等规模的BBST", "256阶B树的高度至少也应降低至1/7", "这两个数值相差不大", "这也具体的验证了B树的高度变化幅度有限这一事实"]}, {"name": "07B3-1 删除：框架", "block_id": "6c5debe2317445868f1e0bfd3aa3bd10", "text": ["相对于节点插入操作", "BST的节点删除操作要略微复杂一些", "在此我们不妨先给出整个算法的主体框架", "可以看到 首先也需要针对目标", "做一次查找定位", "而且与插入操作正好对称", "我们这里需要忽略的是", "元素尚不存在的情况", "反过来 如果这个元素的确存在", "我们就会调用一个名为removeAt的", "内部例程来真正地实施删除", "当然接下来 同样要更新全树的规模", "同时更新相关祖先的高度", "就运行时间而言", "如果暂时忽略掉removeAt接口", "整个算法的时间消耗", "依然主要集中于search", "以及updateHeightAbove这两个例程", "所以同样地 这些时间累计而言", "也不会超过全树的高度h", "那么接下来的问题就是removeAt", "可能需要处理哪几种情况？", "各种情况又当如何具体地应对呢？"]}, {"name": "06D-7 嵌套引理", "block_id": "a184af94901d4a7281af116c819d91fc", "text": ["通过dfs搜索", "为所有顶点所标注的两个时间标签", "实际上蕴含了大量有用的信息", "这一点可以由所谓的括号引理", "或嵌套引理来加以印证", "为此 我们首先要引入", "所谓活动期的概念", "也就是由它的dTime和fTime", "两个时间标签", "所界定的那样一段时间范围", "也就是这个顶点在整个dfs搜索过程中", "处于活跃状态的时间范围", "那么所谓的嵌套引理", "告诉我们任何有向图", "经过了dfs搜索之后", "在对应的dfs森林或者dfs树中", "任何一对顶点之间", "存在直系的血缘关系", "当且仅当它们的活跃期存在", "包含与被包含的关系", "具体来说", "祖先的活跃期必然包含", "后代的活跃期", "而反过来 如果两个顶点之间", "没有任何直系血缘关系", "那么它们的活跃期", "也是彼此互不相交的", "为了获得对这个引理", "更为直观的认识", "我们不妨以横向作为时间轴", "依然以刚才的那个有向图为例", "我们可以将每个顶点", "都沿水平方向适当展开", "使得它们恰好覆盖", "各自所对应的活跃期", "于是就不难看出 作为祖先", "它的活跃期的确会覆盖它的后代", "而后代", "也将继续覆盖它的后代", "以致后代的后代", "而反过来 没有直接血缘关系的节点", "比如说F和B", "或者B和G", "以致D和F", "或者B和E", "它们的活跃期都的确彼此不搭", "没有任何公共的部分", "这样一种特性是非常强大的一个工具", "比如在算法中 我们经常需要", "做的一个判断就是", "任意的一对顶点 v 和 u 之间", "在遍历树中是否存在", "一个直系血缘的关系", "如果没有这样一种简便的机制", "我们将不得不从 u 出发", "顺着parent引用", "不断地溯流而上", "直到有一天遇到顶点v", "才能够确定它们的确存在", "祖先和后代的直系关系", "或者不得不一直追溯到", "整个遍历的起点", "从而断定u和v之间并没有直系血缘关系", "而现在呢 借助时间标签", "我们可以快速准确地", "在O(1)的时间内", "就得出相应的结论", "这种机制所带来的更多便利之处", "还需要同学们", "在实现相关算法过程中", "不断地深入体会"]}, {"name": "03A-4\t 实现", "block_id": "944516af8eee4fb7b24f2568a655c300", "text": ["我们的列表结构", "是由列表节点作为基本单位组成的", "所以这里呢", "我们首先要定义并且实现列表节点类", "并且将它尽可能独立地封装起来", "那么相应的呢", "可以定义这样一系列的操作接口", "我们来看看predecessor", "取一个节点的前驱", "以及successor 来取它的后继", "以及常用的data 取其中的数据域", "还有包括我们可能会将某个元素", "作为当前这个节点的前驱或者后继", "插入到它所属的那个列表中去", "这样的一组ADT接口", "如何用C++的语言来进行定义", "实现并且封装呢？", "我们来看一种可行的实现方法", "首先定义一个名为", "ListNode position的类型", "虽然严格地来说 它还不是类型", "好", "接下来 定义ListNode这样一个类", "这个类包括data一个数据域", "以及predecessor和successor两个引用", "以及正如刚才所说的那样", "提供前驱插入和后继插入 两个操作接口", "当然也包括构造函数", "从逻辑上看", "每一个节点都可以表示为这样的一个形式", "中间是一个data", "向前和向后分别有一个逻辑上的应用", "在给出列表结构的具体实现之前", "我们首先定义一组", "它所应该提供的操作接口", "仔细看会发现", "它的接口的形式以及对应的功能", "与我们在第二章中所学过的向量", "也就是Vector结构颇为类似", "我们这里就不花更多的时间逐一再展开", "好在后边相应的各节", "将对它们的功能和实现 再做详细的介绍", "好 接下来我们就来看列表", "也就是List这种模板类的具体定义", "首先 我们要引入刚才所实现的列表节点类", "接下来 我们可以看到", "所谓的List这种模板类", "也是分为三个层次", "其中private 私有的层次 与向量类似", "记录的都是那些对外不可见的部分", "具体包括规模、引入两个哨兵节点", "另外 也包括一些内部的功能函数", "以及刚才我们所定义的", "那些对外开放的标准的ADT接口", "那么在这 我们只是给出了一个主体的框架", "我们这里再强调一下", "如果大家有兴趣", "你愿意在这个电子版的讲义上", "要进行阅读的话", "那么保持你的电脑是连线的", "接下来 只要点击这个或者是这个", "就可以打开相应的源码 就像这样", "在课堂上 我们都忽略掉一些细节", "同样 因为后面还会逐一地介绍这些接口", "而这里我们主要是要来领会", "它的宏观的结构", "这样的一个宏观结构", "可以用下面这幅图来表示", "我们可以看到 任何一个List结构", "都会与生俱来地拥有一个叫作header", "以及另一个叫作trailer的哨兵节点", "header和trailer对外是不可见的", "当然我们后面会看到 它们的作用非常巨大", "而对外可见的部分呢", "我们说主要是介乎header", "和trailer之间的这样的一系列的元素", "其中 如果存在的话", "第一个元素 也就是firstNode", "我们称作首元素", "而最后一个last 我们称作末元素", "那么相应的呢", "我们也把这个名字规范一下", "称header叫作头元素", "我们称trailer是尾元素", "尾巴的尾 尾元素", "所以大家记清了头和首 末和尾", "在至少我们这个课程中 讲的都是不同的", "而且是确定的概念", "那么它们之间的联系", "可以在这里强调一下", "头节点和尾节点是与生俱来的", "而且二者并不相同", "first和last并不见得不相同", "甚至不能保证它们存在", "但是对外而言first、last是可见的", "而trailer和header", "这两个哨兵都是invisible", "也就是说 不可见的", "当然从秩的角度来看", "一个长度为n的列表中", "头、首、末和尾这四个节点的秩", "可以分别理解为", "是等于-1、0、n-1以及n", "如此定义的一个列表结构", "可以按照这样的过程来创建", "可以看到 首先要为header", "和trailer分别地分配一个节点", "使它们真实的存在", "接下来 要将它们的后继以及前驱引用", "分别指向对方", "从而实现这样一个互联的效果", "当然逻辑上看", "这个时候 我们所谓对外可见的那个列表", "实际上是没有任何元素的", "对应的就是一个空列表", "而在接下来的几节里 我们将会看到", "我们可能会在其中插入一些元素", "以及再插入一些元素", "也可能时不常地从中删除", "或者是修改某一个元素", "总而言之", "这个列表将有可能会包含", "一些实在的、对外可见的节点", "我们在后面再来看这些操作", "是如何具体实现的"]}, {"name": "10c-1:\t算法", "block_id": "c35442a3a115472384b661c06889afc7", "text": ["作为完全二叉堆的一个应用，我们这一节来介绍堆排序算法。", "是的，谈到优先级队列，我们很自然地就会联想到排序，", "因为就功能而言，包括完全二叉堆在内的任何一种优先级队列都天生地具有选取功能，", "也就是选取其中的最大元。", "因此，我们很自然地就可以联想起选择排序。", "你应该还记得这样一张插图，我们曾经用它来解释选择排序的原理及过程。", "不妨温习一下，在选择排序算法中，我们始终将整个序列分为两部分：", "也就是左侧的待排序部分以及右侧的已排序部分，", "而且前者中的任何一个元素都不大于后者中的任何一个元素。", "因此我们只需反复遍历待排序元素，从中选出最大者，并将它加入到已排序的子序列中。", "是的，正因为我们每次都需要对待排序的部分作遍历，从而导致每次选取都需要线性时间，", "以致整个算法需要平方量级的时间。", "究其原因，可以理解为我们当初对数据结构的理解和掌握还非常有限，", "以致于我们还只能够通过一些简单的数据结构来组织待排序的元素。", "而经过了一段时间的学习之后，我们已经今非昔比，", "我们可以运用更为高级的数据结构来组织这些待排序的元素，", "从而实现更高的选取效率。", "比如，联想到我们刚刚学过的内容，我们就会很自然地想到用一个完全二叉堆", "来取代我们此前简单的线性结构。", "如果暂时忽略底层的具体实现，我们就会发现整个算法的流程可以基本保持不变，", "此前在预处理阶段对整个线性队列的初始化，在这里则对应于建堆操作。", "我们刚刚介绍过，若采用Floyd算法，这一步只需线性时间，", "接下来我们需要反复地取出最大元，也就是整个堆当前的堆顶，", "我们知道，delMax操作每次只需log(n)的时间。", "没错，log(n)，而不再是n。", "因此，整个算法的复杂度，也就应该是nlog(n)，", "而不再是n^2。", "当然，此前的不变性依然保持，也就是待排序的部分都不超过已排序的部分，", "因此算法的正确性依然可以得到保证。", "那么难道这个算法就是这样的平淡无奇？", "不是的，事实上堆排序的奥妙还不止于此，", "比如在空间复杂度方面，堆排序算法还可以做得更好。"]}, {"name": "09C-3 整除留余", "block_id": "aa67d0e6d937420d8dfd791448e53379", "text": ["我们所设计的第一个散列函数 使用的是所谓的除余法", "实际上我们对这种方法应该并不陌生", "是的 在此前清华大学校园电话簿那个应用实例中", "我们所采用的正是这种散列方法", "当然这里有一个问题 你应该还记得当时的表长", "也就是这里取模余的基底 是取做90001", "为什么取这样一个有点古怪的数字呢", "是的 这个数字的确有些古怪", "因为照常理 我们或许会选用一个更为规整的数字", "比如熟知二进制的你 很有可能会选取2的若干次方", "你甚至会发现 如此可以更加高效的来计算散列地址", "因为此时M的二进制展开", "应该是1后面接1个2个3个直到第k个0", "而此时 相对于M的模余计算", "也就等同于相对于M-1的位与运算", "是的 就计算效率而言 的确如此", "然而就我们刚才所确立的第四条原则 也就是均匀性而言", "这种方法却是非常糟糕的", "因为在整个关键码的取值空间中 存在某个特定的子集", "该子集中的每一个元素", "都会统一的映射到散列表中的某一个特定单元", "而不是均匀的分布于整个散列表中", "实际上 M的每一个同余类 都是这样的一个实例", "放弃这些形式极其规整的表长", "映射的均匀性的确会有所改进", "但这还不是根本的办法", "一种最为简明的策略 莫过于将表长取作为素数", "此时 不仅数据对散列表的覆盖程度能够达到最充分", "而且在散列表中的分布 也将达到最均匀", "我们不妨从一个角度来理解这一点"]}, {"name": "10xa2-3: 实现", "block_id": "f40a135fdd344e53b1208df06a1c6c33", "text": ["现在，我们就来将刚才的算法原理兑现为具体的代码，", "比如这就是一种可能的实现方式，可以看到这是一个递归式的算法，", "作为递归基，总共有两种情况，对应于待合并的堆中至少一个为空的情况。", "事实上只要其中一个为空，我们就直接返回另一个即可。", "因此当算法执行到这一句的时候可以确认两个堆都不是空，", "此时我们要比较两个根节点在数值上的大小，如果有必要应将二者互换名称，", "从而保证在数值上a总是不小于b，以便在后续递归的过程中将b作为a的后代。", "接下来是核心的一步，我们需要递归地将a的右子堆与b进行合并。", "得益于递归的机制，接下来我们就可以假设这次合并的确完成，", "因此接下来我们要在a及其新的右子树之间建立起正确的连接，", "在完成这样的拓扑连接之后，我们还需要进一步确认a满足左倾性，", "也就是说就NPL而言，如果当前的左子堆要小于右子堆，则需要将二者互换位置，", "最后我们还需要根据NPL定义即时地更新a的NPL值。至此，算法方可顺利返回。"]}, {"name": "02C-3 插入", "block_id": "2ff3387ebf214cca85879947144b6a77", "text": ["再来考察向量的插入算法", "具体来说 也就是", "如何将某一个特定的元素", "插入到向量的特定位置", "在原来向量中", "因为所有的元素", "都必须是紧邻排列的", "所以为了能够插入新的元素", "我们需要做一个调整", "也就是将对应这个位置之后的", "所有的那些元素", "称作它的后继", "整体的呢 构成一个后缀", "进行一个整体的右移操作", "这个right shift操作 效果就是", "所有的后缀元素都向右", "也就是向后 移动一个单元", "从而空出一个单元", "此时才可以将", "指定的那个元素纳入其中", "从而完成插入", "整个算法", "可以描述并且实现如下", "具体来说", "刚才我们所说的右移操作", "可以通过这个for循环完成", "每个元素确实都是后移一位", "当所有的后移完成之后", "我们再将新的那个元素", "纳入到这个rank所指的位置上", "当然同时还要更新", "整个向量的规模", "那么需要解释的有两个问题", "第一个问题 大家注意到", "在这个地方 for循环的方向", "是从最后一直向前", "不断地递减", "也就是说", "整个的移动的方向", "虽然是向右", "但是所有元素移动的", "先后次序却是后优先的", "我们用图来表示 也就是", "最后这个元素先移动", "接下来 是次后这个元素", "再往前 这样一直一直", "直到最前面的那个元素", "我们说这是必要的", "如果把这个次序颠倒过来", "会怎么样？", "会有危险", "也就是说 会出现数据", "在无意中被覆盖的问题", "第二个需要解释的情况", "就是大家注意到这一句", "这里有一个expand()", "也就是我们所说的扩容的操作", "现在大家可能已经注意到", "它的必要性了", "因为确实在某些时候", "这个向量可能已经是满载了的", "所以为了插入新的这个元素", "我们在后移的过程中", "必然会出现", "我们曾经讲过的上溢", "在这种时候需要", "对它进行扩容处理", "比如说", "按照前面推荐的方法", "加倍处理", "这样一件事情", "完全由expand()完成"]}, {"name": "08B4-1\t算法框架", "block_id": "ddd812420fe24c11ad4e6990f1e4fb5f", "text": ["在了解了B树的查找算法及其效率之后", "接下来一个自然的问题就是", "B树的动态操作 又当如何高效的实现", "以下 我们首先来讨论它的插入算法", "假设经过查找", "我们确定需要在这个节点的这两个关键码之间", "插入一个新的关键码", "也就是说 从逻辑上看", "这个节点需要变成上面这样的一个形式", "这个深色的节点正是我们希望插入的关键码", "那么 这样一个转换的过程应当如何实现呢", "我们来看一种可能的实现方法", "首先 我们要调用B树的查找算法 并且不妨假设", "经过查找之后 可以确定该关键码尚不存在", "于是根据我们的语义约定", "这次查找最后应该终止于一个由_hot所指向的真实节点", "你应该记得 _hot所指向的应该是位于最底层的一个叶节点", "也就是图中的这个节点", "于是接下来 我们进一步在这个节点的关键码向量中查找", "以确认新的关键码究竟应该插入在哪个原有关键码的后边", "请特别注意 这里的search是向量的接口", "而这个search 则是B树的查找接口", "于是 根据向量查找操作的接口语义", "它的确会返回不大于目标关键码的那个最大的关键码", "因此 如果返回的秩为r", "我们自然就应该将新的关键码", "作为第r+1个元素 插入向量当中", "从图中所示的逻辑次序而言", "也就是 紧随于插入位置之后 插入在这里", "在关键码增加一个之后 分支数也需要相应的增加一个", "你应该还记得 我们建议的画法", "也就是让关键码向量", "与分支引用向量 如此交错的对齐", "如此 便可清晰明了地显示", "每个关键码及其对应的左右分支", "这里 为了理解的方便 我们不妨认为", "因为这个新的关键码的插入 而引入的新的分支", "就是该关键码的右侧分支", "这也是为什么我们在r+2的位置上插入一个新的分支", "当然 新的这个分支目前为空", "其实 稍加观察 不难发现", "既然此时的这个节点 是位于底层的叶节点", "因此 其下属的分支", "无论是此前的 还是新引入的 都应该是空", "因此 一种更为简明的方法是", "直接在分支向量的最后插入一个空分支", "这种方法 与这里给出的方法完全等效", "只不过稍微费解而已", "接下来 如果没有什么特殊情况发生", "我们只需动态的更新全树的规模 即可成功的返回", "然而不幸的是 在引入了一个新的关键码之后", "当前这个节点 可能会违反B树的约定", "也就是因为其下属的分支增加了一个", "从而导致分支总数超过了B树的阶次m", "因为新关键码的引入", "而导致所属节点的分支数超过B树阶次的情况", "称作上溢 overflow", "这样的一种非法情况 必须及时处理", "为此 我们需要借助一种技术 称作分裂"]}, {"name": "09B-2 循值访问", "block_id": "4bb5e3a219dc4bf0ad8e55a6c36a5493", "text": ["这种巧妙体现在两个方面", "其一 通过这样一种形象生动而友好的方式", "不仅可以使得你便捷的记住这个电话号码", "同时更重要的是 你能记住它是这家公司的电话号码", "另一方面 只要你能够辨识26个英文字母", "你就可以通过这种方式来进行拨号", "而你的每一次拨打 依然对应于一串数字", "整个的电话服务系统除了需要引入一种扩充之后的键盘", "无需做任何更多的改造", "比如 当你按照这样的提示去拨打时", "你所拨打的电话号码实际上依然是由数字组成的", "实际上在这样一种巧妙的变换技巧背后", "是某种深刻的思想", "我们不妨就访问数据的方式来做一对比", "你应该记得对于不同的数据结构", "我们在此之前都根据其如何访问数据 进行过分类", "你应该还记得有寻秩访问", "call by rank 比如向量", "再如 寻位置访问 call by position", "这方面的典型例子是列表 list", "而以BST为典型代表的这类数据结构呢", "都属于寻关键码访问 也就是call by key", "反观我们这里对电话号码的访问", "如果说我们这里访问的对象是公司的服务", "那么刚才这种获取服务的方式 又属于其中的哪种呢", "首先这种方式既不是寻秩 也不是寻位置访问", "这是因为所有的公司的各项服务之间并不存在某种线性次序", "那么它是寻关键码访问吗", "这里的确有关键码", "也就是每个服务所对应的那个电话号码", "然而即便你是按照刚才的方式去拨打某个特定的电话", "在整个过程中", "在你的脑海里除了那个公司和服务的助记符号之外", "完全可以不出现任何形式的数字电话号码", "因此 这也不属于寻关键码访问的方式", "那么我们刚才实质访问的是什么呢", "是的 也就是你所需要找到的那个对象本身", "我们称之为value 数值", "因此我们不妨将新的这种访问方式称作寻数值访问", "call by value", "我们刚才已经领略到了这种新的访问方式的威力", "是的 若能加以充分利用", "这种访问方式将使我们的计算效率进一步得以提高", "而这样的一种典型的技巧 就是所谓的Hashing", "中文可以根据含义 译作杂凑", "也可以根据发音 译作哈希", "在这里不妨采用一种折中的译法 也就是散列", "那么具体什么是散列呢"]}, {"name": "09D2-2 一利一弊", "block_id": "d74938aa43df4de78e4ad05a3bc5ff8c", "text": ["是的 相对于线性试探", "平方探测的确可以在很大程度上缓解数据聚集的现象", "这得益于我们此前的构思", "仍然 从这副图上我们可以看出", "按照这种策略 相邻试探位置之间的间距", "将按一个算术级数不断的递增", "也就是说 一旦发生冲突", "这种策略将会聪明的以一种不断增加的速度跳离这个是非之地", "理论上更为详细的分析以及实验的统计都证明了这一点", "当然任何事情都是一利一弊", "为此我们也可能需要付出一定的代价", "因为相对于线性试探策略", "平方试探策略将在一定程度上破坏数据访问的局部性", "在某些时候 可能会导致IO访问的激增", "在一些极端的情况下 系统的缓存功能也将失效", "不过好消息是 在通常的情况下问题还不算很严重", "我们不妨就此做一个估算", "我们知道 在通常的情况下", "缓存页面的规模都在若干个KB左右", "不失一般性 这里不妨就取做1个KB", "如果我们的桶单元只记录相应的引用", "那么大致只需要4个字节", "每一个缓存页面都足以容纳至少256个桶单元", "也就是16的平方", "也就是说 如果我们需要做一次额外的IO兑换", "必须连续的发生16次冲突", "果真如此 我们只能说自己的运气太糟糕了", "就这个意义而言 我们也可以说", "平方探测所增加的试探位置间距是适度的", "当然试探位置间距的加大 又会引来一个附加的问题", "你能看出来吗", "没错 从直观上看", "这样一种方式已经不再是逐个的去试探", "因此我们或许会怀疑是否会出现这样一种奇异的现象", "也就是在散列表中明明还存在空桶", "但是按照这种策略却永远不能发现"]}, {"name": "11e3-2: \t各算法纵览", "block_id": "5d00ee2dba0945008be9198297bd8291", "text": ["在结束本节之前 让我们通过这样一组图", "来对串匹配的各种典型算法在性能上作一对比", "这里的纵轴表示运行时间", "而这3个标尺", "由低到高 分别表示n/m n+m 以及n*m", "正如我们已经知道的", "对于蛮力算法而言", "在最坏情况下的运行时间将达到最多的n*m", "然而我们也曾指出", "蛮力算法在最好情况下的运行时间 也大致在线性的幅度", "而在这两种极端情况之间", "最大的一个影响因素", "实际上是某个概率", "也就是所谓 单次比对的成功概率", "就蛮力算法而言", "这个概率越高", "它也就越容易误入歧途", "从而导致非常高的时间复杂度", "反过来 在这个概率并不是很高的时候", "蛮力算法的性能将很自然地接近于线性", "实际上 在通常的意义上", "决定这一概率值的最大因素", "莫过于字母表本身的规模", "实际上 单次匹配成功的概率", "大致与字母表的规模成反比", "我们再来看KMP算法", "我们已经证明", "无论在什么情况下", "它的性能都始终稳定在线性的水平", "由此可见 只有在字母表规模非常小的情况下", "KMP算法相对于蛮力算法在性能上的优势才会充分地体现出来", "这幅图是仅采用bc策略的BM算法", "我们可以看到 它非常适用于大字符集", "当单次匹配成功的概率极低时", "它的性能将接近于O(n/m)", "当然 在字母表规模很小时", "bc策略依然很容易误入歧途", "从而导致极高的 O(n*m)的复杂度", "而只有在将bc策略与gs策略联合使用时", "二者才可以相得益彰", "可以看到 联合使用这两种策略", "在最好情况下我们依然可以实现O(n/m)的运行时间", "同时 bc策略的缺点也会得到有效的抑制", "并保证在最坏情况下", "运行时间也不超过线性", "我们也可以从性能的维度", "从最低到最高", "划分为3个阶次", "这是蛮力算法", "它在最好情况下", "也不过线性", "而在一般甚至最坏情况下", "它都需要O(n*m)的时间", "这里是bc策略", "可以看到 它的性能变化幅度极大", "从最好的O(n/m)一直到最坏的O(n*m)", "而KMP在这儿", "可以看到 它是中规中矩的", "始终保持线性的时间复杂度", "最后是融合了bc和gs两种策略的BM算法", "我们可以看到 在最坏的情况下", "它也只需线性的运行时间", "而在最好的情况下", "它甚至可以达到O(n/m)"]}, {"name": "02C-7\t 唯一化", "block_id": "51f92c752cc149dda6d908f434e8624d", "text": ["再来考察无序向量的", "唯一化问题", "也就是说，我们要把", "其中重复的元素都剔除掉", "使得每一组重复的元素", "只保留一个拷贝", "这样一个问题", "在很多实际的应用中", "都能够找到影子", "比如说，在网络搜索的环境中", "有很多个不同的结点", "所分工完成的局部的搜索结果", "可能会含有大量的重复的元素", "我们需要将其中", "重复的元素剔除掉", "从而得到一份记忆完整", "同时又不冗余的搜索报告", "这样一个算法大致可以", "通过这样的一个图示", "来表示它的原理", "也就是说，如果这是一个向量的话", "我们总是把它分为三个部分", "以当前的这个元素为界", "当前这个元素自己是一部分", "它的前驱所构成的", "那个前缀是一部分", "以及对称地，所有的", "后继是一部分", "每一次我们遇到一个", "新的元素", "都在它的前缀中去进行查找", "我们说过，这是可以", "通过find操作来完成的", "如果能够找到雷同的元素", "比如说，在某个位置上", "出现了一个x", "就可以把这个元素剔除掉", "反之，经过查找以后", "如果这个元素没有出现", "那么我们就可以", "大胆地把它保留下来", "同时再去考察它的", "下一个元素", "这样的一个算法的思路", "可以很好地兑现为这段代码", "在这里，最主要的是", "这样一个循环", "控制变量i", "实际上对应的", "就是我们当前这个元素的秩", "初始值是1", "也就是说，初始的情况下", "是从第一号元素", "而不是第零号元素开始的", "第一个考察的是它", "每一次考察的是什么呢？", "就像我们刚才所说的那样", "在当前那个向量里", "在零到i的这个区间中", "这不就是它的前缀吗？", "去查找第i个元素", "如果查找之后", "得到的那个秩是合法的", "也就是说，它至少", "小于(误)等于它的右边界", "那么就可以认为", "确实存在这么一个元素", "这个时候我们要把", "这个元素给删除掉", "如果反过来经过查找以后", "得到的是一个非法的秩", "那么就说明查找失败", "换而言之", "比如说，这个x就不存在", "这个时候我们说", "可以坦然地将它保留", "并且继续考虑下一个元素", "这也就是为什么", "我们简明地做一个", "i++就可以了", "当整个这个过程执行完之后", "我们说，就得到了一个", "去重之后的向量", "这样一个过程", "非常的形象，也很好理解", "但是严格地说", "我们如何来证明", "这个算法是正确的呢？", "也就是说，我们如何给出", "这个算法正确性的", "一个严格证明呢？", "我们下面就来回答这个问题", "这里我们再次以这个问题为例", "展示一下如何通过挖掘算法", "所具有的不变性和单调性", "来证明一个算法最终的正确性", "我们先来看这个算法的", "不变性", "我们会发现，在这个算法", "运行的任何一个时刻", "如果当前所对应的", "是第i个元素V[i]的话", "那么在它所对应的那个前缀中", "所有的元素必然是彼此互异", "也就是说，不包含重复元素", "我们可以看到", "在算法最初的时候", "i 是等于1", "所以它的前缀", "只有V[0]一个元素", "单个元素自然没有办法", "构成什么重复的元素", "所以这个是显而易见的", "那么其余的一般情况下呢", "我们可以用数学归纳法", "来予以证明", "假设当时的状态", "是第i个元素e", "它的前缀是", "从0到i的区间", "如果按照数学归纳法", "我们假设在此前", "确实不变性是成立的话", "那么接下来，无非两种情况", "也就是当前的这次对应的", "查找成功或者失败", "如果是失败，也就是说", "在它的前缀中不含元素e", "我们刚才的算法，给出的处理方法", "是直接令i++", "也就是无形中", "我们已经指向了", "它的下一个元素", "而将刚才那个元素e", "归入了新的这个前缀中", "我们可以看到", "既然e和此前的那些前缀", "是互不重复的", "所以将e", "归入这样的一个区间以后", "这个区间必然", "依然是不含重复元素的", "反之，如果e", "即便出现在它的前缀中", "按照刚才的算法流程", "我们也会将它剔除掉", "也就是通过删除操作", "使得后继的元素", "整体地向前移动", "从而使得原先", "它的直接后继", "变为当前的这个元素", "并且算法继续地运转下去", "经过了这样一次迭代之后", "当前的这个元素虽然换了", "但是它的前缀并没有换", "这个前缀所具有的", "那样一个性质", "也就是元素互异的这个性质", "也依然会保持下来", "所以我们说，在算法的", "每一次迭代过程中", "只要前一次迭代是", "满足不变性的", "那么后一次迭代中", "这种不变性", "必然会持续地保持下去", "那么最终会到什么情况呢？", "我们说最终", "无非是覆盖整个向量", "到那个时候", "我们所说的当前的元素", "其实就是最末尾的", "那个哨兵元素", "而它的前缀其实就是", "整个这个向量", "那么它的前缀中", "不包含重复的元素", "其实也就相当于", "整体的向量中不包含", "重复的元素", "这正是我们这个算法的功能", "唯一化所要求的", "所以在最终这个不变性", "必然会转化为", "我们所需要的正确性", "好了，那么我们还差第二步", "就是来证明一下", "这个算法同时是具有", "某种单调性的", "从而保证它必然会终止", "我们可以看到，这个算法的主体", "是由一个while循环构成的", "我们说，虽然经过一次", "while循环之后", "对应的前缀的长度未必会增加", "但是这个向量中", "有效的元素必然会", "单调地下降一个单元", "具体来说，也就是", "我们还没有处理", "留待处理的", "当前这个元素的后继", "它们的个数必然会", "严格单调地下降", "直到最终，我们也可以看出", "最多经过线性步", "最终将至零", "也就是所有的元素", "都被检查并且处理过了", "所以我们可以得出结论", "这个算法也必然会终止", "而且在终止之前", "最多迭代循环O(n)轮", "由此我们就很好地确立了", "这个算法的正确性", "这也是一个相对严格地证明", "那么准确地说", "刚才这个唯一化算法的", "复杂度又是多少呢？", "我们可以看到这个算法", "确实是由while循环", "作为主体构成的", "而在while循环中", "真正能够造成有效复杂度的", "无非是find操作", "和remove操作", "其中find操作", "是对于当前的", "元素的整个前缀而言的", "而remove操作恰好对称", "是相对于当前", "这个元素的后继而言的", "所以换而言之", "每一次while循环所需要的成本", "也就是find和remove", "两类操作的成本", "累计起来也不会超过", "整个向量的长度", "也就是我们所说的", "O(n)线性步", "每一次while循环", "只需要O(n)的时间", "而刚才我们讲过while循环", "最多会迭代O(n)", "所以这个算法累计起来", "最多不超过O(n)平方的时间", "这也是最坏情况", "当然我们如果对", "这个算法的效率不够满意的话", "还可以做进一步地优化", "这里我们罗列出了几种", "可行的优化的方案", "限于时间的关系", "我们把这个留给大家在课后完成"]}, {"name": "09C-4 以蝉为师", "block_id": "9421353e043a42c18eac495cb53fc842", "text": ["我们知道在实际应用中", "我们所处理的数据通常都具有一定的局部性", "其中一种典型的现象是", "数据序列中的数据项 大多是按某一步长单调变化", "想想你在程序中常写的while或者for之类的循环", "就应该不难理解这一点", "如果数据序列的步长为S", "我们来考察S与M的最大公因子 将其记作G", "假设这就是散列表的地址空间 其长度为M", "而你的数据序列呢 将从某一个位置开始", "以S为间隔 逐次的转入下一项 以及再下一项", "当然如果你的数据序列足够长", "它就有可能会从另一端回到这个空间", "并且继续以S为间隔 在散列地址空间中逐次访问下去", "现在考察这个数据序列在散列地址空间中留下的足迹", "这些足迹能够遍历整个散列表空间吗", "如果能 那么这种散列方法就具有均匀性 反之就不具有", "借助数论的知识不难知道", "数据序列的足迹能够遍布整个散列表", "当且仅当刚才这个最大公因子等于1", "请注意 因为可能有不同的程序", "而每个程序的每一次运行所对应的这个步长", "必然未必相等", "也就是说 这里的M", "相对于几乎任何S最大公因子都只能是1", "这意味着什么呢", "意味着M应该是一个素数", "很有意思的是 很多动物 包括一些昆虫都懂得这个道理", "在这里我们再次向蝉学习 学习它的哲学", "没错 蝉的哲学", "昆虫学告诉我们 蝉有很多变种", "每一个变种都有其固定的生命周期", "比如有些蝉是13年 而有些却是17年", "那么蝉是否有某一个子类寿命是14年15年甚至16年呢", "据我所知 没有", "为什么没有呢", "不妨回到我们的散列表", "实际上 每一只蝉的生命周期", "都可以对应为一个散列表", "蝉的寿命有多长 散列表也就有多长", "所以有些种类的蝉所对应的散列表长度为13", "有些对应于17", "当然也可能是11等等这类的素数", "我们知道在自然界蝉是弱势群体", "它有很多天敌 无论是螳螂还是螳螂之后的那只黄雀", "每一种天敌大致也有一个自己的生命周期", "这就相当于我们这里的步长S", "没经过S年 蝉的天敌都会更新一代", "当然 蝉不能去改变弱肉强食的法则", "它唯一能期望的 只能是 在同一年  不要遇到更多的天敌", "相应的 反过来 所有的天敌都应该在每一年分布的更加均匀", "这更有利于蝉作为一个物种得以在自然界延续下去", "用数学的语言来说 如果蝉能够选择自己的生命周期", "那么自然的就应该选择与天敌的生命周期保持最大公约数为1", "而为了与更多的天敌在生命周期上保持这种关系", "尽管蝉有不同的变种 但是在经过长时间的进化之后", "每一个变种都会聪明的将其生命周期设定为素数", "正像我们所看到的那样 取做17 13等等"]}, {"name": "08B3-1\t算法过程", "block_id": "ddcbb22010534037b448ab2f5afe417c", "text": ["在给出了B树的结构定义之后", "接下来的一个话题自然就是", "如何才能充分的利用它 并且有效的维护它", "首先来看如何在B树中有效查找", "假定这就是一棵B树 我们此前曾经讲过", "B树中所存放的词条数量极多", "以至于不便完全容纳在内存中 甚至根本不能由内存容纳", "因此我们假定它相对的只能存放在速度更慢的外存之中", "我们将会看到 所谓B树的查找", "其诀窍在于只需要将必须的若干个节点载入内存", "也就是说 通过这种策略可以尽可能的减少IO的次数", "当然 对于一棵处于活跃状态的B树而言", "不妨假设它的根节点已经常驻于内存", "现在假设我们需要在这棵树中 查找特定的关键字key", "于是我们首先会在常驻于内存的这个根节点中进行一次查找", "你应该记得 每个节点中的关键码均已存成一个向量", "因此我们这里实施的无非是一个顺序查找", "如果能够在某个特定位置命中 我们的查找随即以成功告终", "因此我们不妨再来看如果查找失败 又当如何处置", "假设失败于一个特定的位置", "我们知道在这个特定位置 应该预先已经记录了一个引用", "这个引用将会指向B树中下一层的某一个节点", "是的 因此我们继而可以沿着这个引用 找到下层的那个节点", "并且将它载入到内存之中", "也就是说 我们的查找深入一层", "而代价呢 是做了一次读入性的IO操作", "当然 既然我们已经搜索到这样一个节点", "就可以断定 如果目标关键码的确存在于这棵树中", "那么就必然存在于这个节点所对应的子树中", "于是我们继续在这个新载入的节点中进行一次查找", "请注意 借助向量结构 我们在此只需进行一次顺序的查找", "同样 我们可能在某个位置命中 从而成功的返回", "而反过来 如果在这个节点中的查找以失败告终呢", "此时我们在新的这个节点中 也必然会停止于某个适当的位置", "而且在这个位置 必然也预先记录了一个引用", "使得我们可以顺利的找到在这棵B树中的下一层的某个节点", "比如它", "同样 如果目标关键码存在于整个B树中", "那么至此可以断定 它必然存在与这个节点所对应的这棵子树中", "因此为了进一步进行查找 我们也需要再做一次IO", "将这个下层的节点载入内存", "以下的过程与刚才几乎一样", "具体来说 我们也需要在这个新载入的节点中做一次顺序查找", "如果成功 完则罢了 否则的话 我们依然借助在失败位置的引用", "进而找到再下一层的节点 乃至再下一层 乃至再再下一层", "在最坏的情况下 这个过程有可能会反复持续到叶节点", "也就是说 充其量我们需要抵达B树底层的一个叶节点", "在这里 我们依然需要针对目标关键码 做一次顺序查找", "同样 查找可能成功 也可能失败", "而且即便失败 也不要紧", "因为我们依然可以顺着失败方向的引用 找到下一层的节点", "没错 下一层的节点尽管它并不是真实存在的节点", "而只是一个虚拟的外部节点", "至此 我们就可以报告整个查找以失败告终", "当然 还有另外一种情况 也就是这个外部引用", "实际上指向的是一棵存放于相对而言更低层次存储级别上的B树", "这也是为什么将此类节点称作外部节点", "因为借助它们 我们可以将存放于不同存储级别上的B树串接起来", "构成更大的B树", "当然在此我们不妨只将目光放在当前这一级存储上", "而假设查找的确是以失败告终", "纵观整个过程 可以看到所谓对B树的查找", "无非是由一系列在内存中的顺序查找", "以及一系列的IO操作", "相间隔组成的一个操作序列"]}, {"name": "08A1-3\t自适应调整", "block_id": "382122a90ba54a898d0836e3279abf30", "text": ["我们不妨先来考察一个简单的实例", "也就是典型的线性结构 列表", "我们知道在列表结构中", "所有的元素都按照他们之间的逻辑关系", "可以排列成一个线性的序列", "相邻的元素通过引用 确立前驱和后继关系", "我们知道 在这样的一个结构中", "对任何一个元素的访问效率", "将主要取决于它在这个序列中所具有的秩", "具体来说 秩越小 也就是越靠前的元素 访问的效率越高", "秩越大 也就是越靠后的元素 访问的效率越低", "如果对于各元素的访问是完全理想随机的", "我们恐怕只得如此", "而不能奢望有什么实质的改进", "然而如我们刚才所说的", "如果对这个集合中的元素的访问具有局部性", "甚至有极强的局部性 我们就可以通过简明的策略", "来实现对整个数据集合的更高效访问", "比如一种行之有效的办法就是", "一旦有某个元素刚刚接受访问", "我们就立即将它移动到这个序列的最前端", "这种技巧背后的策略 不难理解", "因为根据局部性 我们接下来将要访问的元素", "很可能就是我们刚刚访问的那个元素", "而这个元素就在此前刚刚被移送到这个序列的最前端", "而对于这样一个最前端的元素而言", "我们的访问是唾手可得最为便捷的", "从整个数据结构的生命周期而言 这样一个列表结构", "即便最初是完全随机分布的", "那么在经过了足够长时间的使用之后", "在某一段时间内 被集中访问的那些元素", "都会不约而同的 集中到这个列表的前端去", "我们已经知道 这个区域的访问效率是相应更高的", "因此我们因此就可以在一个足够长的时间跨度之内", "获得比此前更高的访问效率", "好了 现在我们可以回到我们的二叉查找树", "为便于对比 我们不妨将BST的画法旋转90度", "具体来说 也就是将树的顶部与树的底部", "分别与列表的头部与尾部 对应起来", "这种对应是有道理的", "因为在BST中位于顶部的元素", "相对于位于其他位置 尤其是底部的元素而言", "访问效率要高得多", "因此如果我们希望借助局部性", "对BST的访问效率做进一步的优化", "就不妨参照列表的这种技巧", "将在某一段时间内 经常要访问到的元素 通过某种方式", "尽可能的移送到更加接近树根的位置", "也就是等效的说 要尽可能的降低他们的深度", "那么这样一种构思是否真的可行呢?", "如果可行的话 具体的方法又是如何的呢?"]}, {"name": "07C-4 歧义=等价", "block_id": "c7a642a597074eaaaccd544ec881657b", "text": ["在前一节我们曾经介绍过", "所谓BST 它的本质特征", "就是处处局部的顺序性", "以及全局的单调性", "具体来说 只需要考察", "它的中序遍历序列是否是单调的", "然而只需考察树的遍历算法", "我们就不难发现", "结构不尽相同的两棵BST", "它们的中序遍历序列有可能是完全雷同的", "这也就是我们所说的中序遍历序列的歧义性", "在某些场合中", "比如中缀表达式的求值计算", "这种中序遍历序列的歧义性非常令人生厌", "因为我们不得不通过一些办法", "来明确地辨析", "不同操作符之间的优先级关系", "而针对BBST这样的一个问题", "歧义性却变成了一个非常重要", "同时也是不可或缺的一种性质", "以这里所给出的两棵BST为例", "不难看出", "它们都是由同一组关键码所构成的", "而且它们的中序遍历序列是完全一样的", "然而反过来 我们也注意到", "它们的拓扑结构也不尽相同", "比如在这样一个局部", "左侧局部子树的树根是19", "而在右侧却是16", "当然 还可以很容易地举出更多这样的实例", "拓扑结构不尽相同", "但中序遍历序列却相同的", "任何一对这样的BST", "也就称作相互等价的BST", "等价的BST之间", "在拓扑结构上 虽然不尽相同", "但也有其独特的规律", "这种规律概括起来有两句话", "第一 上下可变", "比如在这个例子中", "19和16的祖先和后代关系", "就有可能在两棵树中彼此颠倒", "这也可以认为等价的BST", "在垂直方向有一定的自由度", "然而我们的第二条规律则是左右不能乱", "这里的左右自然是指中序遍历序列", "确实相对于任何一个节点", "居于它右侧的节点", "以及居于它左侧的节点之间不能相互混淆", "那么在这样一种上下存在一定的调整余地", "但左右次序却不得颠倒的规则下", "又当如何来实现BST之间的等价转换呢？"]}, {"name": "07A-4 单调性", "block_id": "45ba544ef19444cc9157371757e7d164", "text": ["尽管此前所定义的顺序性", "只不过是处处局部的一个特征", "但是正如我们马上就会看到的", "这样一种局部性的特征", "居然可以导出BST", "整体的全局性的某种特征", "具体来说", "也就是所谓的单调性", "实际上只要考查BST的中序遍历序列", "就会发现它必然是单调的", "我们来看下面这样一个实例", "在此你不妨稍事暂停", "以确认在树中的每一个顶点处", "顺序性都是满足的", "好了", "接下来 我们不妨沿着中序遍历序列", "浏览所有节点", "我们可以看到", "所有这些节点", "的确是以它们的关键码为序", "单调排列", "实际上 任何一棵BST", "都具有这样的一个特征", "反过来 具有这一特征的任何二叉树", "也必然同时是一棵BST", "我们不妨来证明其中的必要性", "对于任何一棵BST", "我们首先考查它的树根", "自然地 在这个树根位置", "顺序性必须得到满足", "这就意味着左子树中的所有的节点", "都不致大于树根", "而右子树中的所有的节点", "也不致于小于树根", "而根据中序遍历的规则", "左子树所对应的遍历子序列", "必然严格位于树根节点的左侧", "而右子树所对应的遍历子序列", "也必然严格地位于树根节点的右侧", "所以在整棵树的中序遍历序列中", "位于树根节点左侧的所有节点", "都不致于比它更大", "对称地 位于树根节点右侧的所有节点", "也都不致比它更小", "也就是说 在根节点处", "整个遍历序列是满足单调性", "那么至于左子树", "所对应的遍历子序列和右子树", "所对应的遍历子序列", "通过数学归纳", "不难证明 在它们各自的内部", "也是处处满足这种单调性", "因此如果我们在绘制二叉树的时候", "能够保证 相对于每一个顶点", "它的左子树和右子树", "都绘制于它的左和右侧", "那么我们就可以简明地来判定", "这棵树是否是一棵BST", "为此我们只需考查所有节点的垂直投影", "所有这些节点的投影", "所构成的序列", "其实就是这棵树的中序遍历序列", "因此只要这个序列是单调变化的", "那么原二叉树就必然是一棵BST", "反之亦然", "因此BST的特征可以概括为", "在微观上处处满足顺序性", "而在宏观上 整体满足单调性", "那么作为一种抽象数据类型", "BST又该提供哪些标准操作接口呢？", "这些接口的具体形式又如何呢？"]}, {"name": "07D4-3 rotateAt()", "block_id": "4479f062e4994a97b8aeda0c9e8e6d3c", "text": ["现在这个曾经多次出现", "并引得我们非常好奇的rotateAt算法", "终于到了可以揭开它", "神秘面纱的时候了", "它的传入参数只有一个", "也就是在我们所关心的祖孙三代中", "作为孙辈的那个节点v", "所以通过父亲引用", "我们可以很便捷地找到p以及g", "于是接下来", "我们只需要分别判断p和v", "究竟是左孩子 还是右孩子", "就可以正确地区分zig-zig zig-zag", "以及zag-zig和zag-zag各种情况", "而在每一种具体的情况下", "v p g究竟应该如何命名为a b c", "以及它们属下的4棵子树", "究竟应该如何重新命名为T0 T1 T2和T3", "都是固定的", "我们甚至可以把这些情况汇总为一张表", "我们不妨来考察这四种情况中的两种", "第一种 也就是所谓的zig-zig的状态", "无论v 还是p 都是左孩子", "在这样一种情况下 你不难理解", "它们的中序遍历序列", "自然应该是v a p b 和g c", "而4棵子树呢", "也相应地应该是v的左子树 v的右子树", "以及p的右子树和g的右子树", "就像这幅图所画的那样", "再来看所谓的zig-zag情况", "也就是说 v是右孩子 而p却是左孩子", "在这种情况下 同样按照中序遍历次序", "不难确定 应该是p a v b以及g c", "而4棵子树呢 也自然应该是p的左子树", "v的左子树 v的右子树以及g的右子树", "在这个图中 我们可以更清晰地看出这一点", "也就是p的左子树 v的左子树", "v的右子树以及g的右子树", "另外的情况完全对称", "我们就不再浪费时间了"]}, {"name": "11c1-4: \t预知力", "block_id": "91680fb727434762947242450401be38", "text": ["依然回到我们已经多次使用的这个二进制串的实例", "根据刚才的分析 在当前这轮比对失败于模式串的末字符之后", "即便我们依然只能向后移动一个字符", "但相对于新的P[j]而言", "整个前缀都无需重复比对了", "也就是说 我们只需从上一次失败的位置出发", "继续进行下一轮的比对", "正所谓 从哪里跌倒的 就从哪里爬起来", "实际上 即便是对于更为复杂的例子", "也依然存在此类优化的可能", "比如这就是一例", "其模式与刚才类似", "也就是说 相对于当前这个对齐位置", "我们所做的一轮比对首次失败于E和O之间的失配", "请注意 在这种情况下我们完全不必亦步亦趋地右移模式串", "而是可以大胆地将它后移3个字符", "也就是说 此前的两个对齐位置都可以排除掉", "你能看出这背后的原因吗", "没错 如果一个位置值得对齐", "那么它的一个必要条件就是", "所对应的首字符", "应该与模式串的首字符一样", "也是R", "而在这种情况下", "无论E或G 都不是R", "这里我们再强调一次", "关于这个子串的所有信息", "都是我们通过前一轮的比对所获得的", "而通过这两个实例我们已经确实地看到", "只要我们能够对这类信息充分加以利用", "就可以获得两个方面的优化效果", "一方面 我们可能大幅度地向后滑动模式串", "而另一方面 我们也可避免大量重复的比对", "而为了同时兑现这两个方面的优化", "我们的算法实际上只需具有某一种预知力即可", "具体来说也就是 在每一次失败之后", "我们应该将模式串中的哪一个字符与文本串中刚才失败的那个字符彼此重新对齐", "并继续从这个位置开始进行比对", "在这个例子中 也就是要确定这个0", "而在这个例子中 相应的对齐位置也就是这个E", "那么具体地 又当如何来确定此类继任字符的位置呢", "为此我们需要花费多少时间和空间", "而且更重要地 既然是作为预知力", "我们的算法 能否在事先就提前确定此类继任字符的位置呢", "好消息是 所有这些 都是可能的"]}, {"name": "11c3-1: \t快速移动", "block_id": "31652ecb9e7749538358ae8b4f6b7d0d", "text": ["在接下来的这节", "就让我们从严格的意义上来理解", "next表的具体含义及其原理", "我们已经切实地看到", "KMP算法的优化效果", "首先体现在它可以使模式串得以快速地后移", "而不是如蛮力算法那样只能亦步亦趋", "反过来我们也可以认为", "KMP可以聪明地排除掉很多不必要的对齐位置", "而这些位置之所以被排除掉", "是因为KMP发现它们不具备某种必要条件", "正如我们马上就要看到的", "这种必要条件就具体体现为模式串自身的某种匹配性", "依然回到这样一个串匹配的典型场景", "我们在T[i]与P[j]之间 发现了一次失配", "接下来 KMP会去查询next表", "取出对应的表项t", "并用P[t]来取代此前的P[j]", "使之继续与此前的T[i]相对齐", "并从这个位置出发", "继续后续的比对", "我们的问题是", "KMP在这种场合 为何会选定这样一个特定的t呢", "或者说 这样的t又具备哪些必要条件呢", "答案就藏在这幅图中", "我们来考察t所对应的这个前缀", "在KMP算法中", "这个前缀将不再会重复地接受比对", "我们已经看到", "之所以能够这样", "是因为KMP已经预先判定", "这个前缀必然会与主串中对应的这个子串完全匹配", "在这里 我们需要回过头来考察此前P[j]所对应的这个前缀", "同样地", "这个前缀在当年 也应该和这个子串是完全匹配的", "因此 相对于它", "文本串中这个长度为t的子串", "就是一个后缀", "另一方面", "既然这个新的前缀", "是由此前的前缀 经过右移之后而得到的", "所以 同样相对于此前的这个前缀", "它依然是一个长度为t的前缀", "由此 我们也就得出了关于t的一个 至关重要的必要条件", "也就是说 在此前的这个前缀中", "必须有一个长度为t的前缀与长度为t的后缀彼此相等", "也就是说", "在相对于p[j]而言的这个前缀中", "其首部和尾部 必须具有一定的相似性", "这个必要条件 可以形式化地表示为这样一个等式", "其左侧是一个真前缀", "而右侧则是一个真后缀", "就任何一个特定的模式串P而言", "对于区间内的任何一个整数j", "如果将满足上述条件的t筛选出来 就可以得到这样一个候选集合", "根据刚才的分析", "既然这些t都满足上述必要条件", "那么一旦在T[i]和P[j]处发生一次失配", "只有来自于这个集合中的t 才有资格作为下一轮的对齐位置"]}, {"name": "08A3-4\t查找算法", "block_id": "0090b0f80fea4f94bb13f327d1d95503", "text": ["再来看伸展树的查找接口 应当如何实现", "这里我们给出一种可能的实现方法", "首先与常规的BST一样 我们也需要调用searchIn这个接口", "在以root为根的BST中 查找数值为e的节点", "我们知道 查找可能成功 也可能不成功", "如果查找成功 我们就需要随即将命中的节点", "通过刚刚介绍的splay算法伸展至树根", "并且将命中的节点 也就是树根返回", "如果是失败的情况呢", "虽然没有命中的节点 但是我们知道会有一个搜索路径的终点", "在这里 我们也将这个终点通过splay算法伸展至树根", "所以概括而言 无论是成功或者失败", "我们都会在树根处获得一个相等或者近似的节点", "不难理解 这种处理手法的原理", "正是为了充分利用我们此前介绍的局部性", "需要强调的是 既然在其内部需要调用splay算法", "调整树的拓扑结构", "所以对于伸展树而言 search接口 将不再是一个静态的操作", "这也是伸展树区别于其他同类BBST的最本质特点", "那么伸展树的另外两个动态接口 也就是insert和remove", "又当如何实现呢？"]}, {"name": "02C-1\t 概述", "block_id": "bcc1673e814b4d0eba297000a785a0d9", "text": ["好 欢迎回来", "我们继续研究向量", "回顾前两节", "我们以向量为例", "给出了数据结构定义的", "一种通用方法", "这种方法 也就是所谓的模板", "大致的格式是这样", "以Template引导", "然后在括号之间", "有一个关键词typename", "当然在后边要给出", "数据结构的名字", "比如就我们这里首先举的例子是Vector", "当然还包括它的具体实现", "那么 这里最最重要的是", "这个typename所定义的模板参数", "这个参数的作用就是", "指定Vector这个结构中", "所有元素的类型", "这样的一个方法", "与其说是定义了一个Vector", "不如说是定义了一系列的Vector", "因为在使用的时候", "我们可以灵活指定它的类型", "典型的方式就是", "我们在此后可以这么来定义", "用上我们的尖括号", "然后定义一种", "自己喜欢的向量", "那么这个向量中的元素", "具体是什么类型呢？", "我没说可以有不同的类型", "比如说 最基本的可能是整型", "那这个意思就是说", "我定义了一个", "由一系列的整数构成的向量", "也可能是浮点数 float", "也可能是字符", "诸如此类", "那么我们读起来", "用英文反而更加便于理解", "如果这里是int的话", "那我们这个Vector实际上是", "a Vector of integers", "由一系列的整数组成的向量", "或者a Vector of floats", "一系列的float numbers", "构成的一个向量", "等等等等", "那么更重要的是 在后边", "我们将利用这种方式", "来构造更为复杂的数据结构", "比如说 我们可以把", "某些数据结构作为基本的组成元素", "来构成向量", "举个例子 在后边", "会定义二叉树 Binary Tree", "这样一种数据结构", "那么如果把Bin Tree", "作为基本的元素", "来构成Vector", "那我们就可以构成一个", "由一系列的二叉树", "构成的一个线性序列", "也就是A Vector of Binary Trees", "这个东西是什么呢？", "如果取个名字的话", "我想比较形象地 应该是", "把它叫作forest 森林", "确实 在后面介绍", "霍夫曼编码的时候", "会用到这种技巧", "所以从这里我们可以领会到", "通过采用统一的", "这种模板式的方法", "可以使得数据结构的定义", "非常的规范", "而且更重要的是", "此后它们可以互相的融合组合", "便捷地搭建更为复杂的数据结构", "那么我们今天的主要话题呢", "将围绕向量的最基本的形式", "也就是无序向量来展开", "无序向量的意思", "不见得一定是说", "其中的元素没有顺序", "甚至呢 有的时候", "其中的元素是根本就", "不可能排成顺序", "所以在这样的一个前提下", "我们将研究如何来定义", "并且实现相应的操作接口"]}, {"name": "01XC-A: LCS：动态规划", "block_id": "cecac02d741043ffacdfa7443ce8e56c", "text": ["稍加对比不难发现", "我们这里所处的困境", "与最初Fibonacci数的递归算法", "颇为类似", "具体来讲", "这里也有大量重复的递归实例", "也就是对应的子问题", "而且在最坏情况下", "它确实会出现指数这么多个", "而反过来 这里头的每一个子问题", "正像我们刚才那个表那样", "其实都唯一的对应于A B各自", "某一个前缀共同的一个组合", "因此它们总数就像", "那个表格里头的单元数一样", "累计也不过就是 n乘以m", "是乘法这么多种", "因此我们完全可以采用", "或者叫套用", "刚才改进Fibonacci数算法的", "那种动态规划的策略", "具体来说 也就是将", "计算的方向颠倒过来", "并且把计算的形式", "从刚才貌似简明的递归", "改为“似拙实巧”的迭代", "我们可以在同样的这张表上", "进行新的计算", "具体地 这里同样是把相应的", "那一对序列 分别作为行和列", "然后呢 对这个表做一个初始化", "也就是分别给出", "第0行和第0列", "我们接下来的工作呢", "就是逐行逐列地填写这张表", "如何填写呢？", "看一下", "就是按照这样的一个次序", "具体来说", "对于其中的任何一个单元", "我们都要根据它", "到底是减而治之", "还是分而治之 来做处理", "如果是减而治之", "像刚才这个情况", "因为a和a是相同的", "那么我们就直接取它", "左上角的这个单元", "简明地加个1就可以了", "大家需要确认的是", "每次碰到这种情况的时候", "所对应的左上角这个元素", "都是必然存在的", "所以这种计算是安全的", "我们再来看分而治之的情况", "比如说 还是这个T", "和这里的C", "所对应的这个情况", "因为这个时候T和C不等", "所以它会分别地", "去取它的上方的这个单元", "也就是它对应的那个子问题", "以及左侧的这个单元", "所对应的子问题", "将它们的解分别取出来", "并且将它们中的", "更大者保留下来", "同样我们这里要确认一下", "按照我们初始化的原则", "和计算的方向和次序约定", "每一个这样的情况出现的时候", "上方和左侧两个单元格", "所对应的子问题", "都已经计算并且得到了结果", "所以这种取法同样是安全的", "总而言之", "只要做刚才那样的一个初始化", "然后按照适当的 比如说从行", "然后接着再到列的计算次序", "总能够保证这个表中的各项", "可以按照刚才的", "那样的一个原则", "安全地、准确地计算出来", "而整个这样的一个计算过程", "是我们最初向上", "和向左的计算过程的", "逆向的一个过程", "而更重要的是 对于其中的", "任何一个子问题", "都只需要计算一次", "而不是很多次", "所以这样一个颠倒次序以后的", "迭代式的计算过程", "复杂度就应该恰好等于", "这张表格的规模", "也就是它的行乘以它的列", "n乘以m 而不是2的n次方", "或者是m次方", "总结一下", "递归虽然可以帮助我们很好地", "找到一个可行并且正确的解", "但是 如果要将效率提高", "使之变成一个实用算法的话", "我们往往还需要进行", "进一步的调试", "而在这个过程中", "动态规划扮演着", "非常重要的角色", "这也是这一节", "希望大家重点掌握的内容"]}, {"name": "10xa3-2:\t删除亦是合并", "block_id": "2588f9d7e7f14bd78094d35f7730ce7a", "text": ["实际上，基于左式堆的合并操作，我们还可以顺利实现它的删除接口。", "一个典型的删除操作的情景无非如此：", "在左式堆中，最大元依然在根节点处唾手可得，", "因此每次删除操作我们都需要将这个点在物理上摘除掉。", "而接下来的任务也无非是将分离出来的左子堆和右子堆合并起来，", "继续构成一个总体的左式堆。", "看到了？实质的操作又是一次合并。", "同样地，如果你能参悟到这一点，也应该能很自然地写出以下的算法。", "前三句都是铺垫，对相关的数据作备份而已。", "根节点的物理摘除由这一句来完成。", "而此后呢？正如我们参悟到的原理，", "只需将此时被隔离开的左子堆与右子堆重新地合并起来。", "同样地，此后也没有更多的实质操作，仅此而已。", "可以看到，按照这一方式，无论是左式堆的删除还是刚才的插入操作，", "实质的计算无非都集中在合并接口上。", "我们此前介绍过，合并可以高效率地在log(n)的时间内完成，", "既然这样，如此实现的删除以及刚才实现的插入操作也能达到这样的计算效率。", "同样的计算效率，更为简明的实现方法，", "我们还有什么理由不采用这种方式呢？", "实际上关于分合之道，左式堆的发明者Crane堪称个中高手。", "除了左式堆，他还针对其它的许多数据结构给出了高效的合并算法。", "比如对于我们已经熟悉的AVL树，Crane也给出了一个高效的合并算法。", "如果你对这一问题感兴趣，不妨看看我们《习题解析》中相应的习题。"]}, {"name": "08A2-4\t点睛之笔", "block_id": "6a53ab6f5c804dc5a9137db800ade943", "text": ["为了切实的感受和领会这只眼睛的神奇之处", "我们不妨来看这样一个实例", "依然是汉字中的一撇", "只不过为了更好的体现效果 我们这里取了更长的一撇", "接下来我们不妨恶意的来访问其中最深的那个节点", "因为这样的话 所消耗的时间 将会最多", "那么按照Tarjan的建议", "此时我们不仅要关心节点1的父亲 也就是2", "同时还要关注他的祖父 也就是3", "我们的第一次旋转 应该在祖父而不是父亲的位置上进行", "因此针对这种情况 我们首先对节点3做一次顺时针的zig", "接下来才轮到对原先的父亲也就是2 来做一次zig", "从而形成这样的一种局面", "v还是v 只不过上升了两层", "但是他拥有了新的一个父亲和新的一个祖父", "继续采用Tarjan建议的方法 具体来说", "要对新的这个祖父也就是5 做一次zig旋转", "然后再对新的这个父亲4 做一次zig旋转", "那么接下来继续采用Tarjan的建议", "将会通过怎样的一系列双层调整", "最终使目标节点1 伸展到树根呢", "连续的看一下这个过程", "一次双层调整", "又一次双层调整", "以及再一次", "再一次", "以及最终那一次", "来看一下最终这棵树的全貌", "看到效果了吗?", "不出意外 节点1被伸展到了树根", "然而这只是最基本的一个任务", "我们注意到 作为这样一个调整过程的副产品", "整棵树的树高 已经有了本质的变化", "你应该还记得 我们此前针对逐层伸展", "所举的那个最坏的例子", "没错 那个例子之所以很坏", "是因为每次尽管它能够将目标节点调整到树根", "但是整棵树的高度却会不得不按照算数级数", "亦步亦趋的小步的变化", "于是呢 使得恶意者每次都可以去", "试图访问它最深的那个节点", "从而导致累计的平方量级的时间复杂度", "以及分摊意义上的线性时间", "而现在呢 我们至少可以看出", "那种恶意的方法将会失效", "因为我们这棵树的形态 得到了有效的优化", "具体来说 树的高度大致缩减为原先的一半", "接下来如果我们继续恶意的试图去访问", "它的新的这个最低点", "我们就会发现 他会继续的优化调整", "来看一下 调整的过程 以及结果", "可以看到 树的高度在此前的基础上又进而缩减了一半"]}, {"name": "02D3-3\t 实例", "block_id": "abea2b478e7f4d29b463ec0ffaa48f4c", "text": ["实际上通过精确地估算", "我们确实可以认定", "fibonacci查找算法的平均查找长度", "在常系数的意义上", "的确优于此前的二分查找版本A", "关于这方面的结论", "可以详细地参见我们的教材以及习题解析", "在这里呢 我们只想通过", "一个具体的实例来给出分析", "依然以上一节", "所采用的那个长度为7的向量为例", "非常巧", "7恰好也是一个形如fibonacci数", "减1的这么样一个长度", "具体来讲 就是第6项", "fibonacci数 也就是8再减掉一个1", "我们可以来看一下", "对于这样的一个向量", "如果采用fibonacci算法的话", "所有的搜索可能的情况", "如果画成一个最终图", "是这样", "第一次比对 是在这个元素的位置上", "注意 这大致是一个黄金切分点", "而不是终点", "但是尽管位置不同", "正向我们前面所看到的代码一样", "在后面的分支逻辑是完全一样的", "具体来说", "如果我们在第一次比较成功", "那么我们就可以确定向左", "如果我们经过第二次比较才成功", "那么才可以向右", "而只有当两次比较都失败", "我们才会在当前的那个位置上终止", "所以同样刚才我们说的那个道理", "每次我们向左的成本都是1", "而向右的成本都是2", "那么以下也是类似", "我们可以采用此前一样的方法", "来具体地给出", "每一种情况所对应的查找的成本", "也就是查找的次数", "分别可以标定于此", "对于这个元素来说", "如果是成功在这个位置的话", "对应的是两次", "这也是一种成功的情况", "这种成功的情况", "不出我们的意料 应该总共有7种", "成功的情况", "而它们各自对应的查找的长度", "都列在这儿", "所以我们如果做一个总和的考虑", "所有这7种情况所对应的查找长度", "把它们累加起来 再除以这个7", "恰巧是4", "如果大家还回想的起来", "此前的二分查找对应的数是4.14", "略微有所优化", "当然我们也可以", "把失败的情况用同样的方式累积起来", "那么不出意外", "应该总共8种失败的情况", "我们将它们所有的罗列在这儿", "并且做一个累加 就会发现", "这个数从原来的36优化成了35", "同样这个结果", "也要比原来的4.50略低", "当然更大的例子", "我们可以看得更一般一些", "我们把这类工作", "留给大家在课后进一步地完成", "那么这样一个例子还不足以说明问题", "我们接下来要给出一个相对严格地证明", "说明为什么在此类查找中", "bonacci查找才是最好的"]}, {"name": "02D2-2\t 接口", "block_id": "beccf499c02841bba57888f10f576edc", "text": ["我们这里所提供的search接口", "确实从形式上看，是统一的", "这也就是所谓的ADT", "从内部讲", "它的具体实现算法", "却不见得完全一样", "那么这里接下来的各节，将会分别介绍", "比如说二分查找算法", "以及Fibonacci查找算法", "而且对每一种算法，我们都有不同的版本", "为了做测试", "我们这里采用了一个随机的方法", "也就是，在0和1之间随机地取一个数", "视到底是0还是1", "随机地调用这两个算法", "那么在实际应用中", "当然大家可以针对不同的情况", "在这几种算法中，选择其一", "我们再来看一下，它的简要地操作语义", "也就是说，所谓的seach", "就是在lo和hi所确定的这个区间", "它是在整个这个向量所属的区间", "也就是，0到size之间的一个子区段", "lo和hi", "在这个区段中，找出目标元素e", "如果它确实存在的话", "没错，如果它确实存在的话", "换而言之，这里需要处理很多特殊的情况", "比如，目标元素可能压根就不存在", "这就叫失败", "在此前的，无序向量的find的接口中", "我们只是简单地返回了一个标志", "比如说-1", "那么我们待会儿会看到", "严格地说，是不够的", "那么反过来，有可能目标元素存在", "比如这是一个e", "也可能，另一个位置上，也可能存在一个e", "当然，既然作为有序向量", "一旦有多个e的话", "那么它肯定会连续地分布构成一个区间", "但是至少这里会有", "有可能有多个元素", "在这种情况下，到底是返回谁呢？", "返回最前边这个，最后边这个？", "还是中间的某一个？", "那么这些都是我们需要", "进一步地从语义上，予以约定的"]}, {"name": "08XA2-3\t提升变换", "block_id": "f182401692eb4917a26b3179119739d5", "text": ["回过头来 再重新审视此前所给的这一组规则", "即便在刚才我们已经看过红黑树的实例之后", "这组规则依然令人费解", "那么有没有什么更为直观的解释呢", "答案是肯定的", "为此我们可以借助此前刚刚学过的一种数据结构", "为了更好的理解红黑树的定义", "需要借助树形结构的另一种等价拓扑变换", "也就是所谓的提升变换", "具体的 将每一个红色的节点都向上提升至与它的父亲平齐", "无论是它 还是它 以及它", "每一个红色节点 都是如此", "你应该记得 每一个红色节点的父亲必然是黑的", "因此尽管可能某个黑色节点会接收左右两个孩子", "但经过如此变换之后", "绝对不会出现两个红色的节点彼此紧邻并排的情况", "即便并列 其间也必然夹有一个黑节点 也就是它们此前的父亲", "我们不妨来具体体验一下这一变换的宏观效果", "这是变换之前的红黑树", "现在来做刚才所说的提升变换", "可以看到每个红色的节点都向上提升至与它的黑父亲平齐", "这个 这个 这个 这个 以及这个 诸如此类", "再看一遍 这是变换之前 以及变换之后"]}, {"name": "05E2-4 构思", "block_id": "690aa974369b4754ac2879455cd6c526", "text": ["站在这样的一个角度，纵观整个遍历过程", "我们确实可以发现整个遍历", "的确是可以分为若干个阶段", "总共有多少个阶段呢？", "整个左侧链有多长 就有多少个阶段", "具体来说 左侧链上的每一个节点", "都对应于一个阶段", "而每个阶段的情节都是雷同的", "访问左侧链的对应的这个节点", "然后再遍历它对应的右子树", "访问左侧链上的节点 遍历右子树", "访问左侧链节点 遍历右子树", "以及访问左侧链节点 遍历右子树", "一直到最终访问根节点", "再遍历全局的右子树 如此而已", "那么这样一种思路又该如何", "具体地兑现为代码呢？", "我们注意到 在这样的一个过程中", "存在着某种逆序性", "难道不是吗？", "我们最初的起点是在根节点处", "可是首先接受访问的却是它所对应的", "这个左侧链的末端节点", "如果说整个谦让的过程是自顶而下的话", "那么我们也不难发现各节点", "实际被访问的次序大体而言", "是呈一种自下而上的过程", "现在你大概有点想法了", "是的 如果我们要采用数据结构的话", "应该能采用某种支持后进先出的结构", "没错 当然也就是栈了", "你甚至已经设想出这个栈的使用方式", "是的 它应该是这样一种开口向下的形式", "底端在上 顶端朝下", "左侧链上各节点的入栈次序呢", "应该是从根节点开始 首先入栈", "然后是它的左孩子入栈", "以及左孩子的左孩子入栈", "以及左孩子的左孩子左孩子", "以及左孩子的左孩子的左孩子", "最终的这个Ld入栈", "可以想象 最后入栈的Ld应该首先被弹出", "并第一个接受访问", "这与中序遍历的策略是吻合的", "好了 现在就到了该将", "这样的一个总体思路", "具体落实为代码的时候了"]}, {"name": "03D-2\t 实例", "block_id": "4d798180e99f4e9d8307f7cac906f968", "text": ["来看一个具体的实例", "正像我们刚才所言", "在算法的任何时候", "我们都像起泡排序那样", "将整个序列分为前后的两部分", "前面那部分是属于Unsorted", "还未排序的部分", "而后一部分", "是已经排序了的部分Sorted", "我们也讲过 从数值上看", "前者绝对不会大于后者", "我们的输入是一个长度为7的序列", "它们也就构成了最初未排序的部分", "以下对于这个长度为7的序列", "我们总共要做7次迭代", "每次迭代的过程都是相似的", "我们都要找到当前的最大元素", "比如在第一轮中也就是7", "并且随即将它挪至到S的最前端", "下一轮也是如此", "继续在新的U中找到最大者", "并且将它转移至S的最前端", "以致于下一次继续找出最大元素", "并且将它转移至S的最前端", "好", "最大元素挪至最前端", "最大元素挪至最前端", "以及最大元素挪至最前端", "当只剩最后一个元素的时候", "我们可以直接将它移至S的最前端", "纵观整个过程", "与起泡排序非常相似", "但是我们要强调的是", "二者之间也有本质的区别", "也就是说 在前后进行的", "这样O(n)次迭代中", "每一步迭代只做了一次元素的移动", "而不是像起泡排序那样", "在每一步迭代中", "都有可能做多达O（n）次的交换", "从交换次数的意义来讲", "新的这个算法有很大的提高"]}, {"name": "04C2-6\t 拓展", "block_id": "e4f5eb106ac64d87a2f17f220a2df964", "text": ["这背后的原因在于", "采用栈可以便捷地", "推广至多种括号并存的情况", "请注意 这个时候", "即使你愿意使用多个计数器", "也是行不通的", "比如哪怕只有圆和方这两种括号", "也可以很简明地得到这样一个反例", "因为如果孤立地通过计数器", "来考察方括号或者是圆括号", "两个计数器都是可以正常工作", "并且在最终复位为0的", "而不难看出 这个表达式", "无论如何都是不匹配的", "同样地", "我们通过下面这个实例来看一下", "这个算法如何扩展到", "多个括号并存的情况", "它的原理依然", "也就是每当我们碰到一个左括号", "无论它是大括号、圆括号", "抑或是方括号", "都是简明地令其入栈", "入栈、入栈以及入栈", "而一旦遇到右括号", "无论它是圆的、方的", "抑或是大的", "我们都沿用刚才的策略", "去寻找栈顶的那个左括号", "并且在这个栈顶的左括号", "确实是与之配对的情况下", "我们才将其弹出", "弹出、弹出", "弹出以及弹出", "同样地", "在经过了这样一趟线性的扫描之后", "只有当这个栈重新恢复为空", "我们才可以断定", "原来这个包含多种括号的", "表达式是匹配的", "反过来 这里括号不匹配的情况", "相对于此前单括号的情景", "要多出一种", "也就是当我们试图", "去弹出一个左括号的时候", "却发现它与我们当前", "所扫描到的右括号是不匹配的", "比如对于我们刚才这个反例而言", "第一个方括号以及接下来的右括号", "确实可以顺利地入栈", "但是接下来", "当我们遇到第一个方括号的时候", "却会发现栈顶括号虽然是左括号", "却与之不匹配", "从而准确地得出失配的结论", "这里我们省去了", "这个拓展算法的具体实现", "有兴趣的同学可以查阅教材", "以及习题解析", "最后需要指出的是", "实际上这样一种拓展", "还可以进一步地进行", "也就是说 我们并不限于", "某几种特定的括号", "甚至不需要对这些括号", "到底有多少种做出限定", "就像在HTML语言中那样", "只要表达式中能够按照合理的语法", "表达式中能够定义", "任何一种匹配标志", "我们都可以来进行这种", "意义上的匹配检查"]}, {"name": "08XA2-4\t末端节点", "block_id": "e0e4f131d2944148ad1f535f786166ff", "text": ["为了更好的理解提升变换之于红黑树的意义", "来看一个更大的实例", "这是一棵由100个节点所构成的红黑树", "请特别留意其中所有的底层节点", "不难理解 在实施提升变换之前", "就结构而言 这只不过是一棵普通的BST", "因此树中的底层节点", "通常都是高低错落此起彼伏式分布的", "那么在经过提升变换之后 情况又会如何呢", "我们不妨来实际的看一下", "这是提升之后", "再看一遍 提升之前 以及提升之后", "可以看到在经过这样的提升变换之后", "所有底层的节点都变成沿同一水平高度平齐的分布", "这一现象难道是巧合？", "如果不是 背后的原因又是什么呢"]}, {"name": "11b1-1: \t问题与需求", "block_id": "3a773a48c4c742c5af3cb4ca96eae9b0", "text": ["好 接下来我们就对这一章的主角儿 也就是串匹配问题 作一概述", "包括这个问题是什么 有哪些不同层次的功能要求 以及如何评测相应算法的性能", "尽管我们还没有涉及到具体的算法", "如果你使用Unix或Linux 那么对于grep这个命令肯定就不会陌生", "这个支持正则表达式搜索的命令功能非常强大", "其中最基本的一项功能就是 在某个文本中去查找特定的模式串", "比如 这就是一次成功的查找 因为我们注意到people这个单词的确在上面这个句子中出现了", "其实 类似的这种搜索 在当下是无处不在、无时不在的", "想想你在Google或百度上 通过关键词搜索网页", "就不难理解这一点", "是的 对于这类搜索引擎来说", "你所输入的关键词 就相当于这里的模式串", "而文本串T呢", "是的 它们是Internet上所有的网页", "由此 我们也可以看出此类问题的一个鲜明特点", "这体现在两个串的长度上", "按照我们的惯例 通常都将文本串和模式串的长度分别记作n和m", "通常 m本身就足够大 因此不能视作是一个常数", "例如 你所搜索的关键词 通常都由几十个到一百个字符组成", "另一方面 相对于已经比较大的m而言", "n的规模 又要比m大上若干个甚至很多个数量级", "仍然以刚才的搜索引擎为例", "整个Internet上所有网页的长度之和 必然是惊人的", "即便是单张网页 其规模也通常在几十到几百K", "当然 我们所说的模式匹配问题", "从功能和难度上 可以分为若干个递进的层次", "首先 是所谓的检测 detection", "也就是说 我们只关心模式串是否在文本串中出现过", "至于出现在哪儿 以至于出现多少次", "相对而言我们都不是那么关心", "比如病毒的监控系统", "更在意的是病毒的特征码在对应的邮件或文件中是否出现", "只有不包含特征码的邮件或文件 才允许通过", "当然 接下来的一个层次自然是定位", "也就是说 如果模式串出现 我们还关心它具体出现在文本串中的哪个位置", "例如 你在一份很长的网页上要查找某个特定的入口 就需要用到这样的功能", "当然 通常而言 模式串有可能会出现多次", "而此时 我们有可能会关心它总共出现过几次", "比如 根据一份学生的花名册", "借助这种功能 我们就可以统计出特定届次的学生总数", "当然 再进一步地", "是所谓的enumeration 枚举问题", "也就是说 我们需要知道模式串在文本串中具体都出现在哪几个位置", "比如在刚才的例子中 我们有可能需要进一步地确定 特定届次的学生具体是哪几位", "纵观这4个层次 不难发现 其中核心的 是第2个层次", "实际上 只要这个层次的问题 能够得以高效地求解", "后续的问题 也自然可以迎刃而解", "因此 这一层次的问题 也是我们在这一章中将主要讨论的范畴", "鉴于串匹配问题的特殊性 在给出具体的算法之前", "我们需要首先来确定 应该如何地测量和评判 此类算法的性能"]}, {"name": "12a4-5: 时间 + 空间 + 稳定性", "block_id": "6c5a88776e4046dba293b103ac1787aa", "text": ["纵观整个算法的计算过程", "我们为每一个元素", "只需花费常数的时间", "因此这个新的partition算法", "总体依然只需线性的时间", "当然这里也只需要常数的辅助空间", "因此它依然是一个就地的算法", "那么这个算法的稳定性呢", "在这里实例中我们可以看到", "无论是5a和5b", "还是8a和8b", "重复元素之间的相对次序", "似乎是可以保持的", "然而我们说这只是一个假象", "对于子序列L中的重复元素而言", "它们之间的相对位置的确是可以保持", "因为根据这个算法的原理", "所有此类的重复元素", "都是严格的按照", "它们此前的相对次序", "加入到子序列L当中的", "那至此你可能会说", "根据算法的原理", "子序列G中的所有重复元素", "也是按照它们原有的次序", "加入到这个序列当中的", "所以它们之间的相对次序", "也应该得以保持才是", "然而这一判断并不全面", "这里需要注意的是与子序列L不同", "子序列G有可能会向后滚动", "是的", "尽管这种滚动的方式", "可以保证时间效率的最优", "然而由此却有可能导致不稳定性", "我们就以这里的重复元素8a和8b为例", "它们在最初进入到子序列G之后", "的确保持了原始的相对次序", "然而在经过了一次滚动之后", "二者的次序依然颠倒了过来", "而在经过了此后的另一次滚动之后", "它们的次序又再颠倒了一次", "从而造成了能够保持原状的假象", "当然子序列L中的", "重复元素之间的相对位置", "也并非系绝对一成不变的", "你能举出这样的一个实例吗"]}, {"name": "09C-8 伪随机数", "block_id": "37640fb6a23441f986f7dc033742db0f", "text": ["谈到随机 你应该很自然的会想到系统所提供的随机数发生器", "比如这就是一种实现的方式", "可以看到 这里每一个所谓的随机数", "实际上都是在前一个所谓随机数基础上", "按照确定的计算规则递推而得的", "因此更为准确的应该称之为 伪随机数发生器", "就逻辑效果而言 这等同于将取值范围以内的所有整数", "按照这种规则重新编排为一个貌似随机实则确定的序列", "而这个发生器所返回的", "只不过是在这个序列中对应于某个特定秩的那个元素", "比如一种最常见的方法", "就是将这个秩取做系统当前的时间", "如果就接口参数的形式", "对散列函数以及伪随机数发生器函数做一对比", "我们就会发现 二者惊人的相似", "难道不是吗", "只不过前者是经统一散列转换之后 所得的关键码", "而后者只是伪随机数序列中的某个秩", "因此我们不妨直接借助后者来实现前者", "事实上很有意思的是", "如果反过来考察此前我们已经确立的那4条准则", "无论是确定性 高效性 满射性还是均匀性", "它们恰好同时也是评判随机数发生器的重要标准", "既然每一个伪随机数发生器都可视作为一个散列函数", "我们也可以将散列函数的设计难题", "转交给伪随机数发生器的设计者", "我们可以直接套用它们的工作成果", "当然事情还不是这么简单", "如果采用伪随机数法 有一点是非常重要的", "事实上 在不同的平台和环境中", "所提供的伪随机数发生器 所采用的算法不尽相同", "即便在同一个平台环境中 不同的历史版本", "也可能对应于不同的随机数发生算法", "因此你在特定时间特定平台上 所生成的散列表", "未必可以直接移植到其他的平台", "对这一点你应该保持足够的谨慎"]}, {"name": "10b2-4: \t效率", "block_id": "53553d77058043a397005e6fa5ffb2f7", "text": ["你应该记得，在完全二叉堆中插入新元素之后的调整过程之所以被称为“上滤”，", "是因为每经过一步迭代，新插入元素的位置都会上升一层。", "换言之，整个算法在完全二叉堆的每一层次上最多只需做一步迭代。", "我们知道，完全二叉树是理想平衡的二叉树，其树高可以严格控制在log(n)的范围内。", "的范围内。我们刚才也已看到，每一步迭代只需常数的时间。因此所有的迭代所需的时间累计也不过log(n)", "就渐进的意义而言，这已经实现了我们最初的设计目标。当然就常系数的意义而言，这里依然还有改进的余地。", "你应该还记得，在我们刚才所给出的实现中，每一次交换都是通过一个swap的过程来完成的，", "这样的一次交换操作通常都意味着3次赋值操作，因此在最坏情况下，我们累积需要进行多达3log(n)次的赋值。", "针对这一问题，一种简明的改进方法是，对于新插入的词条首先备份，", "每次如有必要交换，我们只是下移它的父节点。", "直到能够确定e已经无需继续上滤时，我们才将此前备份的词条纳入于最终的这个位置。", "如此，我们就可将赋值操作的次数从3log(n)减至log(n)+2，", "从而在常系数的意义上有所改进。", "当然，另一类操作，也就是父子词条之间的大小比较操作也可以有一定改进。", "关于这一话题，大家可以在课后参考我们的习题解析。", "关于完全二叉堆，它的平均性能远远优于刚才分析的最快情况。", "实际上，新插入的节点需要持续上升足够多层，乃至最终能够抵达树根的情况，出现的可能性是极低的。", "更加精细的估算表明，在通常的随机分布下，每个节点上升的平均高度实际上只不过是常数。", "这也是完全二叉堆低成本、高效率的重要证据。", "关于这一结论，你也可以参考我们所提供的习题解析。"]}, {"name": "08A1-1\t宽松平衡", "block_id": "7fee9b7c55f444bea0fe072cdfd41fd2", "text": ["同学们好 从今天开始我们进入到第8章", "在这一章中 我们将介绍若干种高级搜索树", "在前一章的最后 我们曾经介绍过AVL树", "这是一种典型适度平衡的二叉搜索树", "你应该还记得 为此我们需要为其中的每一个节点", "都定义并且引入一个名为平衡因子的指标", "并且要求其中所有节点的平衡因子的数值", "必须介于-1到+1之间", "尽管相对于理想平衡而言 这种形式的适度平衡", "已经在条件上 略有放松 但依然显得有些过于苛刻", "如果我们注意到 我们还需要在AVL树的动态调整过程中", "保持这种特性", "这种苛刻就更是显而易见了", "如果比喻作人 AVL树就犹如那种 时时小心处处谨慎的类型", "那么能否成为那类更为潇洒的人呢", "也就是说 我们可否秉持一种更为宽松的准则", "同时又从长远 从整体来看 依然不失某种意义上的平衡性呢", "答案是肯定的", "答案就是我们这节的主角 伸展树"]}, {"name": "01b-1: \t性能测度", "block_id": "47135139ea7843ed9b38a8f48389abc7", "text": ["欢迎回到数据结构的课堂", "今天我们介绍计算模型", "上一节讨论了计算这个概念", "我们知道", "如果是从有效性和高效性来说的话", "它的基本前提是", "数据结构和算法这两个方面的有机结合", "所以我们也笼统的称之为DSA", "那么相应的我们也获得一个概念", "也就是说不同的DSA", "实际上有好坏之分 有优劣之别", "这种好坏和优劣完全是从它的效率而言的", "那么这只是一个定性的感觉", "在实际的应用中这还是不够的", "我们必须能够学会定量的来做度量", "没错 度量", "在这里度量非常重要", "我们不妨重温一下", "Kelvin爵士的一句名言", "他指出To measure is to know", "也就是说如果我们科学的使命", "是去了解这个世界", "是去理解这个世界的规律", "那么最终的形式往往是体现为", "你能够对这个世界", "或者这个自然界的某一个侧面", "或者是某一个方面", "来进行有效地", "尽可能准确的测量或者测度", "就像我们现在需要对算法来做测度", "那么如果这句话是", "非常有道理的话", "那么下一句话", "对于计算机科学的工作者来说", "就更加具有针对性了", "他说 如果你需要去改进某一样东西", "在我们这里 就是指DSA", "我们的数据结构和算法", "那么你首先就要懂得", "如何去测量 测度它", "原因很简单", "如果你都不知道它到底有多好", "包括不知道它能够有可能有多好", "甚至反过来", "你不知道它不能有多好", "那么无从谈起如何去改进和优化它", "这也是我们这一节的主题", "当然在测度这个问题上", "我们实际上还有两步要走", "第一步也就是这一节", "形象的比喻的话", "将交给大家一把尺子", "在这样一个抽象的理想的尺子上", "它已经标记好了刻度", "而后面我们还会花一些篇幅和时间", "教给大家如何真正地运用这把尺子", "去度量任何特定、具体的DSA", "我们先来了解", "这样一个公共的理想的尺子"]}, {"name": "09E-3 计数排序", "block_id": "b9f8dfc862834e78ad40c5d735b84c3d", "text": ["没错 根据我们此前的定义 这个积分值也就是", "包括它所对应的那个字母在内", "以及相对而言 更小的那些字母", "在输入序列中 所出现次数的总和", "而这个总和 也就给出了对应的这个字母", "在有序的输出序列中 所对应的位置", "或者更一般地 如果这个字母出现多次", "也就是它在最终有序序列中 所分布的区间", "以这里的字母F为例 它总共出现了一次", "而对应的积分值为6", "这就说明在输入序列中 小于G的字母应该恰为6个", "因此 作为这些字母中的最大者F", "也自然应该被放在编号为5的位置", "没错 5", "因为从0到5恰好是6个小于G的字母", "而同样的道理 因为字母G所对应的积分值为8", "所以输入序列中的这两个字母G", "在最终的有序序列中", "自然地 也就应该被归入至6到8之间的这个区间了", "具体地 也就是6和7这两个单元", "由此可见 只要我们能够得到每个字母的统计值以及累计值", "就可以根据相邻字母的累计值", "确定其在输出序列中所应处的区间范围", "刚才已经分析过", "散列表count 可以在线性时间内计算而得", "那么 累计值散列表accumulation呢？", "我们说 它的建造只需要O(m)的时间", "也就是说 每个单元只需常数", "你能看出具体的算法吗？", "是的 只需从头到尾 线性扫描一遍即可", "首先是 字母A所对应的第一个桶单元", "我们可以直接 用它的统计值作为它的累计值", "接下来 是字母B", "我们可以在A的积分值的基础上", "累计上B的统计值 从而得到B的积分值", "再接下来的字母C呢 也是如此", "也就是说 将B的积分值再加上C的统计值", "也就得到了C的积分值", "以下完全同理", "由此可见 整个的计算过程", "无非是从第一个字母开始 依次地向后递推", "而每一步递推的算法模式 都是一样的", "也就是将前一项 累计上后一项的统计值从而得到后一项", "累计 更新", "累计 更新", "累计 更新"]}, {"name": "01b-3: \t最坏情况", "block_id": "e004762167dd4c5ebd78bc05c705114e", "text": ["在经过了这样一个", "等价类的划分之后", "我们就可以重新将刚才那样一个", "数学的度量的形式进行改写", "我们看到这里最大的一个不同就在于", "把原来每一个具体的问题实例P", "变成了笼统而言的一个规模的度量值", "也就是n 也就是说", "我们可以把某一个算法", "在求解规模为n的不是一个", "而是一大类实例的过程中", "它们各自所需要的时间成本", "笼统记作TA(n)", "我们如果暂时把算法固定的话", "那么也可以把这个A忽略掉", "就直接记作T(n)", "很遗憾这样的一个定义", "依然不能满足我们实际的需求", "不足以支撑我们分析的需要", "为什么呢？", "我们注意到 对于同一问题", "即便是规模接近甚至相等的输入实例", "计算成本虽然大体是差不多的", "但毕竟还是有差异", "甚至会有实质性的差异", "我们来看这么样一个例子", "假设在平面中", "随便给定你有限个 比如说n个点", "那么当然这里的n就是输入规模", "我们知道其中的任何三个点", "都会定义一个三角形", "那么我们这里不妨提出一个问题", "就是如何找出其中", "面积最小的那个三角形？", "如果你不知道技巧的话", "不妨采用所谓的蛮力算法", "也就是说逐一地去枚举", "所有的n中取3的组合", "分别的算出它们各自对应的面积", "并保留和记录下", "最后的整体的最小值", "没问题", "这个算法的正确性是不言而喻的", "但是我们说采用这样", "即使是固定的一个算法", "对于不同的n个点的组合", "有可能运气是不一样的", "所需要的成本有很大的区别", "比如说我们说在最坏情况下", "可能会直到所有的组合都尝试遍后", "在最后才会找到", "那个最小的三角形", "但是反过来也有的时候", "你会运气比较好", "比如说你在比较早的时候", "甚至是一上来所枚举的三个点", "你就会发现它们", "是不仅像现在这样是近似的共线", "而是正好是共线的", "这个时候你应该会知道", "它的面积是0", "而作为面积来说不可能是负值", "换而言之", "在这个时候其实你已经找到了", "这个问题的一个解", "也就是说你在这个时候", "可以直接返回", "报告最小的面积是0", "所以我们可以看到", "同样规模为n的那些实例", "所需要的计算成本是有天壤之别的", "当然你还可以举出更多的例子", "可能我想有些同学", "现在已经想到了我们在前面讲过的", "Hailstone的那个例子", "它也是这样的情况", "好 既然这样的话", "那么我们又该如何去定义", "我们刚才所给出来的这个T(n)呢？", "显然我们不能把命运", "寄托在最好的情况下", "而我们应该更多的", "关注一个算法的最坏情况", "所以确实如此", "如果我们确实像现在大部分的", "主要的这种分析的准则所要求的那样", "只关心其中的最坏的情况", "也就是成本最高的那种情况", "那么T(n)的取值应该是", "在所有规模为n的问题实例中", "将它们的计算成本进行总体的比较", "并且取出其中的最大值", "这样也就是我们所说的", "最坏情况分析的原则", "这是首先必须关注的", "当然我们也会关注其它的性能", "在稍候我们会关注平均性能", "分摊性能等等等等", "但是我们首当其冲的", "确实是最坏的情况"]}, {"name": "05E5-1 遍历序列", "block_id": "c5f15681df5b455381f0d1519b2cbe13", "text": ["同学们好，接下来的这一节", "我们讨论一个饶有趣味的问题", "也是二叉树的重构", "由任何一棵二叉树", "我们都可以导出三个序列", "也就是先序、中序", "和后序遍历序列", "这三个序列的长度相同", "它们都是由树中的所有节点", "依照对应的遍历策略", "所确定的次序", "依次排列而成", "是的 任何一棵二叉树", "都可以明确地导出这样三个序列", "那么我们现在考虑的问题", "是正好颠倒的", "如果我们已知", "某棵树的遍历序列", "是否可以忠实地还原出", "这棵树的拓扑结构", "什么情况下可以？", "什么情况下不可以？", "如果可以 具体又应该使用", "什么样的方法？"]}, {"name": "10b4-1\t: 自上而下的上滤：算法", "block_id": "dc3250b9dec24568926e4dc2693d2f93", "text": ["在介绍过完全二叉堆标准的静态和动态操作接口之后，我们接下来将会介绍如何批量来建造一个堆。", "也就是说，对于任给的n个元素，我们希望将它们构建成一个堆。这样一个过程也称作heapification。", "在完全二叉堆模板类中，我们可以找出这样一个构造函数，其功能是以任意指定的规模为n的数组a为蓝本，", "将其中的元素组成一个完全二叉堆，为此我们需要首先调用向量的copyfrom接口，", "将这个数组复制到内部，而实质的操作则是调用heapify这个算法将这个元素调整为堆。", "那么，这个heapify算法又当如何实现呢？", "如果不在乎计算成本，这算不上是一个难题，甚至我们有现成的解决方案，", "比如这就是一个现成的解决方案，我们称这个方案为蛮力算法，因为它的思路是直截了当的，", "也就是逐个地将每个元素通过完全二叉堆标准的insert()接口插入其中。", "比如一种相对更为紧凑的实现方式是这样：", "为此我们只需按照层次遍历的次序，也就是自上而下，自左而右，逐一地对每一个元素做上滤处理。", "每经过这样一趟上滤，就等效于插入了一个新节点，", "而当所有节点都经过如此上滤之后，整个堆也就自然建成了。", "来看一个具体的实例，考察一个由5个元素构成的初始向量——", "当然这里画出的是逻辑上与之完全对应的那棵二叉树。我们首先来考虑根节点：", "作为第一个节点，它所对应的上滤是一个平凡的情况，实际上它只需原地不动，", "我们就可以认为我们将它作为第一个元素插入了这个堆。", "也就是说，我们直接得到了由一个元素构成的堆。", "正因为这一步我们并没有实质的动作，因此我们不妨将其直接忽略掉，而直接从编号为1的元素开始。", "在我们的图中，也就是这个灰色的节点。相对于当前的堆，这个节点恰好就是末元素，", "因此根据我们此前的插入算法，在对它进行一次上滤调整之后，就可以顺利地将它插入到堆中，", "于是我们就可以得到一个规模为2的堆。再接下来我们需要考察2号，也就是这个灰色的节点。", "同样地，相对于当前的堆，它也恰好是末元素。", "因此我们也只需对它进行一轮上滤，即可将它插入到当前的堆中。", "于是这个堆的规模又将从2拓展至3。", "接下来的故事都类似，也就是我们需要去考察编号为3的节点，", "并且通过一趟上滤将它插入到当前的堆中，从而使堆的规模进一步上升为4。", "最后一个节点也是如此，我们也只需对它做一趟上滤，", "就可将它插入到当前这个堆中，从而最终得到一个规模为5的堆。", "从逐一插入各节点的角度来看，这个算法平淡无奇，其正确性也因此显而易见。", "那么，这个简明的算法效率又如何呢？"]}, {"name": "11c1-1: \t重复匹配的前缀", "block_id": "a07ffd8ff8ab4fb5afc35f88c2950898", "text": ["关于串匹配", "包括蛮力算法在内", "据我所知 至少有30多种知名的算法", "而接下来 我们就将介绍其中最为经典的KMP算法", "这个算法之所以著名", "不仅是由于它出自包括Knuth在内的若干名人之手", "而更为重要的是 它正如我们此前所期盼的那样", "能够保证即便在最坏的情况下 运行时间也不超过线性", "当然 在这一部分的末尾 我们也将通过对比指出", "这一算法从某种意义上讲 也是被过度地神话了", "正所谓不破不立", "我们的KMP之旅 是起始于蛮力算法", "让我们首先来揭示 蛮力算法为什么会如此低效", "从宏观上来看", "蛮力算法的一次典型的运行过程 可以由这样一幅图来示意", "假定这就是足够长的一个文本串", "而下边则是相对而言更短的模式串", "我们知道 在算法的每一步迭代中", "相对于文本串", "模式串都有一个相应的对齐位置", "请注意 在这个算法中", "相邻的对齐位置之间 间隔都是一个字符", "在每一对齐位置", "这个算法都需要从首字符开始", "进行一系列的比对", "直至在某个位置发生失配", "请注意 在此之前每一次迭代所花费的时间 都正比于这样一个前缀", "在这个图中 我们可以清晰地看到", "所有这些前缀之间", "存在着大量的重复", "也就是说 在此前曾经参与比对的字符", "在后续的迭代中", "往往还会再次地参与比对", "如果我们将视线集中于文本串中的某一特定字符", "就会发现 在最坏情况下 它有可能会与模式串中的每一个字符都比较一次", "也就是说 文本串中的每一个字符 都有可能参与多达m次的比对", "依然回到我们上一节末尾针对蛮力算法所给的那个最坏实例", "我们可以从这样一个新的角度来阐释 为什么蛮力算法效率如此低下", "因为站在文本串中每一个字符的角度来看", "在这种最坏情况下", "它都会与模式串中的每一个字符比对一次", "在这类最坏情况下", "每一步迭代 都需要经过长途跋涉", "才能够在最后一个位置发现失配", "因此反过来 这类情况之所以棘手", "也可以理解为在模式串中存在大量与文本串能够局部匹配的前缀", "而蛮力算法的计算成本 也主要消耗于这些前缀中", "然而 在对这个具体的实例进一步观察之后", "我们或许会发现", "这些局部匹配前缀所涉及的比对", "绝大多数都是不必进行的", "至少不必反复进行", "你能看出其中的原因吗"]}, {"name": "02D1-1 \t有序性", "block_id": "431747052b834deaa87a16d57d005f1b", "text": ["欢迎同学们回来", "接下来的几节 将重点围绕", "有序向量展开讨论", "所谓有序向量", "是相对于无序向量而言", "无序向量要求元素之间", "至少应该能比较是否相等", "我们称作比对操作", "而有序向量呢 更为复杂", "它需要能够判定任何一对元素孰大孰小", "这叫作比较操作", "元素之间可以相互比较", "只是有序向量的一个必要条件", "如果要成为一个真正的有序向量", "还必须要求其中的元素", "确实是按照顺序排列的", "因此就存在一个如何甄别", "一个向量是否有序的问题", "那么为此呢 我们可以回忆起", "此前所介绍的起泡排序", "当时曾经讲过这么一个基本的事实", "包含向量在内的任何一个序列", "如果整体是有序的话", "那么任何一对相邻的元素必然是顺序的", "反之 如果是无序的话", "那么至少存在一对相邻的元素是逆序的", "如果将这种相邻的逆序元素", "称作是逆序对的话", "那么 这种相邻逆序对的总数", "就可以成为度量一个向量逆序程度的指标", "相应地 我们也就可以按照这种指标", "来进行比较和统计", "我们可以看到", "主体上是由这个循环完成的", "具体来说 就是从第一号", "注意不是第零号元素开始", "依次地 将当前的第i个元素", "与第i-1个元素", "也就是它的紧邻的前驱 进行比较", "如果它们确实构成一个相邻的逆序对", "就累计到累加器中去", "最终将这个累加器返回", "所以根据上面的分析 我们可以知道", "一个向量是有序的", "当且仅当经过disordered()判断以后", "返回的值是零", "实际上 我们后面会看到", "只要向量中的元素本身是支持大小比较的", "我们就有一定的办法将它转化为有序向量", "其中的原因在于", "经过这样的一个转换以后", "虽然我们花费了一定的成本", "但此后涉及到的很多操作", "也就是相关算法", "大多都可以优化 而且大大的优化", "相应地所得", "要远远比转换时", "所花费的成本大的多", "我们下面就来看一个例子"]}, {"name": "08B3-3\t算法实现", "block_id": "81473b0b431143719409b20d079a818a", "text": ["以上B树查找算法的策略 又当如何以代码的形式具体实现呢", "这里给出一种可行的实现方法", "假设我们的目标关键码为e", "查找过程中的逐层深入在这里是通过一个while循环来具体兑现的", "在进入循环之前 我们首先要对内部的_hot引用进行初始化", "同时将v初始化为指向树根节点", "在这个引用v变空之前 整个循环会持续的进行下去", "while循环的每一步迭代", "都对应于在当前层当前节点中的一趟顺序查找", "具体的 这可以兑现为在当前节点的关键码向量中", "通过向量的查找接口 查找目标关键码", "如果查找成功 则直接返回这个节点", "这也是该算法成功返回的出口", "反之 至此意味着当前的顺序查找是失败", "于是我们就需要找到当前节点的某个孩子", "通过IO将其读入 并且重新令v指向这个新的节点", "当然在此之前 我们还需同步的更新hot引用", "那么究竟是哪个孩子节点呢", "这里的原则是 如果此前失败返回的秩为r", "则应该转向第r+1个孩子", "请注意 在这里每个节点中所包含的关键码", "以及对应的后代引用 尽管分别都是组织为向量", "但在逻辑上我们不妨将它们稍作错位 按这种形式来排布", "这种排布是有道理的 因为它可以更加便捷和清晰的", "让我们看成每个节点与它的左右孩子之间的关系", "是的每个节点与它的左和右孩子", "你也应该记得 我们此前在实现向量的查找算法时", "曾经对返回值的语义做过严格的界定", "也就是说 返回的必然是不大于目标关键码的最大值", "因此如果顺序查找失败于第r个关键码", "也自然应该顺着第r+1个引用深入到下一层继续搜索", "请记住这样的对应关系 第r个关键码以及第r+1个后代引用", "因此 这种迭代也不可能一直持续下去", "即便在最坏的情况下 v也迟早会变成空", "此时可以退出while循环 并且通过返回null报告查找失败"]}, {"name": "08B2-1\t观察体验", "block_id": "e8ae6273d56b4ceb90d46baeffea1010", "text": ["好的 现在就让我们来揭开B树神秘的面纱", "看看它在内部究竟是怎样一番模样", "这就是一棵典型的B树", "与此前的二叉查找树一样", "B树也是用来存放一组具有关键码的词条的数据结构", "但是它的特点也非常的鲜明", "我们可以看到首先这里每一个节点未必只有两个分叉", "实际上 可以拥有更多的分叉", "其次呢 所有底层节点的深度都是完全一致的", "从这个意义上讲 它不失为一种理想平衡的搜索树", "最后 也是最重要的一个整体特征", "我们注意到相对于常规的二叉查找树", "B树会显得更宽 更矮", "那么为什么B树会长成这样一副模样呢", "背后又有什么原因呢", "现在回答这个问题还略早", "你不妨先将这个问题记下来 看看在这一节的学习完成之后", "你是否能独立的给出背后的答案", "当然B树也是可以动态变化的", "比如我们可以在其中插入一个新的词条100", "请注意 一个新的词条出现了", "而且在插入词条之后 B树有可能会相应的自我调整", "比如这样", "以及这样", "同样 逆向的操作也是可行的", "比如我们可以将刚插入的这个词条100删除掉", "我们首先查找到这个词条 并且将其摘除", "为了删除某个词条 B树同样有可能进行拓扑结构的调整", "比如我们继续来删除其中的这个111", "同样 我们需要通过查找对它进行定位", "接下来摘除掉这个词条", "并相应的进行拓扑结构的调整", "直至重新恢复为一棵B树", "那么在B树的这样一个静态结构", "以及刚才我们所看到的动态调整的背后", "究竟是什么样的一些规则呢", "又为什么会采用那样一套规则呢"]}, {"name": "08A1-6\t一步一步往上爬", "block_id": "42cc12e9f8c84401813375b9328e151d", "text": ["概括而言 对某个特定节点的伸展调整过程", "无非就是 自下而上 逐层做单旋调整", "非常有意思的是 如果借用《蜗牛》那首歌", "中的一句歌词来形容这个过程是再贴切不过的了", "在那首歌里 我们会唱道 我要一步一步往上爬", "描述的 难道不正是这样一个过程吗", "是的 我要一步一步往上爬", "按照刚才所设定的策略", "也就是任何节点一经访问 就随即被推送至树根", "我们已经可以得到某种意义上的伸展树", "然而不幸的是 尽管蜗牛那首歌的旋律和歌词都非常优美", "但是就效率而言 那句一步一步向上爬所暗示的策略", "并非是最佳的选择", "原因在于它有最坏情况"]}, {"name": "08A3-1\t功能接口", "block_id": "22ff963a02c849299b48615827d3e90f", "text": ["这里再次采用模板类的形式给出伸展树的接口定义", "可以看到 作为BBST的又一变种", "它自然可以在我们此前已经设计并实现的BST类的基础上", "通过派生直接得到", "具体的 与AVL树一样 我们也需要重写", "其中的insert和remove这样两个动态的操作接口", "而与AVL树不同的是 在这里我们还需要重写search接口", "回顾一下 在其他的众多变种中 search接口都可以视作是静态的", "也就是说 它并不会导致树中节点之间拓扑连接关系的变化", "然而在伸展树中 正如我们此前已经看到的 这是个例外", "即便是查找操作 也会引起全树的结构变化", "因此这个接口在这里也需要重写", "然而正如我们马上就要看到的 这个接口对于伸展树而言举足轻重", "这个接口内部的实质功能 无非是完成伸展", "因此在这里我们也设计并提供了一个保护类型的splay接口", "用以实现这个功能"]}, {"name": "10b2-1: \t上滤", "block_id": "013d6c4391f14bb5b45bd5a4d2cfb344", "text": ["好，接下来我们就来学习在一个完全二叉堆中，", "如何有效地插入一个新的元素。", "我们将会看到，插入过程中的核心技巧是所谓的“上滤”过程。", "为了在完全二叉堆中引入一个新词条e，", "我们只需在物理上将它作为末元素", "直接插入至对应的向量之中——", "没错，向量。", "请记住，尽管在逻辑上我们可以将优先级队列理解成一棵完全二叉树，", "但是在物理上它依旧是一个不折不扣的向量。", "向量在物理上增加一个末元素，", "相当于在这棵完全二叉树底层向空缺部分拓展一个节点。", "我们可以看到，将新的词条作为末元素接入向量的好处在于，", "可以使得完全二叉堆的结构性得以延续。", "当然，另一条件，也就是堆序性如果也能够得以延续，", "我们也能够大功告成。", "然而很遗憾，在新的节点引入之后，", "堆序性未必能够延续。", "当然，即便如此，情况也不致太糟糕，", "唯一可能违背堆序性的只有新插入的这个节点与它的父亲。", "也就是说，新插入的这个节点拥有一个父亲，", "而且在数值上，新插入的这个节点要大于它的父亲。", "既然找到了问题的症结，我们也就自然得到了解决的办法。", "没错，在这种情况下我们只需将新插入的节点e与它的父亲互换位置，", "从而转化为这样一种状态。", "不难看出，经过这样的转换之后，", "不仅顺利地解决了节点e与它此前的父亲的逆序性，", "不仅顺利地解决了节点e与它此前的父亲的逆序性，", "同时其它所有节点之间的堆序性也不致受到影响。", "当然，问题未必就此完全地解决：", "因为e有可能依然会有一个新的父亲，", "而且如果不巧e有可能依然会大于这个新的父亲，", "也就是说e和它新的父亲再次违反堆序性。", "你应该知道如何解决这个问题了，", "是的，我们只需再次套用此前的策略，", "令e和它新的父亲互换位置，", "从而进入这样一种状态。", "同样，经过这样一次交换，在刚才这一层的逆序性得到了修复，", "而且不致同时影响到其它的节点。", "接下来如果依然存在问题，", "也只可能是e和它新的父亲违背堆序性。", "果真如此，我们可以继续令e和它的父亲互换位置，", "从而转入这样一种状态。", "好消息是，这样一种反复交换过程满足某种单调性。", "不难看出，每经过这样一次交换，e的高度就会上升一层。", "同时违反堆序性的情形如果存在，也必然会上升一层。", "既然这样一个逐层调整的过程充其量不过抵达到树根，", "因此也迟早会终止于某个位置。", "而一旦这个过程终止，也就意味着堆序性在这个完全二叉堆得到了彻底的恢复。"]}, {"name": "01c-2: 大O记号", "block_id": "2cd3fbd0d38042fc92c81e9523fc4677", "text": ["为此我们可以采用所谓的大O记号big-O notation", "来从形式上简化我们刚才所说的", "度量时间成本的T（n）的表示", "具体来说 在满足一些条件以后", "我们可以在big-O的意义下", "将大写的T（n）表示为某一个f（n）函数", "什么条件呢？", "这个充要条件就是", "我们存在一个预先确定的一个常数C", "而且确实 当n足够大之后 我们就会发现", "T（n）绝对不会超过F（n）的c就是常数倍", "这样的话就有可能使得我们更为简便地", "界定一个算法的复杂度", "我们可以来看这样一个例子", "假设我们已经得到了", "这样一个T（n）的表达式", "那么我们可以看到 这个表达式", "像通常的一样 总是会显得略微复杂", "我们不容易抓住其中主要的脉络", "为此我们可以采用", "刚才所说的那个办法 不断地简化", "大家注意 这里我们用的是小于号", "也就是说 我们可以不断地", "对函数大写的T（n）做放大", "比如说 我们先把其中这个2替换成n", "刚才我们说了 n足够大以后", "是会远远地大于2的", "我们不妨替换成它", "那么很快我们就可以看到", "这个地方就是2n", "这就是为什么我们可以将这个", "经过依次放大之后", "转化为6的n方", "接下来我们再采用这种办法", "对4做一个放大", "我们同样的把它放大成n方", "这就是为什么有一个7n方", "乘上前面的5n以后 我们说", "可以得到一个35倍的n的立方", "接下来 我们再对6做一次放大", "放大成n的立方", "这样的话 我们可以得到", "36倍的n的立方", "这就是为什么我们说", "大概是等于6倍的n的3/2次方", "我们说 因为这里还有一个常数", "而这里可以看到", "其实常数是无所谓的", "所以我们可以把这个6进一步地抹去", "从而通过在外面再加一个big-O记号", "来完成这样的一个估计", "刚才那个例子已告诉我们", "经过这样的一次变换以后", "big-O内 用来近似的那个函数f（n）", "将会更加地简捷", "而且 同时它也依然能够", "准确地反应前者的增长趋势", "根据这样的一个定义", "这样的一个充要条件", "我们可以得出", "关于大O记号的两个重要的处理的手法", "第一个 任何这种函数的常系数是可以忽略掉的", "就像这样 可以视为1", "第二个方面 低次项也是可以忽略掉的", "也就是说 如果一个表达式可以表示", "或者是至少展开成", "这样的一个多项式的形式", "其中的低次项", "比如说b相对于a 略要小一些", "低次项 n的b次方 是可以忽略掉的", "从这里 我们也再次看得出来", "我们前面所讲过的 所谓的长远", "是体现在n足够大", "而所谓的主流 就体现在", "所有这些常系数和低次项", "我们说 非主流一些旁枝末节的因素", "都可以在此忽略", "使得主流的信息能够突出出来", "我们依然用一个图来表示", "这个图是在原来那个基础上", "增加了一个big-O的这样一条虚线", "我们可以从这个图很好地看出来", "big-O所设计和定义的用意", "也就是说 它可以理解为", "在上方给出了T（n） 也就是", "我们说的这个时间复杂度的一个上界", "也就是upper bound", "所以 我们也可以认为big-O", "是对T（n）的一个悲观的估计", "这里我们再次提醒大家", "注意这个图所画的用意", "大家可以看到在n规模比较小的区域内", "我们说这个T（n）未必一定", "在big-O这个曲线的下方", "其实这里还有一个含义", "我们没有通过这个图画出来", "也就是说 实际上这个big-O的upper bound的这条线", "完全是可以在常系数的意义下的", "它在准确的数值上 未必是低于大写的T（n）", "只要预先约定好的一个常系数c", "它经过放大能够完成构成上界的功能", "就可以了", "所以 这是我们所说的大O记号", "我们可以看到非常地简明"]}, {"name": "12a4-1: 不变性", "block_id": "11ace5e04b6b42a68923520034c51677", "text": ["实际上同样是按照霍尔爵士", "最初的设想和思路", "快速排序算法还有很多", "其它的实现方式", "比如在这一节我们就来介绍", "其中的一个有趣变种", "新算法的原理及过程", "同样可以由这样一组图来示意", "可以看到与此前的基本版本相比", "这里的不变性几乎完全一样", "首先我们也是始终将整个序列视作为", "四个部分", "也就是一个侯选的轴点", "以及名为L G和U的三个子序列", "而且这里同样始终要求", "在数值上子序列L中的元素", "都必须严格的小于侯选轴点", "而且对称的子序列G中的元素", "在数值上也不得小于侯选轴点", "然而从这种图中", "我们也可以发现", "这个新的版本", "与此前的基础版本", "也的确存在着微细而本质的差异", "这种差异就体现在L U和G", "这三个子序列的相对位置", "你应该记得在基础的版本中", "子序列U是加在L与G之间的", "而现在的次序则由以前的LUG", "变成了现在的LGU", "当然我们在这里也约定", "这三个子区间的边界", "将分别由lo mi hi 以及k来界定", "也就是说lo和mi之间是L", "mi与k之间是G", "而k到hi则为U", "那么在继续维持不变性的前提下", "新的这个算法", "又是如何使得子序列L和G", "得以单调的递增呢"]}, {"name": "11e2: \t构造gs表", "block_id": "89381c09b14245c8ad8a0f4f1eeff94d", "text": ["以下 我们就来简要地介绍gs表的具体构造算法", "为了便于理解其原理", "这里将整个算法划分为若干个层次", "并逐层递进 逐层细化", "我们首先需要引入MS子串与ss表的概念", "实际上 相对于模式串中的任何一个字符P[j]", "所谓的MS[j]", "就是某个以P[j]为末字符的子串", "而且 这个子串也同样会出现于整个模式串的尾部", "当然 如果同时存在多个这样的候选", "我们会在其中选择最长的那个", "概括而言 所谓的MS[j]", "就是终止于P[j]", "同时与全串的后缀实现最长匹配的子串", "当然 这个子串也有可能是空", "我们来看这样一个实例", "对于P[8] 也就是字符E而言", "它所对应的MS子串自右向左由E、C、I、R这4个字符组成", "因为这个子串与整个模式串的后缀", "实现了最长的匹配", "相应地 在ss表中", "j所对应的那一项", "其实也就是MS[j]子串的长度", "在刚才这个例子中", "8号字符E所对应的ss表项 也自然就应该是子串RICE的长度4", "同理 对于字符P[2]而言", "它所对应的MS子串为ICE", "相应的ss表项 也就是这个串的长度 3", "实际上 在中转的这个ss表中", "已经蕴含了我们最终要计算的gs表的所有信息", "因此 快速构造gs表的问题", "也就自然地转化为了如何快速地构造ss表", "那么 通过ss表 具体地如何构造出最终的gs表呢", "无非两种情况", "首先 ss[j]可能达到最大的极限 也就是j+1", "此时的情况如这个图所示", "也就是说 MS[j]子串足够长", "以至于它就是整个模式串的一个前缀", "于是 对于这个范围内的任何一个字符P[i]", "一旦在扫描比对中发生失配", "m-j-1也必然是一个值得考虑的位移距离", "此外 都是一般的情况", "也就是MS[j]子串的长度充其量不过j", "此时的情况可以由下面这幅图来示意", "可以看到 此时的MS[j]子串", "长度还没有达到极限", "于是如果将来在扫描比对的过程中在这个位置处发生首次失配", "接下来一种值得考虑的位移距离自然也是m-j-1", "通过以上的分析可以看到", "构造gs表 关键就在于如何构造出ss表", "当然 根据以上定义", "即便采用蛮力策略", "也是可以构造出这个表的", "然而很遗憾", "我们为此需要平方量级的时间", "那么 这个结果能否改进呢", "答案是肯定的", "在我们的习题解析中", "给出了具体的算法描述", "以及代码实现", "好消息是 采用这一新的算法", "我们只需线性的时间", "就足以构造出gs表"]}, {"name": "01-A-1: 计算", "block_id": "7321f00db10b461f93039df886fe9e8f", "text": ["下面就进入这门课程的第一章第一节", "我们首先来讨论所谓的计算", "计算首先是我们这门课程的直接研究对象和内容", "同时更重要的它也是", "我们这门课程最终的研究目的和目标", "具体说来 我们需要研究在计算的过程中", "所蕴含的本质的内在的规律", "也需要总结和挖掘出其中一般性的方法", "以及典型的技巧", "当然最终所有这些都需要服务于我们的研究目标", "也就是实现有效的和高效的计算", "同时也需要在资源的消耗方面做到足够的低廉", "实际上推而广之", "所谓的计算 也可以看做是", "整个计算机科学的研究对象内容和目的", "因此在这里我们不妨重温一下", "著名的计算机科学家Dijkstra的一段名言", "他说所谓的computer science也就是计算机科学", "更准确的说应该称作", "computing science计算科学", "我们体会其中的原因在于", "他实际上是在强调 所谓的计算机", "无非是我们的一个工具和手段", "而计算才是我们不应忘记的", "最终的研究目的和目标"]}, {"name": "02D2-1\t 概述", "block_id": "7307c85f4b264685b9ca37bcc031c7da", "text": ["欢迎回来 我们继续讨论有序向量", "在这一节以及接下来的两节中", "我们将重点讨论有序向量的查找算法", "同学们应该记得 此前的第c节", "已经介绍过无序向量的查找算法", "它的格式大概是这样", "总共有三个参数", "其中第一个参数 指明查找的对象", "第二和第三个参数lo和hi", "指示查找的区间范围", "这种算法从思路上来说 大体是", "从一端出发不断地逐个比对", "直到发现某一个特定的元素就是e", "或者一直到 实际上是lo-1这个位置", "在左侧越界", "从而这个地方是失败", "成功", "所以最好情况", "虽然它只需O（1）的时间", "在这个地方命中", "但是我们说 从最坏的情况", "以及从一般的概率分布e而言的平均情况而言", "都不得不需要线性的时间", "那么在进入有序向量之后", "我们就应该可以得到更快的一种解决方案", "我们把这个不妨重新起一个名字", "管它叫search", "以示与无序向量的那个find的区别", "当然从操作的参数以及接口的语义来说", "都是类似的", "也就是说 我们同样要在", "lo到hi这样一个左闭右开的区间里", "找到一个特定的元素", "在这一节里 我们要介绍二分查找"]}, {"name": "10a1-1: \t应用需求", "block_id": "dd1aa6857ca6445faa2025a2d4148c79", "text": ["同学们好，从今天开始，我们将进入第10章，优先级队列。", "我们将会看到，这是一类非常有趣的数据结构。", "顾名思义，在逻辑上，它们首先是队列。", "然而与常规的队列不同，其中的元素接受访问的次序未必是先进先出，", "而是按照所谓的“优先级”进行访问。", "以下，就首先让我们来通过几个具体的应用实例，", "体会设计和实现这种数据结构的用意所在。", "我们的第一个应用场景是夜间门诊。", "假设某家医院在夜间只安排了一位医生值班，", "那么他将按照什么样的次序为到来的病人提供服务呢？", "如果只是一般的感冒发烧、头痛脑热，那么自然是采用先来先服务的次序。", "然而真实的场景要复杂得多。", "比如，倘若某位病人是发生了骨折，", "那么相对于一般的病人，他更应该优先地接受处置和治疗——", "即便他是刚刚才到。", "而即便是在这位骨折病人接受处置的过程中，", "如果又有一位心脏病突发的病人到来，", "那么相对而言，骨折就显得不那么重要了。", "是的，在这样的场景下，每一位医生都会将包括骨折病人在内的所有病人放在一边，", "而去优先治疗这位刚刚到来的心脏病患者。", "可以看到，在这一场景中，此前的先到先服务的原则已经不再继续适用。", "实际上在我们的电脑中，这样的场景每时每刻都在发生，", "因为当今的绝大多数操作系统都支持多任务，", "而操作系统对于多任务的调度策略也与门诊医生类似。", "如果将电脑类比于医院，那么CPU就类似于门诊医生，", "而同时参与调度的计算任务，则可类比于同时等候门诊的一批病人。", "在这里，每个任务都有一个指标，有的数值更大，有的数值略小。", "当然，这些指标都是动态变化的，", "而操作系统总会挑选指标最大的那个任务，交由CPU进行处理。", "在这里，每个任务所拥有的指标，可以类比于每个病人的病情严重程度，", "这个指标的数值越大，或者病情越严重，则会优先接受服务，", "因此我们也称之为“优先级别”，或者简称“优先级”(priority)。", "在算法方面，这类的需求更是举不胜举。", "比如，在Huffman编码树的构造算法中，", "我们就需要将整个森林组织为某种高效的数据结构，", "从而可以使得我们可以反复地从中取出权重最小的两棵子树，", "并将它们合并之后，重新加入到森林之中。", "而在基于扫描线策略的诸多算法中，", "我们也需要将所有的事件点组织成某种高效的数据结构，", "从而使得我们可以反复取出最邻近的事件，", "完成相应的处理，", "并将可能生成的新事件加入到这个数据结构当中。"]}, {"name": "10xa1-6: 左展右敛", "block_id": "0c52c616f140492da18b42f1f45be95c", "text": ["实际上对于左式堆而言，左子堆和右子堆在规模和高度上的差异并不是那么重要，", "真正重要的是全堆的右侧链。", "在以x为根的任何一个子堆中，从这个节点出发一路向右不断前行所确立的那个分支就称之为右侧链。", "特别地，对于全树根节点而言，它的右侧链的终点必然是全堆中深度最小的一个外部节点。", "比如在这个图中，相对于根节点r，它所对应的右侧链的终点应该是这个外部节点。", "刚刚介绍过，在左式堆中r的NPL值必然是它的右孩子基础上累进一个单位，", "而它的右孩子呢？也必然是在它的右孩子基础上累进一个单位。", "如此递推，可以得知所谓NPL(r)必然是在这个终端节点，npl值也是0的基础上不断累进而得。", "因此，如果r的NPL值为d，则不仅意味着这个外部节点的深度也是d，", "而且更重要地，按照我们当前的结论，必然存在一棵以r为根高度为d的极大满子树。", "这一点对于左式堆来说至关重要，事实上这就意味着在左式堆中应该包含足够多个节点。", "因为即便我们只计入这颗满子树，也至少应该有2^(d+1)-1个节点。", "当然，也至少包含2^d-1个内部节点。", "没错，如果根节点的NPL值为d，那么其中就至少含有2^d个节点。", "反过来，如果将左式堆的规模固定为n，那么右侧链的长度d也就至多不过log(n)，", "没错，右侧链的长度至多为log(n)，这难道不正是我们最初的设计目标吗？", "因此进一步地，如果我们所设计的堆合并算法的确能将操作的范围限定为右侧链，", "那么相关算法的复杂度也同样可以控制在log(n)的范围，那么这样的算法到底是如何运转的呢？"]}, {"name": "03D-1\t 构思", "block_id": "aeac88a148d54a75b8b6fc2435c2f956", "text": ["欢迎同学们回来", "与向量那一章的做法一样", "列表这一章 接下来几节", "也将针对列表这种结构的特点", "介绍几种典型的排序算法", "比如 这一节我们要介绍的就是", "选择排序", "这种排序算法其实并不神秘", "我敢打赌 你在日常生活中", "此前肯定已经甚至经常使用这种方法", "举个例子", "假设你有一篮子苹果 或大或小", "如果你需要从小到大", "把它们排成一个序列", "那你会怎么做呢？", "我想大家常用的一种方法", "应该是这样的", "首先在其中挑选出最大的", "接下来 在剩下的中 挑选出最大的", "也就是整个来说 次大的", "再往后呢 当然是接下来的最大的", "也就是整个的第三大的", "不难看出 这个过程可以继续下去", "直到篮子中只剩下最后那只苹果", "虽然我们这里画得很夸张", "但是它确实是全局最小的那个", "可以看出 在这个过程中", "我们所采用的策略", "或者说原则非常的简单", "具体来讲 就是", "每一次我们只需在篮子中", "找出当前最大的那只苹果", "并且随即将它转移到桌子上", "这个策略是如此简明", "以致于我们可以反复地进行", "直到最后", "可见 这里每一步所做的", "实质的关键动作", "其实无非就是所谓的选择select", "而基于这样一种选择过程", "和策略的排序算法", "就叫作selection sort", "即便是在这门课中", "我们也不是第一次接触到选择排序", "我并没有骗你", "回顾一下此前", "我们所介绍过的bubble sort", "其实它也是一个不折不扣的", "selection sort", "难道不是吗？", "我们来看一下", "在这样一个算法的过程中", "我们曾经讲过", "它的不变性可以表述为", "整个序列总是可以", "分成前后两个部分", "其中后面的一个部分", "是由一系列已经就位的元素组成的", "它们构成了一个有序的sorted的部分", "而前半部分的元素呢", "数值的分布是随机的 或大或小", "但是就数值而言", "它们都绝对不会超过这样一条黄线", "也就是说 如果从分布讲", "它们都应该落在", "这样一个黄色的矩形中", "那这个算法我们讲过", "是由一趟又一趟的扫描交换构成的", "在接下来的一趟扫描交换中", "最实质的故事实际上是", "从当前最大的那个元素开始的", "我们讲过此后的情节是确定的", "也就是说 这个最大的元素", "必然会和随后的邻居", "以及再随后的邻居", "以及再随后的邻居", "不断地交换", "直到它最终", "被移送到", "这个黄色区域的末尾", "于是这个有序的S部分", "就可以向左侧拓展", "或者说生长一个单位", "这也是我们所说的", "这个算法的单调性", "纵观这个过程", "并且与上面的选择排序做一对比", "我们会发现 二者之间惊人的相似", "也就是每一次扫描交换的作用", "其实实质上都等价于", "找到这个最大节点", "并且随即将它转移至有序", "和无序子序列的分界点", "从这个角度来看", "起泡排序确实就是", "一个不折不扣的选择排序", "那反过来 既然如此", "还有什么必要去专门讨论选择排序呢？", "原因在于 起泡排序的效率太低", "正如我们此前说过的 在最坏情况下", "它需要n平方", "我们注意到 这个效率", "是完全可以改进的", "细加观察我们可以发现", "在起泡排序的过程中", "所执行的计算无非两类", "一类就是相邻元素的比较", "另一类才是元素位置的交换", "然而很遗憾", "在这里将最大元素", "转移至合适的位置这样一个任务", "是由一系列的短距离", "实际上是相邻元素之间的移动构成的", "这种小步慢跑式的移动", "正是低效率的来源", "所以反过来", "既然我们最终实际上无非", "就是要将这个最大的元素", "挪到最终的位置", "为何不直接一次性地", "来完成这项工作呢？", "没错", "这正是我们改进的思路"]}, {"name": "06B1-8 顶点动态操作", "block_id": "5f3d315c406541d2a0419b4878890d34", "text": ["那我们接下来", "讨论如何在图中引入一个新的顶点", "相对于边的操作", "这种操作要更为复杂", "原因在于", "在此前的边操作中", "整个矩阵的规模", "并不会发生变化", "而顶点的插入", "以及稍后的删除就不是这样了", "我们假设此前", "以邻接矩阵所实现的图", "在内部是这样一个场景", "一个顶点向量", "以及一个二维的边向量", "也就是邻接矩阵", "为了在其中引入一个新的顶点", "整个的过程以及最终的结果", "可以由这样一幅图来表示", "首先我们要将邻接矩阵中", "已有的各行分别向后扩展一个单元", "也就是我们说的", "增加一列", "接下来 针对新引入的那个顶点", "我们还需在邻接矩阵中", "增加对应的一行", "当然 作为二维的边表", "我们还需在第一级的边表中", "增加一个相应地单元", "用来指示或者说记录", "新引入的这样一个行向量", "最后对应于这个新引入的顶点", "我们还需要在顶点向量中", "加入一个新的对应元素", "这样的四个步骤", "可以总体地描述为这段代码", "为了插入一个新的顶点", "我们正如刚才所说的", "首先需要做的一件事情", "是为每一个行向量", "分别增加一个单元", "也就是在每一个行向量的尾部", "引入一个初始为空的记录", "所以总体相当于各自延长一个单位", "接下来我们需要生成一个行向量", "这个行向量中的元素", "都是一系列的边记录", "它的总数是n", "而且其中所有边引用", "都初始化为空", "请注意 在第一步延长了", "每一个已有的行向量之后", "我们曾经随手将n递增过", "因此这里所生成的这个新的行向量", "实际上长度要在原来的基础上", "会增加一个单位", "总而言之", "我们能够生成这样一个", "长度为新的n的行向量", "那么接下来呢", "我们还要取出这个行向量的地址", "并且将它存入到第一级的边表中", "而这一步呢 是由在一级的这个边表中", "调用insert命令来完成的", "整个这一系列动作串联起来", "完成的相当于是第二步和第三步", "当然最终我们还需要创建", "一个对应的顶点记录", "并且存入于整个的顶点向量", "也就是这个向量之中", "如此才整体地完成了", "一个新顶点的引入", "尽管这个顶点与已有的其它顶点之间", "还没有任何实质的连边", "相应地 顶点删除的过程", "也可以描述并且实现为", "这样一段代码", "不难理解 整个过程", "无非是刚才顶点插入过程的逆过程", "这个过程的分析以及验证", "交给同学们在课后完成"]}, {"name": "09C-1 冲突难免", "block_id": "a99b6d3e5bf34a4ba70ed915ef62e858", "text": ["好 接下来的这一节我们就来介绍散列策略中的第一项", "也是最重要的技术 散列函数的设计与定制", "在上一节我们已经看到", "散列策略具有诸多的优势和巨大的潜力", "然而尽管如此 冲突却是这一策略的致命缺陷", "然而更糟糕的是 从理论上讲 这一缺陷是无法根本消除的", "依然回到我们电话键盘的实例", "借助字符来助记电话号码的策略 尽管十分精巧", "但同样不难举出冲突的实例", "比如有时你需要找某个人", "但对应的号码却有可能属于某个学院", "你要找的或许是欧几里得 但这个电话却有可能属于小黄鸭", "你可能需要联系太阳鸟 但接听这个电话的却可能是只臭虫", "凡此种种 皆是冲突", "我们知道散列函数无非是一个映射", "其功能无非是将词条空间中的元素映射到散列表地址空间", "而在通常的情况下 前者要远远的大于后者", "因此绝不可能是一个单射", "当然面对这种现实 我们并非无可作为", "这方面的一条好消息是 在一般的实际应用中", "我们还是可以在一定的程度上得到一个近似的单射", "比如黑白打印机经常要做的一件事就是", "将原本是彩色的图像 转换为黑白灰度", "从映射的角度来看 这样一种转换也是散列", "对于这个散列而言", "数据项的取值范围应该是图像中各像素可能取的颜色种类数", "也就是2的24次方", "而散列表的长度呢 也就是灰度的级别 2的8次方", "二者之间的差异 已高达10的4至5次方", "然而尽管经过了如此之大幅度的压缩", "对我们辨识灰度图像中的物体 并没有多大的影响", "当然这主要得益于图像中各像素在空间上是有一个分布的", "然而即便离开这个条件 一般意义上的散列", "也是有可能做得足够实用的", "为此我们需要做两件事 这也是实现散列的两项基本任务", "首先我们需要精心的设计散列表及其对应的散列函数", "消除掉一些能够导致冲突的先天性因素", "从而尽可能的压低日后发生冲突的概率", "这也是本节讨论的主题", "当然既然无论如何都不可能从根本上消除冲突", "所以我们也应该在事先准备好充分的预案", "日后一旦发生冲突 我们就可照此预案及时予以排解", "关于冲突的排解技巧 我们将留到下一节"]}, {"name": "11c2-2: \t主算法", "block_id": "182fa15a0d6140cdacfcc75cc61a1d85", "text": ["我们现在就来考察KMP的主算法", "可以看到 无论接口形式", "还是算法的主体流程", "KMP与我们此前蛮力算法的版本一", "都颇为类似", "是的 它的确是在版本一的基础上", "略加修改而得的", "尽管在形式上 这种改动非常地细微", "但是在本质上 却有巨大的区别", "首先 这里增加了一步预处理", "也就是构造出我们刚才所说的那份查询表", "我们称之为next表", "正如我们刚才所言", "这个构造过程 仅仅取决于模式串", "而与文本串没有任何关系", "因此是名副其实的预处理", "接下来与蛮力算法一样", "我们也需要两个整数 i和j", "分别指向文本串和模式串中当前接受比对的那一对字符", "算法的主体循环也基本类似", "if分支完全一样", "差异仅仅体现在else分支", "可以看到 KMP算法在失配情况下的处理更为简明", "具体来说 只需从查询表中取出j所对应的那一项", "并且用它来替换此前的j", "请注意 在这种情况下 KMP并没有修改变量i", "也就是说 它依然指向文本串中此前刚刚失配的那个字符", "这样的处理过程 可以由这幅插图来说明", "请再次确认 此时情况也就是", "在当前的这轮比对中", "主串的字符T[i]与模式串的字符P[j]首次发生了失配", "在算法中 也就对应于那个else分支", "在这种情况下 如果此前模式串所对应的那个前缀长度为j", "那么接下来 KMP算法将会把这个前缀", "替换为长度为next[j]的那个新的前缀", "并从刚才失配的那个位置出发 继续下一轮比对", "当然 细心的你可能会发现", "相对于蛮力算法", "这里的if分支也并非完全地一样", "是的 在对应的逻辑判断式中", "这里新增了一个并列的条件", "j<0", "关于这个条件的妙用之处", "现在来谈还为时过早", "我们不妨暂且将其搁置起来"]}, {"name": "11d1-2: 善待教训", "block_id": "2dc71e95493a4f78853ebf11e1153c02", "text": ["让我们将视线拉回到蛮力算法", "你应该记得 蛮力算法一次典型的运行过程", "可以表示为这样一幅图", "是的 如果将文本串固定在这里", "那么 这些就是模式串在不同对齐位置处的历史快照", "事实上 模式串在每一个对齐位置的故事 都是类似的", "首先 要经过若干次成功的比对", "在这里 用绿色的线条来表示", "而接下来 总是一次失败的比对", "此后 在下一位置的故事依然", "该算法也需要经过若干次成功的比对", "然后终止于失败的比对", "而在接下来的第三次、第四次、第五次等等等等", "各次对齐中 也同样都是要经过若干次成功的比对", "并终止于一次失败的比对", "因此 就局部的每一次对齐而言", "我们都需要经过若干次的成功", "并终止于一次失败", "请注意 在每次对齐中尽管只有一次失败", "但却足以确定相应的对齐位置是无效的", "事实上 只有最后一次对齐位置才有可能是成功的", "因此 就整体而言恰好与刚才局部的模式相反", "多次失败 以及至多一次的成功", "因此 如果我们着眼于改进蛮力算法", "那么 我们的目标与其说是要加速匹配", "不如说是要加速失败", "或更准确地讲", "要尽可能快速地、低成本地排除掉无效的对齐位置", "事实上 KMP等算法就是这样", "你应该记得", "KMP会聪明地排除掉其中的若干个 甚至是大量的对齐位置", "从而大大地节省计算的成本", "甚至从某种意义上讲", "我们或许能够做得比KMP还要出色", "正如我们刚才所指出的", "就排除某个对齐位置而言", "相应的那些成功的比对", "并不重要", "而在这个意义上起实质作用的 反而是那些失败的比对", "如果真的像刚才说的那样", "我们总是需要在排除多个无效的对齐位置之后", "才能够确定最终有效的对齐位置", "那么 我们反倒应该更加期盼这种失败的比对出现得更早", "比如 按照这种思路的一种极端情况就是", "我们或许可能只做这些失败的比对", "就足以排除掉相应的对齐位置", "无论是它", "还是它", "以及它", "它", "诸如此类", "正如我们在习题解析中所指出的那样", "为了排除掉一个对齐位置", "我们平均只需做常数次比对", "而且在理想平均的情况下", "你甚至不必去关心", "哪个字符更有可能首先失败", "而只需按部就班地从前向后、自左而右地依次比对就可以了", "是的 如果我们的关注力只停留于单个的比对位置", "那么固然如此", "但是 倘若我们将所有的对齐位置作为一个整体来考虑", "我们就会发现 实际上 在每一个对齐位置处", "按照什么样的次序去尝试对比各字符", "却十分敏感而关键", "我们的建议是 你或许应该优先去比对那些靠后、乃至最靠后的字符", "也就是说", "与我们常规的做法恰恰相反", "或许你应该更多地去关注教训", "是的 如果教训的确不能避免的话", "或许我们应该让它更早地暴露出来", "或者再准确地讲", "应该让更大的教训 更早地暴露出来", "那么 为什么就串匹配算法而言", "在越靠后的位置所获得的教训", "所具有的价值越高呢"]}, {"name": "10a2-2: \t有序向量      ", "block_id": "0468fb9a84eb4305a08d670ba47918f3", "text": ["你应该记得我们此前曾举过的多个实例，", "是的，如果始终将向量中的元素按顺序排列，", "也就是构成所谓的“有序向量”，", "往往可以使得算法的效率有实质的提高。", "那么这一策略是否在这里依然可行呢？我们不妨来尝试一下。", "比如，将整个向量组织成一个非降的有序序列，", "我们很高兴地发现，此时最大的元素位置是确定的：", "它必然位于整个向量的末尾。", "因此无论是找到它，或是摘除它，都可以高效率地完成。", "具体来说，为此我们均只需O(1)的常数时间。", "然而依然很遗憾，这个有序序列的维护成本过高：", "为了插入一个新的元素，我们不仅需要花费log(n)时间进行二分查找，", "更重要的是，我们需要提前将它的所有后继顺次后移，", "在最坏的情况下，以及平均情况下，我们都需要花费线性时间。", "因此将向量有序化也不是一个行之有效的策略。", "同样，借助列表也不能高效地实现优先级队列。", "鉴于时间关系，我们在这里只给出示意性的原理图，", "以及关于三个接口效率的结论，请你在课后自行验证。", "而与向量类似的一个坏消息是，即便我们采用有序化的策略，", "也无法兼顾优先级队列三个接口的高效性，", "你在课后也不妨也对照我们这里所给出的原理图，", "就这三个接口的效率作一验证。"]}, {"name": "01d-4: 实例：非极端元素+起泡排序", "block_id": "bb7f356d07054e299db4c98da8ccbd8f", "text": ["上述这些方法 也可以推广至一般性的办法", "来看一个简单的实例", "对于任何整数子集S", "当然 作为集合 其中的元素肯定是互异的", "如果其中的元素的个数至少有三个", "那么 我们需要找出", "其中的某一个所谓的非极端的元素", "这个元素在其中既不是最大的也不是最小的", "方法呢 如下", "从S中 只要任意取出三个元素就够了", "我们刚才说了 这是个集合 其中元素是互异的", "所以这样任意取出三个元素X Y Z", "肯定也是互异的", "剩下的两步 实际上就是在其中", "找到这三者中间的一个非极端元素", "排除掉其中的最小的和最大的", "剩下来的那个居中的元素", "就是这三个元素中的非极端元素", "而且这个元素 不管是X、Y或者Z", "同时也必然是原来整个子集的非极端元素", "这个算法 本身没有什么太多的意味", "但是 它告诉我们", "确实在某些情况下", "无论你这个问题的规模N有多大", "某些算法可能所需要的时间", "都是一个固定不变的常数", "再来看一个更一般的例子", "也就是 我们希望针对所谓的排序问题", "给出第一个算法：起泡排序", "所谓的排序的任务就是将N个对象", "在这里 不妨简化作整数", "按顺序的排列 比如说", "一般都是按所谓的非降次序", "所谓的起泡算法 只是其中的", "一个最基本的方法", "它的思路 是基于这样一个观察事实", "在一个已经排序", "称作有序的序列中", "任何一对相邻的元素", "无论是它们 还是它们", "抑或是它们", "都必然是顺序的", "反之 如果有一个序列不是有序的", "我们称之为无序的", "其中必然能找到这样一对 也是紧邻的", "但是大小次序 正好是颠倒的元素", "这种元素可能不是很多", "但是在无序序列中", "像这个例子指示的那样", "至少会包含一对", "所以 这个算法的思路就是", "逐步的去消除这种", "相互紧邻的逆序的元素", "方法是通过所谓的扫描交换", "也就是说 反复地去扫描这个序列", "每一次扫描 我们称作一趟", "在每一趟这样的扫描过程中", "确实发现了有这样的", "逆序的紧邻元素", "就将二者位置交换", "如果在某一趟的过程中", "发现没有这种元素 就可以终止", "否则的话 这种扫描将持续的", "一趟一趟的执行下去", "整个起泡排序的计算过程", "可以精确地描述为这样一段代码", "这是典型的二重循环的模式", "外循环对应的就是", "一趟一趟的扫描交换", "而内循环执行扫描交换", "在每一次内循环中", "它确实会去逐一地检查", "每一对相邻的元素", "如果它们确实是逆序的", "就会令二者交换位置", "同时 大家注意到", "这里有一个标志sorted", "从语意上讲 它表示的是", "整个这个序列是否已经有序", "在当前的这一趟扫描过程中", "如果我们确实已经发现了有一对逆序对", "那我们就不能保证整体是有序的", "所以必须把它清除", "而这个清除以后的标志", "在下一趟扫描的起始之前", "会经过翻转", "并且初始化为一个true", "如果是这样的话", "所以使得这个扫描可以", "一趟一趟地执行下去", "当然我们也可以反过来看", "什么时候会退出呢", "既然你要赋值以后 等于false", "在翻转之前 这个sorted就应该是true", "应该是上一趟的初始值", "那么 它就必然不会执行这一句", "换而言之 就必然不会存在逆序对", "正如我们刚才所说的", "整体这个序列 已经有序了", "下面通过这个例子介绍", "典型的一些方法 来证明一个算法", "为什么是正确的 必然是终止的", "以及 具体它的复杂度又该如何度量"]}, {"name": "02E-3\t 反例", "block_id": "b058d7498bd646fb88966dcfaa5526b3", "text": ["为此我们来看这样一个实例", "考察某一个向量", "假设这个向量可以分为", "长度相差悬殊的", "一个前缀以及后缀", "而且后缀中的元素", "都已按顺序排列", "并严格地就位", "当然相应地 所有的乱序元素", "都集中分布于这样一个", "相对更短的前缀中", "对于这样的一个实例", "刚才我们已经做过", "优化的起泡排序算法", "会如何表现呢？", "首先它需要做第一趟", "忠实地扫描交换", "并且确认在最后这个位置", "有一个元素就位", "虽然它原本就是就位的", "请注意虽然这个时候", "在我们这个后缀中", "存在着大量的就位元素", "但因为在前缀中", "刚才存在交换", "bubble算法会返回false", "也就是说 算法接下来还会继续下去", "尽管能够判定的", "就位元素数目会继续增加", "但是与刚才同理", "我们依然不能确认可以提前退出", "也就是说 接下来还需要进行", "一次以及再一次、若干次的扫描交换", "那么对于这样的一个例子", "总体而言 需要多少趟扫描交换？", "我们说 扫描交换的趟数", "不会超过这个前缀的长度r", "为什么呢？", "因为此前所做的各趟扫描交换", "与其说 是在对绿色的范围做处理", "不如说实际影响的是", "这个前缀中的倒数第一个", "倒数第二个 以及倒数第三个", "也就是说", "是在这个前缀中的后缀中的那些元素", "的确 我们每一趟扫描交换", "所起的实质作用", "无非是在这样一个前缀中", "令一个一个的后缀元素依次就位", "直到整个这个前缀中的元素完全就位", "因此这个算法总体消耗的时间", "应该是n乘以r", "如果r取作根号n", "相应地 也就是n的1.5次方", "问题是我们如果能有一种技巧", "及时地检测出这样一种情况", "也就是说 实质需要排序的元素", "集中在一个宽度仅为根号n的区间中", "而不是整个向量", "那么即使套用最原始的起泡排序算法", "所需要的时间也无非是", "根号n的平方等于O(n)", "我们的问题是如何才能够", "完成从1.5次方", "到一次方的优化转换呢？"]}, {"name": "05E2-1 递归", "block_id": "4a6d3353c1e14c80b67fdec4717fda5d", "text": ["同学们好", "接下来的这一节我们研究", "遍历的另一种重要形式", "也就是中序遍历", "同样地 从递归的角度", "我们不难理解并且实现", "这样的一个遍历算法", "同样只需四句", "第一句或者叫第0句是处理递归基", "此后的三句依次遍历左子树", "访问根节点以及继而遍历右子树", "同样作为非常基本的算法框架", "我们对采用通常方法所实现的", "递归版本的效率并不满意", "我们也需要在常系数的意义上", "对这样的一个算法进行改进", "此前我们介绍过这种改进在实际中", "意义是非常大的", "那么如何将这样一种递归的形式", "改写为迭代的形式呢？", "不难看出", "相对于先序遍历 这里的难度要增加了几分", "其原因在于对于右子树的递归调用", "如果还可以继续称作是尾递归", "那么对左子树的这句递归调用", "却因为中间嵌套了一句对根节点的访问", "而严格地不是"]}, {"name": "09B-4 原理", "block_id": "c13a2623a9fc46edac7996b68a153833", "text": ["实际上 我们刚才介绍的数组方法并非一无是处", "就原理而言 只需再向前略作改进 也就成为了散列", "为此需要首先统一一些名词", "比如在这里数组中的每一个单元将被称作为桶bucket", "其中可能直接存放某一个词条", "也可能存放的是一个词条的间接引用", "而以上所说的数组 在这里将被称为是桶数组", "bucket array", "或者直接的称之为散列表 hash table", "我们也统一的将散列表的长度记作M", "而这里的核心技巧恰恰就在于散列表长度的选取", "首先散列表至少应该能够足以容纳所有的待存放元素", "因此这个不等号也就必须满足", "其次正如我们已经看到的 直接应用数组的方法", "它的致命缺点在于 所使用的空间远远过大", "因此所谓的散列表", "也可以认为是对这个空间做了一个适当的压缩", "既然散列表的长度关乎我们的空间效率", "所以这种压缩 必须是实质性的", "也就是说 在数量级上M要实质的远远小于R", "尽管M必须大于N", "但是为了实现尽可能高的效率", "M还是应该与N尽可能的同阶", "这样我们实际所花费的空间量", "就能够控制在线性的范围以内", "那么这种思路如何兑现呢", "你应该记得 在此前那种朴素的数组方法中", "对于任何一个关键码 我们都可以在O(1)的时间内", "直接得到对应的记录 或者它的间接引用", "而在做过空间压缩的现在 这个功能又当如何实现呢", "如果将这种确定目标词条位置的功能 称作为定址", "那么具体的定址方法也就是我们所说的散列hashing", "为了完成散列定制 我们需要在事先确定一个散列函数", "借助这个函数", "可以将任意关键码转换为对应的词条或它的入口", "在这个原理图中", "原先一蹴而就的过程 被分解为了两步", "也就是将任意给定的关键码", "通过hash function转换为散列表中的某一个桶单元", "并且进而通过这个桶单元 找到目标词条", "尽管整个过程多了一些曲折", "但是正如我们最终将要看到的", "只要散列函数设计与实现得当", "我们就可以将整个过程所需要的时间控制在期望的常数范围以内", "那么这里的散列表应当如何压缩并得到呢", "相应的散列函数 又当如何设计呢"]}, {"name": "10xa-1:\t第一印象", "block_id": "146e63a4f90a4029a498ea8478b1b5c2", "text": ["在学习过常规的完全二叉堆之后，我们来学习优先级队列的另一个变种，", "也就是左式堆。", "所谓的左式堆，也就是在拓扑形态上更倾向于向左侧倾斜的一种堆，", "比如这就是一个左式堆由生到长，", "直至灭亡的整个生命过程。", "可以看到，相对于常规的完全二叉堆，", "左式堆的确显得有些别致。", "那么，为什么要引入这一新的变种呢？", "让我们从它的设计动机以及结构定义说起。"]}, {"name": "09C-2 何谓优劣", "block_id": "7ccd4a314b7f46a8b33468831ddd6296", "text": ["那么什么样的散列函数更好", "好的散列函数又必须具备哪些要素呢", "首先 它必须具有确定性", "也就是说 词条空间中的任何一个元素", "都应该能被唯一的映射到散列地址空间中的某一元素", "这种映射关系 必须是明确的", "其次从计算的角度来看 这种映射应该能够快速的兑现", "第三条 相对于更大的取值空间", "散列的地址空间要小得多 也需要更加充分的加以利用", "为此散列函数必须是一个满射", "同样是为了充分的利用有限的散列空间", "并降低冲突发生的概率", "我们应该使得各关键码被映射到", "散列表各位置的概率尽可能的接近", "也就是要将所有可能的关键码", "尽可能均匀的压缩到散列空间中", "最大程度的避免很多元素在局部汇聚的现象", "也就是所谓的clustering", "以下我们就按照这4条基本的标准", "介绍若干种常用的散列函数", "并分析其各自的优劣 以及适用场合"]}, {"name": "12a4-2: 单调性", "block_id": "9ff443dd3c074b288d850c796d8e399f", "text": ["实际上新的这个算法依然是", "反复迭代式进行的", "在每一步迭代中", "我们考察的都是子序列U的首元素", "也就是由当前的k所指示的那个元素x", "我们将根据x的数值大小", "将它归入到G或者L子序列当中", "具体来说根据这个元素", "与侯选轴点之间的数值大小", "无非两种情况", "首先如果这个元素不小于侯选轴点", "我们就可以直接的拓展子序列G", "这种情况在图中显而易见", "既然x不小于侯选节点", "所以它自然有资格", "加入到子序列G中", "因此我们只需简明的", "将它归入到G中", "请注意在这种情况下", "L会保持不变", "从代码实现的角度来看", "这种情况也是非常好描述的", "具体来说经过一次比较", "即可判断是否属于这种情况", "若果真属于这种情况", "我们就简明的令k递增一个单位", "令它指向原先的后继", "从而隐式的完成", "将元素x归入G中的功能", "那么反过来如果当前的这个元素", "要小于侯选轴点呢", "自然的此时应该将这个x归入到", "子序列L中", "然而我们却发现此时的l", "无论向左或向右都无法拓展", "因此我们需要通过一种变通的方法", "将x加入到L中", "具体来说我们需要将子序列G", "向后移动一个单元", "从而等效于腾出一个空间", "以便x能够转入其中", "从而完成L向右的拓展", "那么难道我们真的需要将G", "整体的向右移动一个单元吗", "当然如果你不考虑效率", "这种方法固然是可行的", "但实际上我们有更好的方法", "来使G向后移动一个单元", "只要学过初等的物理", "你就应该知道", "在沿着一个表面", "移动物体时", "我们有两种移动的方法", "效率各自不同", "当然这里的效率是指", "在移动过程中所受到的阻力", "或者说摩擦力", "如果是整体的后移", "也就相当于物理学上的平行移动", "我们知道这种平行移动所遇到的摩擦力", "是更大的", "你应该记得", "在这种情况下", "你的物理老师曾经建议过你", "改用滚动的方式", "来替代平行移动的方式", "没错", "相对而言滚动的方式", "所遇到的摩擦力会更小", "那么在这里我们如何将这种思路", "具体的兑现为G的一次高效移动呢", "没错", "只需将G此前的首元素", "直接挪至到最后作为末元素", "而其余的绝大多数元素", "都可以在原地保持不动", "我们知道子序列G此前的首元素", "是由mi加1所指示的", "而此后新的末元素应该是由k加1", "所指定的", "当然这个末元素当前也就是x", "因此我们可以将G的滚动后移", "以及x归入到L中去", "这样两步紧凑的实现为", "这样一个交换语句", "至此虽然我们只介绍了", "这样两种情况的处理方法", "但在算法整个过程中的", "绝大多数时刻", "我们凭借这两招就已足够了", "我们唯一还需要交代的", "是这个算法终止之前的最后一步", "到了那样一个时刻", "子序列U已经变成了空", "而L和G已经占据了", "除侯选轴点之外的所有范围", "至此也就到了这个侯选轴点就位", "并成为一个真正轴点的时刻了", "那么这个侯选轴点", "应该被安放到什么位置呢", "没错", "根据我们L小G大的不变性", "这个侯选轴点应该被安置与L和G", "之间的交接处", "更准确的讲G将保持不动", "而L的末元素则应该被替换为", "这个侯选轴点", "同样的为此我们只需", "在这个末元素与侯选轴点之间", "完成一次互换"]}, {"name": "02D1-2\t 唯一化（低效版）", "block_id": "4fa0b09ab8ae4967b2821aa74c03e1f5", "text": ["此前我们介绍过", "无序向量的去重操作", "现在我们希望把这种去重操作呢", "推广到有序向量", "也就是说 将一个有序向量中的重复元素", "如果确实存在的话", "全部剔除掉 同样地", "每一组重复元素只保留一个副本", "那么稍加观察我们会发现", "有序向量 其实相对于无序向量而言", "具有更好的规范性", "这种规范性用文字来叙述的话", "就是说 在有序向量中", "彼此重复的元素必然会依次相互紧邻的", "构成一个一个的区间", "比如说 就这个例子而言", "这些元素相互重复", "所以它们彼此紧邻", "会紧密地排列成一个区间", "其它元素也有这种规律", "所以既然我们需要从每一组元素中", "保留一个副本", "所以等价于从其中找出", "一个代表并且保留下来", "找出一个代表并且保留下来", "一个代表保留下来", "具体到一个算法", "可以大致用一个线性扫描过程来描述", "具体来说 我们每次都观察", "并比对一对相邻的元素", "如果二者相等 我们就将后者删除掉", "并且继续比较", "如果后者还相等", "我们就把它继续删除掉 删除掉", "直到我们遇到一个不相重复的元素", "这个时候我们才把注意力后移", "我们再去考虑下一对紧邻的元素", "如果依然出现这种情况", "我们再删除 删除 删除 删除", "直到又转到下一对", "这样的话 我们会发现", "确实可以顺利地把所有重复的元素都剔除掉", "更确切地讲 并不像第一次循环这样", "只要我们初始化的足够好", "就可以保证每一次对于每一个区间", "最后保留下来的", "都是这个区间的第一个元素", "我们来看这段对应的代码", "为了与无序向量的唯一化以示区别", "我们将原来的deduplicate()", "换成有序向量的uniquify()", "二者的功能语义是一样的", "只不过针对的对象不同", "所以我们通过命名 对二者加以区别", "那我们也可以看 确实如刚才所言", "我们的初始化是从", "第一个元素也就是首元素开始的", "每一次在下面的循环中", "我们都要把当前这个元素", "与紧邻其后的那个元素做一个比较", "如果确实二者相重复", "构成一个相邻的重复对", "就将后者通过remove()接口删除掉", "如果不是呢", "那我们就意味着 像这里一样", "到达了某两个区间的", "交汇点或者叫切分点", "这个时候 我们可以直接把注意力", "转移到下一对元素", "不难验证 整个这个算法是正确的", "这个算法我们之所以不倾向于使用", "是因为它的效率低", "我们接下来就此做一个分析"]}, {"name": "12b1-4: 减而治之", "block_id": "9d62812e06ec4d71a13216922a3e0ee4", "text": ["在这里我们需要再次的应用", "减而治之的策略", "也就是说从问题的规模上", "不断的缩小众数的求解范围", "这里我们不妨约定", "所有的元素都是按照随机", "无序的次序", "存放于某个向量A中", "我们希望能够依照某种准则", "安全的从A中减除掉某个前缀P", "从而将原先在A中选取众数的问题", "转化为在A减P中寻找众数的问题", "其实这里的准则非常简明", "也就是在P中存在某一类元素x", "而且x出现的次数", "恰好就是P的长度的一半", "也就是说如果A中的确存在众数", "那么相对于每一个这样的前缀P", "A减P也必然存在众数", "而且进一步的A减P的众数", "必然也是原先A的众数", "也就是说在这种情况下", "A减P的众数", "构成了A的众数的必要条件", "实际上既然我们最终", "总是要花费on的时间", "通过一次线性扫描", "来确定候选者是否的确为众数", "所以我们只需考虑", "A的确含有众数的情况", "于是如果将A中的众数记作M", "那么无非两种情况", "也就是随着P被减除的元素X", "等于或者不等于M", "先来考察X与M相等的情况", "在这种情况下既然X", "当然也就是现在的M", "在P中", "恰好占据半壁江山", "所以在将这些M以及同等数量的", "其它元素减除之后", "在A减P中M与其它元素", "在数量上的差距", "将与此前在A中一样保持不变", "第二种情况", "也就是X并非中位数的情况", "其实更为简单", "同样的因为X在P中已经占据半壁江山", "所以即便其它的元素", "都是中位数M", "在A减P中", "M与其它元素的数量差", "相对于此前在A中", "与其它元素的数量差也不至于缩小", "也就是说在这种情况下", "M依然是A减P的众数", "基于这样一个必要条件", "我们就自然可以导出一个相应的算法", "具体来说这个算法", "将反复迭代的进行", "每一次都能够从A中减除掉一个", "非空的前缀P", "从而使得问题的规模", "能够得到有效的缩减", "这个过程将持续下去", "直到最终的平凡情况", "而在每一步迭代中", "为了确定这样的一个前缀P", "我们只需将它的首元素作为X", "然后随着接下来的不断扫描", "不断统计X的数量", "直到某个时刻X在P中", "恰好占据一半的比例", "那么这样一个总体的思路", "又该如何具体的兑现为代码呢"]}, {"name": "09D1-2 泾渭分明", "block_id": "4f8fc8e6eae547b2905f14d5f57923d7", "text": ["多槽位法在空间效率和时间效率之间的两难处境", "我们在学习向量时 也曾遇到过", "还记得那时的解决办法吗", "是的 改用列表", "新的策略如这幅图所示", "如果这是整个桶数组", "那么其中的每一个单元", "都将各自拥有一个对应的列表", "而每一个列表 都可以用来存放一组彼此冲突的词条", "是的 将相互冲突的词条串接起来", "也就是所谓的separate chaining", "来看独立链法的一个实例", "依然是一个长度为23的散列表", "接下来我们将64个词条 插入其中", "请留意观察 每个桶所对应的列表是如何演化的", "相对于多槽位法 独立链法的优势非常明显", "比如 除了最初的空链表 我们无需预留任何更多的空间", "而且表的长度可以根据需要自由的伸缩", "只要系统的资源足够 任意多次的冲突都可以解决", "得益于此前对List结构的良好封装", "我们只需寥寥几句即可实现相应的散列表结构", "当然 这种方法的缺点也同样是很明显的", "比如这里需要引入额外的指针", "而为了生成或销毁节点", "也需要借助动态内存的申请 相对于常规的操作", "此类动态申请操作的时间成本大致要高出两个数量级", "然而这种方法 最大的缺陷还不仅于此", "你能发现吗", "是的 系统的缓存功能", "在这里 每个桶内部的查找", "都是沿着对应的列表顺序进行的", "然而在此之前", "不同列表中各节点的插入和销毁次序完全是随机的", "比如可能会是这样", "因此对于任何一个列表而言", "其中的节点 在物理空间上往往不是连续分布的", "因此系统很难预测你的访问方向", "无法通过有效的缓存加速查找过程", "当散列表的规模非常之大 以至于不得不借助IO时", "这一矛盾就显得更加突出了", "那么为了有效的激活并充分利用系统的缓存功能", "我们又当如何继续改进呢"]}, {"name": "04C3-3\t 甄别", "block_id": "21e58d4ece6141d88bc7faf9b5ce4581", "text": ["我们再来讨论栈混洗的甄别问题", "也就是说 对于输入序列的任何一个排列", "我们如何来判断它究竟是", "还不是一个合法的栈混洗", "我们先从简单的例子入手", "考虑由三个元素所构成的一个输入序列", "套用刚才所得的结果", "我们知道第3个catalan数为5", "同时我们也知道 三个数的全排列", "也就是3的阶乘 应该是6", "这就意味着 对于这种情况而言", "有一种排列并非栈混洗", "那么少的是哪一种呢？", "我们说是它 3 1 2 mi do rui", "为什么是它呢？我们来看一下", "输入栈A中 如果最初是1 2 3 do rui mi", "我们将注意力放在最末尾的那个元素3上", "为了能够将这个元素转入最终的栈B中", "我们需要首先将它转入中转的S栈", "而为了保证3能够作为第一个元素", "被推入栈B中", "在3被转入栈B的时候", "元素2和1应该恰好依次排列在", "S栈中3的下方", "因此在3被转入栈B之后", "接下来的情节是固定的", "也就是说 2以及1将会相继地被转入栈B中", "从而固定地得到一个mi rui do序列", "而不是mi do rui", "这个例子虽然简单 但是却非常的本质", "因为接下来 我们可以发现", "其实任意的三个元素", "能否按照某种相对的次序", "出现在最终的栈混洗中", "与其它的元素实际上是无关的", "因此推而广之", "对于任何三个互异的整数 i j k", "如果在某个排列中出现了 k i j", "其实也就对应着", "我们刚才所说的3 1 2的情况", "那么它就必然不是栈混洗", "换而言之 这是栈混洗", "所必须禁止的一种特征", "我们也不妨称之为禁形", "那么反过来 如果某个排列中", "不含任何的mi do rui式的禁形", "那么它就一定是一个栈混洗吗？", "也就是说 不含禁形的必要条件", "是否反过来也是一个充分的条件呢？"]}, {"name": "12b3-2: \tquickSelect", "block_id": "1d25d9806cc24431a5cc133eb44a0092", "text": ["我们接下来尝试的方法", "将采用简而知之的策略", "为此我们需要借用快速排序中的", "（英文）算法", "因此这一算法也称作quickselect", "你应该记得快速排序中的", "（英文）算法的功能", "就是在当前的序列中", "构造出一个轴点", "我们也知道", "这个轴点具体的位置是随机的", "取决于我们的运气", "或者更准确的说", "取决于它相对于整个数据全集而言", "所拥有的秩", "在此我们不妨来设想一种", "最好的情况", "是什么呢", "是的", "有可能这个后选轴点", "就是我们在K选取问题中的", "查找目标", "也就是说它的秩恰好就是K", "果真如此的话", "我们的计算量只不过是一趟（英文）", "我们知道它所对应的运行时间", "不过on", "在一般的情况下", "我们又当如何处理呢", "不要紧 在一般的情况下", "尽管这个后选轴点", "未必就是我们要查找的目标", "但是根据它我们却可以", "对搜索的范围进行有效的裁减", "具体的如这个图所示", "假设我们的查找目标K", "对应于这个位置", "而在经过（英文）操作", "使得我们的后选轴点", "变成名副其实的轴点之后", "如果它所对应的i不是我们的目标k", "那么根据i与k的大小关系", "无非两种情况", "我们知道在经过（英文）操作之后", "这个轴点之所以成为一个", "名副其实的轴点", "是因为在它左侧的元素", "都不大于它", "而在它右侧的元素", "都不小于它", "因此如果轴点的秩要比K更大", "那么也就说明", "我们的目标元素必然存在于", "子序列L中", "而与子序列G无关", "这就意味着这种情况下", "我们可以将G减除掉", "对称的也同理", "如果轴点的秩要小于k", "那么由图也可看出", "目标元素必然来自于子序列G中", "而与子序列L无关", "也就是说在这种情况下", "我们也可大胆的减除掉子序列L", "综合起来无论是哪种情况", "我们都可以有效的使得问题的规模", "得到缩减", "这样一个缩减的过程", "将持续进行下去", "在整个问题的规模", "退化到平凡情况之前", "我们迟早会找到目标元素", "比如这就是quickselect算法的", "一种可能实现", "如我们刚才所言", "整个算法就是一个反复迭代", "不断减而治之的过程", "在每一步迭代中", "我们都需要仿照快速排序中的", "（英文）算法", "构造出一个轴点", "而且我们可以确定这个轴点的秩为i", "以下无非刚才我们所说的两种情况", "如果轴点的秩不小于k", "那么就意味着子序列G", "可以被减除掉", "为此我们只需将有效区间的", "右边界更新为i减1", "对称的如果轴点的秩不大于k", "则意味着子序列L可以被减除掉", "为此我们只需将有效区间的左边界", "更新为i加1", "很遗憾尽管这里旨在构造轴点的内循环", "每趟只需线性的时间", "但是我们却不能有效的控制", "外循环的执行次数", "尽管可以证明在通常的随机意义下", "外循环平均只需执行常数次", "但是我们依然不难看出", "在最坏的情况下", "它依然需要执行多达N次", "因此就最坏情况而言", "这个算法依然不是最优的", "不过好消息是", "这个算法已经为我们通往", "最优的算法打开了通路"]}, {"name": "12c2-1: \t邮资问题", "block_id": "e3d587efbd0d4cffa089039bb60ca06f", "text": ["我们此前曾经讲到希尔排序", "在对矩阵逐列排序时", "所使用的算法本身未必需要十分高效", "而更重要的是应该具有输入敏感的特性", "因此我们更倾向于使用插入排序", "那么这背后的具体原因又当如何解释呢", "这里的核心依然是逆序对", "让我们从所谓的邮资问题开始", "假设在某个国家寄送一封平信", "需要五毛钱", "而寄送一张明信片只需三毛五", "进一步的我们假设在这个国家", "所发行的邮票只有面值为四分", "以及一毛三的两种", "那么如果你需要邮寄一封平信", "或者明信片", "你是否能够恰好用这两类邮票", "凑出所对应的邮资呢？稍作思考之后", "我想你不难找出平信所对应的", "邮资方案", "是的", "正如这幅图所画的那样", "我们只需六张面额为四分的邮票", "外加两张面额为一毛三的邮票", "就恰好可以凑出平信所对应的邮资", "也就是五毛钱", "然而对于明信片我想你会和我一样", "无论如何苦思冥想", "也不能找出一种恰好的邮资方案", "如果你感兴趣甚至可以编写几行", "简单的代码来穷举所有的可能", "你将会发现", "在这个国家的确无法贴出", "明信片所对应的邮资三毛五", "由此我们可以看到使用特定的一组邮票", "对于有些邮资", "我们可以恰好的凑出", "而有些邮资无论如何都不能恰好的凑出", "那么为什么会有这样的区别呢", "对于其他的邮资而言", "我们又有什么样的一般性规律呢", "翻译成数学的语言", "我们可以说在这个国家", "用四分和一毛三面额的邮票", "所能凑出的邮资", "必然是4m加上13n的形式", "这一个由整数相乘然后累加", "而形成的表达式", "也称作线性组合linear combination", "当然我们也可以将以上的邮资问题", "推而广知", "比如分别用g和h来代表两种邮票的面额", "而用m和n分别代表这两类邮票", "所使用的数量", "于是由m枚面额为g的邮票", "以及N枚面额为h邮票", "所共同构成的邮资", "就可以表示为这样一个形式", "也就是更一般意义上的", "linear combination", "不难理解通过线性组合", "我们的确可以凑出不同的邮资", "但是正如我们已经看到的", "有些邮资却总是无法凑出", "实际上我们更加关注于后一类的邮资", "对于面额特定的两枚邮票", "我们不妨将所有不能由他们凑出的邮资", "汇成一个集合并记作ngh", "我们最为关注的是这个集合中的", "最大（值）", "我们将其记作xgh", "那么对于任何一对互素的g和h", "x又是多少呢", "在此我们直接引述数论中的现成结论", "数论告诉我们说", "xgh应该等于g减1与h减一的乘积", "再减一", "当然你可以化简为很多别的形式", "比如说g和h的乘积", "再减去g和h的和", "我们不妨就刚才的实例来做一个验证", "也就是说在g等于4h等于13时", "按照这个定理", "x应该等于4和13的乘积", "再减去4和13的总和", "不出意外恰好就是35", "也就是刚才明信片所对应的邮资", "当然这个定理也告诉我们", "从三毛六开始向上", "所有的面额都是可以由", "这两种邮票凑出的", "只要这两种邮票足够多", "这样一个邮资的问题", "虽然有趣但是它于我们这里的", "希尔排序又有什么关系呢"]}, {"name": "11c1-2: \t不变性", "block_id": "cfa5c337e8674855aeb126aa9904291c", "text": ["你应该记得 我们在分析蛮力算法时", "曾经指出过这个算法的一个不变性", "没错 不变性", "整个算法过程中的任何一个时刻", "都可以表示为这样一幅具有一般意义的插图", "是的 在当前假设我们需要对T[i]和P[j]进行比对", "并且根据比对的结果", "来确定算法的下一步走向", "而这里所蕴含的不变性就是", "这个子串与这个前缀完全相等", "是的 子串与前缀完全相等", "这意味着什么呢", "是的 这意味着我们已经完全掌握了这个子串的全部信息", "也就是说 它具体是由哪些字符所构成的", "而这类信息 完全可以为后续的各步比对所利用", "还是回到我们刚才的那个例子", "考察在当前这步迭代中的最后一次比对 也就是那次失败的比对", "正如我们的不变性所指出的", "尽管这次比对是失败的", "但它却意味着在此前我们已经获得过足够多次成功的比对", "就这个例子而言 也就是一系列的0-0匹配", "没错 0-0匹配", "这一点 其实可以概括为一条非常有用的信息", "具体来说也就是", "在主串中对应的这个子串 完全是由0构成的", "没错 在这种情况下", "与模式串前缀所对应的文本串的子串", "完全是由0构成的", "很可惜 此前的蛮力算法没有注意到并且充分利用这一点", "事实上 它会中规中矩地将模式串右移一个字符", "然后试图重新与这个子串进行匹配", "现在 你应该不难理解", "实际上 既然无论是这个子串还是这个前缀 都是完全由0所构成的", "所以 它们的任何局部比对 都必然会整体成功", "这也意味着 至少在当前的这种情况下", "这个子串与这个模式串的任何比对 都会以完全匹配而返回", "尽管它们的第一次比对的确有必要", "但如果像蛮力算法那样 在此后还反复地将它们进行比对", "就显然是没有必要的"]}, {"name": "10xa1-3: 奇中求正", "block_id": "f896e0bdec8d4d929ac709c881cf088c", "text": ["事实上，所谓的左式堆，也就是在保持堆序性的前提下，附加某种新的约束条件，", "从而使得在堆的合并过程中，我们只需讨论少量的节点，", "事实上只要这种结构和相应的算法设计得当，我们可以将所涉及的节点数目控制在log(n)的范围内，", "那么新引入的约束条件是什么呢？一言以蔽之，也就是所谓的单侧倾斜，", "比如沿用发明者所确立的惯例，堆中各节点的分布会偏向于左侧，", "而相关算法之所以能高效的诀窍在于，所有操作只会涉及到全堆的右侧部分。", "比如这只是左式堆的典型图解，所谓的向左侧倾斜，", "类比于书法，就相当于把撇写得更长，而捺写得更短。", "简单来讲，左式堆可以将右侧肩部的长度严格控制在大O意义下的log(n)以内，", "可想而知，果真如此的话，我们可以将整体的时间复杂度控制在log(n)的范围之内。", "相对于我们之前所提到的线性算法，这不得不说是一个巨大的改进。", "那么这样一种特性是如何做到的呢？现在回答这个问题还过早，因为我们首先还需要回答另一个问题。", "我们注意到如果真的有这样一个堆，那么它断乎不可能是一棵完全二叉树，", "也就是说尽管在此堆序性还有可能延续，而结构性却已荡然无存，无从谈起了。", "是的，的确如此，然而我们需要明白的是，对于堆结构而言，", "只有堆序性才是其本质要求，而结构性却不是。", "在必要的时候，结构性是完全可以牺牲掉的。"]}, {"name": "02B-4\t 加倍式扩容", "block_id": "5f46ef8dad7a4c2193036ef40dd0d795", "text": ["作为对比 我们也把刚才那句", "关键性的语句", "也就是_capacity", "左移一位", "等效于乘2 列在这", "同样 我们也来考虑", "刚才那种最坏的情况", "这也是这类数据结构的最坏情况", "从某一个", "初始容量开始", "不断连续地插入", "足够多个元素", "而且为了简明起见", "我们不妨设这个n", "是2的某次幂", "我们可以看到", "在整个的插入操作过程中", "应该大致是", "每次都要经过加倍的时间以后", "才会有必要进行一次扩容", "以及再经过加倍以后的时间", "才会进行一次扩容", "具体来说 只会在第一次", "第二次  第四次", "第八次  第十六次", "第三十二次  第六十四次", "诸如此类地", "插入的时候才需要扩容", "而且确实会扩容", "但是不要紧", "我们把它们总体的成本", "如果罗列出来的话", "无非是如此", "当然同样地", "你也可以把它加起来", "去费劲把它算出来", "但是我们说", "同样 我建议你采用", "我在此前所教给大家的诀窍", "我们注意到 这是一个", "以2为倍数的几何级数", "它的总和是什么呢？", "它的总和从渐近的意义上讲", "和它的末项是等阶的", "而它的末项是多少呢？", "我们刚刚说过", "它的末项就是我们在此过程中", "连续插入的元素的总数n", "当然 它也是我们", "最终在这个向量中", "所存放的有效元素的个数", "这意味着什么呢？", "这意味着我们在", "整个这n次插入的过程中", "所需要的时间成本", "不再像此前那种方式一样", "是n平方而变成了n", "这意味着 我们平摊到", "在此期间发生的", "所有这些（插入）操作", "每一次只需要常数的时间", "没错 从O（n）到O（1）", "这不能不说", "是一个巨大的改进", "造成上述天壤之别的根本原因", "可以用左边这幅图来说明", "实际上 在向量规模不断递增", "达到某一固定的数值之前", "如果采用的是", "递增式的增容策略", "那么所需增容的操作", "必然是按当时的规模", "呈算数级数的形式分布", "这种次数太多了", "反过来 如果是以倍增式的策略", "来进行的扩容", "那么 我们只需要进行", "其中的少数几次扩容就够了", "具体来说 就是这些", "以紫色标明的", "我们可以看到", "要远远小于原先的数目", "而且随着数组规模的增加", "这种差异会更加的明显", "因此 我们不妨将这两种策略", "所对应的性能列成这样一张表", "在时间方面", "在达到一个固定的规模n之前", "累计所用的扩容时间", "如刚才所言", "递增策略要多达n平方", "而倍增策略只需要O（n）", "如果从分摊的意义上讲", "分摊到每一次扩容", "所需要的时间", "前者是O（n） 而后者是O（1）", "我们可以看到在这方面", "就时间而言 后一种策略", "具有巨大的优势", "那么在空间方面呢？", "前一种策略似乎要非常好", "确实 因为它", "总是每次增加一个固定的数额", "所以随着向量规模的增加", "整个空间的利用率", "会越来越接近于百分之百", "而倍增策略呢", "我们说", "未必能做到百分之百", "但是它至少有个底线", "这个底线就是至少", "能保证是百分之五十", "什么时候是百分之五十呢？", "无非就是它", "即将发生上溢", "而因此刚刚通过", "加倍扩容的那个瞬间", "所以相对而言", "可以理解为倍增策略", "是通过在空间的效率上", "做了一个适当的牺牲", "来换取在时间方面的", "巨大的收益", "那么这种损失", "和这种收益孰大孰小", "我们相信每个同学", "都可以做出自己的判断"]}, {"name": "05B-2 父亲", "block_id": "c6dfe1415822448d87e6c5e53e325b8c", "text": ["为此 你可能首先会想到", "利用的一个事实就是", "在任何一棵树中", "除了根节点以外的任何一个节点", "都有且仅有一个唯一的父节点", "比如在这幅图中", "我们可以确认任何一个节点", "无论是A B C", "还是D E F以及G H K", "都有且仅有一个父节点", "在这样的图中", "我们只需将所有的边", "都改为由节点向上指向它的父节点", "就可以很清楚地看出这个规律", "因此我们首先能够获得的一个构思就是", "不妨将所有的节点", "组织为一个序列就像这样", "其中的每一个元素", "都分别包括三项", "data是节点本身的信息", "rank或者position指明的是", "这个节点的记录在这个序列中", "所对应的秩或者是位置", "而parent呢", "恰好就是刚才我们所说的那个", "任何一个节点唯一的父节点", "当然是它所对应的秩或者是位置", "比如在这个图中", "节点E的父节点是A", "所以在这种表示中", "E节点的parent 指向的是1号", "当然也就是A所在的那个元素", "同样地 G H K", "都是以F为父亲", "这也是为什么它们的记录中", "parents项都统一地设为6", "而6是谁呢？", "我们可以看到 恰好就是F", "当然我们这里只有一个例外", "也就是根节点本身", "它按照定义是没有父节点", "因此为了统一起见 这里用-1", "也就是一个根本不可能存在的秩", "来表示一个假想的父节点", "这种表示方法似乎效果还不错", "因为从空间上来看", "在整个这个序列中", "每一个节点只占用常数的空间", "所以我们可以得出结论 这种表示法", "如果能够兑现为一种数据结构的话", "那么它的空间性能是O（n）", "已经能做到最好了", "嗯 还不错", "而从时间角度来看", "性能在有些接口方面也依然不错", "比如说 对于任何一个节点", "如果我们要去访问它的父节点的话", "可以在O(1)的时间 就像这样", "比如说D 可以在O(1)的时间内", "确定是1号单元", "并且随即转往并获取D的父节点", "而访问树根节点呢", "效率也不错", "我们只需要从任何一个节点比如E出发", "顺着parent引用不断地上行", "迟早有一天会抵达不能前进的位置", "而这个位置", "就必然是我们所要找的根节点", "整个这样的一个过程", "充其量不过在最坏情况下", "需要遍历所有的顶点", "也就是说 在O（n）的时间内", "我们就足以完成这件事", "甚至我们还可以继续改进", "也就是说 可以将根", "固定的安置在秩为零的位置", "也就是说 作为首元素", "这样的话 对于root的访问", "只需要常数的时间", "然而不幸的是", "如果我们要向下索取某个节点的后代", "比如说它的第一个孩子 也就是长子", "我们也依然需要去", "遍历所有的元素", "并且逐一地确认", "它的父节点是否就是当前查询的元素", "这样一个基本的操作", "在最坏情况下", "我们居然需要线性时间", "而查找兄弟节点也是类似的", "在最坏情况下 需要遍历整棵树", "因此我们下一个改进 矛盾的焦点", "也就自然地集中在", "这样两种向下方向的查询上"]}, {"name": "08B2-5\t阶次含义", "block_id": "267ccab8def641e3a013e51867184e39", "text": ["那么B树的阶次m 究竟扮演了一个什么角色呢", "实际上 它既给出了B树中每个超级节点规模的上限", "同时也给出了下限", "在上限方面 每个节点所拥有的分支数都不得超过m个", "相应的其中所含关键码的数目 自然也就不得超过m-1个", "这里我们不妨约定以n来表示节点中所含的关键码数", "因此拥有n个关键码的节点也就对应于n+1个分支", "在下限方面 每个节点所对应的分支数也不能太少", "具体来说 不得少于m的一半", "请注意 这里使用的是上整", "所以在m为奇数的时候是需要格外小心的", "如果将定义B树的这一套规则 比喻作是一部法律", "那么其中还有一条显得不那么美的额外的修正案", "就分支数的下限而言 树根节点是允许例外的", "在极端的情况下 树根只需2个分支足矣", "那么为什么这里需要附加这样一条显得似乎不那么自然的修正案呢", "这是我们需要在此后不断理解和回答的一个问题", "既然如此 我们也用超级节点所拥有分支数的下限上限来命名B树", "比如m=5的时候 每个节点的分支数自然不得超过5", "同时一般节点所拥有的分支数也不得少于3", "我们也可以称之为(3,5)树", "对于6阶B树而言 分支数的上限自然是6 而下限呢同样是3", "所以也称之为(3,6)树 相应的有(4,7)树 (4,8)树等等", "而再往上呢 对于4阶B树而言 自然的也可以称之为(2,4)树", "饶有趣味的是 (2,4)树在B树中具有非常独特的作用和地位", "我们将会看到 (2,4)树与红黑树有不解的渊源"]}, {"name": "03B-5\t 唯一化", "block_id": "f0b96cb6a980473eaa3b69c6a838284c", "text": ["接下来考察列表的唯一化问题", "也就是如何将列表中", "可能存在的重复元素剔除掉", "在我们接下来将要介绍的这个算法中", "我们始终将整个列表视作由三部分组成", "这个前缀部分", "作为这个算法的一条不变性", "已经能够保证不包含任何重复的节点", "而我们当前所要考察的呢", "就是接下来的这个节点", "不妨将它称作p", "当然 此时可能还存在一个非空后缀", "我们这个算法的关键部分是", "如果当前那个节点的数值为e", "我们就以e为目标", "在前缀中对它进行查找", "无论查找成功与否", "我们都可以将问题的规模", "有效地降低至少一个单位", "具体的算法可以实现为这样一段代码", "我们来解读一下", "首先是处理平凡情况", "确保这个列表中至少包含两个节点", "接下来 这一步可以认为是初始化", "我们可以看到p最初的时候", "是指向首节点", "也就是说 这个时候的前缀", "实际上可以认为是空的", "所以刚才我们所说的", "不变性自然也就满足", "那么接下来", "算法的主体部分是这个循环", "可以看到 每一次我们都将", "p中所存的那个元素", "这就是e 作为查找的对象", "那么查找的范围在哪呢？", "是以p为基准的r个真前驱", "那么这个r是多少呢？", "这个实际上也是这个算法的一个不变性", "我们说 r在任何时候其实就等于", "整个这个前缀的长度", "换而言之 也就是在整个", "这个前缀中进行查找", "无非两种情况", "一种就是这个find这个操作", "返回了一个非空的元素", "它的数值当然就等于e", "在这里呢 我们是以q来指向它的", "这个时候 大家可以看到", "我们将这两个重复元素中的一个", "具体来说 也就是这个q删除掉", "否则的话呢 如果q是一个null呢？", "那就意味着查找失败", "换而言之", "在这样的一个前缀中根本就不存在", "语义相同的元素", "所以在这个时候 p这个节点", "可以归入这样的一个前缀中去", "使得这个前缀拓展一个单位", "在这种情况下", "我们就可以将r加1", "也就是说 前缀的长度", "增加一个单位", "同时p转入它的后继元素", "继续迭代", "直到抵达哨兵trailer", "也就意味着整个列表全部扫描", "并且处理完毕", "细心的同学可能已经注意到", "这里如果发现了一个q", "与刚才那个p相同的话", "我们倾向于去删除q", "既然它们数值都一样", "为什么我们不去删除p呢？", "在此大家不妨暂停一下", "略加思考 然后再继续", "是的", "我想你应该已经找到答案了", "如果我们不是删除q 而是删除p", "表面上看是等价的", "但是在接下来的这步迭代中", "我们首先要将p转向p的后继这个操作", "就存在风险", "因为p这个时候 实际上已经", "没有一个明确的指向", "很有可能会发生错误", "所以相对而言", "删除q是更安全的一个方法"]}, {"name": "08XA1-3\t关联性", "block_id": "f611ada5e1e8444cbaac13e16f5f7940", "text": ["是的 对于每一组相邻的历史快照而言", "后者都是在前者的基础上做过相对而言少量的更新而得的", "也就是说 绝大部分的数据对象 在二者之中都是相同的", "二者的差异只是非常非常小的一部分", "因此 我们就自然的可以改用这样一种策略", "也就是大量的元素都作共享", "只有发生变化的那少量的数据元素我们才需要进行更新", "实际上只要我们的实现方法得当", "完全可以将相邻版本之间的差异量 控制在logn的范围", "比如对于BBST而言 这就是一种可行的实现方法", "在这幅图中 每一条红线 都对应于一个共享", "比如这条红线就意味着 它所指的节点1既出现在前一个版本中", "同时也出现在后一个版本中", "尽管在两个版本中 它的父亲不同", "但是作为数据元素 它就是它", "类似的 这条红线也意味着节点2同时被1号和2号版本所共享", "你可能也注意到 其中还有一些蓝色的虚线", "没错 我想你已经猜到了", "它们所指示的就是在相邻版本之间的更新量", "也是我们不得不花费空间来进行存储的量", "好在这个量可以控制在极低的水平", "比如这条蓝线就意味着", "尽管节点8和节点8'对应于同一个数据对象", "但是在前和后两个版本中 它们的父节点已经发生了变化", "因此在新的快照中我们不得不为它另存一个副本", "类似的 这条蓝线也意味着从7到7'的更新", "而这条蓝线则示意着节点6需要更新至6'", "以及节点5需要更新至5'", "当然这类高级结构已经超出了我们这门课的范围", "如果你对此感兴趣", "敬请关注邓老师稍后将要推出的另一门算法课程 计算几何", "当然 你也可能并不满足于此", "比如我们能否将BBST前后版本的空间差异控制在O(1)的范围呢", "如果这样的话 整体的空间复杂度", "将进一步优化至n+h 而不是h*logn", "好消息是 只要方法得当 这也是可以做到的"]}, {"name": "11e1-2: \t好后缀策略", "block_id": "5c67fff935964fd2a5641154c3091a7b", "text": ["我们来将刚才的实例一般化", "也就是说 在BM算法的任何一个时刻", "如果当前的这趟扫描失败于X不等于Y处", "那么也同时意味着模式串中相应的后缀", "必然是完全匹配的", "也就是我们所说的好后缀", "因此如果接下来希望通过右移", "重新在某个位置上对齐", "就应该至少使得文本串中刚才匹配的部分能够继续得以匹配", "当然还有一条", "既然刚才我们已经发现Y不能与X匹配", "所以在经过了这次移动之后", "对应的这个新的字符", "也至少不能依然是Y", "就像我们在改进KMP算法时所举的那个例子一样", "既然已经发现鸡蛋不如石头硬", "我们接下来就至少应该要换一个不是鸡蛋的东西", "去与石头相碰", "当然 至此只是最为基本的情况", "与bc策略一样", "这里同样也有若干特殊的情况", "比如在模式串中", "足以与刚才文本串中匹配的部分继续匹配的子串 有可能会有多个", "此时 我们又当选择其中的哪一段呢", "这里的取舍原则与bc策略也是一样的", "也就是要在安全的前提下", "避免回溯", "为此 我们同样倾向于让位移量尽可能地小", "是的 位移量尽可能地小", "这也就意味着 如果的确存在多个这样的子串", "我们应该从中选择最靠后者", "当然 还有一种反过来的极端情况", "也就是说 在模式串中不存在任何一个这样的子串", "能够足以与刚才匹配的部分继续匹配", "当然 这条信息也就意味着我们此后的对齐位置", "至少应该越过当前失配的这个字符", "也就是说 移动的距离将会更大", "从计算效率的角度来看", "这反而是一个好消息", "当然 我们同样地需要保证", "所有值得对齐的位置 都不至被遗漏掉", "因此在这种情况下 我们还是应该尽可能地从模式串中去找到这样一个子串", "或者在这种情况下 更准确地讲是一个前缀", "使得它至少能与刚才匹配部分的相应后缀继续匹配", "现在 纵观以上一般的情况以及各种特殊情况", "我们会发现 无论如何位移量只会取决于j", "以及模式串P本身", "而与文本串无关", "这就意味着我们可以仿照KMP算法的模式", "提前将相应的位移量计算出来", "并将这些信息整理为一张表", "以备算法执行过程中能够快速地查询"]}, {"name": "07D3-2 删除：双旋", "block_id": "278a177bc648459e8d4e51d89294f138", "text": ["我们只需考虑其中的一种", "也就是所谓的zag-zig的情况", "另一种zig-zag的情况完全对称", "在这种情况下 v是p的右孩子", "而p是g的左孩子", "此时 我们依然只可能", "至多有一个失衡节点", "不难理解 如果g果然是这个失衡的节点", "那么此前我们删除的", "必然是T3这棵树的某一底层节点", "而且因为这个底层节点的删除", "导致T3整体的高度收缩一层", "从而使得节点g的平衡因子", "由此前的+1变为超标的+2", "在这种情况下", "我们要先后做两次旋转调整", "具体来说 首先需要围绕着节点p", "做一次逆时针的zag旋转", "同样地 我们假定同学们", "已经对这种基本的旋转非常熟悉了", "所以在这里直接给出旋转之后的结果", "我们可以看到", "它等效于将此前的zag-zig", "转换为了现在的zig-zig", "恰好就是我们刚刚介绍过的单旋操作", "没错 接下来", "我们只需要围绕着节点g做一次zig", "就可以使得这棵子树重新恢复平衡", "尽管如此 我们还是特别提醒你留意", "这棵局部子树在调整前后的高度变化", "我们知道 在T1和T2这两棵子树的底层", "至少有一个节点存在", "这就意味着 在旋转调整之前", "这棵局部子树的高度", "应该是由这条水平基准线来确定的", "而在调整完成之后", "这棵局部子树的高度", "将由这条基准线来确定", "两相比较 高度收缩了一层", "这意味着什么呢？", "没错 这意味着", "在这棵局部子树以上的每一个祖先", "此时都存在由原先的平衡转为失衡的可能", "也就是说 同样会发生失衡的向上传播", "当然 果真如此", "我们可以依然套用这里所给的算法", "好在失衡传播的方向是单调的 一直朝上", "所以同样地", "充其量至多经过Logn次这样的传播", "迟早会抵达某个不再失衡的节点", "或者抵达树根", "当然你可以同样参照我们的习题解析", "构造出这样极端的反例", "至此节点删除可能的几种情况", "我们都已论及", "那么这些处理算法", "又当如何落实为具体的代码呢？"]}, {"name": "12c1-4: \t插入排序", "block_id": "2dead14aa1ce4993a6eab4860de61179", "text": ["接下来的一个技术要点是", "在每一趟迭代中逐列的排序", "又当如何具体实现", "非常有趣的是在这里我们并不需要", "去追求非常高效的排序算法", "事实上我们这里在底层所采用的", "排序算法只需要具有", "输入敏感性就可以了", "也就是说随着算法的不断推进", "在序列的有序性不断改善的同时", "这类算法单次运行的成本", "将会逐渐的递减", "从而能够保证总体计算成本的足够低廉", "是的", "我们早先介绍的某些初等排序算法", "的确就具有这种输入敏感性", "你还记得吗", "没错", "插入排序 insertionsort", "你应该记得我们曾经通过逆序对的数目", "来度量序列的无序性", "而插入排序的计算成本", "恰恰就取决于输入序列的这一指标", "当然影响希尔排序总体效率的", "最大因素莫过于其中具体采用的", "步长序列H", "接下来我们将会具体的剖析", "其中的几个实例", "需要指出的是在评判这些", "序列的相互优劣时", "我们主要需要考察这样几个方面", "包括在整个算法的过程中", "我们需要执行的关键（码）比较", "以及数据项移动操作的次数", "另外我们也十分关注整个过程中", "所涉及的迭代次数", "也就是矩阵的重组次数", "因为每一次矩阵的重组", "都对应于整个序列的一趟遍历", "而在数据量非常大时", "每一次遍历都有可能会引发", "相应的IO", "因此在这种情况下", "迭代的次数", "也就自然成为了一个非常敏感", "而重要的因素", "以下我们就来考察步长序列的一个", "具体实例", "这个序列提出的更早", "因此也难免有更多的缺点"]}, {"name": "07D1-3 适度平衡", "block_id": "df7719d389c54eadbc45e989831aedf8", "text": ["可以证明AVL树", "的确是适度平衡的", "也就是说 一棵规模为n的AVL树", "其高度在渐近意义下", "是不超过logn的", "实际上 为了证明规模固定的AVL树", "其高度不会超过某个上限", "我们可以等价地证明", "在高度固定的情况下", "一棵AVL树的节点", "也不至于太少", "具体来说", "我们可以证明这样一个事实", "对于高度固定为h的AVL树", "其中所包含的点数", "至少是与h呈fibonacci数关系", "为此我们需要借助递推式", "具体来说", "我们可以证明这样一个递推式", "也就是说", "如果我们将高度为h的AVL树的", "规模下限定义为S(h)的话", "那么S(h)与S(h-1)", "以及S(h-2)之间", "满足这么样一个叠加的关系", "为此我们来考察那棵高度为h", "同时规模达到最小的AVL树", "既然它的规模要达到最少", "所以它的左子树和右子树的规模", "也应该尽可能少", "那么在AVL树的定义下", "可变化的余地充其量不过", "其中一棵子树", "比另一棵子树高一层", "不失一般性", "假设左子树比右子树高出一层", "因为它的高度为h-1", "所以它的规模下限自然也就是S(h-1)", "同理 作为高度为h-2的右子树", "它的规模下限自然也就是S(h-2)", "当然 还不要忘了这里的树根节点", "这也就是为什么", "我们还要再附加上一个单位1", "这个递推式是我们所有分析的核心", "而以下只不过是一些", "简单的数学技巧而已", "为此 我们不妨对它做一个等价变换", "也就是在左右各加一个1", "那么左侧这块添加了一个1", "右侧这块也添加了一个1", "以及此前原本已有的一个1", "接下来 如果我们将S(h)+1", "定义为一个新的函数T(h)", "就会发现这个递推式的右侧", "会变成T(h-1) 再加上T(h-2)", "这种形式是fibonacci数", "所特有的递推形式", "所以我们可以断定", "它应该是等于", "fibonacci的某一项", "那么具体的是从 h", "前后位移多少项呢？", "我们只需考察对应的边界情况即可", "首先考察规模为1", "高度为0的AVL树", "此时的T(h)应该等于1加1 也就是2", "我们知道这是fibonacci数的第三项", "再来考察高度为1的AVL树", "其规模最小也不至低于2", "也就是左子树为一个节点", "右子树为空的一棵AVL树", "此时的T(h)应该等于2+1 也就是3", "我们知道这是fibonacci数的第四项", "由此可见 这里的T(h)", "只不过是fibonacci数", "向前位移了三位", "我们知道fibonacci数", "大致是呈Φ的指数形式增长", "由此我们也得到了n", "关于高度h的一个下界", "因此反过来等价地 n的对数", "也就构成了h的一个上界", "而这一点正是BBST", "所谓适度平衡的要求", "这就意味着我们的AVL树", "的确是适度平衡的", "好了", "至此我们也就完成了第一项使命", "也就是给出AVL意义下的", "适度平衡标准", "那么接下来", "在我们着手完成第二项使命", "也就是给出具体的重平衡算法之前", "也许我们应该首先", "以C++语言的形式", "明确给出AVL树各种操作接口的规范"]}, {"name": "04C2-1\t 实例", "block_id": "7e5d21b37bd7430e86b69c0387760185", "text": ["同学们好", "接下来这一节我们介绍", "栈结构的另一典型应用", "也就是括号匹配", "按照我们此前的分类", "这类情况可以归为", "所谓的递归嵌套式问题", "以括号匹配为代表的这类问题", "它们的共同特点是", "具有某种意义上的自相似性", "也就是说 它们的某一个局部", "往往和整体具有某种共性", "同时 这种局部作为分支", "它的位置以及嵌套的深度", "却难以在事先固定或者确定", "括号匹配是合法表达式的", "必要条件之一", "相信大家对此都不陌生", "我们来看一个实例", "在下面这个表达式中", "这对括号是匹配的", "这对括号也是匹配的", "这对以及这对", "还有这对都是分别匹配的", "因此总体而言", "这个表达式中的括号是匹配的", "反观上面这个表达式", "由于在这里多出了一个右括号", "所以尽管它可以和", "这个左括号相互匹配", "但是相应地 原来的这个右括号", "却没有任何与之匹配的左括号", "所以总体而言 这个表达式是失配的", "我们的任务是任意给定这样", "或那样的一个含有括号的表达式", "如何来判定它是否是匹配的", "为了简化问题", "我们不妨将括号之外的", "其余符号都暂时地忽略掉", "也就是说", "得到只含括号的这样一个表达式", "这件事并不难完成", "我们只需要做一次", "线性扫描的预处理即可", "这样我们的注意力可以更加的集中"]}, {"name": "12a1-3: 构造轴点", "block_id": "ece309257a544421b9e87e42bc16e093", "text": ["霍尔爵士所设计的轴点构造算法", "其原理和过程", "可以由这幅图来示意", "首先我们要选取一个轴点侯选", "作为培养对象", "通常我们都不妨取作", "这个序列的首元素", "而在整个构造的过程中", "我们都需要用到lo与hi", "两个指针", "这两个指针将整个序列", "分为L U和G三部分", "这里的L是一个前缀", "其中的任何一个元素", "在数值上都不超过轴点的侯选", "对称的 G是一个后缀", "其中的任何一个元素", "在数值上也不会小于轴点侯选", "而居于二者之间的子序列U", "则由大小仍然未知的元素构成", "在初始状态下U也就是整个序列", "而L和G都是空的", "在算法起动之后", "我们会尝试着将lo与hi交替着", "向内侧移动", "从而令它们彼此靠近", "lo每向后移动一步", "L也就会向后拓展一个单位", "对称的hi每向前移动一步", "G也会向前拓展一个单元", "为了完成这种拓展", "我们需要适当的将U中的某个元素", "加入到L或者G中", "最终当lo与hi同时指向同一个位置时", "我们只需将此前选定的轴点候选者", "放到这个位置", "那么这个候选者", "也就自然成为了一个", "名副其实的轴点"]}, {"name": "04D-1\t 接口", "block_id": "7b0d8d06322b4379a3ca7c0d1fa2c88a", "text": ["同学们好，在这一章的最后", "我们将介绍一种与此前的栈结构", "完全对称的结构", "也就是队列", "需要说明的是，因为队列结构", "在此后的图算法", "以及其它的场合", "都有广泛的应用", "因此这里我们只是首先简要地", "介绍它的接口定义", "以及它在C++中的实现方式", "说到队列，我想每一个同学都不会陌生", "是的", "在机场等待检录时，所有的旅客", "都会排成队列", "在超市等待付款时", "你往往也需要加入到一个队列", "甚至连你收纳在球筒中的羽毛球", "也可以构成一个队列", "所有这些队列", "无论是由人构成的", "还是由羽毛球构成的", "都具有一些共同的特点", "首先用我们数据结构的语言来说", "它们都构成一个线性的序列", "而且这个线性序列的两端", "也分别扮演着不同的角色", "具体来说，其中有一端", "只能够出", "而另一端只能够进", "概括而言", "我们所说的队列", "的确是一个序列", "只不过它与栈一样", "同样是一个受限的序列", "我们将允许插入的那一端称作尾部", "相应的操作呢", "叫作enqueue()，当然有的时候", "我们只关心尾部的当前元素", "所以也有的可能会提供一个接口rear()", "对称地", "只允许出的那一端，称作头部", "因为需要从中取出一个元素", "所以这种操作也称作dequeue()", "对应地，也有的时候我们并不需要去做dequeue()", "而是只需要查询头部的当前元素", "这样的一个接口，我们也有的时候需要提供", "称作front()", "这个图给出了队列的一般形式", "与栈一样", "我们也倾向于将它垂直地来绘出", "所以如果试图将一个元素插入其中", "我们的尾部，实际上也就是底部", "这样的一个操作，刚才我们讲过", "叫作enqueue()", "反之，如果我们取出顶端", "也就是头部的那个元素，这样的一个操作", "就叫作dequeue()", "这样一种数据结构，与栈的特性完全对称", "也就是说，在这样的一个结构中", "先加入的元素", "必将相对而言更早地退出，反之亦然", "这也就是我们所说的", "first in first out，先进先出", "在社会资源或者是各种计算资源的分配中", "这样一个原则是再公平不过的了", "所以也被在这些场合中广泛地应用"]}, {"name": "05D-4 高度更新", "block_id": "2bcaadd0ab2f4446aedea4e70fb8cf7b", "text": ["以下我们就以高度更新接口为例", "介绍背后的算法", "以及这个接口的实现方法", "因为我们这里还没有接触到", "二叉树的更多变种", "所以我们所谓的高度依然采用此前", "常规的定义", "具体来说 对于任何一个节点x", "所谓它的高度其实就是", "在以它为根的子树中", "从它通往那个最深的", "叶节点的路径长度", "只不过这里我们需要", "考察几种特殊的情况", "比如第一种就是只有单个节点的情况", "你应该记得我们将这种", "只有单个节点的树的高度取作0", "而另一些时候呢", "我们可能要考虑一些", "根本就不存在任何节点的树", "也就是我们所说的空树", "同样地 你也应该记得我们此前约定", "空树的高度为-1", "那么这种一般性的情况", "退化的情况", "以及极其退化的情况", "又应该如何统一呢？", "这里我们采用了一种", "通过宏定义的封装的方式", "通过重新命名一个新的", "等价意义上的高度", "我们的确可以将常规情况下的高度", "与退化情况下的高度统一起来", "使得我们此后对算法的描述和理解", "可以更为简便", "同时也不致于影响到算法的正确性", "我们知道 一个节点的高度", "之所以会发生变化", "是由于它的左孩子", "或者右孩子的高度", "发生了变化而引起的", "准确地讲 一个节点的高度", "应该恰好等于它的左孩子", "与右孩子高度中的更大者 再加1", "因此我们也就可以相应地得到", "这么样一个对任意节点x", "进行高度更新的算法", "一旦x的左孩子与右孩子的高度确定", "我们就可以在它们之间取出更大者", "并且在此基础上再累加1", "就可以得到x节点的高度", "这种高度的更新往往会体现出一种", "层层递进的连锁形式", "比如说 如果x的父节点存在", "那么父节点很有可能", "也会因为x的高度", "发生变化而高度变化", "而再往上 如果有祖父节点", "乃至有曾祖父节点", "那么这些祖先节点的高度", "都有可能发生变化", "因此如果要对全树做整体的高度更新", "我们往往需要从某一个节点", "比如x出发", "向上逐层地追溯它的历代祖先", "直到最终抵达根节点", "这样一个过程也自然地可以用我们的", "新的一个算法来实现", "也就是updateHeightAbove 参数是x", "也就是说 经过逐层逐层逐层", "逐层的上升", "抵达根之后", "如果我们依然希望向上追溯", "就会抵达根的父亲 也就是空", "此时算法终止是再自然不过的了", "由此我们也可以看到", "整个这样的过程需要从x开始", "遍历它的所有历代祖先", "这个路径反过来也恰好是", "从根节点出发", "向下而行", "抵达这个节点的那条唯一的通路", "我们讲过这个恰好就是", "x这个节点的深度", "因此这个算法的复杂度", "正比于x节点的深度"]}, {"name": "01c-7: \t增长速度", "block_id": "e41cb8134f8e4e7e90b8747d7e07642a", "text": ["我们可以把所有的刻度汇总到一起", "这样的话 我们就对整个这把直尺", "以及上面的刻度有了一个总体的感觉", "当然需要指出的是", "这里同样 我们需要放眼长远", "如果我们只是在一个相对比较小的尺度", "比如像这个复杂度是从0到30的尺度", "只观察局部的话", "我们甚至可能会往往得出一个错误的结论", "比如说 在这里我们认为", "最高复杂度的指数复杂度 在这里", "并不见得体现的增长速度是最快的", "原因很简单", "因为我们这里的尺度太小", "所以我们也许应该", "换成一个更大的尺度", "比如说 只要到大概2000以后", "我们就可以看得出来了", "比如说 刚才所说的指数复杂度 2的n次方", "就可以在这地方 很明显地看出", "虽然在小的尺度范围之内", "它并不见得胜过", "比如这里头的 n的立方", "但是毕竟 它的增长速度", "在足够远之后 是会体现出来的", "它总有一天会超过 刚才所说的", "所有这些固定阶次的多项式", "所以 这也是我们从总体上", "获得了这个标尺的一个感觉", "在后边 我们将针对具体问题", "得到这方面 更加具体的感觉"]}, {"name": "02D1-3\t 复杂度（低效版）", "block_id": "0d4d3c6979f94036b88102f88af10813", "text": ["算法的复杂度主体", "应该是来自于其中的while循环", "不难看出 迭代次数取决于", "整个向量中元素的个数", "大致是线性的O(n)", "遗憾的是 在这个循环的内部", "有可能要执行一次remove()操作", "以删除掉可能发现的重复的元素", "我们说 在最坏的情况下", "有可能每一次 你都需要调用这个remove()操作", "我们来看下面这个图", "我们可以构造这么一个例子", "也就是 向量中所有的元素都是彼此重复的", "这样的话 从第0个元素开始", "后面的故事都是类似地", "每一次将它和后继的元素进行比较", "答案都是一样的 都是发现一个重复", "所以我们要调用一次remove", "好 后面的元素接替上来", "但是接下来 我们下一次比对", "依然是发现一个重复", "又要执行一次remove", "然后呢 再要、再要、再要一直到最后", "只剩唯一的一个元素", "那结果不出我们的意料", "但是这个过程是值得推敲的", "因为在整个这个过程中", "我们每一次remove操作", "正像我们此前所介绍的那样", "它所需要的时间都决定于", "它的后继的数目", "那么这些后继有多少个呢？", "对于第一次迭代来说 是n-2", "第二次是n-3", "第三次是n-4 诸如此类", "大致从O(n)一直到最后的常数O(1)", "呈现一个算术级数", "只不过是递减的一个算术级数", "这样的一个形式", "我们此前已经教过大家诀窍", "那么它的总和都应该是与末项", "也就是n大致是平方关系", "换而言之", "这个算法的总体时间复杂度是n平方", "翻到此前无序向量的去重算法", "我们会发现", "其中的while循环也调用了remove()操作", "而且还附加的有一个find()操作", "在我们这个问题 新的版本中", "尽管把find()这个操作省掉了", "但是从最坏情况而言", "它的总体居然和原来无序向量的那个", "deduplicate()算法是一样的", "从这一点来看 我们是不能满意的", "因为毕竟我们现在所处理的对象有序向量", "应该比原来的无序向量要简单的多", "那么有没有更好的方法？", "又应该如何更快地来完成", "有序向量的去重操作呢？"]}, {"name": "12a1-2: 轴点", "block_id": "52efeef645ae44e69f6269ed916e3836", "text": ["为了实现霍尔爵士所设想的划分", "我们需要借助轴点", "所谓的轴点pivot", "是在序列中的某一类特殊元素", "这类元素的特征是", "凡是居于它左侧的元素都不比它更大", "对称的居于它右侧的元素也不比它更小", "因此如果我们用高度", "来表示元素的数值大小", "那么相对于轴点所对应的这条水平线", "左侧的元素都位于下方", "而右侧的元素都位于上方", "不难看出以任何一个轴点为界", "整个序列总是可以分为左小右大的", "两个子序列", "而这正是霍尔爵士所设想的那种", "左小右大式的划分", "因此只要我们能够", "在任何一个序列中", "快速的找到其中的轴点", "那么借助二分式的递归", "我们就自然可以导出快速排序的", "完整算法", "由此我们也再一次更为清晰的看到", "快速排序算法的核心", "就在于如何快速的确定轴点", "因此我们接下来需要实质讨论的重点", "也无非就是这样一个", "快速划分的算法", "然而在通往快速划分算法", "partition的道路上", "我们首先就会遇到一个拦路虎", "因为我们不能保证", "在任何一个待排序的序列中", "轴点元素总是存在的", "实际上既然相对于轴点", "所有的元素都是按照", "前小后大的次序排列的", "所以轴点自身必然是已经就位了", "它在当前序列中所对应的秩", "也就是它最终在有序序列中", "所对应的秩", "是的 轴点必然是就位的", "这是一项非常强的必要条件", "实际上每一个元素都有可能天生", "不具备这个条件", "任何元素都非就位的序列", "普遍存在", "实际上他们也就是所谓的乱排序列", "derangement", "比如任何一个有序序列只要经过一次", "循环移位", "就可得到一个这样的乱排序列", "不难理解在完全有序的序列中", "所有的元素自身都是一个轴点", "而反过来如果一个序列中的所有元素", "都是轴点那么它也自然是有序的", "从这个角度来看", "所谓的快速排序无非就是将", "原序列中的所有元素", "逐个的转换为轴点的过程", "尽管在任意序列中", "轴点未必天然的存在", "但好消息是", "只要适当的交换元素的位置", "我们总是可以将任何一个元素", "转化为一个轴点", "那么具体的又当如何交换呢", "为此我们又需要付出多高的成本呢"]}, {"name": "07C-5 等价变换", "block_id": "6c28ef8abd33430dab572096f91e1802", "text": ["实际上 任何一对等价BST之间的相互转换", "都可以视作是由一系列的", "基本操作串接而成的", "而这种基本的变换无非两类 彼此对称", "其中一类如这个图所示", "也就是说 如果节点V拥有一个左孩子C", "而且它们属下分别有三棵", "在此命名为X Y Z的子树", "我们只需将这局部的", "两个节点以及三棵子树", "重新调整为这样一种拓扑连接的形式", "那么无论是在此局部", "还是在它们所属的那棵全树", "顺序性和单调性将依然保持", "也就是说 全树依然将是一棵BST", "为了对此做一验证", "我们不妨来考察在此局部的中序遍历次序", "我们可以看到", "无论是在变换之前 还是变换之后", "在此局部 中序遍历序列的次序", "必然是X C Y V 以及最后的Z", "从效果来看 这样一个变换", "可以大致理解为是在此局部围绕着节点V", "做了一个顺时针的旋转", "我们称这种变换为zig", "那么这种旋转的中心V 则是zig的参数", "右图是完全对称的另一种基本操作", "因为它可以理解为是围绕着节点V", "做了一次逆时针的旋转操作", "我们也形象地称之为zag", "在后续的章节中 我们将会看到", "包括AVL树 红黑树在内的", "各种BBST都分别精心地", "定义了某种适度平衡的准则", "从而使得原本在其中的任何一棵BBST", "即便在经过某次操作之后", "会暂时地游离到这个边界之外", "我们也总是能够通过", "一系列精巧地等价变换", "令它重新回到这个边界以内", "并重新成为一棵BBST", "而在设计所有这些等价变换的组合时", "我们始终不要忘了", "应该遵循两个重要的准则", "一个就是所谓的局部性", "也就是说 我们执行的每一次等价变换", "都应该局限在某一常数规模的局部", "比如对于我们刚刚介绍的", "zig和zag操作而言", "它们都局限在局部的V和C两个节点处", "如此它们所牵涉到的节点总数既然是常数", "这类操作所需要的计算时间", "也可以严格地控制在常数的规模", "第二个需要严格遵守的是", "在我们将一棵刚刚失衡的BBST", "重新恢复为一棵BST的过程中", "累计需要执行的", "这样的操作的次数不要过多", "比如至多不能超过logn次", "这样我们就可以有效地控制", "整个操作序列的长度", "以及总体所需要的时间", "后面我们会看到 任何一种BBST", "都必须至少满足这样一个logn的基本条件", "但是在进一步的要求上", "它们各自又有所差异", "比如对于AVL树而言", "它的删除操作只能刚刚达到这个及格线", "而它的插入操作却可以优化到常数", "而我们在第八章中将要介绍的红黑树", "也就是Red Black Tree", "则可以进一步地将这两种操作的性能", "同时提升到最优的常数", "那么接下来的一节 我们就首先来看看", "AVL树是如何达到这样一个及格线的"]}, {"name": "04A-3\t 实现", "block_id": "d30da7443ec448c4800d0324c7964b49", "text": ["我们接下来，讨论栈结构的具体实现方法", "实际上 既然栈可以视作是", "序列的一种受限后的特例", "那么自然可以通过我们此前所学过的", "向量或列表结构直接派生而得", "也就是说 我们完全可以利用向量", "或者列表来模拟栈以及它的接口行为", "以向量为例 栈中有多少元素", "我们的向量中也对应地有多少个元素", "如果约定首元素是栈的底部盲端", "那么末元素也就是可操作的栈顶", "按照这样一个思路 我们就可以", "简洁地写出栈模板类", "可以看到 它是以public的形式", "直接继承自我们此前已经设计", "并且实现完善的Vector向量模板类", "因此对外统一开放的size()、empty()等接口", "都可以直接沿用而不必重写", "这样我们的精力就可以集中于", "实现栈所特有的几个接口", "我们先来看最容易的top接口", "正如我们刚才所说的", "在这里我们约定所谓的top元素", "也就是向量的末元素", "因此这样一个取顶操作", "只需简明地将当前向量的末元素", "直接返回即可", "再来看相仿的pop()接口", "既然顶部元素是末结点", "所以为了弹出它", "我们只需将这个结点删除", "或者更加简明地等效于", "将原先末结点的前驱作为新的末结点", "而这样一个动作 完全可以通过调用", "向量的标准remove接口统一的实现", "那么 如果要将一个新的元素", "推入栈中呢？", "从图中 也可以看出", "只需将这个元素", "作为向量新的末元素插入其中", "同样地 这也可以通过调用", "向量所提供的插入接口来完成", "我们知道 对于向量结构而言", "无论是插入操作 还是删除操作", "所需要的时间都线性正比于", "插入和删除位置的后继的数目", "而按照这里所给的方法", "无论是插入操作 还是删除操作", "都是在向量的末端进行", "因此所有这些操作接口的时间复杂度", "都是常数的", "这再好不过了", "请注意 虽然从理论上看", "我们也可以将向量首部作为栈顶", "但是从实际性能而言", "这是一个非常糟糕的选择", "因为如果插入和删除操作", "都集中在前端进行", "那么每一次操作", "都需要涉及到向量中的", "当前所有的元素", "于是入栈和出栈操作的复杂度", "都将上升到O(n)", "这一点非常重要", "大家需要特别注意", "当然 通过列表结构", "用类似的思路", "同样可以模拟并且实现栈", "我们将这个工作留给大家", "在课后完成"]}, {"name": "12a4-4: 实例", "block_id": "818c01fbe4b14bea88eb009e944b1dd0", "text": ["在告别本节之前", "我们不妨通过一个具体的实例", "来切实的体验", "快速排序的这个新的版本", "这里的输入序列由11个元素构成", "这个算法会首先将首元素6", "作为侯选轴点", "而其余的元素则整体构成子序列U", "当然相应的子序列L和G此时都是空", "以下进入算法的迭代部分", "首先在第一步迭代中", "我们考虑的是U 当前的首元素3", "这个元素要比侯选轴点更小", "因此它应该被归入到子序列L中", "在我们刚才实现的算法中", "这就对应于if的分支", "当然这是一种退化的情况", "因为这个兑换", "实际上就是它自己和自己", "所以在位置上这个元素", "并没有实质的改变", "然而此后在逻辑上", "子序列L将拥有第一个元素", "而不再是空", "接下来我们继续考察新的首元素8a", "因为它在数值上要大于侯选轴点", "所以对应于los那个分支", "这是一个只需简明处理的分支", "具体来说", "我们在这种情况下", "只需简明的利用k++", "从而在使得子序列U", "缩短一个单位的同时", "使得子序列G拥有了第一个元素", "再接下来我们会进而考虑", "新的首元素1", "可以看到它比侯选轴点要更小", "因此应该被归入到子序列L当中", "我们需要令它和子序列G的首元素", "互换位置", "当然此时G的首元素", "也就是它那个唯一的元素8a", "可以看到在经过了这样一次交换之后", "二者的位置的确颠倒了过来", "请注意在经过了这样一次交换之后", "更主要的在逻辑上是等效于子序列L", "向后拓展了一个单位", "同时子序列G滚动式的后移了一个单位", "接下来我们继续考察", "子序列U的首元素也就是5a", "可以看到", "它依然应该被归入到子序列L当中", "为此我们依然需要令它", "和子序列G的首元素", "也就是8a做一次交换", "经过了这样的一次交换之后", "不仅这两个元素的相对位置", "颠倒过来了", "而且更重要的是在逻辑上", "子序列L又继续向后拓展了一个单位", "同时子序列G也滚动式的", "又后移了一个单位", "接下来我们依然要考察子序列U", "新的这个首元素9", "作为大于侯选轴点的元素", "它自然应该归入子序列G中", "我们知道这对于算法中的los分支", "因此只需简明的利用k++", "就可以在逻辑上利用子序列G", "向后拓展一个单位", "在以下我们仍然是要", "考察子序列U的首元素", "这回轮到的是8b", "因为它不小于侯选轴点", "因此同样对应的是los那个分支", "也就是说", "我们依然只需简明的利用K++", "就可以使得子序列G", "继续向后拓展一个单位", "接下来的这个首元素4", "要小于侯选轴点", "所以它对应的是if分支", "于是我们需要令它", "与子序列G的首元素8a互换位置", "在经过了这样一次交换之后", "子序列L向后继续拓展了一个单位", "同时子序列G也滚动式的", "后移了一个单位", "再接下来的这个首元素5b", "同样应该被归入于子序列L当中", "因此我们仍然需要令它", "与子序列G的首元素9互换位置", "同理在经过了这样一次交换之后", "子序列L得以向后继续拓展一个单位", "同时子序列G再次滚动式的后移一个单位", "现在轮到新的首元素7了", "它要比侯选轴点更大", "所以应该通过简明的K++", "将它归入到子序列G中", "同时子序列L保持不变", "现在轮到子序列U的最后一个元素2了", "它比侯选轴点更小", "因此应该被归入到子序列L中", "我们的处理手法依然", "也就是要利用这个元素", "与子序列G当前的首元素8b", "做一次交换", "在经过最后的这一次交换之后", "L再次向后拓展了一个单位", "而子序列G", "再次滚动的后移一个单位", "至此子序列U变成空", "因此循环得以退出", "在算法终止之前", "我们还需要完成最后一步", "也就是利用侯选轴点就位", "并成为一个名副其实的轴点", "你应该记得我们的做法是", "令这个侯选轴点", "与当前子序列L的末元素", "也就是2互换位置", "可以看到在如此交换之后", "候选节点6的确成为了一个", "名副其实的轴点"]}, {"name": "11c2-1: \t制表备查", "block_id": "502f90c70e6e4099a1044e682c3a91d1", "text": ["接下来我们就来看看", "KMP算法究竟如何兑现我们刚才所提及的记忆力以及预知力", "我们将会看到 这种方法非常地便捷与高效", "本质上讲 它无非就是构造了一张查询表", "回到我们刚才的问题", "在当前这轮比对 首次失败于T[i]与P[j]之后", "我们应当如何地向后滑动模式串", "从而等效地以一个新的P[j]来与刚才的T[i]对齐", "并从这个位置开始", "继续新一轮的比对", "这里的好消息是", "新的这个P[j]不仅可以事先确定", "而且这个位置仅取决于模式串", "而与主串无关", "你能看出 为什么与主串没有关系吗", "是的", "事实上 在这样的一个时刻 主串无非4个部分", "也就是文本串的这个前缀以及后缀", "再加上 在当前这一轮已经匹配的这个子串 以及失配的这个字符", "不难看出", "这个前缀与后缀", "对于新的这个P[j]字符 的确没有任何影响", "而这个子串", "表面上看 对它有所影响", "但正因为这个子串", "与模式串的前缀是匹配的", "所以与其说这种影响是来自于文本串", "不如说最终还是来自于模式串", "能否看透这一点", "对于我们以下理解KMP算法至关重要", "既然下一个接替的字符完全取决于模式串自身", "由此出发 再进一步地", "与其说 这个接替的字符是取决于模式串", "不如说 它取决于被它顶替的此前的那个P[j]", "事实上 在一个长度为m的模式串中", "这样的字符P[j]无非m种情况", "而KMP算法在此处的关键诀窍在于", "将所有这m种情况事先处理 并且归纳整理为一张查询表", "在经过了这样的预处理之后", "在后续的各轮比对中", "一旦在某一位置P[j]处发生失配", "我们只需简单地从查询表中取出对应的那一项", "并用它来更新此前的j", "由此可见 这种策略与其说是在借助强大的记忆力", "不如说是在事先 已经为各种情况准备好了充分的预案", "那么 基于这种以查询表的形式给出的预案", "KMP算法又是如何具体工作的呢"]}, {"name": "08XA4-2\t算法框架", "block_id": "5a9c228a432b4fad86d7a1548e63ad24", "text": ["首先来看删除算法的总体框架", "首先需要调用BST的常规节点删除算法", "也就是说通过removeAt历程", "摘除掉经定位以后确认在_hot以下的节点x", "你应该还记得removeAt的语义", "是的 如果返回的是节点r", "则意味着原先的节点x 将由r替代", "比如在这副图中 节点x在被删除之后", "将由它的某一个后代r来替代", "当然替代者r 有可能就是一个实际并不存在的外部节点", "尽管在此后 树的拓扑结构依然保持完整", "但是红黑树的性质却未必都能继续满足", "不妨逐条加以验证", "首先红黑树的根以及外部节点并没有受到影响", "但此时 同样在此局部有可能会出现两个连续的红色节点", "而更重要的是 在被删除节点所在的通路上", "黑节点的数目 却有可能发生变化", "也就是说 第四条规则也未必能够满足", "当然有一大类的情况 还是非常容易处理的", "也就是被删除节点x 与它的替代者r之间", "有一个是红的 当然不可能都是红的", "比如x此前可能是红的 r此前是黑的 或者反过来", "对于这样一大类的情况", "我们只需简明的将替代者r染为黑色即可", "这背后的原因也不难理解", "从删除操作之前的树结构可见", "在此局部 都包含一条指向红节点的虚边", "我们讲过 这类虚边 对于黑高度是没有影响的", "因此在简明的将r置为黑色之后", "都等效于在原树中删除了一条此类虚边", "因此所有外部节点的黑深度 将依然保持原状"]}, {"name": "08B1-4\t一秒与一天", "block_id": "f9076e168110439eae3c942e360f43a4", "text": ["当然 面对存储器在速度和容量之间的内在矛盾", "我们并非只能无所作为", "其中采用高速缓存就是一种被证明行之有效并且普遍采用的方法和技巧", "为此我们需要对不同层次存储器的性能做进一步的了解", "这包括两个方面", "首先容量和类型不同的存储器在访问速度上的差异是极其悬殊的", "就以我们最常见的磁盘以及内存这两级存储为例", "他们在访问速度上的差异究竟有多大呢", "其实我们只要找到相关产品的性能指标说明就不难看出这种差异", "就传统的旋转式磁盘而言 它的访问速度大致是毫秒量级", "而典型的内存呢 大致是在纳秒量级", "不要小看了m和n之间的差异 以一秒为基准", "前者是10的-3次方 而后者呢是10的-9次方", "因此 二者的差异大致是在10的5至6次方", "是的 即使保守的估计 也是5个数量级", "如果你还记得我们介绍过的封底分析", "你就应该意识到这种差别是一秒之于一天", "没错 一秒之于一天", "也就是说 如果将内存的一次访问比作是一秒", "那么响应的一次外存操作则是一天", "再打个形象的比喻", "假设一次内存访问就相当于我从讲台上拿起一支粉笔", "这可以在一秒钟之内瞬间完成", "那么对应的外存操作呢", "就相当于我要去买一张火车票 然后赶到火车站", "乘上火车 经过一天的路程到达比如说广州", "甚至像现在的高铁的速度应该完全可以到海南", "然后在当地购买到一支粉笔 再乘同样的火车连夜赶回北京"]}, {"name": "08B4-2\t分裂", "block_id": "28be715baceb428d81ab0dcde3d9fb32", "text": ["确切的说 如此发生上溢的节点应该恰好拥有m+1个分支", "相应地 也恰好有m个关键码", "我们不妨 将其计作k0一直到km-1", "对上一节点的分裂 要尽可能的均衡", "因此 在这里不妨采用中位数s作为分割线", "也就是说 左侧取0到s-1 右侧取s+1到m-1", "而ks作为独立的关键码 居于二者之间", "而具体的分裂规则是需要将分界的ks关键码 提升一层", "交给此前的父亲 如果有的话", "并将刚才左右的两组关键码分别作为它对应的孩子分支", "来看一个具体的实例", "假设在这样的一个节点中", "因为某个关键码的插入 使得关键码的总数多达6", "如果该节点所属的恰好是一棵6阶B树", "那么这就意味着 在此处发生了一次上溢", "为了进行修复 我们要在这6个关键码中选取其中的中位数", "相应地 以这个关键码为界", "原先的关键码将会分为", "左侧的3个一组 以及右侧的2个一组", "接下来 中位数关键码 也就是37", "将顺着指向该节点的那个引用 逆行向上", "并在其父节点中 插入于这个引用所对应的左右两个关键码之间", "其结果如下面这个图所示", "相应地 原先的这一组关键码就被分割为了左右两组", "各自成为一个独立的B树节点", "在增加一个引用之后 这两个分裂出的节点", "恰好可以作为此前被提升的那个中位数关键码的左和右孩子", "至此你不妨验证一下 经如此分裂之后所得的左右两个新节点", "尽管关键码的数量相对于此前 几乎折损一半", "但依然不会低于B树关于关键码数所设定的下限", "相应地  我们也不妨反对来体味一下", "B树关于分支数所设定的上界和下界", "具体来说 也就是m和m/2的上整", "正是得益于这条规则的精妙", "使得我们的分裂操作可以在这两个界限之间游刃有余", "至此 刚才一度存在的上溢缺陷的确在这个高度已经得到了修复", "但故事并没有就此终结", "细心的你 可能已经发现", "这等效于在这个父节点中插入了一个新关键码", "不难理解 父节点在此时同样存在发生上溢的风险", "比如倘若它在此前恰好已经处于即将发生上溢的临界状态的话"]}, {"name": "07C-2 平均高度", "block_id": "e0862b2a3c4d418c9990f535f66fb761", "text": ["以下我们就从两种最常见的统计口径出发", "针对BST的平均高度 分别给出估算的结果", "首先是所谓的随机生成统计口径", "也就是说 对于任何一组关键码词条", "我们考察它所有可能的排列", "对于其中的任何一个排列", "我们都假设按照这样的排列次序", "将关键码依次插入一棵初始为空的树", "比如当关键码总数为3时", "依次插入1 2 3 将会得到这样一棵BST", "相应地 如果插入的次序是3 2 1", "那么得到的将是这样一棵树", "接下来 对于其它的排列", "比如说1 3 2 将得到这样一棵BST", "以及其它的排列都会各自得到一棵BST", "这样一种创建BST的方式称作随机生成", "不难发现 当关键码总数为n时", "可能的生成序列", "也就是这n个关键码的全排列", "总共有n!种", "那么可以证明 如此所得到的", "n!棵BST平均高度为logn", "我们考察的第二种统计口径", "是所谓的随机组成", "也就是说 我们将所有的n个关键码", "视作n个互异的积木", "然后在符合BST顺序性要求的前提下", "考察它们总共能够拼接出", "多少棵拓扑结构互异的BST", "可以证明 如此所得BST的总数", "恰好为我们已经熟知的卡特兰数", "而按照这一统计口径", "所有BST的平均高度值为根号n", "是的 你没有听错和看错 的确是根号n", "你现在可能会置疑", "按照我们刚才所说的随机生成的统计口径", "累计生成的BST应该是n的阶乘种", "而且对应估算出的平均树高应该是logn", "那么根据这两种统计口径", "各自所得到的结论哪一个更为可信呢？", "我们说后者更为可信", "其原因在于前者实际上是有所重复的", "这种重复性就体现在", "不同的关键码序列", "有可能会生成同一棵BST", "比如对于n为3的情况而言", "这样两个输入序列所生成的", "都是这样同一棵BST", "也就是说 只要第一个插入的是居中的2", "那么分列于它左右的1和3", "究竟是按什么次序输入是没有关系的", "实际上 不难理解", "这个结论可以进一步地推广", "也就是说中位数", "或者接近于中位数的关键码", "越是被更早地插入", "整体而言 这棵BST的高度", "也相应地会更低", "这就意味着在前一种统计口径中", "这类高度更低的BST", "将会被以更高的重复度参与统计", "以及最终的平均估算", "这也是为什么按照前一统计口径", "所得到的估算值会相对更小", "从这一观点来看", "前一统计口径可以说是过于乐观了", "而后一统计口径所得到的结论将更为可信", "但对于在此非常在意树高的我们来说", "这并不是一个好消息", "这意味着在天然的随机意义下", "这样一个高度是不能够令我们满意的", "为了进一步地降低和控制这个高度值", "我们应该做点什么", "而且我们很快就会看到", "为此我们将不得不发现", "并且利用一系列的技巧"]}, {"name": "08XA1-4\tO(1)重构", "block_id": "93841fa256054d27b653b9ed4936d22b", "text": ["尽管这里我们没有时间去讨论实现的细节", "但是为此所应具备的一项必要条件是非常好理解的", "也就是说就BBST的树形拓扑结构而言", "相邻版本之间的差异 本身不能超过常数", "然而很遗憾 绝大多数的BBST", "包括我们此前所学过的AVL树 都不能保证这一点", "所谓的拓扑结构差异 无非是来自自调整过程中的旋转操作", "每一次局部的旋转 都意味着在结构上引入常数的差异", "因此反过来 如果需要保证前后版本在拓扑结构上的差异不超过常数", "也就意味着 在从前一版本转入后一版本的过程中", "所执行的旋转操作不得超过常数次", "因此反观AVL树的两个动态操作 插入操作是满足这一条的", "因为正如我们所知的 每次插入之后", "一旦经过一次旋转 局部乃至全树的高度都会复原", "然而很可惜 删除操作却并非如此", "你应该还记得 从AVL树中删除一个节点之后", "有可能自底而上 逐层引发多达logn次的旋转", "从而导致树形拓扑结构的剧烈变化", "因此为了使得上述的构思能够兑现", "我们就需要这样一种BBST", "它的任何动态操作 无论插入还是删除", "对树形拓扑结构的影响 都能控制在常数的范围之内", "而红黑树 正是具有这一特性的一个变种"]}, {"name": "05A-7 深度+层次", "block_id": "f084fee254314e1889d49c64f98de330", "text": ["以上我们看到，对于任何一个节点而言", "它所对应的那条通往根的路径", "必然是唯一的", "反之", "再按照刚才的递归嵌套形式", "构成出它所属于的那棵大树的过程中", "任何一个节点也必将在某一个时刻", "对应于以它为根的那棵子树", "既然这三个概念就是同一件事情", "所以在不致引起歧义的情况下", "我们可以往往将它们混淆起来", "彼此指代", "也就是说the path from root to v", "可以直接简化为the path v", "而the subtree rooted at v", "也可以直接地简化为the subtree v", "既然任何一个节点都会以它所对应的", "那条通路的长度作为指标", "而这样一个指标也很好地体现了", "任何一个节点v", "从根节点开始向下深入的程度", "因此我们也将v所对应的", "这条路径的长度 也就是它的指标", "形象地称作点v在这棵树中的深度", "任何一个顶点", "也因此具有了一个深度的指标", "那么继续考察任何一个顶点", "所对应的这条通路", "相对于某一个特定的顶点", "在它所对应的那条通路上", "如果还存在其它的点", "那么这个点", "就称作是它的祖先ancestor", "反过来呢", "这个点也就称作是它的祖先的后代", "descendent", "当然 我们这里一般所定义的祖先和后代", "都是包括顶点自身的", "如果需要将自身排除掉", "那么我们更严格地", "也称其为真祖先或者是真后代", "当然 在不致引起歧义的情况下", "我们也往往会将真字省略掉", "不难看出 对于任何一个节点而言", "在它以上的任何一个层次上", "它必然只有唯一的一个祖先", "而反过来 对于任何一个节点而言", "它在任何一个层次上的后代", "却未必是唯一的", "比照我们此前的向量和列表等线性结构", "如果祖先对应于前驱", "而后代对应于后继", "那我们就会发现", "前驱的唯一性 在这个意义上讲", "依然是保持的", "但是后继的唯一性却不再保持", "因此从这个意义上讲", "也应该将树结构称作是半线性结构", "稍后我们会看到 对于图结构而言", "这两条唯一性都是不能满足的", "所以我们直接地称它为非线性结构", "也是再合适不过的了", "当然", "全树的根节点", "也应该是任意节点的祖先", "或者说是它们的公共祖先", "它所对应的那条路径的长度为零", "所以我们说它所对应的深度", "也自然就是零", "树根节点没有祖先", "而反过来 有些节点也会没有后代", "那么这样一类节点", "我们也形象地称之为叶节点", "或者简称为叶子", "请注意 在树中叶子节点必然是存在的", "否则的话 我们沿着深度", "不断地下行", "总能够前进", "这就会得出一个很荒诞的结论", "也就是说 这棵树中", "将包含无穷个节点", "既然节点的数目有限", "那么有限集中必然存在最值", "我们考虑其中的最大者", "也就是形象地来说 其中最深的那个节点", "当然这个节点必然是一批叶子", "在这样一个图中", "叶子节点应该出现在这样的位置", "而这种叶子节点", "所对应的那个最大的深度", "我们也形象地称之为这棵树的高度", "当然树的高度这一概念", "也可以推广至其中的任何一棵子树", "如此定义的子树高度", "也称作它的根节点的高度", "所以任何一棵子树的高度", "就是它的根节点的高度", "所以反过来 全树的高度也可以当作是", "全树根节点的高度", "这几个概念比较容易混淆", "所以我建议同学们脑子里", "记下我们这里所绘的这张图", "你就很容易搞清楚什么叫作全树的高度", "子树的高度", "以及其中任何一个节点", "包括根节点的高度", "需要特别说明的是", "对于退化的树", "也就是只有单个节点的", "这样一棵树", "不难发现", "它的高度应该是零", "那么再进一步的呢？", "一个节点都不包含的树呢？", "也就是我们所谓的空树呢？", "为了一致起见", "我们不妨将它的高度取作是-1", "这一点现在你还不容易理解", "稍后我们就会发现", "它是非常自然的一个设定", "现在我们回过头来观察", "树中的任何一个一般性的节点v", "按照我们刚才的介绍", "任何这样的一个点", "都既有深度的指标", "同时也有高度的指标", "那么我们也不难证明这样一个事实", "也就是任何一个节点的高度", "与深度之和绝对不会超过全树的高度", "在我们所建议的这幅图中", "也就是说", "对于任何的", "这样一个顶点", "它的深度与它的高度之和", "不会超过全树的高度", "从图中非常好理解", "尽管我们在此把严格的证明省略掉了", "那么有一点倒是希望大家", "在课后进一步思考的", "也就是说 这个不等号", "在什么时候取等号？", "它的条件是什么？", "你所给的条件是否是充要条件？"]}, {"name": "01c-5\t: 难解", "block_id": "5c1d7ccdf8954a3c9168f4fe4bfe2189", "text": ["我们的下一个刻度 被归结为难解的问题", "这个刻度 也就是所谓的指数复杂度", "具体来说 计算成本T（n）", "可以表示为 一个常数a的n次方的形式", "我们说 这个和刚才的多项式是有天壤之别的", "可以从以下这几个性质 看出这一点", "也就是说 对于任何固定的", "n的c次方 这样的多项式而言", "它都可以在大O记号的意义下", "被2的n次方 也就是这样的一个指数形式", "给覆盖", "其它的更极端的情况 也是如此", "我们看看 即便这个次数非常非常的高", "1000应该已经足够大了", "而反过来 作为指数下面的那个底数", "既使是尽可能的小", "但是它只要是严格地大于1", "后者构成前者的上界的这样一个性质", "总是能够满足的 当然反过来", "多项式也构成了指数的一个下界bigΩ", "这类算法的计算成本 是增长的极其之快的", "我们很快就会有直观的感觉", "所以通常认为是不可忍受的", "尽管是可计算的 还不属于不可计算的", "但是 我们也称它作难解的问题", "而前者 就是我们上页所介绍的多项式", "通常认为它是容易解的", "所以在指数和多项式之间", "有一个明显的分水岭", "可解的 就是多项式的问题", "我们称作是存在有效算法的", "反之 我们也称作是不存在有效算法的", "这里有个很有意思的现象", "很多问题 它的指数形式的算法", "都很容易看出并且实现", "然而 我们如果要试图去设计", "并且改进成一个多项式的算法", "就会发现极其不易", "甚至在很多情况下 注定是徒劳的", "我们下面就来看 这样一个具体的例子"]}, {"name": "02F-4\t 二路归并：实现", "block_id": "799ce5f169104dcb8c33e7eda414fdb6", "text": ["这里所给的就是二路归并算法的一种实现", "正如刚才所言", "这里需要将定义两个向量的三个界桩", "也就是lo、mi和hi作为参数传入", "接下来 我们要定义清楚ABC三个向量", "首先A向量在这里", "将继续地保存在它输入的位置", "准确地讲 就是在_elem这个整个数据区中", "起自于最左侧的界桩lo的这么样一段区间", "这也就是为什么我们可以", "直接令A指向这个区间的起点", "好 接下来是左侧的子向量B", "我们需要为这个子向量申请一段空间", "它的宽度应该就是mi到lo之间的距离", "这也是为什么我们在这里", "相应的申请这么大的一段空间", "当然接下来 我们还需要将A中", "对应的那些元素", "也就是左半部分的那些元素", "逐一地取出来并且复制到", "新开辟的这段空间中去", "从而完成整体的这个子向量B的一个缓冲", "好 C呢？", "我们看到C非常的简单", "实际上 定义的就是", "在_elem数据区中", "起始于mi的这段数据", "那么不同的在于右侧的子向量C", "并不需要另辟空间进行缓存", "尽管在这里 为了说明的方便", "我们还是将它画在了上边", "作为一个单独的子向量", "好 接下来", "就开始了我们最主要的这个循环", "这也就是刚才", "我们的例子所给的过程", "具体来讲就是", "每一次我们都比较", "两个子向量当前的首元素", "取出其中更小的那个", "比如说 在这种情况下 B更小", "而在下一种情况下 C更小", "无论谁更小 我们都把它转入到A中去", "而这个首元素是由谁来标定的呢？", "可以看到是由j和k", "这两个秩来标定的", "在最初始的情况下", "它们都是0", "分别指向B和C的第一个元素", "在随后 每当有一个元素转移到A中", "它们各自都会自加", "从而指向下一个替补的新的首元素", "而A中每次纳入的那个元素", "又是由谁来指示的呢？", "可以看到 是由i来指示的", "同样 i最初初值也是0", "而每次接纳了一个元素之后", "它自己也会通过自加", "指向下一个适当的位置", "细心的同学可能已经注意到", "我们在这里头有相对更复杂的逻辑", "尽管从形式上看 显得比较紧凑", "我们不妨来进一步地解读它", "我们可以看到 所谓B更小的情况", "严格的讲 是由一系列的逻辑判断构成的", "准确的说 首先是一个and", "是一个与", "也就是说 我们要确定j小于lb", "也就是说 B中这个所谓的首元素的秩", "应该至少没有越过它的右侧的边界", "它还是合法的", "换而言之 这个时候", "B[j]指向的还是一个实在的", "而不是虚拟的元素", "接下来地 有两种情况", "要么这个k已经越界", "要么就是可以理解为 这个k没有越界", "但是它作为一个实在的元素", "比另一个实在的首元素不小", "大家注意 这里我们运用了", "C++语言里头的“短路求值”的语法特性", "否则的话", "这个不满足的情况下", "我们还去对这个进行比较求值", "实际上 这个k因为已经越界", "就会造成程序运行过程中的错误", "那么k大于lc", "也就是它越界的时候", "为什么我们可以理解成", "是将它的那个实在的对手转移出去呢？", "我们说 为了把这两个逻辑统一起来", "很好的一个做法", "也是我们这门课中常用的一个技巧", "就是假想着 在C的末尾添加了一个哨兵", "而且将它的数值假设为是正无穷", "那么现在我们就很好理解这句话了", "或者 与其说是k越界", "不如说 C[k]这个元素已经是正无穷了", "那么作为正无穷来说", "任何实在的元素B[j]都不可能比它大", "所以这个情况下", "我们把B转移到A中去", "也是符合这个语义的", "这样的话 我们就非常好想象了", "那么同样地", "我们也可以考虑在B的末尾", "缀上一个数值为正无穷的哨兵节点", "这样 我们也可以很好地来解释第二条if语句", "那么它的意思是说", "j一旦超出了B的右边界", "也就是 它实际上是一个哨兵", "那么其实也等效于这样一个判断", "也就是说 作为一个实在的C中的一个元素", "和这样一个数值为正无穷的元素比", "必然是更小的", "所以这个时候或者是这个时候", "统一地都可以将C视作是更小的元素", "转移至A中去", "当然整个这个循环的退出条件也值得揣摩的", "我们看到 这里的条件", "可以理解为是", "或者j已经越出它的边界非法", "或者是k越出它的边界非法", "我们可以 这两个条件是或的关系", "而不是像通常的理解那样 是与的关系", "所以从这里我们也可以看得出来", "这个算法所终止的条件是", "这两个位置j和k", "同时越界之后 这个算法才会退出", "而在这个时候 无论是B还是C中的元素", "都已经完整地归入到了A中", "成为了一个整体的序列"]}, {"name": "02C-4 \t区间删除", "block_id": "d7c26cad504641e6b68527dd4c8f0f1f", "text": ["再来考察删除算法", "我们先考虑一个通用的一个版本", "也就是所谓的区间删除", "具体来说，也就是", "在某个向量中", "我们要将介于lo和hi之间的", "一系列的元素", "成批地从中剔除掉", "当然，因为向量要求所有的元素", "始终都是彼此紧邻排列的", "所以不应该在删除之后", "留下这个缝隙", "换而言之，我们需要将它", "后继的那些元素", "如果有的话，统一地向前", "或者说向左移动", "来填补这段空白", "其实，你可以反过来看到", "如果能够完成", "这样的一个左移的话", "那么实际上也就相当于", "把这些元素给剔除", "或者叫覆盖掉了", "所以我们说，关键的任务在于", "如何实现这个左移", "这样的一个过程", "大致可以实现为这样一段代码", "而其中最最关键的是", "这个while循环", "它会遍历整个后缀", "并且将其中的每一个元素", "逐一地取出", "向前转移到合适的位置", "比如说，第一个转移的是", "hi这个位置上的这个元素", "它将被转移到lo这个位置", "紧接着，是hi加1", "转移到lo加1", "hi加2转移到lo加2，直到最后", "这里同样有两个问题", "需要强调说明", "第一个问题", "在整个移动的过程中", "所有这些元素参与移动的", "先后次序，同样也是很敏感的", "或者说不能更改的", "与刚才插入算法完全颠倒", "刚才是自后向前", "现在呢，是越往前的元素", "越优先参与移动", "所以我们也可以认为它是一个", "自前向后的前移操作", "如果把这个次序颠倒过来", "会怎么样呢？", "我们说是有风险的", "比如说，在这样一种情况下", "两者，也就是说这个前缀的", "原来的那个位置", "和后来的那个位置", "如果中间有相互重叠的部分", "那么我们如果优先移动", "后面的那个元素", "那么它就有可能会", "同样地造成，这种重叠区间的元素", "在无意中被覆盖掉", "第二点呢，是大家注意到", "我们这里还有一个对shrink", "这个历程的调用", "顾名思义", "它是某种意义上讲的缩容", "这种操作在实际应用中", "并不是必须的", "我们往往可以忽略它"]}, {"name": "11f2-2: 散列压缩", "block_id": "7754bdd0aac34be5bb79dc0f97d6215f", "text": ["既然以上问题的根源在于数位的溢出", "那么我们很自然地就会应该想到通过压缩来解决它", "没错", "将一个硕大的取值空间", "压缩到一个可存储、可计算的 更小的空间", "从方法论上讲", "这不正是散列吗", "没错 我们需要对指纹来做散列压缩", "具体地 我们将借助合适的散列函数", "将字符串的指纹", "压缩到存储器可支持的范围", "这里 我们不妨就以模余法为例", "模余的基底 取作素数97", "接下来 假设我们需要在这样一个文本串中", "寻找模式串8 2 8 1 8", "以下的主体流程与蛮力算法一样", "我们也是从首个对齐位置开始", "逐次地去尝试各个位置", "在每一个位置我们都将局部的子串与模式串进行比对", "而在这里 最为本质的不同在于", "我们将不再是逐个逐个地去比较每个字符", "而是直接 在两个串的指纹之间进行比对", "为此 我们首先要计算出模式串的指纹", "如果我没有算错", "应该是77", "在文本串中", "我们首先尝试的是子串2 7 1 8 2", "也不难验证 它所对应的指纹为22", "与目标指纹77不符", "因此我们可以随即将其排除", "并接着转向下一个子串", "也就是7 1 8 2 8", "同样地 也不难验证", "它的指纹为48", "与77不符", "所以也同样被排除掉", "再接下来对应的子串为1 8 2 8 1", "它所对应的指纹也不难验算为45", "同样与77不符", "因而可以排除掉", "不难看出", "整个算法将在下一个对齐位置发现匹配", "是的 这个子串与模式串完全一致", "所以它所对应的指纹也应该为77", "而实际上 这也是算法所发现的", "于是通过这种方法", "我们也同样地完成了一次模式匹配", "需要提醒你再次注意的是", "在整个这样的计算过程中", "我们分别只需要", "常数的时间", "就可以排除或者确认一个对齐位置", "而这一点 正是我们设计这种算法的初衷", "当然 算法至此依然没有尽善尽美", "你能看出其中的问题吗"]}, {"name": "08A3-6\t删除算法", "block_id": "f4baeaab441c4c33a1f76ffd73dc0393", "text": ["再来考察节点删除算法", "同样的 按照直观的思维", "我们或许会首先按照BST的标准删除算法实施删除", "再按照伸展树的约定", "将与之临近的节点 比如_hot伸展到树根的位置", "同样的 这种方法本来也无可厚非", "但是在此时 也依然显得有些迂回", "这背后的原因也是类似的", "因为不失一般性 如果在删除操作之前的search操作是成功的", "那么在查找之后 待删除的目标节点", "必然已经被推送到了树根的位置", "既然如此 我们为何不随即就在树根的位置附近", "来完成这样一次删除操作呢", "具体的过程如下面这一组图所示", "同样的 我们也需要经过一次查找", "对待删除的节点进行定位", "而且不失一般性 不妨假设成功", "于是在紧随其后集成在search接口内的伸展操作之后", "这个待删除的节点自然也就会被伸展并推送到树根", "接下来呢 既然他就是待删除的元素", "我们不妨将这个节点释放", "于是从逻辑上看", "这个节点此前的左右子树就变得彼此分离", "剩下的任务是 如何将他们重新合并起来", "这里有很多种方法", "比如可以在右子树中找到一个最小的节点", "如果你一时还想不起如何才能找到这个节点", "那么我的建议是 你不妨回过头看一看", "此前所介绍的中序遍历算法迭代版", "好 关于这样一个节点", "我们不难发现 尽管它是右子树中的最小者", "相对于左子树来说 它却应该是最大者", "因此接下来 只要将原先的左子树", "作为这个节点的左子树连接上去", "就不仅可以完成拓扑结构上的连接", "而且能保持所有元素的中序遍历次序", "也就是说我们顺利的将他们合二为一了", "而这样一个过程的整体效果呢 同样是我们所期望的", "具体来说 所需要的删除的节点 确实被删除了", "而且在此之后 作为树根的节点", "是一个与此前那个节点非常临近的一个", "也就是说 在此后局部性将可以继续得到充分的利用", "限于时间关系", "伸展树插入删除算法的详细细节", "在此都予忽略了", "你可以在课后 打开我们的教材以及讲义", "对照其上的源代码和注释", "参照刚才我们所介绍的原理及过程", "自行推敲和体会"]}, {"name": "05A-3 有根树", "block_id": "550b789795e54a3dbbbc518908be2279", "text": ["从数学上来看", "树结构只不过是一类特殊的图", "也就是说 它同样可以认为是", "定义在一组元素之间的二元关系", "有些元素之间可能有这种关系", "那么我们就引入一条边", "如果没有这种关系", "就不引入这样一条边", "所以存在关系就引入", "不存在关系就不引入", "存在关系就引入", "当然对于树而言", "还有其它的一些限制条件", "我们稍后就会看到", "那么所有能够定义", "彼此之间关系的元素", "称作顶点vertex", "请大家注意", "这里我们说的vertex", "和我们在程序设计中的节点node", "是有区别的", "虽然它们之间也有很紧密的联系", "每一个vertex都将以node的形式", "在计算机中被表示和实现", "我们这里需要强调的是", "在计算机中所存储和组织的树", "与图论中所讨论的树略有区别", "其中第一个区别就是", "在我们这里 需要为每一棵树", "指定一个特殊的顶点", "我们称之为根root", "一棵一般意义上的树", "只要指定了其中的一个顶点作为根", "那么它就称作有根树rooted tree", "通过彼此的嵌套", "小型的有根树可以逐步地", "整合为规模更大的有根树", "具体来说", "对于任何一组有根树", "我们都可以通过引入一个新的顶点", "并且在新的这个顶点与此前", "各棵有根树的树根之间", "引入对应的一条连边", "从而构成一棵规模更大的有根树", "当然这棵新的有根树的树根", "自然也就是我们所引入的这个新的节点", "通常记作r", "暗示着它就是root树根", "而相对于这棵更大的树", "参与组成它的每一棵有根树", "都相对地称作是它的子树subtree"]}, {"name": "06C-5 实例", "block_id": "4abaa1822b814da3b3803956693e1764", "text": ["以下我们就以这幅无向图为例", "具体地了解", "整个广度优先搜索的详细过程", "请注意 这里首先引入了", "一个初始为空的队列", "我们的起点不妨取作s", "按照算法的流程 首先令s入队", "并且同时将它标记为discovered(误)的状态", "在这里 我们依然用深色", "来表示处于这种状态的顶点", "接下来将逐一地枚举s的邻居", "也就是a c和d", "它们都是白色", "也就是处于最初的undiscovered的状态", "因此它们都会被取出并且归入队中", "请注意 关于同一顶点的所有邻居", "我们这里并没有定义一个优先次序", "实际上 这并不是什么实质的问题", "你完全可以根据自己的偏好", "采用某种策略 甚至是随机的策略", "比如这里不妨以它们的ID", "也就是字母编号为序", "同样地 在这些顶点依次入队的同时", "它们也会从最初的undiscovered的状态", "转化为discovered的状态", "这也是为什么在这个时刻", "它们会进而转为深色", "每个邻居状态转化的同时", "都会生成一条tree edge", "好", "在所有相关的tree edge悉数生成之后", "s也就完成了它的历史使命", "它将会被标记为visited 也就是最终的状态", "相应地 在图中这个顶点", "改为双边框的形式以示区别", "接下来 应该是当前的队首节点a出队", "我们可以看到 在a出队之后", "也同样需要遍历它的所有的邻居", "其中s是它的父亲 所以直接忽略掉", "而c已经被发现 处于discovered状态", "这种情况应该是属于算法的else那个分支", "也就是说 对c不做任何处理", "而是将由a通往c的这条边标记为CROSS", "也就是跨边", "再接下来 a的下一个邻居e", "在当时仍处于最初的undiscovered状态", "这是属于算法流程的if那个分支", "所以令e入队并且同时转为discovered的状态", "在图中变成深色", "好 接下来", "又该轮到新的队首顶点c出队", "c出队之后也需要环顾四周", "首先忽略掉它的父亲s", "以及已处于visited状态的a", "实质需要考虑的只有", "仍处于最初undiscovered状态的顶点b", "所以令b入队并且同时转为discovered的状态", "至此既然c的所有邻居都已处理完毕", "它也顺利地转入最终的visited的状态", "接下来 新的队首节点d同样会出队", "而且站在d的角度 环顾它的所有邻居", "忽略掉它的父亲", "唯一的邻居b已经入队 处于discovered的状态", "所以在这里无需做任何实质操作", "而只需将由d通往b的这条边", "标记为跨边CROSS", "同样在此之后 d也将顺利地转入", "最终的visited的状态", "算法的焦点又进而转至新的队首顶点e", "再一次地 站在顶点e的角度", "环顾它的所有邻居", "忽略掉它的父亲a", "另外两个邻居f和g", "都是处于最初undiscovered的状态", "所以这也是属于算法的if分支", "因此令这两个新发现的邻居依次入队", "并且同时标记为discovered的状态", "此后", "e自己也顺利地转入最终的visited状态", "综观全局 你就会发现", "此时已经没有任何顶点", "依然处于最初的undiscovered状态", "所以接下来只不过是一系列的过门", "可能会标记出一些cross edge", "但是不再会有新的tree edge生成", "所以经过若干过门之后", "最终必然会转入这个状态", "也就是说", "所有的顶点经过入队之后都已出队", "而且相应地 都已转化为最终的visited状态", "此时如果忽略掉所有的cross edge", "那么剩下的tree edge就的确构成了一棵树", "如果你对这个还看得不是很清楚", "不妨把cross edge剔除掉", "转入这样一种形式", "整个遍历的最终产物是一棵遍历支撑树", "至此", "对这个性质和结论", "你应该不存任何质疑了吧？"]}, {"name": "01a-5\t: 有穷性", "block_id": "bb0f5eb0871046d4be6b17032a6dc465", "text": ["考察所谓的Hailstone sequence", "对于任何一个自然数n 都可以定义这样一个序列", "实际上这个序列是以递归的形式来定义的", "具体来讲 如果是不超过1的平凡情况", "我们就直接将它对应的这个Hailstone sequence", "取做由单个的一个元素1", "所构成的一个长度为1的一个序列", "一般的情况 如果n至少是2", "那么我们就视它是偶数或者是奇数分别处理", "如果它是偶数 那么我们就对它做一个除2处理", "使它数值变小 折半", "然后计算出它所对应的Hailstone序列", "再它的前边添加一个长度为1的前缀", "只包含一个元素就是原来的那个数n", "通过这个union操作使得这两个序列串接起来", "构成最终的序列", "如果n是奇数 那么就通过对n乘3再加1", "得到更大的一个数", "然后同样递归的得到它所对应的Hailstone序列", "并且也是同样的在它前面增加一个长度为1的前缀", "从而构成我们所需要计算得到的最终的那个序列", "我们来看一下一个具体的实例", "比如说n=42", "我们可以看到42是非退化的情况", "所以按照偶数的规则 它应该折半", "所以我们先把42记在这 相当于它转换为21", "再接下来呢 我们要考虑的是奇数的一个问题", "根据刚才的规则 这个21应该乘3加1", "所以从而转换为64 也就是说又变成了一个偶数", "接下来我们对偶数折半 并且继续折半 点点点点", "那么 敏锐的同学可能已经发现了", "之所以我们这里用点点点", "是因为后面的故事情节是一目了然的", "原因在于64是一个很特殊的数", "它除了2以外 没有其他的素因子", "所以它可以不断的除2除2除2", "直接了当不断的除2 直到最终得到平凡的1", "在这个过程中 我们注意到", "确实这个序列中各项的数值", "有的时候会折半下降", "也有的时候会因为乘3加1上升", "也有的时候会连续的下降", "所以总体来说", "它体现出一种飘忽不定琢磨不透的形式", "有一点我们可以补充说明一下", "就是说 虽然它有可能持续的下降", "但它绝对不会持续的上升", "原因在于任何一个奇数乘以3再加1以后", "它必然会回到偶数的状态", "所以它接下来必然会紧接着除2折半", "而不会连续的乘3加1", "但是即便如此 我们也待会会看到", "更复杂的一些例子里头", "它会变化确实很捉摸不定", "呈一个上下起伏动荡的过程", "整个这个过程与冰雹运动的过程非常相像", "有时候会偶尔上升 但是紧接下来总体会下降", "有时候又会偶尔上升", "接下来又会间或的不断的下降", "直到它最终 如果确实有这样的情况发生的话", "落到地面", "程序设计略有基础的同学", "都不难写出下面这样一段程序来计算这个序列", "当然这里与其说是计算确切的大写的Hailstone序列", "不如说这个小写的程序实际上是计算这个序列的长度", "我们说其实这已经足够说明问题了", "所以我们不必把这个事情搞得更复杂", "简单来看 小写的这个hailstone是如何来计算", "大写的Hailstone序列的长度的呢", "按照刚才的定义 我们这个计数器的初值取做1", "接下来呢 我们要把刚才那样递归定义的过程", "转换为一个循环", "也就说不断的视当前的n的奇偶性来分别做处理", "经过模2做一个测试以后 奇数就按乘3加1处理", "如果是偶数就按折半处理", "而每处理完一次以后", "都会相应的把它的长度递增一个单位", "所以当这个循环执行完后 返回的这个length值", "应该就是不折不扣的对应的序列长度", "所以这个算法或者说我们如果还不能管它叫算法", "我们说这个程序的正确性似乎是不言而喻的", "我们马上就会看到 其实这里头是不那么简单的", "我们来看更复杂的一些例子", "也许能够让我们略微有些感觉", "我们会注意到 Hailstone序列的长度", "与这个输入的n未必是成正比", "比如说42这个大概也就是10来个数", "可是取一个小一点的数7", "我们就会发现它的长度会远远的超过10", "大家可以逐项的验证一下", "我们在这不妨抽几个", "奇数 乘3加1", "偶数 除2 等等等等", "那么27呢 介于7和42之间的这个数呢", "如果大家有兴趣的话 你回去可以去试一下", "用手或一个程序把它算出来", "我可以告诉你的是", "它的长度比刚才那两个要长很多很多", "虽然还不是无穷", "所以这里头我们其实已经引导大家", "到了这个词了 无穷", "我们刚才说的是 有穷", "在这里头 为什么值得去讨论那个有穷呢", "细致的同学肯定应该已经会脑子里闪现这个问题", "上面这个程序如果要称作是一个算法", "它就应该满足我们刚刚说过的有穷性", "也就是说 它对任何的输入", "都应该能够在有限步之后退出返回", "那么while这个循环 能够做到这一点吗", "对任何n都能做到这一点吗", "这不取决于这个程序", "而是取决于这个序列本身的定义", "也就是说 对于任何的n", "它对应的Hailstone sequence的长度", "是否都是一个有限的一个长度呢", "如果是 那它的有穷性", "这个程序的有穷性 自然就满足", "否则的话 我们就要打问号", "它就不见得能称作是一个算法", "那么 据我所知 我可以告诉大家的是", "这个问题的结论是 还没有结论", "也就是说 我们既不能证明对于任何的n", "这个序列都必然是有穷的", "反过来 我们也还没有找到一个反例", "所以从这个意义上讲 我们这段貌似再简单不过", "而且正确性都是一目了然的程序 未必是一个算法", "程序未必是算法", "这是我们要告诉大家的一个现象", "其实这个现象大家并不陌生", "大家可以各自回忆一下", "在你刚刚学习编写程序的时候", "应该会经常犯的一个错误就是写出死循环的程序", "当时你得到的反馈就是", "机器会告诉你说栈溢出 从而非法退出", "老师呢 会给你一个大大的一个叉", "然后告诉你说 下次要小心", "但是尽管你再怎么小心", "我们时不常的偶尔还是会犯这种错误", "坦诚的讲 包括我也是这样", "所以我们说 算法的有穷性", "即使作为算法的一个侧面的要求", "也不是那么简单的能够确定的", "更不要说还有其他的一些东西", "当然好消息是 我们这门课里", "只是在绪论部分略微的介绍这些", "不会详细的展开更不会去深入的探究", "这是其他的课程", "其他的学科分支讨论和研究的问题", "而我们的问题不是这个", "那么我们的问题是什么呢", "我们的问题是 在正确性确定性可行性", "包括有穷性都基本上确定了之后", "如何能够设计并且优化出更好的一个计算过程", "一个对应的数据结构和对应的算法", "所以我们首先的一个问题就是", "什么是好的算法什么是好的数据结构", "或者说什么是一个好的计算过程"]}, {"name": "07D4-2 ”3+4“实现", "block_id": "00d8c1ba5eaa473f8cdd24781f0d93b9", "text": ["在这里 我们就给出3+4重构算法的", "一种实现方式", "作为这个算法的输入", "我们的确需要提供三个节点a b c", "以及4棵子树T0 T1 T2和T3", "以下 我们可以通过", "这样一段非常规整的代码", "完成这3个顶点以及4棵子树之间的连接", "可以看到 这样一种实现的思路", "非常的简明清晰", "而且因为这段代码非常的规整", "所以更加便于编写 调试以及维护和重用", "出现错误的概率也会降到最低", "那接下来我们需要解释的一个问题就是", "在以上各种情况下", "我们如何来完成对3个节点", "以及4棵子树的重命名", "从而以正确的参数形式", "转交给这样一个connect34例程呢？"]}, {"name": "06A-3 路径+环路", "block_id": "34de74b197f6475faeb7d6dc4b190669", "text": ["我们在二叉树一章", "所学过的路径以及环路等概念", "也自然地可以推广至一般性的图", "所谓的路径 也就是由一系列的顶点", "按照依次邻接的关系", "构成的一个序列", "比如在这幅图中", "那么从顶点C开始", "经过一条边抵达顶点A", "再经过一条边抵达顶点D", "再经过最后一条边抵达终点B", "因此我们说", "C A D B这四个顶点", "在图中定义了一条长度为3的路径", "再来看这幅图 我们会发现", "从顶点C可以经过一条边抵达A", "然后再从A经过一条边抵达B", "并进而再经过一条边回到顶点A", "最终再经过一条边抵达最后的顶点D", "那么C A B A D", "是否构成了一条通路呢？", "我们说应该是", "尽管在其中A出现了两次", "那么这种路径和这种路径的区别", "正在于此", "如果在一条通路中不含重复的节点", "我们就称之为simple path 简单路径", "而否则的话呢", "也就是一般性的路径", "或者是non-simple 不简单的路径", "所以概括而言 所谓的简单路径", "就是其中不含重复节点的路径", "特别地 路径的起点和终点", "有时也可能是重合的", "正如我们此前所介绍的那样", "这种路径我们称之为环路", "比如在这样一幅图中", "起自顶点C经过A B", "最终回到顶点C的这样一条路径", "就是一条环路", "同样环路也有简单与不简单之分", "具体来说 就是其中", "是否包含重复的节点", "如果在一个有向图中", "不包含任何的环路", "我们就称之为", "directed acyclic graph", "简称DAG", "在所有的环路中", "有一种环路是非常有名", "而且也非常有意思的", "也就是它覆盖了图中的所有的边", "比如对这幅图而言", "所有的有向边合在一起", "可以构成一个环路", "你不妨在此暂停一下", "从任何一个顶点比如说C出发", "尝试着将这些边组成一条环路", "这样一条经过所有的边一次", "而且恰好一次的环路", "称作欧拉环路", "那么还有一种对称的环路", "它经过每一个顶点一次", "而且恰好一次", "我们称之为哈密尔顿环路"]}, {"name": "10a2-3: BBST        ", "block_id": "47980d39640f4768ac6d770c2366fa14", "text": ["至此，你可能会想到求助于刚刚介绍过的强大的BBST。", "是的，无论是用AVL树、伸展树或者红黑树实现优先级队列，", "三个标准接口的效率都可以达到大O意义下的log(n)，", "而且只需稍作优化，其中的getMax()接口效率还可以进一步提高到O(1)，", "然而尽管如此，仅就优先级队列所要求的功能来说，BBST的功能却过于强大了。", "难道不是这样吗？将优先级队列与BBST的接口功能作一对比就会发现，", "相对于BBST，优先级队列的插入功能是完全一样的，", "然而BBST的search()接口在优先级队列当中却只限于针对最大元素。", "相对而言，充其量只能算半个查找。", "而BBST的remove()呢？在这里同样只限定于优先级最高的元素，", "因此同样地，充其量只能算是半个删除。", "从这一角度而言，优先级队列充其量只不过是三分之二个BBST。", "也就是说，我们实际上是使用了一个非常高级的数据结构来实现一个功能更为简单的结构。", "形象地说，也就是杀鸡用了牛刀。", "那么，有没有成本更低一点的实现方式呢？", "我们注意到，对于优先级队列来说，矛盾的焦点都集中在优先级最高的那个极值元素——", "是的，极值元素。", "这就意味着，我们只需要维护所有元素之间的一个偏序关系，", "就足以确定这个极值元素，", "而不必像BBST那样，始终都不折不扣地维护一个所有元素之间的全序关系。", "根据这一分析，我们就有理由相信，", "的确可能存在某种形式上更为简单，而且维护成本更加低廉的实现方式。", "就接口的效率而言，我们不妨参照BBST，将实现的目标定为均为log(n)，", "那么这样一种实现方式具体如何？", "我们所设定的目标是否真的能够实现呢？"]}, {"name": "11e1-3: \t实例体验", "block_id": "b14e347aef664cc4818a0aa14187f3be", "text": ["为了体会好后缀表的妙用", "我们不妨来看这样一个实例", "这里的文本串由13个汉字组成", "而模式串由8个汉字组成", "通过预处理", "为每个字符所计算出来的gs表项也列在这里", "接下来 算法依然首先将二者在首字符位置处对齐", "并且从末字符开始比对", "我们可以看到 这是一次失败的比对", "相应地 此时的好后缀为空", "所以它并不能给我们提供任何经验", "因此我们只能采用bc策略 借助这次教训", "将模式串整体地向后移动一个字符", "在接下来的这轮比对中", "我们将成功两次", "并失败于第三次", "尽管此时的好后缀只有两个字符", "但它也足以帮助我们快速地移动", "既然当前失配的字符为“固”字", "我们也就可以从gs表中找出它所对应的那个表项 也就是4", "也就是说在这种情况下", "gs策略建议我们可以直接向后移动4个字符", "没错 4个字符", "可以看到 接下来的这轮比对将完全匹配", "算法也因此顺利地结束", "那么接下来 很自然也是必须要解决的一个问题就是", "对于任何的模式串", "我们应当如何计算出它所对应的gs表呢", "而且更重要地", "为此 我们又需要花费多少时间成本呢"]}, {"name": "11f1-3: 串亦是数", "block_id": "c1cb2b628088493b801df68f76f16e66", "text": ["既然万事万物的本源都对应于自然数", "那么串也自然应该对应于数", "接下来我们就来看看", "这句话如何兑现", "首先来考虑一种我们最为熟悉的串", "也就是由10进制数字所构成的串", "比如 由阿拉伯数字所构成的这样一个串", "如果我要说这个串是一个自然数", "我想你不会有任何异议的", "没错 这正是我们最常用的技术方法", "那么 一般的串呢", "你应该还记得我们的约定", "组成字符串的每一个字符", "都来自于事先约定的某个字母表", "而在这里 字母表的规模又是至关重要的", "如果将它记作d", "那么字母表中的所有字符也就可以按照任何一种次序 与0与d-1之间的整数一一对应了", "于是 基于这个字母表所建立起来的任何一个字符串", "都可以视作为一个d进制的自然数", "不妨考察 以26个大写英文字母所构成的字符集", "于是 由大写字母所构成的任何一个英文单词", "也必然对应于某个26进制的自然数", "比如在单词CAT中", "C对应的编号为2", "A对应于0", "而T对应于19", "如果你关心这个数字的具体数值", "不妨借鉴一下我们在第4章所给出的进制转换算法", "不过 这个方法还存在一点小小的瑕疵", "好在修补这个瑕疵并不困难", "这一任务 不妨由你在课后独立地来完成", "既然每一个串都可以对应于一个自然数", "那么接下来很自然地", "一个模式串", "在某个主串中能够出现", "仅当这个子串在数值上与模式串相等", "请注意 经过这样的视角转换", "我们已经在无形中", "将串与串的比对", "转化为了整数与整数的比对", "也就是说 串与串之间的比对将有望在常数的时间内完成", "果真如此", "以上也就自然给出了一个串匹配的算法", "的确如此", "我们已经朝着这个方向迈出了最重要的一步", "尽管我们还需要做更多细致的工作"]}, {"name": "10b1-4: 堆序性", "block_id": "37419a690ae74193850855e9dabdf91b", "text": ["如果说以上的结构性令完全二叉堆有了血肉，那么堆序性就是它的灵魂。", "也就是说，需要在完全二叉堆的所有节点之间定义某种次序。", "实际上，关于这一次序的约定并不复杂，", "简而言之，也就是任何一个节点在数值上都不会超过它的父亲。", "请注意，在我们刚才所使用的这幅图中，", "每个节点上所标注的，只是它所对应的元素在向量中的秩，", "而不是真正的数值。", "而按照堆序性，任何节点在数值上都不得超过它的父亲。", "反过来，如果一个节点拥有左孩子和右孩子，那么在数值上，它也不会小于它的任何一个孩子。", "回到优先级队列的功能接口，其中所涉及的最大元，", "在完全二叉堆中，又可能在哪里呢？", "根据堆序性不难推知，最大元只可能是根节点。难道不是吗？", "否则的话，如果最大元不在根节点处，那么它就必然拥有父亲。", "而根据堆序性，它的父亲要比它更大。", "我们刚才已经讲过，物理上，根节点所对应的向量元素的秩必然是0。", "因此我们马上就会发现，按照这种实现方法，getMax()只需返回内部数组中的首元素。", "好消息是，按照这样一种低成本的实现方式，其它接口同样可以高效率地加以实现。"]}, {"name": "11f1-1: 化串为数", "block_id": "63fe62657f07473c874a8840edcba64a", "text": ["接下来的这节 我们再来讨论一种十分另类的串匹配算法", "也就是所谓的Karp-Rabin算法", "回顾此前所介绍的几种串匹配算法", "我们所面临的难题都是一样的", "也就是说在这里 我们每次比较的对象不再是单个字符", "而是由一系列的字符所构成的串或者子串", "因此 如果局部子串的长度为m", "那么对于所有的n个潜在的对齐位置", "我们在最坏情况下都可能需要执行m次比对", "因此在最坏情况下", "我们往往必须付出如此之高的代价", "那么", "能否从中自然地剔除掉这个因子m呢", "我们马上就会看到一种别致的方法", "也就是将每一个串", "视作为一个数", "更确切地讲", "应该是整数", "不难理解", "果真若能实现这种转换", "那么任何两个串之间的比较", "都相当于整数之间的比较", "从而我们只需花费常数的时间", "也就是说 与字符串的长度无关", "那么 这一美好的设想", "能够实现吗", "答案是 能够", "实际上 不少前贤先哲都已经指出", "包括串在内的万事万物", "其实本质上讲都是数", "或者确切地讲 是整数", "没错 整数", "它们才是自然的本源"]}, {"name": "12b3-1: \t尝试", "block_id": "bdd37e017d7d46ad9c9294506a6a0834", "text": ["在讨论过众数 以及特殊情况下", "中位数的计算方法以后", "我们接下来针对一般性的选取问题", "介绍优化的通用算法", "既然选取问题的查找目标", "就是在整个数据集中", "按大小次序秩为k的那个元素", "所以最直接不过的方法", "莫过于首先对整个数据集做一次排序", "此后我们只需从首元素开始", "依次向后移动", "当累计移动了K步之后", "我们也就自然的抵达了查找的目标", "然而很遗憾这里首先需要做一趟排序", "我们知道在最坏情况下", "我们不得不为此花费nlogn的时间", "对于这样一种性能", "我们是不能满意的", "正如我们马上就要看到的", "实际上存在更为优化的算法", "当我们听到选取这个词时", "获取很自然的会想起堆结构", "没错", "堆结构主要功能也是在做", "某种意义上的选取", "也就是选取其中的极值元素", "从这个意义上讲", "选取极值就是选取问题的一个特例", "而反过来选取问题", "也是getmax之类操作的", "一般化推广", "那么是否有可能借助堆结构", "来实现高效的选取操作呢", "沿着这个思路你或许会想出", "如这个图所示的一种方法", "具体来说我们需要首先将", "所有的N个元素", "组织为一个堆", "当然这里我们需要的", "是一个小顶堆", "也就是说堆顶元素是全局的极小值", "因此每当我们调用一次delmin接口", "就可以摘出当前的极小值", "就全局而言", "第一次调用将会摘出全局的最小元", "也就是秩为0者", "而接下来的第二次调用", "将会得到全局秩为1者", "因此在我们连续的", "对这个接口调用K次之后", "整个堆的规模", "将变为N减K", "而此时的堆顶也就应该恰好是", "全局秩为K的那个元素", "就第一步预处理", "也就是建堆操作而言", "我们的性能还不差", "我们可以直接调用弗洛伊德算法", "也就是说为此我们只需花费", "线性的时间", "然后此后对delmin接口的调用", "累计时间却很长", "具体来说", "我们每次都需要花费logn的时间", "而总共需要调用k次", "也就是说只要K在数量集上与N同阶", "这个方法的渐进性能", "将与全排序的方法", "没有什么实质区别", "当然我们也可以尝试", "利用堆的其他方法", "比如一种可行的方案是", "我们首先从数据集中", "任选出K个元素", "并将它们组织为一个大顶堆", "接下来对于剩余的N减k个元素", "我们分别调用一次insert的操作", "将它插入堆中", "然后随机调用一次delMax接口", "摘除掉新的堆顶", "对于这样的每一步迭代", "如果此前堆的规模为K", "那么在执行insert的操作之后", "它的规模将变为k加1", "而在随后立即执行过delmax操作之后", "堆的规模又会从K加1", "重新恢复为K", "请注意当每一次这个堆的规模", "从K增加到K加1时", "对应的堆顶元素", "都是迄今为止发现的秩为K的那个元素", "因此当所有元素都经过如此处理之后", "当这个堆的规模最后一次达到K加1时", "堆顶元素也就是全局秩为K的那个元素", "由此可见按照这种方法", "我们的确可以完成选取的任务", "然而同样很遗憾", "它的时间复杂度", "依然不能得到有效的控制", "具体的为了构件初始的堆", "我们这里同样只需线性的时间", "然而在随后的N减K次迭代中", "无论插入或者删除", "我们都需要多达logk的时间", "当然如果k非常小", "或者反过来非常大", "这个算法的性能将接近于线性", "然而当K的取值接近中间范围时", "这个算法的复杂度", "又将重新回到nlogn", "当然利用堆结构", "来实现选取功能的方法", "还有很多", "我们这里再来看其中的一种", "具体来说这里我们将使用两个", "而不是一个堆", "首先我们要从数据集中", "任取K个元素", "构件一个大顶堆h", "相应的我们要将剩余的n减k个元素", "组织为一个小顶堆g", "接下来我们需要反复的比较", "这两个堆的堆顶", "只要H大于g", "我们就令二者互换位置", "然后分别通过一次（下律）", "将这两个堆重新复原", "这个迭代将持续进行下去", "直到最终h不再大于g", "而一旦达到这种状态", "对于g的顶元素", "也就是我们要查找的目标", "因为对于此时的这个元素来说", "总共有k个元素不大于它", "同时有n减K再减1个元素", "不小于它", "尽管这种方法的构思非常精巧", "但是同样的", "它在最坏情况下的复杂度", "依然不能得到有效的控制", "请你在课后", "对照我们这里所给的标注", "独立的验证这一结论"]}, {"name": "06A-1 邻接+关联", "block_id": "d1f5959882114587add7905363bf4f94", "text": ["同学们好", "在新的这一章 我们重点介绍图结构", "相对于此前的线性以及半线性结构", "图结构对其中元素的限定更少", "因此反过来", "它描述应用问题的能力也就更强", "在这一章中", "我们将分三个层次逐步展开", "也就是术语", "实现以及算法", "这一节我们首先来介绍", "相关的一些概念和定义", "就数学意义而言的图", "包含两个要素", "首先是顶点集V", "也就是任意一组元素", "这里只考虑有限集", "所以我们不妨将", "这个集合的规模记作n", "在这n个顶点之间", "可能存在某种两两关系", "如果的确存在这样的关系", "我们就在对应的顶点之间", "以连边来表示", "存在对应关系就连边", "存在对应关系就连边", "存在对应关系就连边", "所有这些连边", "构成了图的第二个要素", "我们也形象地称之为边集", "同样地 我们通常也用e来表示边的总数", "彼此之间存在这种关系", "并且因此也存在连边的任何两个点", "都称作是彼此邻接的", "那么这样一个关系", "也称作邻接关系", "而参与定义这种邻接关系的", "每一个顶点", "与这个邻接关系之间的关系", "我们也称作关联关系", "请留意二者之间的区别", "形象地说 所谓的邻接关系", "就是顶点与顶点之间的关系", "而关联关系呢", "实际上是描述顶点以及与它相关的", "某条边之间的关系", "可以看到 图的这种邻接关系的定义", "是可以任意的", "我们此前所学的几种数据结构", "因此也都可以视作是它的特例", "比如在此前的向量和列表等线性序列中", "只有互为前驱与后继的元素之间", "才能够定义邻接关系", "因此整体而言", "序列结构应该是图的一种特例", "而树结构呢", "也只能在父节点与子节点之间", "才能够定义邻接关系", "因此就整体而言", "树结构也可以视作图的一种特例", "也就是说 图更为一般化", "其中的任何两个节点之间", "都允许存在这样的一个邻接关系", "当然这里有一个特例", "我们需要排除", "也就是是否允许同一个节点", "与自身构成一个邻接关系", "在图论中 的确有时需要讨论这类图", "而在我们这个课程中 为了简化起见", "不妨将此类称作自环的边忽略掉", "而不予讨论"]}, {"name": "08B5-5\t道法自然", "block_id": "7704e760c0e94bad8fe2b798f4a5938f", "text": ["在告别本节之前 不妨重新打开这幅我们业已非常熟悉的图", "你应该还记得 我们在本节开篇所提过的那样一个问题", "B树为什么会被设计成为这样一种相对比较矮", "却又比较宽的形状呢？", "现在你应该可以做一总结 并且有所领悟", "我们知道 所谓对B树的访问", "无非是由一系列的外存操作和内存操作交替的组成", "有多少次外存操作 就有多少次内存操作", "因此 为了保证整个访问的高效率", "一个基本的原则就是应该使外存操作的代价与内存操作的代价大致相当", "实际上 B树能够做到这一点", "而此前AVL之类的BBST却不能做到这一点", "你应该还记得 中学物理所学过的折射现象", "在两种介质的分界面处 光线的传播方向可能发生偏折", "你也应该记得物理学就此所给出的一个形象的解释", "也就是所谓的最小光程度原理", "因为在这样两种介质并存的情况下", "唯有如此 才能够使得光线所传送的实际距离变得最短", "或者反过来讲 传播的最快", "从这一点讲 大自然是最聪明的设计者", "而B树的设计原理 也在于此", "其设计过程 某种意义上讲 是在模仿自然的这种最优性", "也就是我们所说的 道法自然", "其实在这个图中 B树大致有两个方向", "首先是水平方向 它对应的是在每个节点的内部所做的搜索", "这种搜索因为是在内存中进行的", "所以速度相对而言 非常之快", "同时 我们还有垂直这个方向", "也就是说 沿着垂直方向 它所对应的是磁盘操作", "也就是说 在树中每下降一层 我们都要付出一次IO操作的代价", "我们知道这种时间代价 相对于内存操作来说", "至少要高出5个数量级", "这样一种情况 完全可以类比于光线穿越两种物质之间的分界面", "既然光线在这种情况下会聪明地通过改变方向 达到速度上的最优", "那么B树通过适当的调整自己的形态来适应这种现实", "也就再自然不过的了"]}, {"name": "11c6-5\t: 可视对比", "block_id": "3131f5b058834cc7a003bcf0f748dab5", "text": ["在告别KMP算法之前", "我们不妨以一种可视的形式", "将其与蛮力算法作一对比", "我们此前曾经指出", "对于串匹配算法的评判与对比", "需要分成功和失败两种情况分别进行", "因此这里 我们不妨只针对失败的情况", "对二者的最好与最坏性能作一对比", "在这个图中 我们用这条线来表示文本串", "它相对而言更长", "而模式串的长度m则相对更小", "在蛮力算法中 如果我们将文本串固定于此", "然后将模式串在各次迭代中的快照记录下来", "并按照与文本串相应的对齐位置 如此排列", "就会得到这样一个相对比较窄", "同时非常高的平行四边形", "当然 既然是失败情况 所以 每一轮的比对过程都类似", "具体来说 都是在经过了一系列的成功比对之后", "最终失败于某个位置", "而一旦失败之后 算法都会将模式串右移一个字符 并重新开始一轮比对", "而且同样地 接下来也会经过一系列的成功比对 并最终失败于某个位置", "这样的故事会反复地发生", "直到最终模式串试图越过文本串的右侧边界", "从这个图中 我们可以清晰地看到", "在每一个对齐位置所消耗的计算成本", "都可相应地由深色区间的宽度来度量", "整个算法累计所消耗的时间", "应该也就是这些深色区间的宽度总和", "那么这一总和的变化范围是多大呢", "首先我们注意到有最坏情况", "也就是在某一个对齐位置", "可能会持续地经过m-1次成功的比对", "而最终失败于第m次比对", "而整体的最坏情况", "莫过于每次都出现这样的最坏情况", "关于这一点 我们在此前曾经举过一个具体的实例", "既然在数量级上 m要小于n", "所以这个平行四边形的高度 也就可以直接度量为n", "因此 平行四边形的面积 也自然就是n*m", "这也是蛮力算法在最坏情况下的性能", "再来看看KMP算法", "我们同样地可以将所有潜在的和实在的对齐位置", "按照刚才的方式排列起来", "从而同样得到这样一个平行四边形", "然而幸运的是", "因为KMP算法的智能性", "它所消耗的时间", "要远远地小于这个平行四边形的面积", "来看右侧这个局部放大图", "在这里我们可以清晰地看到KMP的两种优化效果", "你应该记得 KMP首先能够令模式串得以快速地滑动", "也就是说 它有可能会直接越过一些潜在的对齐位置", "在每一次快速的滑动之后", "它也不必继续从头开始比较", "而事实上 它只需从刚才失败的那个位置出发", "继续开始下一轮的比对", "如果有必要 在经过下一次的快速移动之后", "它依然会从新的失败位置开始", "启动下一轮的比对", "以致再下一轮", "以及再再下一轮比对", "同样地 在这样的一个计算过程中", "我们所花费的时间也可以用这些深色的区间来表示", "它们的宽度之和", "也就给出了KMP算法总体的计算时间", "为了统计出所有这些深色区间的宽度之和", "我们不妨回到左侧这幅总览图", "不难看出 如果将所有这些深色的区间 都沿着垂直方向投影到文本串上", "我们就会发现 任何两段深色的区间", "除了在端点处之外 绝不会有任何的重叠", "因此 既然文本串的长度为n", "我们也可以由这个图直接推知", "整个KMP算法所消耗的时间总量", "也不会超过2n", "这与我们此前的分析完全一致", "在学习过KMP算法之后", "如果我们回过头来再看看蛮力算法", "你或许会对它不屑一顾", "是的 就最坏情况下的效率而言", "这个算法的确不值一提", "然而在此 我们也不妨为蛮力算法作些辩护", "如果还不是平反的话", "事实上 即使是在失败情况下", "蛮力算法也有最好的情形", "你能想到吗", "是的 在总体失败的情况下", "蛮力算法依然需要在每一个对齐位置作一轮比对", "然而在最好的情况下", "每一步迭代 可能只牵涉到常数 甚至只有一次比对", "是的 只经过一次比对", "就可排除掉一个对齐的位置", "你应该不难构造出这样的实例", "因此在这种情况下", "为了排除掉所有的O(n)个对齐位置", "蛮力算法所消耗的时间 累计也不过是线性的", "当然 你有可能会质疑这种最好情形所发生的概率", "事实情况是 在通常的情况下 这个概率并不像你想象的那么低", "而且 随着字符集规模的增大", "这个概率也会急速地提高", "也就是说 在这类情况下", "KMP算法相对于蛮力算法的优势 也就不那么明显了", "或者反过来等效地", "只有在字符集规模相对很小时", "KMP在性能上的优势", "才能充分得以展示", "你或许已经注意到了", "在介绍KMP算法的诸多教材中", "绝大多数的实例都是基于二进制串", "如果你能够领会到我们刚才所说的那个现象", "你就应该能够更好地理解那些作者的良苦用心了"]}, {"name": "11c5-2: \t精准估计", "block_id": "973fbe28c5da4b1187146f6c524dfd86", "text": ["为了对KMP算法的性能作出更为精细的分析", "我们可以参照在第一章就确立的方法", "将这个算法中 不涉及到实质计算内容的非迭代部分都删除掉", "而将注意力集中于复杂度的主体 也就是其中的这个循环", "在这里 我们需要引入一个观察量k", "在算法执行过程中的任何时刻", "这个k都等于2*i-j", "实际上 在很多开发环境中", "都提供了观察功能", "允许你设置这样一个表达式", "并且在算法的调试运行过程中", "动态地给出表达式所对应的数值", "实际上 随着算法中这个迭代过程的不断推进", "这个观察变量k 必然是单调递增的", "这一性质并不难看出", "实际上无非if和else两种可能", "首先 如果当前这步迭代", "选取的是if分支", "那么 根据算法的流程", "i和j会同步地递增一个单位", "于是作为2*i-j k应该恰好增加一个单位", "反之 如果当前这步迭代进入的是else分支", "那么 尽管i不会受到任何影响", "但是j会被替换为它对应的next表项", "你应该记得我们此前已经指出", "j所对应的那个next表项", "必然会严格地小于j", "也就是说 经过这样一次替代之后", "在数值上 j必然会严格地减少", "所以k也至少会增加一个单位", "综合这两种情况我们就会发现", "k随着迭代的进行", "的确会严格单调地不断递增", "因此 整个计算过程中所进行的迭代步数", "就绝对不会超过k", "也就是说", "只要我们能够界定k的上界", "也就自然确定了整个算法复杂度的上界", "那么 k的变化幅度究竟是多大呢", "首先 既然i和j的初值都是0", "所以k的初值也应该是0", "而在算法结束时", "i至多与n同阶", "而j呢 也至少是一个常数", "这也就意味着在渐进的意义上", "k绝对不会超过线性的范围", "至此 我们也就确凿地给出了KMP算法性能的一个准确估计", "是的 这里给出的估计方法非常初等", "因此其结论也毋庸置疑", "当然 作为进一步的探求 你或许会好奇于这里的k", "也就是2*i-j的具体含义", "如果你的确对这一问题感兴趣", "不妨参考我们所提供的习题解析", "当然 作为KMP算法的有机组成部分", "我们也不要忘了next表的构造过程", "然而正如我们已经看到的", "这个预处理算法的原理及过程与主算法完全相同", "因此 其复杂度也应该线性正比于它自己的输入规模 也就是模式串的长度m"]}, {"name": "11c4-3: \t实现", "block_id": "9064d606b44c4f58bcd724832b1388a6", "text": ["next表的构造算法可以具体实现如下", "正如我们刚才所分析的", "其总体框架应该与KMP的主算法几乎一样", "主要的差别有这么几点", "首先 入口参数只有模式串自己", "这一点不难理解", "因为我们刚才讲过 整个next表的构造过程就是它自己与自己的匹配", "因此在这个场合 P既是模式串 也是文本串", "另一点区别在于初始化", "我们刚才已经分析过", "next表的首项 也就是第0项", "数值必然固定为-1", "因此我们不妨首先就完成这一设置", "接下来是我们业已非常熟悉的KMP循环", "其中的if和else分支", "分别对应于当前匹配与失配的两种情况", "按照我们刚才的分析 一旦发现一对新的匹配字符", "我们就可以立即得出next表的下一项", "而且它的数值就应该是在此前一项的基础上再累进一个单位", "反过来 如果是失配", "根据我们刚才的分析", "也只需将当前的尝试位置t 更新为它所对应的next表项", "当然 根据我们刚才业已指出的单调性", "这个表项 当前必然已经计算出来", "所以你尽可放心", "这幅图也给出了该算法的一次典型运行过程", "假设我们正需要递推地计算出下一项", "此时 我们的P[j]是这个X", "首先尝试的是next[j]", "如果对应的字符与P[j]不等", "也就对应于循环中的else分支", "于是我们会将next[j]进而替换为next[next[j]]", "并且继续用对应的这个字符与P[j]进行比对", "如果依然不等", "我们就需要将next[next[j]]进一步地替换为next[next[next[j]]]", "在任何一步迭代中", "一旦当前的字符与P[j]相等", "我们就可以立即将下一个next表项设置为 在这个前缀的长度基础上 再累进一个单位", "当然 这个迭代的过程有可能会进行很多步", "但是正如刚才我们所分析的那样", "充其量不过迭代到这样一种状态", "也就是当假想的那个哨兵", "与P[j]对齐时", "必然会随即终止", "在课后 你也不妨对照我们所给的代码", "分别就控制逻辑与整体的功能语义", "作一验证", "至此 我们已经了解了KMP算法的基本原理以及相应的计算过程", "那么 接下来的一个问题自然又是", "这个算法的总体时间复杂度是多少呢", "是否如我们所期盼的那样 可以控制在线性的范围以内呢"]}, {"name": "02C-8\t 遍历", "block_id": "0315fb304e134cf49146d1c51cf1d6e3", "text": ["最后来考察向量的遍历操作", "所谓遍历就是", "按照某种事先约定的操作", "我们称之为visit", "对向量中的每一个元素", "逐一地、统一地执行一次", "所以这里涉及到两个问题", "第一，我们如何来指定", "或者来描述这样一个visit操作", "第二，如何将它传递到", "向量内部的每一个具体的元素", "这里我们说有两种方法", "第一种，我们用的是", "函数指针", "这样的一个机制", "也就是说，可以对于", "vector这样一个类", "定义一个traverse接口", "作为它的参数，本身", "就是一个函数的指针", "它的名字叫visit", "所以呢，为了兑现", "这样的一个遍历操作", "我们只需要逐一地取出", "向量中由这个 i 确定的每一个元素", "通过这个函数指针", "找到这个函数", "并且对这个元素实施这个函数", "所指定的操作", "第二种方式呢", "是所谓的函数对象的这种机制", "也就是说，我们指定的这个参数", "visit的呢，本身就是一个对象", "只不过呢，它的作用", "就是用来模拟一个操作", "一个函数的一个行为方式", "所以同样地，我们也可以", "对这个向量中的每一个元素", "都逐一地取出", "并且转交给这样一个函数对象", "通过它，来实施具体地、统一地操作", "那么这两种方法", "其实是非常接近", "但是也有一些重要的区别", "我们相对而言", "后一种方式的通用性更强", "下面我们通过一个实例", "来具体讲解如何通过函数对象", "实现刚才所说的具体地遍历", "比如说，我们可以考虑", "将向量中的所有的元素", "统一地各自加一", "为此我们只需要", "实现这么样一个，对应功能的函数对象", "它本身也是以一个类的形式给出来的", "我们可以看到", "当然这里为了简化起见", "我们使用了struct", "而没有进行过多的封装", "这个对象最重要的一个作用", "或者说唯一的作用就是重载了", "它的圆括号操作符", "从而使得它在行为上", "与一个函数非常的类似", "而具体的功能就是", "把每一个参数e", "做一个加一操作", "在实现了这样一个对应的类之后", "我们就可以通过", "这样的一个调用", "也就调用vector", "统一的traverse", "那个遍历的接口", "将我们刚刚编写的", "这个函数对象", "以参数的形式传入", "就可以实现", "相应的这个功能", "也就是把向量中的", "每一个元素统一地加一", "那么作为练习", "大家可以举一反三", "实现更为复杂的一些遍历功能"]}, {"name": "08XA3-6\t归纳回味", "block_id": "34b605db172a4c4dbe669881e5f643b9", "text": ["我们来对双红修正算法的复杂度做一分析", "首先这里无非牵涉到两种基本的操作", "也就是3+4重构 以及对节点颜色的重新定义", "二者都是局部的基本操作 各自只需常数时间", "因此我们只需统计 在整个的修正过程中", "二者各自总共执行了多少次", "这是整个修正算法的流程图", "可以看到通过判断叔父节点的颜色", "无非两个分支 其中叔父节点为黑的这个分支相对简单", "我们只需做一次局部的3+4调整", "再做常数次的染色操作 即可完成调整", "也就是说 在这种情况下 旋转至多一轮2次", "而染色呢 至多牵涉到两个节点 都是常数", "当然叔父节点为红色的情况 略微复杂", "因为尽管在每一个节点处 我们只需做常数次的重染色", "但是事情未必彻底解决", "因为由此可能导致在更高的节点处进而出现双红缺陷", "此时我们还需要重新回到算法的入口", "并等效的去试图修复新节点的双红缺陷", "在最坏的情况下 这种情形有可能会出现多达logn次", "尽管如此 请注意在这样一个可能的循环过程中", "我们只需做重染色 而不必做任何的结构调整", "也就是说 在这种情况下", "尽管在每一个高度上 我们都有可能会执行若干次重染色", "但是绝对不会执行任何的旋转", "反过来 通过这个流程图 我们也不难发现", "无论整个修正算法如何运转", "其间一旦做过结构的调整 整个算法就会随即结束", "因此总体而言 整个修复过程中", "我们的确可能会执行很多次染色操作", "但是就我们更为关注的重构操作而言", "在整个修复过程中 至多只会执行常数次", "你应该还记得 我们为什么会更加在意重构操作", "是的 这类操作 对于持久化结构而言是至关重要的", "当然对于插入操作的这些性能要求", "AVL树同样是满足的", "然而正如我们在此前所指出的", "AVL的删除操作却不具有这样的性能", "那么 红黑树呢", "让我们拭目以待"]}, {"name": "08XA3-4\tRR-1", "block_id": "72e649f736c642559821c5a92e431948", "text": ["先来考虑第一种情况 叔父节点u是黑的", "依然考察x p和g这祖孙三代节点", "它们可能的位置关系 同样包括zig zag之类的4种组合", "在这里我们只考虑zig-zig和zag-zig两种情况", "另外两种完全对称", "无论哪种情况 此时的x p g下属都应该有4个直接的孩子", "尽管它们都有可能是外部节点", "但是根据红黑树红节点只能有黑孩子的规则", "包括u在内 它们都必然是黑的", "而且既然在此前 这是一棵合法的红黑树", "这4个黑节点的黑高度也应该是一样的", "为了更好的来理解此时的双红缺陷", "无论是它还是它 我们不妨借助此前的提升变换", "也就是将此前指向红色节点的所有虚边都收缩起来", "于是局部的这祖孙三代节点", "就会合并为一个4阶B树中的超级节点", "这种情况下的祖孙三代也是如此", "乍看起来 这样的超级节点并没有违规", "因为它们下属的分支都不超过4阶B树的上限", "是的 其实此时的缺陷并不严重", "确切的说 唯一的缺陷只是在每个超级节点中", "居中的这个关键码不是黑色", "因此从B树的角度看 这种调整非常简明", "我们并不需要调整B树的拓扑结构", "而只需在违规的超级节点中对关键码重新的染色", "比如对于这种情况而言 只需简明的交换p和g的颜色即可", "而这种情况的 只需简明的交换x和g的颜色即可", "将另外两种尚未列出的情况一并考虑", "实际上只需沿用此前针对AVL树所设计的3+4重构算法", "即可统一的处理这种类型的所有情况", "具体的只需找到x p g这3个节点及其下属的4棵子树", "按照中序遍历的次序重新命名", "并对这一局部 按这一种模式重新的拓扑连接", "当然这里还需要做进一步的重染色", "而各种重染色操作呢", "也可以统一为将居中的节点b染黑", "将其左右两个孩子染红 整个调整过程以及效果", "从B树的角度来看 是非常清晰明了的", "双红缺陷之所以是非法的 从B树的角度看", "可以认为是因为在某个原本是3叉的节点中", "插入了一个红色的关键码", "从而使得原先的黑关键码不再居中", "对照所有的4种情况 不难验证这一点", "而调整之后的效果呢", "相当于B树的拓扑结构不变 而在对应的4叉节点中", "三个关键码的颜色已经改为合法的红黑红模式", "请注意在这种情况下 尽管红黑树的拓扑结构有所调整", "但仅限于局部", "而更重要的是 这种调整是一蹴而就的", "无需任何进一步的调整", "因此就全树的拓扑连接关系变化量而言", "必然是不超过常数"]}, {"name": "11f2-4: 指纹更新", "block_id": "c98bbfb1c76b4a41b4e79d383be9e96e", "text": ["就目前的模式而言", "为了计算出文本串中每一个子串所对应的指纹", "我们所需要花费的时间", "似乎都需线性正比于子串的长度", "当然 也就是模式串的长度", "如果考虑到有多达O(n)个这样的潜在子串", "那么你或许会沮丧地发现", "最终的整体时间复杂度", "又再一次回到了O(n*m)", "难道 我们此前的心血都是白费的吗", "这也是我们在最后这一小步中所要解决的一个关键问题", "我们思考的方向和目标是", "将每一指纹的计算成本", "从O(m)降低到常数", "如果你还没有想出有效的方法", "不妨首先温习一下此前的进制转换算法", "或许你能从中得到一些启示", "没错 在那个算法中 我们很好地利用了相邻数位之间的相关性", "其实在这里 也存在着类似的相关性", "在文本串中 任何两个相邻子串之间 都存在着紧密的相关性", "具体来说 二者的指纹之间 存在着相关性", "而这两个指纹的计算过程及结果之间 也存在着紧密的相关性", "从这幅图中可以看出", "相邻的子串几乎一样", "二者唯一的区别只在于前者的首字符", "以及后者的末字符", "只要能够悟到这一点", "相信也就不难设计出一种新的方法", "使得我们可以在常数的时间内", "由前一个指纹 得到后一个指纹", "在我们的教材中给出了具体的方法", "这里 我们将阅读和理解这一算法的任务", "交给你在课后完成"]}, {"name": "12b3-5\t: linearSelect：性能分析B", "block_id": "ea02249a123949fa9bdac58c693fd94d", "text": ["那么新问题的规模", "为何必然会得到有效的削减呢", "回顾一下你应该记得", "新问题都是在原问题的基础上", "削减掉子序列e加g或e加l而得的", "而l和g都是以全局的中位数", "也就是那个大写的M来确定的", "实际上这个大M虽然未必就是", "整个集合的中位数", "但就某种意义而言", "它的确不会过小或者反过来过大", "具体来说在整个集合中", "必然有不少于25%的元素", "不小于这个大M", "而且另外还有25%的元素", "在数值上不大于这个大M", "这一性质通过这幅图", "可以很清楚的看出来", "在这里我们将所有的n除以q个子序列", "垂直摆放并平行的罗列于此", "以他们各自的中位数为界", "每个子序列都可以相应的分为", "更大的一半 以及更小的一半", "每个子序列都是如此", "如果将所有子序列中的", "中位数由大到小排列于此", "那么它们当中的那个中位数", "也就是大M大致应该在这个位置", "现在可以看到以这个大M为界", "整个序列的确可以分为三个部分", "首先是这些白色的部分", "不难看出它们在数值上", "都不会小于大M", "而且从数量上讲这些白色部分", "至少占据整体的四分之一", "对称的你也可以注意到", "这些深色的部分 它们的总和", "也至少占整个集合的四分之一", "而且其中的元素在数值上", "也绝对不会超过大M", "进一步的不难看出", "所有这些白色部分", "都应该属于此时的子集g或e", "反之对称的所有的深色部分", "也都应该属于此时的子集l或e", "这样我们就证明了", "我们此前的那个断言", "也就是无论我们每次剪除的", "是l加1或g加1", "新问题的规模都不会超过", "此前问题规模的75%"]}, {"name": "09D1-1 一山二虎", "block_id": "778bed0107f043de82c8fb987fdc5b54", "text": ["此前我们已经多次指出", "对于需要动态维护的散列表 冲突是不可避免的", "无论你的散列函数设计的有多么精妙", "因此我们不得不回答的第二个重要问题就是", "一旦发生冲突 我们应该如何加以排解", "当然 任何一种可行的排解方法", "都应该是在事先就约定好的预案", "所谓冲突 形象的说 也就是一山不容二虎", "那么 倘若的确有两只老虎呢", "用铁丝网将这座山分成两部分", "两只老虎 各居一侧", "这种思路 也就是所谓的多槽位法", "如果此前的桶单元 对应于山", "那么每一个slot 就对应于在这个山中", "用铁丝网分割出的一个子区域", "在这幅图中 如果这是散列表", "那么这就是一个一个又一个的桶单元", "在这里 我们将每个桶单元都继续细分为ABCD 4个槽位", "每个桶内部的这些槽位", "就可以用来存放彼此冲突的若干个词条", "比如 这就是一个长度为23的散列表", "其中每一个桶都被分成了3个槽位", "现在我们依次将24个词条插入其中", "可以看到这里尽管有些词条的确会彼此冲突", "但依然可以在对应的桶中和平共处", "当然 查找过程需要多出一步", "除了需要根据关键码确定对应的桶单元地址", "还需要在桶中遍历所有的槽位", "直到找到目标或者失败", "当然 只要每个桶中槽位的总数能够控制在常数以内", "整体的查找效率就不会有实质的降低", "不过这种方法的缺点 也是显而易见的", "你能看得出来吗", "是的 每一个桶具体应该细分为多少个槽位", "在事先几乎是无法预测的", "如果分的过细 就会造成空间上的浪费", "而反过来 无论你分的多细 在极端的情况下", "仍有可能在某个特定的桶中 发生大规模的冲突", "那么面临这一两难的抉择 如何破解呢"]}, {"name": "05E2-3 思路", "block_id": "f6db8296634f47be983ddabe57c12983", "text": ["与先序遍历同理", "我们可以将任何一棵二叉树抽象地", "规范为如图所示的形式", "也就是说 整棵树必然可以分解为", "一条起自根节点的左侧链", "以及左侧链上各节点所对应的", "右孩子 右子树", "左侧链 右孩子 右子树", "左侧链 右孩子 右子树", "以及左侧链 右孩子 右子树", "无非如此", "当然也同样地", "其中某些右孩子", "可能并不存在", "或者等效地认为某些右子树", "可能是空的 但这并不要紧", "如此我们可以发现在任何一个局部", "当控制权转移到当前的树根节点", "这个节点并不是立即接受访问", "而是形象地说 它会将这个控制权", "谦让给它的左孩子", "而直到它的左孩子接受访问之后", "才会继续深入到它的右子树中", "而接下来 只有在这棵右子树", "也被遍历完毕之后", "控制权才会重新地回到此前的根节点处", "而只有在这个时候", "这个根节点才会欣然接受访问", "这样一个局部的次序模式", "如果转化为整个这样的一棵树的话", "那么必然就会导致这样的一个总体次序", "而整棵树的遍历过程呢", "可以由此分为若干个阶段", "我们来看一下 正像我们刚才所说的", "首先接受访问的应该是左侧链的末端", "也就是沿着左侧链向下行进的终点", "在刚才那个例子中 命名为a", "它被访问之后 继而它的右子树将被遍历", "此后控制权才重新地回到", "此前谦让于Ld的上层节点Ld-1", "请注意 在d-1重新接过控制权的这个时刻", "Ld以及它的右子树Td都已经被访问完毕", "什么叫访问完毕呢？", "我们既可以认为它们被访问完毕", "同时也可等效地认为", "它们根本就未曾存在过", "而如果它们确实没有存在的话", "相对于由剩余的部分所构成的这棵树", "首先第一个被访问的节点", "也确实就应该是Ld-1", "于是接下来 无论是根据算法的基本策略", "还是我们站在新的角度所形成的理解", "都应该是继而访问新的这个末端节点", "并且进而遍历它的右子树", "在所有这两步完成之后", "才将控制权重新地交还给此前", "谦让过的祖先节点", "请注意 这依然等效于我们在这个地方", "进行了一次截除", "如果控制权果真回到这个位置", "我们完全可以等效地理解为", "它左侧的那些后代根本就未曾存在过", "继续按照这种理解 我们可以认为", "要访问这一部分", "以及进而访问这部分", "直到最终访问全树"]}, {"name": "04C4−6C\t 实例C", "block_id": "e46560ffffd84ed98224643a103c293a", "text": ["这是一个操作数", "所以我们直接将它归入操作数栈中", "也就是说 接下来的状态应该是这样", "5入栈 我们随即将注意力转向下一个字符", "这是一个阶乘运算符", "算法的处理手法依然", "这里我们采用刚刚记下来的诀窍", "当左括号在栈顶的时候", "它总是乐于接收包括阶乘在内的", "任何一个常规运算符", "所以接下来，我们会看到", "阶乘号不出意外地入栈", "同时注意力转向下一个字符", "我们看到这是一个减法运算符", "同样地，将减法与阶乘进行优先级比较", "会发现出现了一次大于号的情况", "也就是说，我们刚才所缓冲起来的", "阶乘运算现在等到了能够执行的时机", "讲到这里，细心的你或许会发现", "在我们目前所定义的运算符体系中", "阶乘号是优先级最高的", "所以即便是它被推入了栈中", "在接下来的一步中，必将会出栈并且执行", "既然如此，我们为什么不判断出来", "阶乘号而直接运算呢", "原因在于虽然可以利用这种性质", "加速阶乘处理", "但是无形中必然会引入一句额外的判断", "而且这句判断是对所有的运算符", "都要执行一次的", "而我们刚才所做的优化的效果", "只能体现在阶乘这一种运算上", "得与失两相比较，得不偿失", "所以不妨采用算法", "所建议的这种简明的方法", "统一进行处理", "好了", "回到我们的阶乘运算符", "既然它可以运算", "我们就应该", "弹出栈顶元素5来进行运算", "并且将所得的结果，我们心算一下", "120重新纳回操作数栈中", "作为新的栈顶", "同时，我们的关注力依然停留在", "仍未处理完毕的减法运算上", "既然接下来，栈顶运算符是左括号", "按照我们刚才所总结的规律", "它总是乐于接收", "包括减号在内的任何运算符", "所以接下来，减法运算符会顺利地进栈", "转为这样的一个状态", "而此后呢，我们的关注力", "转向接下来的字符，也就是左括号", "我们刚刚总结过", "左括号出现在当前的位置", "它也会被任何栈顶操作符乐于接纳", "所以它也会随即进栈", "转入这样一个状态", "我们的关注力，会转向下一个字符6", "作为一个操作数", "它也会顺利地推入操作数栈中", "成为这样", "好", "接下来又碰到了", "我们总结到的一个情况", "左括号处于栈顶的时候", "它也会乐于接受", "包括当前的减号在内的", "任何一个运算符", "所以接下来减法运算符", "也会顺利地进栈", "我们又转向了下一个左括号", "同样它会入栈", "并且转向下一个操作数7", "这个操作数会随即进栈", "并转向下一个操作符减法", "同样", "这个时候栈顶既然是左括号", "减法运算符也会顺利地入栈", "这个时候我们又再次地遇到了左括号", "左括号人缘非常好", "它也会被任何一个字符接纳", "成为它顶端的朋友", "我们的关注力，这个时候转向了8", "当然8会随即进栈", "但是接下来，我们的注意力又转向了9", "此时就涉及到我们在算法中", "所提供的一个叫ReadNumber的例程", "它的具体实现", "虽然我们只是放在示例代码包中", "但是我们从语义上能够知道", "它是用来读取像89这样的多位数的", "其实它的原理也非常简单", "对于这样连续的一系列的数字", "它会每一次都将上一次的结果弹出栈", "乘以10，加上当前的这个字符", "然后再重新地推入栈中", "就这个例子而言", "我们接下来应该把8弹出乘以10", "再加上9，得到89", "操作数栈的栈顶被替代为89", "同时，我们的关注焦点转向下一个字符减法", "再一次地，这个减法运算符", "会被当前处于栈顶的", "那个好客的左括号", "接纳，成为它顶端的朋友", "所以应该转入这样一个状态", "而我们的关注焦点转向下一个数字0", "同样，作为操作数，它会直接被推入栈中", "变成操作数栈的栈顶", "同时我们的关注力转向阶乘", "经过查表，不出我们的意料", "作为优先级最高的运算符", "阶乘号自然会比减法更加优先", "所以接下来", "我们应该将这个阶乘运算符推入栈中", "并且将注意力转向下一个字符", "也就是右括号"]}, {"name": "06B1-4 顶点和边", "block_id": "4d91f38e79dd4c3791a5ffc0c457f957", "text": ["以下我们给出图顶点类的", "一种实现方式", "为简明起见", "这里我们对Vertex类", "没有做严格的封装", "首先需要一个data域来记录", "顶点的自身信息", "其次当前顶点与其它的", "多少个顶点相互关联", "也可以用它的入度", "以及出度来分别指示", "以下信息都是服务于稍后要介绍的", "图遍历算法", "在整个遍历过程中", "图中的每一个节点", "在任何时候都处于特定的状态", "这种状态总共有可枚举的三种", "可以看到 在被创建时", "每一个顶点都初始地被置成", "所谓的undiscovered状态", "此外 我们还需要两个时间标签", "分别来记录顶点被发现", "以及被访问完毕的时刻", "而在遍历所生成的遍历树中", "当前节点的父节点是谁", "则是由parent记录的", "而在基于优先级的遍历算法中", "我们还需要为每个顶点", "维护一个优先级数", "这些信息的具体含义", "我们在接下来的遍历算法中", "将会详细介绍", "因此当一个顶点被创建时", "自然地 也需要对以上各项进行设置", "也就是把数据域设成", "对应的指定域", "而入度以及出度", "都被初始化为零", "其余各项也是如此", "我们进而给出", "边类型的一种实现方式", "同样地 出于简捷的考虑", "这里对于Edge类 也省去了严格的封装", "首先需要有一个域", "来记录自己所携带的信息", "其次对于带权网络 还需记录边的权重", "与顶点类似地", "在经过遍历之后", "所有的边都会被归入某一种类型", "可以看到 这里枚举的", "总共有五种类型", "它们的具体含义也将在稍后", "介绍遍历算法时", "逐一详细介绍", "如此为了创建一条边", "我们也是需相应地对其中的各项", "进行初始化设置即可"]}, {"name": "09C-9 多项式", "block_id": "f6cb3411beb24af098edde30901c7762", "text": ["当然在实际应用中 原始数据的关键码", "未必天生都是整数形式", "因此往往需要先做一个预处理", "将其转换为整数 称作散列码hashcode", "然后才可以将其进一步转换为桶数组中的地址", "浮点数以及字符的hashcode转换并不困难", "因此接下来我们重点讨论一下", "字符串型关键码应该如何更好的完成这种转换", "比如一种行之有效的方法就是所谓的多项式法", "比如这就是一个长度为n的字符串", "我们首先将其中的每一个字符分别转换为对应的整数", "接下来 再将来这n个整数", "分别视作为一个n次多项式的n个系数", "并采用事先确定的某一个常数a", "计算出这个多项式的具体数值 并将其作为散列地址", "请注意 这样一个一元n次多项式", "可以在O(n)而不是n^2的时间内计算得出", "因为时间关系 我们忽略掉具体的算法", "如果你对这个算法还不甚了解", "这个插图应该会对你有所帮助", "当然 这里的O(n)毕竟涉及较为复杂的乘法运算", "能否加以避免呢", "答案也是肯定的", "比如这就是一种可行而有效的方法", "实验数据也表明", "这种散列码转换算法非常适用于英文字符串", "可以看到 这里也是通过一个for循环", "依次的处理串中的各个字符", "对于每一个字符 我们首先将其转换为整数", "并对其做累计 而在每次这样的累计之前", "原有的累计值 都要按这种方式做一个数位变换", "这个图可以帮助我们理解整个变换的过程", "如果这是此前累计值的二进制展开", "一般的取做32位 那么调整的实际效果就是", "将前端的5个比特与此后的27个比特互换位置", "这一不断调整不断累加的过程", "实际上可以视作为是对以上多项式计算的近似", "只不过这里消除了相对费时的乘法计算", "至于如何来具体理解和解释这种近似的效果", "可以作为你课后的一项作业", "当然无论是原始的多项式法", "还是变通之后的近似方法", "其计算过程 都不免显得相对复杂", "你或许会质疑 有这个必要吗", "答案是的确有"]}, {"name": "01d-1: 算法分析", "block_id": "e9197a1e5dc142d8aa8debae66e77a26", "text": ["通过以基本的计算模型作为参照", "并且以大O记号的形式在上面加入适当的刻度", "我们实际上已经建立了一套", "对DSA进行分析的完整工具和体系", "所以接下来这一节将重点围绕", "如何运用这种工具对DSA进行性能的分析", "包括其中主要的思路和方法", "与这套体系建立的思路类似", "我们在具体运用这套体系的时候", "依然要坚持去粗存精", "这部分内容的学习效果如何", "最终要看我们是否能够真正的自如驾驭", "和运用这套工具来完成去粗存精式的估算", "这种估算能力的最高境界", "从某种意义上讲", "就像很多人夸赞大数学家欧拉一样", "这里的He是指欧拉", "能够成为像呼吸一样对人而言的一种本能", "算法分析的任务主要包括两个方面的内容", "一是算法自身的正确性证明", "我们稍后将会举例给出一种主要的办法", "也就是通过挖掘算法所具有的", "不变性和单调性来共同证明", "其次也是我们接下来将要重点介绍的", "是复杂度的分析和界定", "我们可以回忆起来", "一个算法的复杂度需要转化为", "在标准的计算模型 比如说RAM上的描述", "并且统计它在对应的执行过程中", "所执行的基本指令的总数", "那么难道我们在实际的估算过程中", "真的需要去统计并且累计", "这样的基本指令的执行次数吗", "非常幸运这是大可不必的", "而之所以能这样是得益于", "前面所引入的渐近复杂度这样一个概念", "实际上我们可以注意到这么样一个事实", "也就是C++或者其他的高级语言", "所提供和支持的基本指令", "其实和RAM或者图灵机模型所给出的", "那种基本的操作是等效的", "当然这种等效是在常数意义下的", "就渐近复杂度而言其实前者所说的基本指令", "和后者所说的基本指令大体是相当的", "所以我们往往在不致歧义的前提下", "会偷换或者是借用这两个概念", "二者所说的的基本操作或者基本指令", "在这个意义上讲是等价的", "当然 我们这里考察的重点", "依然不是平铺直叙式的代码段", "而是包括条件分支转向", "以及它的规范化的形式", "也就是迭代循环包括for while", "包括在很多语言中还有do while、repeat until等形式", "本质上讲都是迭代循环", "归根到底还是通过迭代来实现的函数调用", "包括自我调用也就是递归", "我们所提供和采用的分析方法", "大概可以分为这么几类", "针对于迭代式算法 最重要的技巧", "也是我们需要训练和提高的一种功夫", "就是对级数求和的能力", "而对于递归式的算法主要的武器有两个", "一个是直观形象的递归跟踪", "第二个是借助于抽象思维的递推方程", "当然在实际的研究过程中", "包括在考试和习题过程中还有第三种方法", "也就是猜测再加上验证", "这种方法其实也是非常非常重要的一类手段"]}, {"name": "02D3-1\t 构思", "block_id": "5290ad158e564ab782f2ef07c3d43dfc", "text": ["欢迎同学们回来", "我们这一节继续讨论有序向量的查找算法", "在上一节，我们引入了所谓的二分查找", "Binary search这样的一个概念", "并且给出了一个基本的算法的版本", "这个版本的复杂度", "从渐近意义而言", "应该是logn量级的", "但如果进一步地细微地来", "考察前面的系数", "大致是1.5", "我们也指出，这个1.5是可以改进的", "我们现在就来看看，如何通过一种新的算法", "也就是fibonaccian search", "所谓的fibonacci查找", "来对此进行改进", "上一节的末尾", "我们曾经以一个长度为7的有序向量为例", "具体地给出了，在成功和失败情况下", "平均查找长度的估算的过程", "实际上，通过那个实例的推而广之", "我们如果考虑更一般的情况", "不难发现，此前所介绍的版本A", "确实还有很大地改进余地", "这样一个判断", "更多的是，来自于这样一个观察事实", "也就是说，版本A这个算法", "实际上从用意上讲", "它是试图通过使各种情况的搜索", "在迭代次数上的平衡", "来尽可能地回避掉最坏的情况", "具体讲，比如所有的失败情况", "大部分都会失败在同样深度的", "也就是最深的这个位置", "所以它表面上看是平衡的", "但我们说，这其中却蕴涵着", "很大的不平衡", "因为我们可以看到，在整个这个查找的过程中", "我们在任何一个位置上", "如果要决定是向左或者是向右深入的话", "其实我们所花费的成本", "也就是比较的次数是不等的", "准确地说", "按照我们的版本，向左侧只需要一次比较", "而向右侧却需要两次比较", "所以这样一个表面上看", "是非常公平的一个平衡", "实际上在内部，却蕴涵着极大的不平衡", "所以因此我们确实有理由怀疑", "算法的效率是否已经达到最优", "反过来，我们也可以得到", "改进的一个思路", "具体讲就是，既然我们已经看到", "目前的机制中", "向左侧确实会成本更低", "向右侧更高", "那么为什么我们不干脆", "就把这个搜索的各种情况", "如果能够画成", "也是一个类似的这样一个树状图的话", "做成左侧是更深的", "而右侧是相对更浅的", "这样一个表面上看的不平衡", "却因为它恰好和这种成本", "互相之间能做一个合适的补偿", "反过来，有可能从整体上会得到更优", "也就是说，使得整体的查找平均长度", "有可能反而会缩短", "具体来讲，越是成本低的转向", "我们就越希望更多地做", "越是成本更高的", "我们越是希望它能更少地来做", "所以这样的话", "我们就得到了新的算法的改进的思路", "那么具体这个思路怎么来兑现呢？", "非常有意思", "需要用到fibonacci数", "不失一般性，假设我们的表的长度", "也就是这个有序向量的长度N", "就是某个fibonacci数减1的形式", "如果确实是这样的一个形式的话", "那么如这个图所示", "如果这个整个长度", "确实是一个fibonacci数减1的话", "那我们就在其中", "选择这么样一个特定的切分点", "这个mi", "这个mi是什么呢？", "正好是整个长度", "如果是第k个fibonacci数的话", "那么它的位置就是", "第k-1个fibonacci数，再减1", "换而言之", "如果以这个点为切分的话", "那么左边这个子向量的长度", "就恰好是第k-1个fibonacci数", "再减1", "而右边呢，恰巧是", "fibonacci数第k-2项，再减1", "可见这样一种切分的好处就是", "在任何时候", "只要按照这样来切分", "切分下来，无论是向左还是向右", "它都会从长度上讲", "依然保持某个fibonacci数", "再减1的形式", "我们稍后就会看到，这种形式", "实际上还非常巧", "恰好是最优的", "我们先来看，它具体是怎么实现的"]}, {"name": "11c5-1: 失之粗糙", "block_id": "3d39e2697a7d43a8bf81b475a55971ae", "text": ["以下 我们就来对KMP算法的性能作一分析", "我们知道 KMP算法的计算过程", "可以根据对齐位置", "相应地分为若干个阶段", "然而 每一个阶段所对应的计算量是有很大区别的", "我们很快就会看到 如果只是简单地从最坏的角度来进行估计", "我们将无法准确地来评估这一算法", "而实际上真正有效的方法是", "放眼整个计算过程", "将整体的计算成本分摊到每一个阶段", "没错 分摊", "我们这里需要再一次地借助分摊的分析技巧", "而这里我们将要采用的估算方法", "也是分摊分析中的一种典型手法", "我们首先来看一种貌似无可厚非", "但实则非常粗糙的估算方法", "这一方法建议我们将注意力放在文本串中的任一字符上", "因为这种方法认为我们只要估算出每一个字符所参与的比对次数", "也自然地就可以得到整体的比对次数", "然而我们很快就会发现", "在任何一个特定的字符处", "我们的模式串的确有可能会多次地后移", "实际上不难构造出这样的例子", "也就是相对于文本串中的某个特定字符", "模式串有可能需要连续地后移多次", "并且用其中多达Ω(m)个字符 与文本串中的这个字符进行比对", "当然具体的次数可能是m/3 m/40", "或者m/500", "但无论如何 在渐进的意义上都可以达到Ω(m)次", "因此 如果再考虑到主串所贡献的那个因子n", "那么按照这种思路", "KMP的时间复杂度似乎会高达Ω(n*m)", "这样一个分析结论多少会让我们感到沮丧", "因为蛮力算法也不过如此", "然而事实上这种方法的确失之粗糙", "而接下来更为精细的分析将表明", "KMP算法的效率 即便在最坏情况下 也不会超过线性"]}, {"name": "06B1-6 顶点静态操作", "block_id": "53fc237b61c74011987cdda1055fee5d", "text": ["按照这种实现方式", "我们可以简明实现顶点操作中的", "大部分基本操作", "比如直接返回顶点所对应的信息", "以及它的入度和出度", "它的状态 它的时间标签", "在遍历树中的父节点", "以及在遍历过程中", "动态维护的优先级树等等", "当然 并非所有的顶点操作", "都能如此直截了当地", "一蹴而就地实现", "比如在图的遍历过程中", "需要反复地使用这样一个接口", "也就是说 站在当前", "顶点 i 的位置", "我们需要逐一地罗列", "也就是枚举出", "与之邻接的所有顶点", "我们称这些顶点为", "当前顶点的邻居 neighbor", "为此我们首先需要实现一个", "名为nextNbr的接口", "它的功能语义是", "如果我们现在已经枚举到", "顶点 i 的编号为 j 的这个邻居", "那么它将返回", "接下来的下一个邻居", "我们知道 与顶点 i 潜在的", "可以相邻的点", "无非就是它在邻接矩阵中", "所对应的那一行", "这个行向量中的元素", "取值或0或1", "而所有那些数值为1的单元", "才各自己对应于", "与i邻接的一个顶点", "那么如果我们现在已经枚举到", "编号为j的这个邻居", "我们如何找到下一个有效的邻居", "因此我们不难理解", "这个算法为什么要从j开始", "不断地通过减减", "逆向地向前进行搜索", "每抵达下一个潜在的邻居", "都要通过exists接口", "判断对应的这条边是否存在", "只要不存在", "我们就继续通过 j 减减", "指向下一个潜在的邻居", "直到最终发现一个有效的邻居", "至此我们只需将", "新发现的这个邻居返回即可", "而接下来 如果我们再次调用", "nextNbr这个接口", "自然也就返回下一个邻居", "以及再下一个有效邻居", "以及再下一个", "和再下一个", "请注意 最终的特殊情况", "也就是当我们试图", "越过这个向量的左边界0", "也就是试图抵达-1的时候", "我们将终止这样一个搜索的过程", "这也就是为什么", "在这个短路求值的逻辑表达式中", "首先需要检查j是否已经越界", "那么第一个有效的邻居", "又该如何确定呢？", "为此我们需要准备另一个例程", "我们可以看到", "其实这个firstNbr", "也是调用了nextNbr而已", "不同的在于 它将顶点n", "作为上一个有效的邻居", "没错 n 你并没有听错", "尽管编号为n的顶点压根就不存在", "依然不妨将它视作是一个假想的哨兵", "而且等效地认为", "它会和包括 i 在内的", "任何顶点都相邻", "从而简明而有效地", "启动整个搜索和枚举的过程", "那么整个这样", "从第一个有效的邻居", "一直枚举到", "最终的一个的过程", "累计需要花费多少时间呢？", "我们可以看到", "尽管各自nextNbr所对应", "while循环的长度不尽相同", "但是累计而言", "其总数不过是整个行向量的长度", "我们讲过 这个长度恰好就是n", "因此整个算法所需要的运行时间", "累计不过是线性", "当然如果你对这个效率", "还不甚满意", "可以借助我们稍后介绍的", "邻接表结构进行改进", "你将会看到 在如此改进之后", "整个过程累计所需要的时间", "将线性正比于", "当前顶点的出度"]}, {"name": "02F-1\t 归并排序：构思", "block_id": "f0cabe69368147628f99e7eefe4cddbd", "text": ["同学们好", "在这一节我们继续介绍向量的排序算法", "在上一节", "我们介绍过起泡排序", "也就是Bubble Sort", "我们看到 尽管它可以从很多侧面进行优化", "但是从最坏的情况 这个角度而言", "至少都需要n平方的时间", "在课后 如果同学们已经学习过", "我们所推荐的一些内容的话", "大家会记得", "如果采用包括Bubble sort在内的", "我们常规的那些所谓基于比较式的算法", "也就是comparison based algorithm", "那么求解排序问题都存在一个下界", "n*logn", "我们的问题从此展开", "也就是说", "在这样一个n平方的上界", "到n*logn的下界之间", "是否存在一些其它的", "相对于n平方而言 更好的算法", "甚至于我们能不能指望", "有一个算法 即使在最坏的情况下", "也只需要n*logn的时间", "就能完成排序呢？", "答案就蕴含在这一节的主题里", "也就是归并排序Merge Sort", "归并排序算法是", "分治策略在算法设计中应用的又一个典型", "这个算法最初是由冯·诺依曼编码实现的", "尽管算法的思想出现地要更早一些", "我们说 所谓的分治策略 在这里就是说", "将待排序的那个序列", "无论是本章所介绍的向量", "还是下一章所介绍的列表", "一分为二", "我们可以看到这种分法很快捷", "只需要O(1)的时间", "其实就是分为左右两部分", "如果把它水平地画出来的话", "接下来 对于划分出的两个子序列", "分别去做递归地求解", "也就是递归地排序", "而当两个子序列已经分别有序之后", "我们接下来要解决的一个问题", "就是将它们合并", "准确地讲 是归并merge", "从而构成一个完整的有序序列", "我们来看右侧这个例子", "这是由八个元素组成的一个向量", "按照刚才所说的思路", "面对这样一个相对还比较大的向量", "我们能够做的事情 首先是分", "沿左右 划分为左和右两个子序列", "这两个子序列递归地求解的过程中", "依然发现还是相对比较大", "所以它们会继续递归地、各自地进行划分", "继续分为左左、左右", "以及右左和右右四个子序列", "同样 它们还是不够平凡", "所以我们最后还要对这四个子序列", "继续地一分为二", "最终八个元素各自成为一个独立的序列", "这个时候从递归地角度讲", "就抵达了递归基", "所有这些元素都已经不需要", "再继续划分下去了", "因为它们各自有序了", "所以如果说前面半层", "是做无序向量的递归分解", "接下来 就要通过逐层的合并", "使之逐渐地变成一个大一点的", "更大一点的 直到最后那个有序的序列", "我们可以看到", "每一次都是将两个", "已经是有序的子序列", "合并为一个有序的子序列", "包括这个、这个、这个", "好 然后再继续", "相邻的子序列逐对地合并", "构成再更大的序列", "以及再来一个", "好", "最后这两个各自有序的子序列", "再逐对地合并", "最终得到整体的序列", "那么我们要说的是", "如果果真能像这里所说的那样", "我们就应该能够得到一个", "总体是n*logn的算法", "因为从递推的角度来看", "整体的排序 如果需要是T(n)的时间", "那么它所要做的事情", "就是递归地去求解2个", "各自规模为原先一半的问题", "然后最重要的是要加上一个", "分以及和累计的时间", "也就是O(n)", "这样一个典型的递推式", "我们应该已经非常熟悉了", "它得到的解就是n*logn", "那么现在接下来的技术细节就是", "如何来兑现这一点呢？", "我们可以看到 从这里的分来讲", "是非常简单的", "不用多解释", "递归 我们也可以交给递归的机制去做", "所以这里核心的任务是在怎么进行合并", "或者准确地讲", "是怎么将两个已经有序的序列", "归并成一个更大的序列", "这也是这个算法最关键的细节和技巧"]}, {"name": "02D4-1\t 构思", "block_id": "c0cd5053b9f5493cb0aa19753c2bf051", "text": ["欢迎同学们回来", "我们这一节继续讨论有序向量查找算法的改进", "回顾上节，我们所介绍的fibonaccian search", "实际上，它的改进思路是在注意到", "我们查找的过程中的每一步", "向左和向右深入的成本是不一样的", "具体来说，左边是1的话，右边就是2", "所以它试图做这样一个改进", "使得整个搜索的倾向", "更加地偏向于成本更低的左侧", "而使得向右的分支，出现的概率更低", "这样的话，我们也严格证明了", "在总体情况下", "它的查找性能将会得到改进", "甚至从一般的意义上讲，已经是最优的了", "那么我们这一节呢", "将给大家介绍另一种思路的改进", "这是一种直截了当的改进思路", "既然我们已经注意到了", "此前的版本A中", "造成效率略低的原因是因为", "左右分支的转向代价不平衡", "那么我们为什么", "就不能够将二者做成是平衡的呢？", "也就是说，如果在任何一个位置", "我们需要向左和向右的话", "我们希望能够使得无论是向左还是向右", "只需要进行一次比较", "没错，一次比较", "当然这样的话，我们每一次迭代中", "经过一次比较之后", "就只能有两个分支而不是像以前一样", "实际上是三个", "也就是说，原来隐藏了一个分支", "那么原来版本A隐藏的是哪个分支呢？", "大家应该能想得到", "也就是在当前这个轴点处", "命中的那个分支", "我们说这个分支，某种意义上讲是", "更好甚至是最好的情况", "因为在这个时候，我们就可以直接返回了", "而在我们采用了新的这样一个改进思路以后", "为了获得在每一处的平衡", "我们不得不在这个位置上做出一点牺牲", "具体来说，我们同样地还是以", "中点mi作为轴点", "只不过呢，只进行一次判断", "也就是我们只判断", "我们的目标关键码是否是", "严格地小于当前的轴点", "如果它确实是小于轴点", "那么我们就向左侧区间深入", "反过来，如果刚才那句判断答案是否", "也就是说，e是大于等于当前的这个轴点x", "那么我们就可以断定", "它如果存在的话", "必然位于右侧的子区间", "同样可以进行递归地深入", "大家注意，这里头的细微区别", "虽然我们这里依然用左和右来区分", "两种减而治之的可能和方向", "而且左侧的也确实和以前的没有任何区别", "但是右侧这个分支所对应的子向量", "却略有区别", "这个区别就在于", "它将这个轴点同时也涵盖进去了", "换而言之，正像我们刚才所说的", "在这个时候，必须做出一个牺牲", "也就是说，我们不能够及时地判定", "在当前这个位置已经命中", "正如我们马上就要看到的", "新的这个算法必须等到整个这个区间", "经过足够多次减而治之", "最后的区间宽度变成1的时候", "才会真正地去判断", "当前唯一的这个元素是否是真正命中的", "这也就是新的这个算法和此前的算法", "在策略上的不同", "但是无论如何，这确实是可行的", "因为它已经使得我们在任何一个细微处", "都能够做到理想的平衡", "所以从而使得整个问题更加地简化"]}, {"name": "10a1-2: \t计算模式", "block_id": "d896e6deb0c24c53b54c0a324ffdf70b", "text": ["通过以上所举的几个实例，我们可以归纳出此类问题的一种典型模式。", "这里有两个主体：首先是一个服务端——", "比如此前的医生，或者CPU；", "而另外还有一批客户——", "比如等候门诊的一批病人，或者同时参与调度的一批计算任务。", "前者也可能是某种算法——比如Huffman编码算法，以及扫描线算法；", "而后者则是算法所需处理的一批数据对象——", "比如一组待编码的字符，或者空间中的一组点。", "在这里，数据集中的每一个数据对象都有一个表示其重要程度的指标，", "称作“优先级”。", "而这里的算法，则是严格地按照各数据项的优先级，", "来确定究竟接下来应该访问谁。", "这样一种访问方式，", "与此前的循秩访问、循位置访问、循关键码访问乃至循值访问都不相同。", "既然这里的访问次序完全取决于各数据项的优先级，", "所以我们也不妨称之为“循优先级访问”(Call by Priority)。", "当然，这样的一种数据访问方式必须兑现并落实为某一类具体的数据结构，", "这类结构需要能够记录并维护所有数据项之间的相对优先级，", "并且按照这种优先级，通过调度器，", "将最高优先级的元素输送给所对应的服务端或者算法。", "因此，我们也将这类数据结构称为“优先级队列”(priority queue)。", "那么，具体地，priority queue应该提供哪些具体的操作接口呢？", "具体地，又该如何定义呢？"]}, {"name": "04C1-3\t 实现", "block_id": "f771694d22244002a7d0bf87d93bc9b1", "text": ["好 我们现在就来将刚才的算法", "具体地兑现为代码", "我们这里编写了一个名为", "convert的函数", "它的作用是将某个输入整数n", "转化为以base为进制的表示", "而且所有的数值", "都按刚才所设想的那样", "会被存入一个名为s的栈中", "在新的进制中", "我们可能需要更多的数位", "所以这里我们用digit数组", "来对应于不同的数位表示", "算法的主体循环在这", "每一次 我们确实都是对", "当前的这个n来取一次模余", "也就是我们所说的整除的余数", "这个也就是我们当前", "所对应的某一个数位", "通过digit数组", "我们可以找出", "对应的这样的一个数位", "并且将它推入栈中", "为了能够继续进行迭代", "我们还需对n以base 也就是进制", "为除数 做一次整除", "这样一个迭代的过程", "反复地进行", "直到最终的商成为0", "至此 正如我们刚才所分析的", "在s栈中 自底向顶", "依次保留了自低向高的所有数位", "因此在主函数中", "一旦convert调用返回", "我们只需通过一连串的pop操作", "就可以将栈中的各个数位", "由高自低地逐位输出", "从而得到最终的结果"]}, {"name": "12a2-1: 不稳定 + 就地", "block_id": "239ed21bb3294cf2bf2a563e8d5f4d4b", "text": ["以下我们就针对刚才所给出的", "快速排序算法的第一个版本", "就其性能做一分析", "我们首先很遗憾的发现", "这个算法是不稳定的", "快速排序算法的不稳定性", "通过我们刚才所举的那个实例", "可以清楚的看出来", "我们注意到在原始的输入序列中", "有两个5", "按照先后次序我们分别", "用5A和5B来表示", "在经过一次划分之后", "我们可以看到这两个元素的位置", "已经彼此颠倒", "实际上这种现象必然是普遍存在的", "因为对于任何两个", "小于侯选轴点的元素而言", "他们加入子序列L的次序必然是颠倒的", "同理对于大于侯选轴点的雷同元素而言", "也有对称的性质", "其次整个算法也是可以就地实现的", "也就是说它只需要常数的附加空间", "这一点从我们刚才这组原理和过程图中", "也可以清晰的看的出", "实际上除了原始的输入序列", "我们这里只需要维护常数个指针", "以及用于保存侯选轴点的一个单元"]}, {"name": "11e1-1: \t兼顾经验", "block_id": "9fef951165da443aa7a7e9e1a775f6fe", "text": ["以上介绍的bc策略", "并非BM算法家庭中的唯一成员", "它还有一个名为gs的好兄弟", "也就是所谓的好后缀策略", "gs策略的作用与bc策略恰好互补", "它着眼于充分利用此前的比对所提供的经验", "我们首先来通过一个实例来看看", "bc策略为什么没能有效地利用经验", "而如果能利用经验", "我们又能做得多好", "来看这样一个文本串", "其中标注为x的字符内容都是无所谓的", "接下来是我们的模式串", "假设按照常规", "我们首先将它们在首字符处对齐", "然后按照BM算法的策略", "从末字符开始比对", "可以看到 第一次比对成功", "第二次比对也成功", "实际上 我们会经过4次成功的比对", "直到C和H失配", "此时的H", "就是所谓的坏字符", "为了与主串中的C相配", "我们接下来应该尽可能地在模式串中", "找到字符C", "并试图与之对齐", "然而尽管这里总共有3个C", "你应该记得 我们最终选用的应该是最靠右侧的那个", "然而很遗憾", "最右端的这个C 位置过于靠右", "以至于 如果我们需要将它与文本串中的这个C对齐", "将会导致整个模式串的左移", "而不是右移", "你应该记得", "bc策略在此时会如何处置", "没错 它会简明地让模式串向右侧移动一个字符", "接下来 继续从末字符开始", "启动新一轮的扫描比对", "可以看到 这一轮比对在经过了一次成功之后", "将会再一次地失败于H和C的失配", "此时的坏字符为C", "于是接下来", "bc策略为了能够使得文本串中失配的这个H", "能够恢复匹配", "将会在模式串中找出某个H", "并试图将其与文本串中的H对齐", "从而使这个H能够得到匹配", "然而刚才的那个特殊情况又再一次出现了", "因为我们注意到 模式串的这3个H中", "最靠后的这个H 同样过于靠后", "从而使得 如果将它与文本串中的这个H对齐", "将同样会导致模式串的左移而不是右移", "可想而知", "bc策略在此时将如何处理", "没错", "依然是将模式串向后移动一个字符", "然后再一次地从末字符开始", "启动新一轮的比对", "这一回", "第一次比对即告失败", "于是 bc策略同样会试图从模式串中找出一个适当的A", "并试图将它与文本串中的A对齐", "从而使得这个A能够得以匹配", "这一回我们的运气好一些", "因为模式串中最靠后的A", "还不至于过于靠后", "我们可以放心地移动模式串 从而使得这个A与这个A彼此对齐", "的确 经过适当的右移之后", "模式串中的这个A的确可以与文本串中的这个A彼此对齐而且匹配", "而在接下来的一轮扫描比对中", "我们会高兴地发现", "所有字符都是匹配的", "于是 算法至此即告结束", "反观算法刚才的这一次执行过程", "我们对它的性能的确很难满意", "因为我们注意到在前后的3次右移中", "居然有两次只移动了一步", "而进一步的观测之后我们或许会发现", "如果能够借助一些其他的策略", "我们本来应该可以移动得更快", "就以刚才的第一轮比对为例", "当我们失败于主串的C时", "我们不仅可以获得坏字符之类的负面信息", "同时还可以获得更多的正面信息", "你能看出来吗", "没错 就是在这次失败的比对之前", "我们刚刚做过的4次成功比对", "通过这些信息 我们能够获得什么帮助和启示呢", "作为事后诸葛亮 我们可以发现", "根据刚才的这些正面信息", "我们完全可以断定接下来的两次对齐都是不必要的", "原因在于 按照这两个对齐位置", "在刚才这4个成功比对的位置处 都是失配的", "自然地 这也就注定了这两次对齐位置都必然是徒劳无功的", "而在进一步的观察之后", "或许你应该能够发现一个更好的消息", "是的", "如果将此类成功的信息依然称作经验", "那么我就可以与KMP算法一样", "对它们加以利用", "而且相应的准备工作也可以通过预处理的方式提前完成", "比如 就针对这样一段区间", "我们应该能够以某种方式", "事先从模式串中将与之匹配的部分提取出来", "从而使得我们在确定下一对齐位置的时候", "可以保证此前的这次对齐", "能够继续得以延续", "果真如此 我们就可以在第一轮比对失败之后", "直接将模式串一步移送到位", "从而有望进一步地提高BM算法的效率", "仿照坏字符的命名方式", "我们也不妨将这种匹配的后缀称作好后缀"]}, {"name": "03C-1\t 唯一化·构思", "block_id": "6522e34a2c1040adb8b36eaec2107079", "text": ["同学们好", "接下来的这几节", "我们重点讨论有序列表", "也就是说 我们假设其中的元素", "不仅可以比较大小", "而且已经按照这种大小关系有序地排列", "我们将会看到 在这样的一个条件下", "很多问题都存在更加高效的解法", "我们现在就来看其中一例", "依然以唯一化问题为例", "我们知道有序向量的唯一化", "可以比无序向量的唯一化", "更快地完成", "那么有序列表的唯一化", "是否也能够比无序列表的唯一化", "完成地更快呢？", "在给出具体的算法之前", "我们先来介绍一下", "这个算法的思路", "回忆一下", "在有序向量的去重算法中", "我们曾经介绍过这样一个事实", "在任何一个有序的序列中", "如果存在重复元素", "那么每一组重复元素", "必然会彼此紧邻地排列成", "一个又一个的分组", "每一个分组都有", "彼此相同的一组元素构成", "而唯一化的任务", "可以等效地理解是", "从每一组中挑选出一个代表", "而将其余的元素都剔除掉", "于是仿照有序向量的唯一化算法", "我们这里也可以得到", "一个迭代式的算法", "具体来讲 每一次迭代", "我们都将注意力关注于", "当前以p指示的那个节点", "同时 我们还要考虑p的直接后继", "如果命名为q的话", "在经过一次比对之后", "如果发现p和q相等", "我们就可以将后者剔除掉", "而这个呢 可以通过列表", "所提供的remove标准接口来实现", "此后q将指向新的后继节点", "同样地 在接下来的一步迭代中", "我们依然会发现q与p相等", "所以可以继续将它删除", "以及再接下来的雷同节点", "在某一步接下来的迭代中", "情况可能发生变化", "也就是说", "我们首次发现一个与p不同的节点", "这个时候就预示着", "一个新的区段出现了", "作为这个新的区段的首节点", "我们将保留这个节点", "而为了这个算法能够继续计算下去", "我们不妨将p由原来的位置", "转向这个新发现的不同的节点", "可以看到 经过这样一轮迭代之后", "刚才相同的一组元素中", "除了第一个", "其余的后继都被删除掉了", "再接下来呢", "我们可以如法炮制", "相应地 删除这些雷同的节点", "以及这些雷同的节点", "以及诸如此类的后继所有雷同节点"]}, {"name": "09E-2 桶排序", "block_id": "b52172df31074bc19390050246dee65c", "text": ["这里最基本的一个思路就是运用散列表", "在这里既然考虑的只是英文字母", "所以各元素的取值无非26种可能", "因此我们只需将表长M取作为26", "并相应的建立这样一个散列表", "而其中的各个桶单元呢", "则依次对应于abc一直到z这26个字母", "在建立了这样一个散列表之后", "我们的第一项任务就是来填充名为count的这一行", "顾名思义 其中的每一个元素都是一个计数器", "分别记录其所对应的那个字母", "在输入序列中所出现的次数", "比如 这个2就意味着对应的字母G", "在输入序列中总共出现了2次", "相应的 B只出现了1次", "而A H K之类的字母根本就没有出现", "当然 这里的5也意味着M在输入序列中总共出现了5次", "我们不妨来确认一下", "1 2 3 4和5 不多不少", "那么 由输入序列如何快速的得到这样一张统计表呢", "我说如果输入的规模为n", "那么我们应该可以在O(n)的线性时间内完成这个任务", "你能想出具体的方法吗", "没错 只需遍历一次整个输入集", "在此过程中 每遇到一个字符", "就对它所对应的那个计数器做累加", "形象的说 这样一个过程就犹如", "将所有的元素分别扔到它所对应的桶单元中", "因此这一步骤也称作分配 distribution", "在这幅图中 请留意蓝色的折线", "它是什么呢", "没错 这条折线恰恰就对应于刚才我们的统计结果", "然而这还不是我们最终所需要的", "我们还需要什么呢", "这条红色的折线", "此前的那条蓝色折线被称作count", "是因为它反映了各字符在输入序列中出现的次序", "而新的这条红线呢 则称作accumulation", "这暗示着它是某种累计值", "没错 累计值", "更精确的说 这条红色折线上的任何一个点", "其实都对应于蓝色折线至此之前的所有数值的积分", "既然蓝色折线是非负的", "所以作为它的积分 这条红色折线是单调非降的", "那么红色折线上的这样每一个积分值具体又是什么含义呢"]}, {"name": "02C-5 单元素删除", "block_id": "e2edcf73020842d296069fa9fb09ff77", "text": ["再来考察删除操作的另一个版本", "也就是单元素的操作", "既然此前已经实现了", "区间的批量删除操作的接口", "所以我们不妨把", "这种单元素的操作", "视作是整个区间操作的特例", "具体来说", "我们要借助这样一个转换", "也就是，将任何一个由", "单个元素构成的区间", "视作是由 r 到 r+1", "所定义的左闭右开的", "那段区间", "如果想到这里的话", "就可以很简明地得到", "这样一种实现的方式", "在这里最重要的一句", "就是调用此前重载的", "那个remove接口", "只不过这里的参数", "我们改变为 r 和 r+1", "与我们刚才的那种转换相对应", "也就是说", "我们确实可以把一个", "向量中特定的某一个元素 r", "借助此前的算法", "同样地把它删除掉", "而那个操作", "我们再回顾一下", "无非就是所有的后缀", "向前移动一个单位", "至此，有些同学", "可能会提出一个疑问", "我们这里为什么不反过来", "基于单元素删除接口", "通过反复的调用来实现", "区间删除呢？", "从道理上看，这个方法是可行的", "比如说，对于一个特定的一段区间", "从 lo 到 hi", "我们可以对其中的每一个元素", "分别去调用一次", "单元素删除接口", "从而完成整体的删除操作", "我们说这毫无问题", "但是正如我们此前所讲过的", "数据结构更多的关注的是效率", "实际上，我们很快就会看到", "从效率上看，这个方法是非常差的", "为什么呢？", "先来看一下单元素", "删除这个版本本身的效率", "我们讲过，在这里", "最重要的实际上是这段区间", "也就是被删除元素的那些后继们", "统一地要向前移动一次", "这也是它的复杂度的来源", "所以也正因为如此，我们说", "它的复杂度是取决于", "它的后继的个数", "反过来，如果确实是", "按这样的一个方式", "来反复调用的话", "那么对于这个区间", "我们说这个宽度是", "hi 减 lo 中的所有的元素", "我们都要执行一次", "对他们公共的这些后缀", "向前移动一格的操作", "而这个成本是多少呢？", "每一个元素", "所对应的这样一趟移动", "累计起来都至少是 n 减掉 h", "这两个量在最坏的情况下", "都可能与 n 是同阶的", "换而言之，这种算法", "有可能会导致 n 平方的复杂度", "相对于我们此前的那种操作", "充其量不过O(n)而言", "这样的一个效率是相当差的", "这样一种颠倒过来的次序", "尽管可行", "但在效率上却是不中用的", "我们不能考虑这种方法"]}, {"name": "10b1-1: \t完全二叉树", "block_id": "1add377a0c354d9882d95175c15fe556", "text": ["在上一节我们看到，就优先级队列的实现方式而言，", "采用基本的向量结构并不足够，", "而采用更高级的树形结构，", "虽然完全可以高效率地实现优先级队列，", "但却有杀鸡用牛刀之嫌。", "那么，能否在这两种策略之间设计一种折衷的方案呢？", "答案是肯定的，为此我们需要以向量为形，", "以树形结构为神，形成二者之间的有机结合。", "为此，我们需要借助完全二叉树。", "所谓的\"Complete Binary Tree\"，可以认为是AVL树的一个特例，", "其中的平衡因子处处非负，", "也就是说各节点的平衡因子或者为0，或者为+1，但绝对不可能是-1。", "而且对树中的任何一个节点v而言，如果它的平衡因子为0，那么它的左子树必然是满树。", "另一种可能，如果v的平衡因子为+1，那么它的右子树必定是满树。", "由这些约定不难推知，就全局的拓扑连接而言，", "完全二叉树大致应该呈现为这样一种形式。", "也就是说，如果忽略它的最底层，", "那么其余节点应该组成一棵满树。", "而最底层呢？也只不过是缺失了右侧的连续一段。"]}, {"name": "08A1-7\t最坏情况", "block_id": "de2c73a4a41f4e69af325fe8f29bee6d", "text": ["这棵树 有do re mi fa so la si类似于", "七个音符所构成的一个逐级上升的音阶", "请注意 这棵树当前的形状 可以形容为是汉字中的一撇", "接下来不妨假设 作为一个周期", "我们就按照do re mi fa so la si的次序", "来访问这个树中的各个节点", "首先是do", "在对它一次查找访问之后 我们将通过伸展", "将它推送至树根", "接下来 该轮到re", "同样 在对它访问之后 我们也需要通过伸展", "将它推送至树根", "再接下来 该轮到的是mi", "同样 在对它进行访问之后", "我们也需要通过伸展使之成为新的树根", "好 后续的过程类似", "我们不妨直接来看一下", "fa", "so", "la", "以及最后的si", "请注意 在经过了这样一轮的访问之后", "这棵树的形态 又重新的成为了汉字中的一撇", "刚才的那样一个访问周期", "可以用类似于此的一系列快照来描述", "可以看到 如果这课树的规模是n的话", "那么第一个节点所需要的访问成本应该大致为n", "第二个节点呢 大致为n-1", "而第三个呢 是n-2", "以及n-3 以及n-4", "以及最终的1", "概括而言 整个周期中各自访问", "所对应的计算成本", "是按算术级数变化的", "整个周期的长度为n", "因此根据我们在第一章业已掌握的技巧", "可以推断出 整个周期内", "所需要的计算成本累计", "应该是n^2量级", "这是一个什么概念呢?", "如果将这个计算成本", "分摊到整个周期内的n次操作", "我们就会发现 每次操作的分摊成本", "居然会高达Omega(n)", "这个量 不仅与AVL树的logn相去甚远", "而且反过来不难发现", "它已经退化成了最原始的线性序列", "比如说 list或者vector的水平", "因此 这样一种效率", "以及在背后决定这一效率的伸展策略", "都是不能令我们满意的", "然而好消息是", "问题的根源并不在于伸展本身", "而是在与我们没有把它运用好", "那么我们又应该如何", "在原有的伸展策略基础上 进行改进呢", "我们马上就会看到", "从量上讲 这种改进并不大", "只需要做一处非常非常微妙的改进", "这就犹如画龙点睛那个故事一样", "作为一条龙", "我们目前的伸展策略实际上已经相当完备", "它所缺乏的", "只是能够体现其灵魂的那样一只眼睛", "没错 不是一双眼睛 而仅仅是一只"]}, {"name": "07D3-1 删除：单旋", "block_id": "eb0c6f8195b34a47ad36eded86a89632", "text": ["再来考察AVL树节点删除算法", "比如这就是在节点删除之后", "引起失衡的一种情况", "如果我们同样地将", "失衡的那个祖先命名为g", "那么它之所以在此时会失衡", "是因为此前所摘除的那个节点", "恰好处于它原本就更短的那个分支", "比如说T3的底部", "也就是说 它的平衡因子", "将由此前的+1变成现在的+2", "从而违规", "请注意 这里子树T0和T1的底部", "应该至少有一个节点", "而T2底部的这个节点有可能存在", "也有可能不存在", "请注意 与插入的情况不同", "在这里 失衡节点g有可能恰好就是", "刚刚被删除这个节点的父亲", "然而无论如何 只要g p v", "这祖孙三代的节点是朝一个方向排列的", "比如 p是g的左孩子 v也是p的左孩子", "那么我们就可以通过一次单旋", "来恢复局部的平衡", "具体来说 也就是围绕这个失衡的节点g", "做一次顺时针的zig旋转", "这个旋转操作的细节", "在此前插入算法中", "我们已经给出过详细的动画演示", "所以这里我们不妨", "直接给出旋转调整之后的结果", "可以看到 局部的子树树根", "由原先的g替换成了p", "而节点v和g", "则分别成为了节点p的左右孩子", "不难验证 经过这样一个调整之后", "在此局部 的确恢复了平衡", "那么故事就此终结了吗？", "我们说有的时候是 有的时候不是", "这里的关键在于 T2这棵子树", "底层那个节点是否存在", "如果它存在 那么我们会发现", "经过这样的调整之后", "子树的新高度", "与此前原树的高度是一样的", "因此与插入算法同理", "在这种情况下 我们可以保证", "在这棵子树以上的每一个祖先", "它们的高度及平衡因子", "都会继续保持原状", "因此不会发生新的失衡现象", "然而问题在于T2的这个底层节点", "有可能根本就不存在", "在这样的一个情况下", "相对于原树的高度", "调整之后新树的高度", "会缩短一个单位", "此时不妨设想这样一个场景", "也就是某一个祖先", "它的另一个分支可能会更高", "换而言之 它此前的平衡因子已经是-1", "因此在原本就更短的左侧分支", "进一步缩短之后", "它的平衡因子将进一步下降到-2", "从而超标", "请注意这个节点在我们调整之前", "原本是平衡的", "而在它下属的后代恢复平衡之后", "它却有可能既而失衡", "我们也可以等效地认为", "这个节点的失衡", "是由于为了消除它后代的失衡", "进而引发的", "这样一种失衡逐渐向上层祖先传播的现象", "也是删除操作所特有的", "当然从算法而言", "这并不是什么了不起的事情", "因为对于这个新的失衡祖先", "我们完全可以套用整个调整算法", "继续使它复衡", "当然 因此有可能又会引发", "更高层祖先的失衡", "极端的情况下", "我们有可能会在每一层都进行一次调整", "累计而言 这种调整可能会多达logn次", "需要指出的是 这样一种估计", "既不是杞人忧天 更不是危言耸听", "我们的确可以构造出这样的反例", "关于这一点 你可以参考教材", "配套习题解析中的[7-17]题", "当然 与插入算法一样", "我们还需要考虑另外一种情况", "也就是g p v这样连续三代节点", "未必是朝一个方向排列的", "如果它们是按照所谓的之字形排列呢？"]}, {"name": "08XA3-2\t双红缺陷", "block_id": "7184d24e6dce413e9c99e0a148dbad51", "text": ["不妨假设 将要插入的是一个新的关键码e", "而且我们也不妨就采用BST的常规插入算法", "于是相应的也会生成一个新的末端节点x", "不失一般性 如果不考察平凡的情况 那么x就不是树根", "这意味着 它的父亲必然是存在的", "于是接下来我们不妨简单的将x染为红色", "这样做的好处是 红黑树的各条规则", "能够尽可能的得到满足 尽管还不能全部满足", "我们不妨来逐条核对一下", "树根节点和所有的外部节点依然是黑的", "在通往各个外部节点的路径上", "黑节点的数目因为没有变化 所以依然保持全局的一致性", "然而遗憾的是 第三条规则却未必满足", "考察这个新插入的红色节点x", "作为末端的叶节点 此时它的2个孩子都是外部节点", "所以的确都是黑的", "然而它的父节点颜色却不定", "在这里为了帮助那些辨认颜色有困难的同学", "我们不妨约定 圆形都对应于红色的节点", "而方形则对应于黑色的节点", "那么八角形呢 对应的就是颜色仍不能确定的节点", "当然它必然有一种颜色 可能是黑 也可能是红", "此时 节点x的父亲p 就是这样一个可黑可红的节点", "如果它的确是黑的 那么第三条规则 也同时满足", "整个插入操作即可成功返回", "然而问题在于 节点p的确可能原本就是红的", "比如这样一种情况", "细心的你 可能已经注意到", "我们这里对边的画法是不完全一样的", "是的 凡是指向黑色节点或者至少颜色还不定的节点的边", "我们都用实线来表示", "而反过来所有指向红色节点的边 都用虚线表示", "这种方式 可以更好的帮助我们思考和分析", "因为这类虚边 在经过提升变换之后", "都会变成是水平方向", "是的 新插入的节点x与它的父亲p 同时为红色", "这是红黑树的规则所禁止的", "这样一种非法的情况 也因此称作双红缺陷 double-red", "那么如何来修复这种双红缺陷呢", "我们首先要考察x的祖父节点g", "请注意此时的g 必然是存在的", "否则作为树根的节点p是不可能为红色的", "进一步的 作为红色节点p的父亲 节点g也必然是黑色的", "此外 我们还需要考查g的另一个孩子u", "形象的类比 相对于节点x 这个节点u是它的叔父uncle", "当然节点u的颜色 也是不定的", "因此以下我们就根据这个节点u的颜色分2种情况分别处理"]}, {"name": "08B3-4\t主次成本", "block_id": "3960f064f20d437f96d0122596e9186d", "text": ["那么按照以上的策略 以及实现方式", "B树的查找算法 需要运行多少时间呢", "无论是从刚才的代码 还是从这张示意图", "我们都可以看出 对B树的查找", "依然是一个逐层深入不断减而治之的过程", "而且在每一个层次上 至多只会涉及到一个节点", "因此 影响整个查找算法效率的最主要因素应该是树的高度", "那么在每一个高度层次 我们都需要做哪些工作呢", "我们所消耗的时间 都去哪了呢", "无非两个方面 第一就是这些灰色线条", "也就是为了读入对应的节点所进行的IO操作", "我们已经详细的分析过 就单次操作而言", "此类操作要远远的慢于任何一次内存的操作", "因此这方面的时间消耗 也构成了我们在每一层次上所需时间的主体", "而另一方面呢 无非是在每个节点内部进行的顺序查找", "没错 是顺序查找", "尽管在我们刚刚给出的具体实现中", "这部分查找都是通过向量内在的查找算法予以实现的", "你应该记得 对于这种有序向量", "完全可以采用性能更高的查找 比如二分查找", "但是鉴于内外存访问在速度上的巨大差异", "这种优化的效果 实际上是微乎其微的", "甚至反而可能是有害的", "这背后的原因非常值得细细的体位和把玩", "我们此前介绍过 为了与IO操作的延迟相匹配", "每一个节点的大小应该尽可能设计为与一次IO对换的页面大小相匹配", "通常这个数值大致为若干个KB", "因此每个节点内所含关键码的数目都大致取做几百", "而实验结果表明 对于如此规模的有序向量", "相对于顺序查找 二分查找的效率反而更低", "接下来的一个问题就是 B树的高度h", "与关键码的数目n之间是一个什么样的关系呢", "可以预期 渐近的应该依然是logn", "那么关键是 常系数又会有多大的区别呢"]}, {"name": "10c-4:\t实例", "block_id": "e283ca51b8fc455bbf8a8fd6475bd5e6", "text": ["我们来看堆排序算法的一个具体实例，考察这样一个规模为5的向量，", "我们首先从逻辑上将它视作为一棵完全二叉树，", "其中有两个内部节点，也就是2和4，", "于是我们采用Floyd算法分别对2和4分别做一趟下滤，即可最终得到这样一个完全二叉堆。", "至此，也就完成了算法的预处理步骤，", "接下来我们进入算法的主体循环，", "请注意在一开始整个向量都是未排序的部分，", "而已排序的部分初始为空。", "即便如此，我们依然可以使用算法的基本策略，", "也就是令当前的堆顶与末元素互换位置，", "互换之后的瞬间应该是这样，原来的末元素2成为了堆顶，", "而5则在逻辑上从原来的堆中分离出来，加入原本为空的S。", "也就是说，已排序的序列此时已经拥有了第一个元素。", "当然，我们还需要对新的堆顶做下滤调整，", "从而使得剩下的4个元素依然恢复为一个堆，尽管规模减少了一个单位。", "不出意外，接下来的最大元4也成为了新的堆顶，", "因此在下一轮迭代中，我们依然将这个新的堆顶与当前的末元素互换位置，", "在逻辑上这等效于将堆顶摘出，并归入到有序序列中。", "同样我们仍需对新的根节点做一次下滤调整，", "从而使得剩余三个元素能够继续保持为一个合法的大顶堆。", "不出预料，当前尚未排序的元素中的最大者3也必然就是堆顶。", "因此，我们也只需令它与当前的末元素2做一次对换，", "在逻辑上这依然等同于将这个堆顶摘出并归入到有序序列中。", "此后再经过一轮下滤调整，剩余元素也依然会恢复为一个合法的大顶堆，", "尽管此时已经只剩最后的两个元素。", "为了节省时间，我们把这部分内容留给你在课后独立完成。"]}, {"name": "08XA4-4\tBB-1", "block_id": "146950dd55244649b896d7a65d3aef54", "text": ["首先 来看第一种情况 如果将双黑称作BB", "那么第一种情况的代号就是BB-1", "这种情况的特点是 r或者是x的兄弟是黑的", "同时它至少有一个红色的孩子 记作t", "当然这只是这种可能下的一种情况", "好在其余的情况都与之对称或相似", "因此同样不失一般性", "这里同样请注意有3个节点 以及4棵子树", "而此时我们借用的方法就是", "对此局部进行一次3+4重构", "比如 对于这个不失一般性的情况而言", "调整的结果 应该是这样", "可以看到 r继续保持黑色", "而t和p都将变换为或保持为黑色", "而s呢 将继承此前根节点p的颜色", "至此 你不妨稍事暂停", "对此局部子树各分支的黑深度做一核对", "你会发现 所有分支的黑深度完全一致", "而且同时 也延续了此前各分支的深度", "当然为此需要注意到的一个重要事实是", "这里的4棵子树其黑高度 都是一样的", "因此如此调整之后", "红黑树的所有性质 都在此局部乃至全局得以恢复", "我们的删除操作自然也可以大功告成了", "当然 这一转换方法 并非偶然", "在其背后有着深刻的原理", "那么这一原理 是什么呢", "没错 同样还是B树", "因此接下来 不妨就让我们转到B树的角度", "来反观这种变换的效果"]}, {"name": "10b3-1: \t算法", "block_id": "12421ba26c7647e9a5f8ef085d9d4ce8", "text": ["接下来的这一节我们来讨论一下完全二叉堆的元素删除算法。", "我们知道，对于优先级队列而言，内容读取操作只限定于特定的节点。", "具体来说，只能是获取最大元或者删除最大元。", "我们也知道，得益于堆序性，完全二叉堆中的最大元必然就是堆顶。", "因此，如果只是需要获取这个元素，我们只需常数的时间。", "然而为了删除这个节点，我们却需要做更多额外的工作。", "首先，我们自然是将这个节点在物理上摘除掉，", "当然此后在逻辑上这就不再是一棵结构完整的完全二叉树。", "为尽快恢复结构性，我们不妨将末元素移送到首元素的位置上，以取代这个被摘除的堆顶。", "经如此处理之后，结构性的确得以恢复，然而堆序性却有可能因此遭受破坏。", "我们来观察一下，在将末元素前移至堆顶之后，", "在那些位置有可能会违背堆序性呢？", "从图中不难看出，唯一的可能只能是这个新的堆顶节点与它的孩子们违反堆序性。", "那么，如何加以修复呢？", "没错，交换。", "如果e的确小于它的至少一个孩子，我们就将它与其中更大的那个孩子互换位置，", "交换之后的情况应该是这样。", "可以看到，在经过这样一次交换之后，在最高的层次上已经不再会出现逆序的情况。", "当然，其它的节点也依然会维持原有的堆序性。", "然而故事可能依然没有完结，因为下降一层之后的e又会有新的孩子，", "而且如果不幸，它有可能至少会小于两个孩子中的某一个。", "你看得出来如何解决这个新的难题吗？", "没错，依然是交换。", "在这种情况下，我们需要将e和它更大的那个孩子进行交换。", "就这个例子而言，交换的结果应该是这样。", "当然，经过这样的一次交换之后，在这个层次以上的所有逆序缺陷都应该得以修复。", "然而不幸的是，在e下降一层之后，在接下来的这个层次上会有可能再次发生逆序。", "不过我们对此已经习以为常了。果真出现这种情况的话，我们也可以故伎重演，", "令e和它更大的那个孩子进行交换。就这个例子而言，交换之后的结果是这样。", "当然这种情况的确可能会再次的以及持续的发生下去，", "不过不要紧，每次出现这样的情况，我们都可以通过交换加以解决。", "与节点的插入过程相仿，这里也存在某种单调性。", "在原本最底层的节点e被前置为堆顶之后，每经过一次交换，它都会下降一层。", "这就意味着尽管逆序的情况有可能持续地发生，但问题出现的高度必然会持续地下降。", "因此这样一个过程也形象地称之为“下滤”(percolate down)，", "正是得益于这种不断下降的单调性，我们才可以保证这个算法必然终止。"]}, {"name": "07B1-3 查找：理解", "block_id": "aa064f5687ed4fd28875a31d3b1faa0e", "text": ["我们的查找首先是对根节点", "进行一次比较", "在有序向量中", "这对应于以某个轴点为基准", "进行一次比较", "这次比较的结果", "既可以认为是摒弃掉整棵树的左子树", "同时也可以等效地认为是摒弃掉", "整个向量的左侧子向量", "当然也包括根节点", "以及轴点本身", "而接下来我们所做的决策", "也就是深入到BST的右子树中", "这也可以等效地认为", "在有序向量中", "我们将搜索的范围有效地收缩到", "它的右子向量中", "以下过程只不过是刚才那一步骤", "在不同尺度上的简单重放而已", "每一次我们都会摒弃掉", "一棵子树或者等效的一个子向量", "并且深入到对应的另一侧子树", "或者说另一侧子向量", "每次对新的根节点的比较", "也相当于在向量中", "对新的轴点进行比较", "如此往复", "直到最终收缩为仅含一个元素", "其实对于并不存在的关键码", "所做的查找", "虽然会以失败告终", "但整个过程相仿", "比如在这棵树中搜索23", "我们依然会在16这个位置向右", "并且在25这个位置向左", "并且在19这个位置向右", "直到最终到22这个位置", "我们依然试图向右", "但是此时已经无路可走", "在这样的一个情况下", "也就是我们可以判断整个查找", "失败的时机", "与成功的查找相比", "无非增加了最后一次额外的判断而已", "本质上没有任何区别", "不难看出 在这个算法的背后", "也就是我们已经熟知的", "减而治之策略", "具体来说 这里不过是通过", "一次又一次的比较", "逐步地缩小整个查找的范围", "直至最终抵达平凡的情况", "通过刚才我们对中序遍历序列的比照", "也可以看出", "整个过程也可以等效地视作是在仿效", "此前有序向量所行之有效的那种", "二分查找的策略", "那么这样一个策略以及查找的过程", "如何具体地实现为代码呢？"]}, {"name": "10a1-3: \t功能接口", "block_id": "e3f869c3599a4ac6bb3882200277c2a3", "text": ["以下，我们首先给出priority queue的接口规范。", "没错，操作接口规范，还不是具体的算法。", "因为根据以上所归纳的典型计算模式，", "这里所需要的优先级队列首先可以看作为抽象数据类型(ADT)，", "至于它的具体实现方式以及适用的场合，我们将在随后详细介绍。", "既然只是一个待实现的接口，", "在这里我们就为每个接口增加\"virtual\"前缀修饰符，并将它们都设作0，", "从而使之成为所谓的“纯虚函数”，", "以便强制要求随后给出具体的实现。", "而单纯地就形式而言，这里的操作接口无非是三个：", "通过getMax()，我们可以随时取出在当前优先级最高的词条，", "而在这个数据项接受完处置之后，", "我们则可以通过delMax()将它从整个数据集中删除掉——", "就像病人在接受治疗之后可以随即离开医院一样，", "这也是整个数据集动态变化的一种可能。", "当然还包括对称的另一种可能：也就是有时候我们需要引入新的数据项，", "因此我们可以借助insert()接口，", "这就犹如一位新来的病人加入到门诊室的候诊序列中。", "从某种意义上讲，优先级队列也是对我们此前所介绍过的栈和队列的推广，", "相应地，栈和队列也可以看作是priority queue的特例，", "在这两类数据结构中，各元素的优先级都是一成不变的，", "完全取决于他们在这个集合中的插入次序，", "具体来说对于栈而言，越是晚到的元素，优先级越高，", "因此也更早地出栈并接受处置，", "而队列则与之恰好相反，越是更早到达的元素，优先级越高，", "因此也更早地出队并接受处置。", "那么具体地，这样一组ADT操作接口又当如何具体地实现呢？", "不同的实现效率又是如何的呢？", "不同实现方法各自又适合于哪些应用场合呢？"]}, {"name": "11b2-2: \t版本一", "block_id": "db805890c4f142678e1923b188e5164b", "text": ["上述的蛮力算法 至少有两种实现的版本", "因为由它们 可以很方便地分别导出后续更为高效的算法", "因此 我们这里不妨对它们都作一介绍", "这两个版本对外的接口都是一样的", "按照我们这里的命名习惯 入口参数P和T 分别指向模式串和文本串", "而且在这里 我们采用了最为基本的字符串表示方法", "而且约定 在每一个串的末尾 都有一个数值为0的哨兵", "而且按照我们一贯的约定 串长并不计入尾部的这个哨兵", "为了分别指示在模式串和文本串中当前的字符位置", "这里还需要使用两个整数 i和j", "在后一版本中 我们同样会用到这样的两个整数", "但它们的语义却不尽相同", "这也是前后两个版本的本质区别所在", "如这个图所示", "在这里 i和j所指示的 分别是当前主串中与模式串中 接受比对的那样一对字符", "因此 二者同时初始化为0 也再自然不过了", "算法将两个串逐位对齐 并进行比对的过程", "兑现为这样一个while循环", "正如刚才所介绍的", "在每一对齐位置 我们都需要将文本串与模式串的当前字符取出", "并将二者作一比对", "如果相等 则令两个整数携手并进", "从而分别指向下一对字符", "否则 则意味着失配", "你应该记得 此时我们应该令模式串相对于文本串向后滑动一个字符", "并重新对齐", "为此 对于j而言我们只需令其复位为0", "那么 文本串的指针i呢", "为了确定指针i的更新方法 我们需要重新回到这幅图", "这幅图告诉我们 在算法的任何一个时刻", "模式串相对于文本串的对齐位置 都是由i和j的差来指定的", "因此 既然j的更新 等效于其在数值上减少了j", "i的更新 也就应该等效于其在数值上减少j-1", "如果能悟到这一点", "也就自然可以理解 在这里对i的更新方法了", "总而言之 这里的if相当于在保持相对位置不变的情况下", "去比较每一对字符", "而else才对应于P与T之间的相对滑动", "我们再来考察这个循环的退出条件", "不难看出 有两种情况", "无论是j越过了它的上界m", "或者i越过了它的上界n", "这个循环都会随即退出", "你能看出 这两种情况分别对应于什么吗", "没错 分别对应于整体的匹配成功与否", "为此我们需要注意到这个算法的另一个不变性", "考察这里作为指针的整数j", "实际上 在整个算法过程中的任何一个时刻", "j的数值就对应于在当前的对齐位置下 已经做过的成功比对次数", "因此 一旦j达到它的上界m", "也就意味着模式串中的这m个字符 都得到了匹配", "这难道不正是一次整体的匹配吗", "在这种情况下 我们返回i-j 是再自然不过的了", "因为通过它 可以向这个算法的上层调用者报告", "就在文本串的这个位置", "发现了一处完全匹配", "我们再来考虑i越界的情况", "因为i是逐一增加的", "因此 它在越界的时候必然会恰好等于n", "而此时的j依然处于合法的区间", "综合这两个条件不难得知", "而在这一分支退出时 返回值i-j必然会大于n-m", "我们知道n-m应该是模式串相对于文本串而言 能够对齐的最靠右、也是最后一个位置", "因此 这时的i-j既然已经超越了这个合法的位置", "这个算法的上层调用者自然就可以据此断定 整个匹配是以失败告终的", "总而言之 在这里通过简明地返回对齐位置i-j 就可以准确地向算法的上层调用者报告", "究竟是匹配成功还是失败"]}, {"name": "06B1-9 综合评价", "block_id": "e8d5e7d006264b18926357c0539f0c14", "text": ["好了", "现在到了可以对邻接矩阵表示法", "做一概括和总结的时候了", "我们可以看到", "这种方法非常的直观", "也非常易于理解和实现", "所以相应地 也具有很多", "独特的优点", "比如我们已经看到的", "它的适用范围非常地广泛", "无论是有向图", "无向图 还是混合图", "以及是否是带权图", "包括是否拥有自环", "都可以通过邻接矩阵表示", "而且尤其适用于所谓的稠密图", "因为这里既然已经为所有潜在的边", "都预留了一个实际的单元", "所以我们自然希望", "每一个单元都真实地对应于一条边", "从而能够充分利用整体的空间", "另外 从操作效率上讲", "邻接矩阵也有很多诱人之处", "很多操作 包括判断是否有连边", "以及获取各个顶点的度数等等", "都可以在常数的时间内完成", "最后得益于我们此前", "所实现的向量结构", "良好的空间控制策略", "以及通过封装以后", "对空间溢出等特殊情况的", "透明处理", "我们所实现的邻接矩阵", "具有非常好的扩展性", "当然邻接矩阵表示法的缺点", "也是显而易见的", "最主要的一点", "就体现在它的空间性能", "我们注意到无论图中", "实际所含的边数有多少", "这种表示法所消耗的空间量", "总是固定为最大值n平方", "而与实际的边数无关", "当然 如果我们的实际边数", "能够达到这种规模", "那自不在话下", "如果这个数要远远地小于n平方呢？", "就必然意味着", "有巨大的浪费", "那么在实际应用中情况又如何呢？", "真的会出现这么多条边吗？", "我们可以说明边数实际上往往", "并不会达到这么多", "而是会远远地小于最大的n平方", "这样一个界", "我们来考虑一类特定", "但又不失一般性的图", "也就是所谓的平面图", "所谓的planar graphs", "也就是那些可以嵌入于平面的图", "简单地说 所谓嵌入于平面", "也就是将图绘制在一个平面上", "比如你的一张足够大的纸上", "当然这里有一个条件", "不相邻的边不能相交", "因此这个是平面图", "这个依然是平面图", "而这个 因为这两条", "不相邻的边是相交的", "而且也没有办法回避这种情况", "所以它并非平面图", "同样地 这样一幅图", "也不能够在不相邻的边", "互不相交的前提下", "绘制于平面上", "所以也不属于平面图", "实际上 平面图所具有的本质特征", "可以由欧拉公式来表示", "也就是说 对于任何一个平面图来说", "其中0维的元素", "也就是顶点的数目", "以及1维的元素 也就是边的总数", "以及2维的元素 也就是区域面片的总数", "以及连通域的总数", "必然会满足这样一个", "简明的恒等式", "从欧拉公式出发", "我们不难证明这样一个结论", "也就是说 对于平面图而言", "从渐近的意义上讲", "边的总数不可能超过顶点的总数", "如此说来 对于这类图", "我们预备了n平方的空间", "但实际上有效的", "只不过是O(n)量级的比例", "大致来说", "整个空间的利用率", "是n分之一", "随着n的增加", "这样一个比例会很快地趋近于0", "这也意味着极其低下的空间利用率", "关于这一结论的详细证明方法", "可以参考教材", "所配套习题解析中的6-3题"]}, {"name": "10b3-3: \t实现", "block_id": "6afc3c2a50ef42a6a8c196f9692f39ba", "text": ["这里，我们就给出完全二叉堆节点删除算法的一种可能的实现。", "按照我们刚才的设计，首先需要取出堆顶元素进行备份，以便最终返回。", "接下来需要将末元素前置为首元素，暂且充当堆顶的角色。", "以下我们需要调用percolate down算法，在一棵规模n的完全二叉树中对根节点实施下滤，", "从而使得这棵完全二叉树成为一个名副其实的完全二叉堆。", "以下是下滤算法的具体实现，", "我们不妨再次重复一下这个算法的语义，也就是在一棵规模为n的完全二叉堆，", "对秩为i的元素实施下滤，", "与上滤过程一样，下滤过程也是一个反复迭代的过程，", "在这个过程中的每一步，在节点i以及它最多两个孩子中找出最大者j，", "只要i不是j，那么就至少有一个孩子要比i大，堆序性在此处没有满足，", "这种情况下正如我们设计的那样，只需令i以及它更大的那个孩子彼此互换，", "这个循环有两种退出的可能：第一种可能是i大于它的任何一个孩子，", "另一种则是i持续下滤到最底层，并成为一片叶子，", "这个条件是由这个名为ProperParent的宏隐式给出的，这一点你可以通过阅读代码自行加以验证。", "总而言之，一旦while循环退出，我们即可返回当前的下滤终点，整个算法也随即大功告成。", "这个算法的正确性不难理解，而接下来更为重要的问题自然又是这个算法，或者更准确地讲，", "这个主体循环需要耗费多少时间呢？", "其总体的效率是否和插入算法一样，也能达到我们的设计目标呢？"]}, {"name": "12b1-1: 选取 + 中位数", "block_id": "11d483cc5f2c426a873ffbfbed8d3395", "text": ["同学们好在接下来的这一节", "我们将讨论由排序问题", "衍生和推广而来的一类问题", "也就是所谓的选取问题Selection", "这类问题的共同特点是", "需要从一组大小可以相互比较的元素中", "找到某一个特殊的元素", "比如找到其中由小而大", "列于特定次序位置上的一个元素", "或者找出其中在数值大小上", "恰巧列于中间的那个元素", "当然只要我们已经得到了", "整个数据集所对应的排序序列", "以上问题自然都可以迎刃而解", "然而正因为排序计算自身的高复杂度", "我们在此不得不绕开它", "并转而寻找更为有效的算法", "而在接下来的这一小节", "就让我们首先来讨论如何选取众数", "如果我们需要从一组大小可比较的元素中", "选举出次序列在DK位置", "我们就称对应的选择问题为", "K-selection", "比如在包括Excell在内的", "各种数据分析软件中", "往往就会提供这样的命令甚至函数", "这类功使得我们可以在", "尚未对所有元素进行全排序之前", "找出其中按大小次序", "列在第K位置", "K选择问题中的一个特例", "就是所谓的中位数median的问题", "也就是说要从一组元素中", "找出按大小恰好列于中间位置的", "那个元素", "在Excell等数据分析工具中", "同样也提供了对应的功能或函数", "具体来说如果所有元素的秩", "隐式的可以由0到n减1来表示", "那么所谓的中位数", "也就是其中秩为", "二分之N下整的那个元素", "比如在秩为零到6的七个元素中", "所谓的中位数", "也就是其中秩为三的那个元素", "除了它自身", "在它的左和右侧各有三个元素", "又如在0到7", "这样八个元素中", "中位数的秩应该为4", "也就是说在它的左侧有四个元素", "但在它的右侧却只有三个元素", "我们稍后就会看到中位数问题", "虽然是K选择问题的一个特例", "但实际上也是其中难度最大的一类问题"]}, {"name": "09D2-6 4k + 3", "block_id": "f4a642e625b44993a3a92c2253e873ff", "text": ["是的 除了2之外 所有的素数无非两类", "取决于它们关于4的模余", "有些素数关于4的模余为3 比如3自己", "以及我们刚才举例的7和11", "也包括19 23 31 诸如此类", "当然剩下来的那些 关于4的模余只能是1", "比如同样我们曾经举过例5和13以及17 29等等", "经过这样的分类 你或许能发现什么", "是的 刚才我们所举的两个好例子 也就是7和11", "关于4的模余都是3", "而糟糕的那两个实例 也就是5和13", "都属于模4余1的那类", "实际上 在使用双向平方探测时", "我们给你的建议是 应该将表长M", "取做那类模4余3的素数", "这样就可以确保查找链的前M项必然是互异的", "如果没有提前分析过以上的实例", "而是直接给出这个建议 你或许会觉得一头雾水", "是的 这个建议听起来的确有些蹊跷", "然而你的问题或许还不止于此", "是的 还有另一方面", "也就是那些模4余1的素数 就注定不能使用吗", "下面我们就一并来回答 这正与反两个孪生的问题", "需要说明的是 这个证明多少需要用到一些数学", "所以如果你对数学不是很感兴趣", "那么我的建议是你不妨直接记下我们刚才所给的这个建议"]}, {"name": "05E5-3 (先序+后序)x真", "block_id": "710d2102bc4344dd8e4b895667653446", "text": ["当然在某些特定的情况下", "由先序和后序遍历序列", "的确也可以还原树的整体结构", "比如对于所谓的真二叉树", "就是这样", "你应该还记得 所谓的真二叉树", "其中每个节点的度数都必须是偶数", "确切地来说", "除了0 就是2度", "而1度的节点是严格禁止的", "因此非退化的真二叉树", "模式无非如此", "请注意 此时的左子树和右子树", "要么同时为空", "要么同时非空", "前一种情况显而易见", "因此我们不妨假设它们都存在", "于是这棵树的先序遍历序列", "形式必然是这样", "而后序遍历序列", "形式也必然是这样", "也就是说先序遍历序列", "首先出现的是根节点", "以及以左子树根节点引领的", "左子树遍历子序列", "以及接下来以右子树的树根引领的", "右子树遍历子序列", "而后续遍历序列呢", "必然是以根节点收尾", "再往前是以右子树的", "树根节点收尾的", "右子树所对应的遍历子序列", "以及以左子树的树根收尾的", "左子树的遍历子序列", "现在请留意左子树的树根节点L", "根据刚才的分析", "这个L在先序遍历序列中", "必然名列第二", "位置是确定的", "因此反过来", "在任何给定的先序遍历序列中", "我们都可以便捷地找到它", "并且进而在后序遍历序列中", "对它进行定位", "如我们刚才所言", "这个节点在它所属的", "这棵子树的后序遍历", "子序列中必然垫后", "这就意味着我们可以明确地", "界定左右子树的范围", "也就是说 左子树由哪些节点构成", "以及右子树由哪些节点构成", "都是可以确定的", "当然对称地", "在后序遍历序列中", "右子树的树根位置也是确定的", "因此通过右子树的树根节点", "依然可以反过来", "在先序遍历序列中进行定位", "而且同样地可以确定", "左右子树的切分位置", "也就是说 我们在这里", "确实可以进行分而治之", "从而通过递归的形式", "完整地重构出一棵真二叉树", "原本的结构"]}, {"name": "08B2-2\t多路平衡", "block_id": "01fb15af85e14d8cab696c96f5a733a4", "text": ["正如我们已经看到的", "B树的设计者将其定义为一种平衡的多路搜索树", "这样一种多路的搜索树", "与我们此前所熟知的二路搜索树在本质上讲 其实是等价的", "如果我们将多路搜索树中的每一个节点称作超级节点的话", "那么每一个超级节点都可以认为是", "由若干个二路节点经过适当的合并以后得到的", "来看这样一个实例", "如果我们忽略掉这些方框", "不难看出这其实就是一棵二叉搜索树的局部", "现在我们两层两层的来考察其中的这些节点", "具体来说 每一个节点以及它的左和右孩子", "如果我们将每一组这样的父子三个节点合并成一个超级节点", "那么整棵树就可以等价的变换为这样一种形式", "具体的 原先的父节点居中", "原先的孩子则经过提升与之并行的列于左右", "这种节点的确可以称作是超级节点", "因为其中不再只含有一个关键码 而是多个", "就这个例子而言 每个超级节点都含有3个关键码", "同时相应的也就拥有4个分支", "可以看到 如此每两代两代的合并之后", "每个节点都将拥有3个关键码 以及4个分支", "推而广之 我们也可能每3代的合并起来", "从而使得每个超级节点里含有7个关键码以及8路分支", "一般的 如果每d代都进行一次合并", "那么每个超级节点都将拥有2的d次方路分支", "以及相应再减少1个单位的关键码", "同样的 这里依然存在一个问题", "既然我们已经看到 这种多路的搜索树", "与我们此前的二路搜索树 并没有本质的区别", "那么为什么还要引入B树呢", "这依然是我们需要回答的一个问题"]}, {"name": "08XA2-1\t定义规则", "block_id": "8dc42061c62742f9a44a612d0d55ea17", "text": ["同学们好 接下来我们就来看看所谓的红黑树", "到底是如何定义的 以及按照这种定义它是否的确是BBST", "实际上 在其研究和发展的历史过程中", "红黑树曾经有过不同的名称", "也曾从不同的角度给出过等价的定义", "那么这里呢 我们只给出其中之一", "为了便于讲解甚至实现红黑树", "我们需要对红黑树的模型 做一个小小的扩充", "具体来说 与B树的处理手法一样", "我们需要通过增设一系列的外部节点", "保证红黑树是所谓的真二叉树", "也就是说 其中的每个内部节点都有2个孩子", "尽管其中之一 甚至两个都有可能是我们新增的外部节点", "我们这里对红黑树的定义 可以概括为4句话", "首先如果红黑树非空 那么根节点必然为黑", "其次我们刚刚统一增加的所有外部节点 也是黑色的", "尽管它们实际上根本不必存在", "如果将红黑树比作人 那么这两条就可以概括为", "他戴的帽子以及穿的靴子 都是黑的", "那么其余的节点呢", "实际上只有红节点才需要有所约束", "它只能有黑色的孩子", "这条约定虽然简明 但实际上蕴含了很多性质", "比如不可能出现同时为红的父子两代", "因此这条规则更具操作性的一种等效表述为", "对于红节点来说 无论是它的孩子还是父亲都必须是黑的", "稍后我们就会看到 这条规则", "对于控制红黑树的深度 是极其重要的", "而接下来的这条呢 可以认为是旨在控制红黑树的平衡性", "因为这里要求 在从任何一个外部节点通往树根的", "这条唯一的路径上 黑节点的数目必然都是一样的", "听到这里 你或许会感到非常困惑", "是的 如此约定的一系列规则", "到底对应于一棵什么样的树呢", "这些规则背后又有什么更为简明的用意和原理呢", "我们不妨来通过一个实例 先回答第一个问题"]}, {"name": "08A2-7\t最后一步", "block_id": "777fb6ead371496a816efab8ad52aca8", "text": ["当然从完整性的角度来看 还有一个细微之处需要补充", "也就是如果v的深度是奇数而不是偶数", "那么在最终必然会发生一种情况 也就是v只有父亲而没有祖父", "此时节点v的父亲 就应该是全树的根", "我们说这个问题并不严重", "因为毕竟这种情况只可能在整个伸展过程中出现一次", "而且只会出现在最后", "果真出现这种情况 我们就可以视具体的形态", "也就是v此时究竟是左孩子还是右孩子", "相应的做一次zig或者是zag旋转", "既然这种情况在整个伸展的过程中 只会出现一次", "因此从渐近的意义而言 并不会实质的影响整个调整过程的复杂度", "至此我们应该能够理解Tarjan所建议的这种双层调整的策略", "不仅是完备的 而且是行之有效的", "那么这样一种双层调整的策略 又当如何具体实现呢"]}, {"name": "11d1-3: 前轻后重", "block_id": "8a1b9154ac0b473ba38604ee6d15af63", "text": ["我们依然来考察蛮力算法的一次典型执行过程", "假定在依次排除了一系列的对齐位置之后", "我们抵达了下一个对齐位置", "此时我们有两种策略", "或者优先去比对靠前的字符", "或者反过来 优先比对靠后的字符", "这里 我们再次强调一下", "只要字母表的规模不是很小", "那么就每一次字符对字符的比对而言", "成功的概率将远远小于失败的概率", "也就是说 我们更有可能获得教训 而不是经验", "果真如此 在前后这两个位置所获得的教训", "其价值大小又有何区别呢", "的确有所区别", "而且很大", "其背后的原因在于", "根据这样的每一次教训", "我们不仅可以排除一个对齐位置", "而且可能排除掉多个对齐位置", "比如 根据在前一位置所获得的教训", "我们或许可以同时排除掉3个对齐位置", "而不是1个", "类似地 在后一位置所获得的教训", "则有可能帮助我们排除掉更多的对齐位置", "远远更多的对齐位置", "是的 如果就这类教训对我们提高计算效率的意义而言", "的确呈现出前轻后重的特点"]}, {"name": "10b3-2: \t实例", "block_id": "876599d52ffc46698b69330f8ea98d31", "text": ["我们来看一下这样一个具体的实例。首先确认，这的确是一个完全二叉堆，", "而且按照我们的习惯，上边是我们的逻辑结构，下边是对应的物理实现。", "不出意外，这个数据集中的最大元5的确位于堆顶，或者说在向量中是首元素。", "现在就假设我们需要将这个最大元摘除掉。", "按照刚才所设计的算法，为了在此后尽快地恢复结构性，我们需要将它的末元素1", "放在堆顶的位置取而代之。", "此时的情况应该如这个图所示：也就是说此前的末元素1的确被前移至堆顶的位置。", "然而正如我们所预期，此前位于底层，相对而言数值更小的元素，", "在被放到堆顶的位置之后，通常都很难胜任堆顶的角色。正所谓“高处不胜寒”，", "比如就这个例子而言，此时无论是它的左孩子还是右孩子，在数值上都要严格地比它大，", "也就是在此局部违反了堆序性。", "所幸的是，在其它的位置，堆序性依然得以延续。", "接下来为了恢复这里的堆序性，按照刚才设计的算法，我们应该在两个孩子之间挑选出数值更大的那个。", "就这个例子而言，自然是数值为4的这个节点。", "于是我们只需令这个节点与它的左孩子4互换位置。", "需要再次提醒大家的是，这种逻辑上的互换在物理上都是在向量的内部完成。", "只不过与其说是交换完全二叉堆的节点，不如更准确地说是交换向量中的元素。", "这次交换之后的情况应该如这个图所示，我们可以看到，在向量内部，4和1在物理上交换了位置，", "而相应的在逻辑上，节点1和4也互换了位置。", "我们可以看到，这样一次交换的确修复了这一层次的逆序问题，", "然而此前惹是生非的节点1在下降了一层之后有可能依然会带来麻烦。", "是的，它依然没有完全符合堆序性。", "我们看到，尽管此时它的右孩子比它要小，但是它的左孩子却依然比它要大。", "为了修复这一缺陷，我们依然需要将违反堆序性的这样一对父子交换位置，这也是最后一次交换。", "因为正如我们在这个图中所看到的，节点1在交换之后已经成为了一片叶子，", "根本没有了后代，因此逆序性也无从谈起。", "因此最终整个数据结构又重新恢复为了一个完全二叉堆。", "那么，这样一个连续不断的逐层下滤的过程又当如何具体实现为代码呢？", "实现的效率又能达到多高呢？"]}, {"name": "08A1-4\t逐层伸展", "block_id": "8041fbf0d410472b955a06b935c3a721", "text": ["根据刚才的分析 下一个刚被访问的节点", "很有可能就是刚被访问的节点", "因此为了提高下一次访问操作的效率", "一种最直接的办法 莫过于将刚被访问的那个节点", "直接移送到根节点位置", "因此我们就得到一个简明的策略", "也就是说 任何一个节点 一旦被访问", "我们都应随即将它转移至树根的位置", "为了实现这样一个目标 我们所能借助的手段", "依然无非是此前所介绍过的等价变换", "具体来说 就是zig和zag变换", "如果节点V在当前这一层是左孩子", "我们就通过对它的父亲 做一次zig旋转", "使得二者在高度上彼此互换", "对称的 如果节点V当前是右孩子", "就对它的父节点P做一次zag旋转", "同样的 经过这样的一个调整之后", "节点V和它的父亲将在高度上 互换位置", "总而言之 无论是经过一次zig旋转 还是zag旋转", "对应的节点V都可以高度上 上升一层", "既然如此 我们不妨反复的使用这一技巧", "使V的高度逐层上升 直到最终抵达树根"]}, {"name": "06D-2 框架", "block_id": "beae909596474718a323699ed10caff6", "text": ["以下我们就给出DFS算法", "一种可能的实现方式", "可以看到 起自顶点v的DFS算法", "从形式和接口看 与BFS算法完全一样", "进入算法之后", "我们依然要将当前的顶点v", "从UNDISCOVERED最初状态", "转化为DISCOVERED", "这等效于我们发现并且访问了这个节点", "因此我们也需要将此时的时钟", "作为标签记录下来", "接下来 又进入了这样一个循环", "我们已经非常熟悉了", "它的作用无非是", "枚举当前节点v的所有邻居", "并且根据这个邻居的状态", "分别加以适当的处理", "我们将具体的处理方法留到下一页", "再做详细剖析", "需要指出的是 与BFS不同", "这里可能含有递归", "但无论如何 一旦当前顶点v的所有邻居", "都已枚举并且访问完毕", "我们就可以将它的状态", "转为最终的VISITED", "另外不同的在于", "我们还需要将此时的时钟也记录下来", "请注意 这是每个顶点的", "另一个时间标签fTime", "这个节点被访问完毕时的时刻", "那么针对于邻接顶点的不同状态", "究竟可以分为几种情况分别处理？", "每一种情况的处理方式又是如何？", "以及为什么要这样处理？", "还有 整体的处理效率如何？"]}, {"name": "03B-1\t 循秩访问", "block_id": "e925d465ce86416db2898738945e3bb6", "text": ["接下来的这节，我们讨论无序列表的", "相关算法", "我们首先关心的一个问题是", "既然列表和向量同属于线性的序列结构", "那么是否可以继续沿用向量那种", "十分便捷也是我们十分习惯的", "循序（也即：秩）访问的方式呢？", "具体说来，对于任何一个名字叫L的列表", "每当我们指定其中一个合法的秩r", "都可以以这样的一个形式来直接引用", "并且访问到对应的这个节点", "我们说答案是可以的", "因为我们可以仿照向量的做法", "对下标操作符进行适当的重载", "具体的方法如下", "对于当前的这个列表", "我们可以重载它所对应的那个括号", "操作符", "接下来呢，如果指定的秩是r的话", "我们就从first node，也就是首节点出发", "不断地沿着succ引用向后行进", "那么总共的步长是多少呢？", "如果指定的秩是r", "那么就是恰好r", "换而言之", "当这个while循环结束的时候", "p就正好处于", "总体秩为r的那个节点的位置", "因此我们只需将这个位置处的数据返回", "由此也可以看出", "整个这个算法的复杂度是取决于", "你所指定的那个秩r的", "具体来说，也就是O(r)", "那么这个效率，我们说是十分低下的", "实际上，这种用法虽然很方便", "但是我们只能偶尔为之", "而不能常用", "我们可以来对它的平均性能", "做一个估算", "假设这个列表的长度为n", "那么正如我们刚才所说的", "对于任何的r所需要的时间都是O(r)", "那么换而言之", "对于第一个元素，我们需要一个单位的时间", "对于第二个元素，需要两个单位的时间", "第三个元素，需要三个单位的时间", "直到最后那个元素需要n的时间", "整体上呢，恰好呈现出一个算术级数的形式", "我们讲过，它的总和是n平方", "而在这个时候总共有n种可能", "每个元素在一般的假设下", "都有均等的n分之一的概率", "被作为那个指定的秩", "所以总体而言的平均就是再要", "乘以这个n分之一或者等效的是，除以n", "我们就可以得到是需要线性的时间", "这样一个性能，无论如何", "我们都是无法接受的"]}, {"name": "10b1-2: \t结构性", "block_id": "cfb33e688cbc4139924ca91f25171ed7", "text": ["比如，这就是一棵完全二叉树。", "可以看到，相对于满树，它的确只不过是在最底层的右侧缺失了连续的若干个节点。", "现在回到优先级队列的实现问题：", "我们的思路是，在逻辑上将优先级队列等同于一棵完全二叉树。", "物理上，我们却可以直接借助更为简明的向量来直接实现。", "没错，通过向量来表示一棵完全二叉树，并且进而实现优先级队列。", "这一思路之所以可行，得益于完全二叉树结构上的紧凑性。", "来看这样一个向量。", "没错，这就是一个向量，只不过为了便于与完全二叉树相对照，", "这里将它切分成了若干段。", "在这个例子中我们不难看出，", "完全二叉树中的每一个节点都与向量中的某一个节点相对应，", "反过来，向量中的每一个元素也都与完全二叉树中的某一个节点相对应。", "更准确地讲，完全二叉树中的节点与向量中的元素是彼此一一互相对应的。", "是的，稍加观察就不难发现，", "在这里逻辑节点与物理元素之间的对应关系，", "与完全二叉树的层次遍历次序完全一致。", "因此我们可以在向量内的各元素之间定义父与子的关系。", "具体来说，对于向量中任意秩为i的元素，", "它的父节点如果存在，其秩就必然等于(i-1)/2，", "比如对于秩为11和12的元素而言，", "它们的父节点不仅存在，而且编号应该为5。", "反过来向量中秩为i的元素如果存在左孩子，", "那么左孩子所对应的秩应当是i*2+1，", "比如对于秩为6的元素而言，它的左孩子如果存在，它的秩应当是6*2+1=13", "6的左孩子为13。", "类似地，任何一个秩为i的元素，它的右孩子如果存在，", "那么它的秩应当是(i+1)*2。", "同样以这个秩为6的元素为例，其右孩子的秩应当是(6+1)*2=14，", "6的右孩子为14。", "由此可见，我们的确可以在向量和完全二叉树之间建立这样的一种对应关系，", "请留意体会这种对应关系的精妙之处，", "实际上在物理上我们没有做任何的改动，所有的元素依然构成一个线性的向量。", "但是，只要我们聪明地变换一下视角，站在这种对应关系的角度重新审视这个向量，", "就会发现它其实的确是个不折不扣的完全二叉树。", "这也为我们实现优先级队列提供了第一种可能。", "因为这种方法在逻辑上借助了完全二叉树，因此我们也将这种实现方法称作\"完全二叉堆\"。", "那么具体地，又当如何将向量的“形”和树形结构的“神”有机地融合起来呢？"]}, {"name": "02A-5\t 复制", "block_id": "fc820a96d327426d81c0834d004c41f7", "text": ["内部操作接口copyFrom()的", "工作原理以及过程", "可以通过这个图来示意", "一般地 我们需要从一个数组A中", "将介于lo到hi之间的元素", "整体复制到当前", "仍然为空的一个向量中", "具体的操作 大概分为两步", "首先在向量内部", "开辟出足够的空间", "接下来 再将区间内的元素", "逐一地复制过来", "这样一个过程可以描述并且实现为", "这样一段具体的C++代码", "我们来看一下", "首先申请足够多的空间", "我们这里再强调一下", "这个区间的宽度可以直接通过", "lo和hi之间的一个减法得到", "之所以能这样", "是因为我们这里包括后面", "都会普遍采用这样的形式", "也就是当我们在描述一个区间的时候", "我们往往是用左闭右开的形式", "所以换而言之", "这个lo是在这个区间中", "最靠左的那个元素", "而hi是在右侧第一个", "不属于这个区间的那个元素", "尽管hi这个元素", "有可能压根就不存在", "但是我们不妨把它", "统一地理解成是一个哨兵", "好 这样的话我们就可以通过", "hi减lo直接得到区间的宽度", "那么有同学可能很细心注意到了", "我们这里头为什么还要乘个2呢？", "也就是说 我们实际开辟的空间", "是我们需要复制的空间的两倍", "而不是恰好那么多", "这中间的原因", "我们在稍后就会介绍到", "它的主要的目的在于", "这样预留了一些空间之后", "就可以使得我们在接下来", "足够长的时间之内", "不会因为有必要扩容", "而打断我们的计算过程", "好 接下来还需要对整个", "这个向量的有效规模", "进行初始化 把它清为0", "再接下来 就是复制过程", "也就是说", "我们对于lo和hi中间的每一个Rank", "都要从A这个数组中", "取出对应的元素", "并将它们顺次的存入到_elem", "对应的区间里面去", "整体这个循环构成了", "这个操作的最重要的部分", "所以我们也可以看得出来", "算法的复杂度主要是来自于", "这样一个循环", "这样的一个主体的复杂度是取决于", "被复制元素的个数", "或者说这个复制区间的宽度", "也可以认为是这个向量", "通过复制 被创建之后的初始规模", "好 这样的话我们就完成了", "向量这种最基本的结构", "作为一种模板类", "它的最基本的一些接口", "在后面 我们将要介绍", "功能更为复杂的其它的接口"]}, {"name": "02E-5\t 综合评价", "block_id": "2304b0b4b1ac431aba9eba746337eec5", "text": ["我们来对起泡排序的各个版本", "做一个综合的评价", "并且做一些延伸的讨论", "首先就效率而言 我们明确一点", "无论是第一章所介绍的算法", "还是这里介绍的两个通用版本", "它们在最好情况和最坏情况的性能", "其实都是一样的", "差异只在于对一般情况而言", "或者说最好的情况出现的概率", "或者是比例 各自有所区别", "另外一个我们需要考虑的", "也是我们此后在此类算法中", "非常注重的一个方面", "就是所谓的stability", "算法的稳定性", "这是对诸如排序算法之类", "算法的一个更为细致的要求", "什么叫稳定性呢？", "这个问题涉及的是", "向量中的重复元素", "就我们这里的这个例子而言", "在其中可能存在三个重复的元素", "三个7", "我们为了以示区别", "分别用下标abc来做标识", "那么在经过排序之后", "从基本的要求来看", "只要是三个7连续地排列就可以了", "但是我们说 这三个7", "分别是原来的哪一个7", "实际上是有讲究的", "在很多算法里头", "实际上是非常敏感的", "如果输出的结果中", "雷同的这些元素", "能够保持它们此前的相对次序", "比如说 像这里的abc依然保持是abc", "那么我们就称这个算法", "stable 是稳定的", "否则的话 如果不能保证", "总是保持这种相对的次序 像这样", "我们就称它unstable", "是非稳定的 不稳定的", "那么 以上的起泡排序算法", "是稳定的吗？", "我们说是的", "原因在哪儿呢？", "如果仔细观察一下刚才介绍的", "那些起泡排序的版本的话", "我们都会发现这样一个规律", "也就是说 其中任何两个元素", "a和b 一般而言", "如果它们的相对位置要发生变化的话", "那么只可能是这样一种场景", "也就是说", "在经过连续地若干次交换的过程中", "它们会从彼此有一定的距离", "而逐渐地相互靠拢", "直到在某一个临界的时刻", "二者会变成相互紧邻", "那么这个场景 接下来也是必然的", "因为它们有可能是逆序的", "所以在紧接着下来的那一趟扫描交换过程中", "它们必然会被检测出来", "而且必然会随之交换彼此的位置", "这是任意两个元素在起泡排序中", "能够交换位置的唯一场景", "前面这步 可以说是一个铺垫", "而这一步才是实质地二者交换位置", "那么在我们这样的一个算法中", "交换位置的条件是什么呢？", "大家如果回过去看的话", "我们会发现 在if语句中", "lo-1和lo这两个相邻元素", "如果要发生交换的话", "条件是 前者是严格地大于后者", "也就是说 它们是严格地逆序的", "所以如果这两个7", "比如说7a和7b", "即使它们能够彼此靠拢", "直到它们变成紧邻", "那根据这样的一个交换条件", "它们也是不可能彼此交换的", "虽然起泡排序可以做大量的改进", "但从最坏情况而言", "它依然是注定也需要O(n^2)的时间", "所以我们非常希望能够得到一个", "即便在最坏情况下", "也能够效率更高的排序算法", "这也是我们下一节所要介绍的内容"]}, {"name": "09B-3 数组", "block_id": "a743219bd9b143fa853fcead3aba2e0b", "text": ["来看这样的一个具体实例", "假设我们现在要某一所高校制作一本电话簿", "也就是说 对于这个学校的每一位老师", "学生以及员工 或者办公室", "都可以通过这个电话簿直接找到对应的电话号码", "现在我们再进一步的假设 还有反过来的需求", "也就是像现在的任何一部智能手机那样", "对于任何一个有记录的电话号码", "都可以及时的给出机主的信息", "那么这样一种需求应当如何来满足呢", "我想略作思考之后", "你很可能就会认为这个问题的难度其实并不高", "是的 表面看来确实如此", "甚至你不需要10行代码就能完成这个任务", "比如你首先想到的很有可能就是数组 嗯 数组", "这种方法的原理可以表示为这样一幅图", "这里由上而下 就是一个线性数组", "而在此区间之内的每一个秩", "都对应于某一个电话号码", "而每一个元素呢 就可以用来记录对应机主的信息", "比如一种方法就是我们通过电话号码确定对应的秩", "找到对应的单元 并根据对应单元所给的引用", "间接的找到对应的机主", "这个是这样 其他的以及每一个单元 都是这样", "你甚至会说 啊这种方法不仅简明而且高效", "因为正如我们所看到的", "从任何一个电话号码找到对应的机主记录", "只需常数的时间", "难道还有比这更高的效率吗", "是的 就时间效率而言 的确如此", "但是不要忘了 同时还有另一个因素需要兼顾", "对 空间", "我们不妨来算一个帐", "就以我所在的清华大学为例", "不妨只考察座机 于是从理论上来说", "清华大学所在的北京市的任何一部座机", "都有可能属于清华", "因此如果采用上述的数组方式", "数组的规模将高达10的8次方 也就是100M", "那么清华大学实际拥有的固定电话又有多少门呢", "据我在10多年前所获得的不完全统计", "大致是在2至3万门之间 不妨粗略的估作为25K", "于是我们就可以大致的估算出空间的效率", "具体来说也就是我们所用的空间总量", "与其中真正有效的数据项之比", "所谓不比不知道 一比吓一跳", "可以看到空间效率只有万分之几", "如此低下的效率是我们万万不能接受的", "这样的实例还很多", "这类应用的公共特点是", "我们需要存储和组织的数据项", "可能来自于一个相当大的空间", "比如对于一个城市而言理论上讲的100M门固定电话", "而在任何一个常规的时刻", "我们所真正需要存储和组织的数据", "只是其中非常非常小的一个子集", "因此即便我们能够开出如此之大的数组", "其空间效率也注定是极低的", "那么如何破解这一难题呢"]}, {"name": "12a4-3: 实现", "block_id": "42c3eb8f04a04cd8a369baed2665ca4d", "text": ["在这里我们就给出", "这个新的partition算法的一种实现", "沿用我们的习惯", "依然将首元素作为候选轴点", "接下来是一个循环", "我们将反复的考察子区间U的首元素", "也就是由K所指定那个元素", "按照刚才所介绍的算法原理", "如果当前的这个元素K", "相对于候选轴点而言更小", "我们就需要将它归入到子序列L当中", "我们刚才讲过", "这可以通过在子序列G的首元素", "与元素K之间的一次交换来完成", "至此你或许会感到疑惑", "是的", "如果当前元素K不小于候选轴点", "又该如何呢", "也就是说这里的if", "按说还应该有一个配对的else", "没错 的确应该有一个else", "只不过这里的else是隐藏的 看不见的", "刚才我们已经分析过", "在else那种情况下", "我们只需简明的令K递增一个单位", "而实际上在刚才if的那个分支", "本来也应该有一个K递增的功能", "既然无论if或else", "我们都需要令K向后平移一个单位", "因此不妨将这两种情况合并起来", "统一记入for循环的更新环节", "如此不仅if分支中的K++可以省略掉", "而更重要的是整个else分支", "也不必显示给出了", "当然在整个循环退出之后", "算法返回之前", "我们还需要另做一次交换操作", "实现候选节点的真正就位", "另外一点需要倒过来补充说明的是", "在算法的入口处", "我们还需要通过在整个序列中", "随机的选取一个元素", "并将它与首元素互换", "实现对候选轴点更为随机的选取", "从而降低最坏情况出现的概率", "如我们此前所介绍的", "与三者取中法一样", "这也是为此可以采用的常见手法"]}, {"name": "02D2-6\t 实例", "block_id": "15663d41c2294ef9bb902307e50a0a1b", "text": ["来看几个具体的实例", "首先关注左侧这个实例", "查找的目标是8", "注意这里，我们不妨取整个这个区段", "也就是lo等于0，hi等于7", "那么在第一次比对", "将取出mi等于0和7之间的中点", "通过取下整，应该对应的是", "秩为3的那个元素，也就是7", "第一次比较是看e，也就是8", "是否是小于7", "我们说是不对的", "所以我会继续地转入else if", "再来进行第二次判断", "也就是，8是否大于7", "或者按照我们刚才所说的习惯", "7是否小于8", "我们说，第二次判断以后才正确", "确实是7小于8", "换而言之，我们的目标", "应该处于这个mi这个点的右侧", "注意为此，我们总共进行了两次比较", "那么接下来呢", "我们要把lo修改为", "指向4，hi保持不变，还是7", "所以接下来的中点", "应该是4加7，整除2，取下整", "所以应该是mi取5", "所以这就是为什么", "对应的下一次比对的对象", "那个mi，A[mi]是9", "好，同样我们来做第一次比较", "也就是e8，是否小于mi，9", "我们说确实如此", "所以经过一次比对", "我们就可以进一步地将注意力", "集中到当前这个mi，也就是9的左侧", "相应地，要移动右侧的界桩", "也就是将原来的lo保持下来", "右侧的界桩变为是5", "好，再下一步取的mi", "应该是5和4相加以后除2的下整", "也就是4", "所以对应的是这个元素", "好，在这个位置上，我们首先来判断", "8是否小于8", "我们说肯定不是", "接下来else if", "反过来，这个8是否小于这个8", "我们说也是失败", "所以我们接下来就可以", "else of else，马上可以断定", "我们在这个位置成功的匹配", "需要注意的是", "在这个地方，我们将8和8", "做了互相对称的两个方向的，两次比较", "所以累计而言，我们总共做了五次比较", "才最终在第四个元素这个位置上命中", "我们再来看另一个", "也就是失败的情况", "同样在一个有序向量中，我们去查找", "只不过这次的对象是3", "也跟刚才一样，第一个mi", "是秩为3的这个元素", "通过一次比较发现", "目标元素3是小于7的", "所以我们深入到左侧", "具体来说，也就是lo保持不变", "hi转移到3这个位置上", "接下来呢，再来取新的mi", "也就是0加3除2下整", "也就是1号这个元素", "确切地讲就是4", "同样地，3和4", "经过一次比较以后，因为比它小", "所以我们继续移动右侧的界桩", "左侧的界桩继续保持不动", "再接下来呢", "又要将3，来看是否它小于2", "我们说是不对的", "接下来，要倒过来看", "2是否小于3，这个时候才成立的", "所以收缩到一个更小的区间", "实际上，已经是非法的区间", "我们要把这个lo", "也就是左界桩", "移动到这个mi的右侧", "其实lo和hi，这个时候都等于1", "这个区间，如果是显式地写出来的话", "就是[1，1）", "我们说，实际上它等于空", "对于空区间而言", "那么当然任何查找都是必然失败的", "所以这个时候我们也", "那个while循环会退出", "最终返回值是-1，表示失败", "同样，注意的是，在我们整个这个过程中", "第一次比较需要的是一次", "第二轮是需要一次", "最后一轮，实际上是做了两次", "所以累计是四次", "最后，在1这个位置上失败", "归纳一下", "无论如何，我们在while循环的每一次迭代中", "有的时候执行一次比较就够了", "有的时候执行两次", "但是无论如何，最多执行两次", "也就是常数次", "所以换而言之", "每当我们经过常数次比较之后", "都可以将原先的问题规模", "有效地降解为此前的一半", "这样一个递推式，我们进行求解的话", "就可以得到", "logn的这样的一个最后的", "大O的渐近复杂度", "你也可以从某种意义上来理解", "我们说，这个n，如果从数字的位数来看", "它的总体的位数就是logn", "二进制展开的位数就是logn", "而我们每一次对它进行降解", "你可以认为是在原来的基础上", "每次都减个1", "所以减到什么时候呢？", "减到最终当然是0的时候", "所以在此期间总共执行了多少层递归呢？", "我们说确实就是与这个n", "最开始的数位是相当的", "从这里也可以简明地来解释这一点", "无论如何", "相对于此前我们的find的操作", "也就是那个顺序的那样的一个查找操作", "我们讲过，它的复杂度平均和最坏都是O(n)而言", "要大大地改进"]}, {"name": "11d4-2: \t最坏情况", "block_id": "daec9a8e4e494956b8bd27d7c5602823", "text": ["然而另一个方面很遗憾", "BM算法在最差情况下的性能", "也的确非常差", "具体来说 它的算法复杂度", "有可能会退化到蛮力算法的水平", "也就是O(n*m)", "就此 你能举出一个具体的实例吗", "我可以给你一点提示", "你不妨去参考一下", "蛮力算法最坏情况的那个实例", "是的", "我想你已经想到了", "就是这个", "这一次 文本串倒是完全由0组成的", "而模式串 也几乎是由0组成的", "唯一的例外 是它的首字符", "按照BM算法的流程", "我们首先需要从末字符开始进行比对", "而且我们会经历一系列的成功", "直到最后一步才失败", "可以看到 在这次失败之前", "我们已经花费了O(m)的成本", "然而最糟糕的还不是这个", "因为 我们花费了如此之高的成本所换来的那个教训", "居然对我们不会有太多的帮助", "因为此时 正属于我们此前所讲的那种最为特殊的情况", "也就是说 坏字符的替代者应该是0", "但是在模式串中", "最后出现的那个0过于靠后", "以至于如果我们需要将它与此前的失配字符对齐", "将导致模式串的左移而不是右移", "因此在这种情况下", "我们只好搬出那个假想的通配哨兵", "并用那个通配的哨兵", "与这个失配的字符相对齐", "非常可惜", "这样的效果", "只相当于模式串向右移动一个单位", "没错 我们每花费O(m)的成本", "换来的收获只是向后移动了一步", "而总体呢", "共有n步", "因此在这种情况下的总体计算成本", "的确应该是n与m的乘积", "我们不妨来反思一下", "BM算法当前的这个版本", "为何还有可能会出现如此之差的情况呢", "没错 经验", "我们已经看到", "BM算法目前的这个版本的确已经能够很好地借鉴教训", "也正因为此 它才能够在最好情况下有出色的表现", "然而很遗憾 到目前为止它还没能够有效地利用好经验", "具体来说 也就是此前的那些成功比对所提供的有益信息", "实际上 完整的BM算法的确也可以同时很好地利用这方面的信息", "为此 我们需要给BM算法增加一个策略", "也就是所谓的好后缀策略", "这个策略 再加上我们刚刚介绍的坏字符策略", "就可以使得BM算法变得几乎完美"]}, {"name": "08B1-2\t越来越大的数据", "block_id": "aed7f85b008f4c21a5cefe0af76a98e1", "text": ["实际上 我们不愿意承认 但又不得不接受的一个基本事实是", "从某种意义上讲 我们在计算过程中所能够使用和借助的内存", "是在日益的变小 而不是如我们直觉那样 变得越来越大", "这听起来似乎是个悖论 因为对我们此前所介绍的典型计算模型来说", "存储器的大小本身就不是问题 难道不是这样吗", "就RAM模型而言 所谓的存储器 无非就是一组寄存器", "而且它的数量是无限的", "而图灵机的存储器呢 也就是纸带", "你应该记得 无论是纸带的长度还是纸带上单元格的数目 都是无限的", "然而无论是RAM机还是图灵机 在这一点上都做了过于理想的假设", "而在真是的世界中 存储器的容量必然是有限的", "而且相对于实际应用的需求 会显得非常非常的有限", "事实情况是 在我们的计算系统中", "存储容量的增长速度要远远小于应用问题规模的增长速度", "为此我们不妨来看这样一组统计数字", "按照我们通常对存储容量的规模分级", "从千-Kilobyte 到兆-Megabyte 到G-Gigabyte", "和T-Terabyte 以及P-Petabyte 诸如此类", "而我们人类所拥有的数字化信息的总量", "在过去的半个多世纪中 增长速度是惊人的", "比如截至2010年总量以及达到Zettabyte", "也就是1后面要接21个0", "我们知道中国的人口大致是十多亿 也就是10的9次方左右", "因此分摊下去 每个人可能都需要一个TB规模的硬盘", "请注意 这里我们说的还只是硬盘", "而如果考虑内存 这方面的压力就更大了", "我们不妨来进一步看一些数字"]}, {"name": "06B1-1 接口", "block_id": "6c0876ae7f6d45f089853e2e9d1fc038", "text": ["同学们好", "上一节从数学的角度", "给出了图的定义", "以及相关的一些重要术语", "尽管图论中涉及的概念和术语", "还远远不止于此", "但好在就我们这个课程来说", "我们所介绍的那些概念大致足够", "因此我们接下来进而讨论的是", "如何在计算机中", "以数据结构的形式表示", "并且实现图", "我们首先不妨从", "抽象数据类型的角度", "对图这种数据结构的接口", "以及操作规范进行一个统一的定义", "利用C++语言模板类机制", "图结构标准接口", "可以大致定义如下", "通过模板参数", "这里可以任意指定", "顶点以及边的基本类型", "而对外的操作接口无非三类", "也就是针对于顶点", "针对于边", "以及针对相关的算法", "因为这些接口数量较多", "所以在此暂且不予列出", "在此后的讲解中", "我们将会陆续地介绍它", "然而无论如何具体实现", "这些接口在形式以及语义上", "都必须做到统一", "在接下来的讲解过程中", "请同学们留意", "针对这种形式以及语义的统一性", "逐一地校对", "这里我们以内部公用的", "reset()接口为例", "可以看到", "尽管我们现在还不清楚Graph", "模板类的具体实现方法", "但是其中已经允许", "我们对顶点以及边", "做一些已经封装好的操作", "比如取顶点的状态信息", "父节点信息以及优先级数", "还有顶点的时间标签", "再如判断两个点之间", "是否存在一条连边", "以及设置或者查询边的状态", "那么所有这些图结构的标准接口", "应当如何的实现呢？", "我们首先要解决的一个问题是", "如何来表示一个图"]}, {"name": "02F-5\t 二路归并：正确性", "block_id": "f67984fc915541fd973ed5ac4ec9bcdb", "text": ["为了更好地理解 刚才那个算法的过程", "我们不妨分几种情况 来给出具体的图示", "同样 这是整个的_elem数据区", "这是待归并的", "两个子序列的公共的部分", "以及最终要归并的内容", "在算法的过程中", "我们分别用i j k来指示", "这三个子向量中的", "当前我们所关注的那个元素", "我们首先来考虑第一种情况", "也就是 i还是介于lo和mi之间", "没有越过mi这个界线", "还没有进入到", "C这个子向量的范围", "这种情况 我们讲是很自然的", "因为显然i不可能居于j的左侧", "顶多是个平齐", "所以每次迭代中", "如果需要发生数据转移的话", "无论是B[j]转移到A[i]", "还是C[k]转移到A[i]", "我们可以看出来 整个数据", "从内容来讲 都不会发生覆盖", "是安全的", "功能上讲 也是正确的", "再来看相对复杂一点的情况(b)", "也就是当这个i在持续增加之后", "终于有一天 会越过mi", "进入C的区域", "表面看 这样会侵犯到C的区域", "但是我们说 实际上不要紧", "因为在这个时候", "k绝对不会位于i的左侧", "所以 介于mi和i之间的这些元素", "其实作为C中原来的元素", "必然已经归入到A中", "当然是它的左侧", "在i之前的这部分中的", "某一个适当的位置中去了", "所以这种情况 表面看有点危险", "但是我们说 依然是安全的", "无论是C[k]、还是B[j]转移到A[i]中去", "都不会导致C中已有的元素", "被无意中覆盖掉", "从而导致错误", "我们再来看最后两种", "更为复杂的情况", "也就是 我们刚才所说的", "有可能在某个时候", "B这个子向量已经提前耗尽", "具体来说 就是它其中的元素", "已经完全地归入到A中", "当然也是就位了", "而在C中还残存有部分的元素", "没有转移和就位", "我们说 这种情况下", "正如我们刚才所说的", "我们的逻辑其实相当于等效地", "是在B的最右侧", "就是lb这个位置上", "增加了一个哨兵节点", "而且它的数值就是正无穷", "因此即便C的右侧 还残存有若干个元素", "它们也会在接下来的各次迭代中", "因为是与这样一个正无穷相比", "而被认为是更小", "从而顺利地转移到A中适当的位置", "直到两个子向量都同时耗尽", "那么反过来 另一种对称的情况就是", "C也可能会提前耗尽", "同样正如我们此前所分析的那样", "我们这里所给的逻辑", "也相当于等效地 在C的最右侧", "增加了一个数值为正无穷的哨兵", "它的秩是lc", "如果真发生这种情况的话", "即便在B的尾部 还残存有部分的元素", "我们说 也不要紧", "它们也等效于", "和这样一个数值为正无穷的哨兵相比", "或者说 它们总是会被认为是更小", "所以按照算法的逻辑", "会等效地转移到A中", "剩余的对应区域中去", "整个这个过程也是会顺利地进行", "不会出现我们所说的数据遗漏", "或者数据被无意中覆盖", "细心的同学可能已经注意到了", "(c)和(d)这两种情况其实并不对等", "因为按照我们这里的设计", "其实向量C和B 地位本来就是不等的", "B是完全复制出来的一个缓冲部分", "而C虽然是独立的绘制出来", "但实际上它就在A中 占据右端", "换而言之 如果是C提前耗尽", "我们确实需要把B尾部的这些元素", "悉数转移到A的尾部", "但如果是B提前耗尽", "那么对C尾部这些元素的转移", "其实都是多余的", "因为它们原来就在那", "完全没有必要", "注意到这样一个现象的话", "我们就不难对刚才表面上很规范的逻辑", "进一步的精简", "也就是说将我们这里所有的灰色部分", "都给它抹去", "这个括号 这个括号以右", "以及这个逻辑", "当然也包括这对括号", "还有这个逻辑和这个逻辑", "那么这里最最重要的其实就是这个部分", "就像我们刚才所说的", "我们并不需要考虑C提前耗尽的那种情况", "我们只需要考虑B提前耗尽的那种情况", "一旦B提前耗尽", "我们就可以直接终止这个循环包括这个算法", "所以这样的话", "可以使这个算法效率进一步的提高", "尽管不是从渐进角度而言的一种实质的提高", "那么这个算法在原来", "以及包括这样精简之后", "从渐进意义上讲 复杂度是多少呢？", "是否能像我们最初所预期的那样", "能够有大幅度的提高呢？"]}, {"name": "09D2-1 平方试探", "block_id": "026bda0308594c66bde4367cde0dc8ca", "text": ["在上一节 我们已经介绍了排解散列冲突的基本方法", "大抵说来 无非封闭定址和开放定址两类大的层", "相对而言 后者的物理结构更为紧凑", "因此 在性能上略具优势", "对于大规模的数据 更是如此", "然而我们也看到 对于其中典型的线性试探策略而言", "往往存在大量本不该发生的冲突", "如何就此作出改进 正是接下来这一节的主题", "实际上 线性试探的问题根源在于", "大部分的试探的位置都集中于某一个相对很小的局部", "因此 解决这个问题的钥匙也就是", "适当的拉开各次试探的间距", "而所谓的平方试探就是这一思路的具体体现", "所谓平方试探 顾名思义也就是", "每次试探的位置 不是简单的以线性递增", "而是以平方数为间距", "也就说 如有必要继续试探", "那么第一个位置的间距应该是1的平方", "如果仍有必要 第二个位置间距应该是2的平方", "以至3的平方 4的平方 诸如此类", "整个试探的过程 也可以通过这幅图来示意", "不妨假设 首先散列映射到的是编号为0的这个位置", "如果不能在此命中", "我们接下来将要试探的将是与之间距为1的平方", "也就是紧邻的这个桶单元", "当然就这一步而言 与线性试探没有区别", "然而接下来的情况就大不相同了", "如果我们在一号位置仍未命中", "接下来第二次试探的位置", "其间距将是2的平方也就是4", "以下类推 第三次试探如果有必要", "其对应的间距应该是3的平方9", "以及第四次 4的平方16", "当然 所有的试探位置 都是相对于M取模之后的", "如此可以保证所有的试探位置", "都在这个封闭的散列空间之内", "那么这种排解冲突的方法", "的确优于此前的线性试探策略吗"]}, {"name": "08B1-3\t越来越小的内存", "block_id": "a4cc2988b14d46be83ded582f4b05ac1", "text": ["我们来对不同年代典型的数据库规模", "以及当时内存的容量规模 做一对比", "在我念书的时候 也就是上世纪80年代", "一个典型的数据库 大致只有10M", "当时的电脑 典型的内存容量 大致是1M", "二者之比 大致是10倍的压力", "而在经过了短短20年 我们进入到新世纪之后", "随着技术的发展 典型的内存容量已经从M的量级跃升至G的量级", "提高了1000倍", "然而在另一个方面 实际应用中的数据规模却跃升到了TB量级", "提升了大致10的5次方至6次方", "审视当今的实际应用 我们会发现", "典型的数据集已经大多以TB作为度量单位了", "这方面的例子 举不胜举", "无论是生物分子学 医学 物理学 还是核能 以及气象", "因此即使从保守的角度来估计", "数据库规模的增长之于内存容量的压力 也提高了至少100倍以上", "总而言之 尽管随着技术的发展 内存的绝对容量的确是在增加", "但是相对于实际应用的需求而言 内存的容量实际上是在越来越小", "那么一个很自然的问题就是 为什么我们不把内存做得更大一些呢", "实际上不难理解 这个美好的愿望是很难兑现的", "这背后的原因在于", "我们不得不在存储器的容量与它的访问速度之间 做一取舍折中", "因为很自然的 存储器的容量越大 它的速度也就会更慢", "反过来 为了使得存储器的访问速度更快", "我们就不得不在容量上做些必要的牺牲"]}, {"name": "11e3-1: \tBM之性能", "block_id": "ea2f18696a994e519596c7144e0c6c68", "text": ["接下来 我们针对已经综合了bc和gs两种策略的BM算法", "标定它对应的复杂度", "并将这种算法 与此前的KMP以及蛮力算法", "在性能上作一个综合的对比分析", "首先是BM算法本身的性能", "在空间方面", "除了模式串和文本串本身", "我们还需要附加一张bc表以及另一张gs表", "前者的规模线性正比于字母表的规模", "而后者的规模则线性正比于模式串本身", "预处理的成本主要消耗于这两张表的构造过程", "我们知道 它们都各自可以在线性的时间内完成", "就我们最为关心的查找操作而言", "我们已经看到", "哪怕仅仅是凭借bc策略", "我们也可以在最好情况下实现O(n/m)的性能", "尽管在只采用bc策略时", "我们在最坏情况下有可能会退化到O(n*m)的时间效率", "但在平行地引入了gs策略之后", "这种最坏情况将会得到杜绝", "实际上 更为精细的分析表明", "在同时兼顾了bc和gs策略之后", "BM算法即便在最坏情况下的运行时间 也不会超过线性"]}, {"name": "05D-5 节点插入", "block_id": "a48579e975c241d893a4d60edd182867", "text": ["我们再来讨论节点插入算法", "也就是说", "我们希望在一棵已有的二叉树中", "将某个新生成的节点", "作为树中某一", "原本没有右孩子节点的右孩子", "接入进去", "从而得到如右图所示的这样一棵", "新的二叉树", "整个接口可以由", "以下这几行代码来完成", "这个接口的名字insertAsRC", "暗示了它的语义", "正如我们刚才所说", "我们要将某一个元素", "封装为一个新的节点", "并且将这个节点作为", "当前这棵树中的", "x节点的右孩子接入其中", "如果x的确没有右孩子", "这种接入一般会成功", "所以这里我们不妨", "提前将树的规模增加1 已更新", "你应该还记得", "我们此前BinNode节点类型", "所提供的同名的那个接口", "insertAsRC", "是的 通过调用它", "我们首先可以将目标e", "封装为一个新的节点", "并且这个节点在创建的时候", "就会以x节点作为它的父亲", "也就是完成自下而上的链接", "接下来呢 你应该还记得", "我们通过一次赋值", "将新生成的这个节点的位置", "交给节点x", "此前为空的右孩子引用", "从而使得这个引用", "能够正确地指向新近生成", "并且封装好的这个节点", "两相合作", "完成了一次有效的连接和插入", "不要忘了在这样的", "拓扑连接完成之后", "x节点的高度有可能因为它", "新加入了一个孩子而发生变化", "这也就是为什么我们需要及时的调用", "此前刚刚实现的", "updateHeightAbove", "来对x这个节点以及它的", "历代祖先更新高度"]}, {"name": "10xa2-2: 算法", "block_id": "3a65cb3c0f2b4d68824b399e7bec8140", "text": ["实际上，采用递归的模式，左式堆的合并算法可以非常简明地描述并实现。", "来看一个一般的场景，假设待合并的两个堆分别以a和b为根，", "并且假设在抵达递归基之前，它们的左右子堆都是存在的，", "我们可以借助递归将a、b两个堆合并的问题转化为这样一个问题：", "具体来说也就是我们要将a的右子堆取出，并且递归地与刚才的堆b完成合并，", "合并所得的结果继续作为a的右子堆。", "当然，为了保证a在此后继续满足左倾性，在这次合并返回之后，", "我们还须比较a_L与合并之后这个堆的npl值，如果有必要，我们还需令二者互换位置。", "没错，整个算法就是这样简单明了。尽管它的实现还需要颇费一些功夫。"]}, {"name": "02D4-3\t 语义", "block_id": "cfe265e7a3254416aa227adc9978d124", "text": ["实际上无论是", "我们此前所给的binary search的两个版本", "还是fibonaccian search", "它们如果从严格的意义上讲", "都没有真正地兑现我们在此前", "针对search()接口所做的语义约定", "大家应该还记得", "我们当时做过严格地语义约定", "无论成功或者失败", "search()接口的返回值", "必须是在整个有效区间内", "不大于我们的目标e的", "最后的那个元素", "我们在此之前甚至讲过这种约定的必要性", "因为只有做过这样的约定之后", "我们才能够支持一些相关的算法", "比如说最简单的，是有些向量自身的维护", "我们经常需要插入一个元素", "并且使得在插入之后", "向量的有序性得到延续", "为此的话，我们就需要在查找的时候", "不光要报告我们成功与否", "更重要的是在于，它返回一个确定的位置", "而这个位置", "再加上1", "或者就做一个简单地调整之后", "就可以作为我们新元素合适的插入位置", "所以即便是就这个小问题而言", "我们也要求至少要满足以下这样几点", "第一，如果是有多个元素同时存在的话", "我们曾经讲过它们", "必然会在整个这个区间里头", "构成一个连续的子区段", "彼此紧密地排列", "我们必须要返回其中最靠后", "也就是说从秩的意义上讲，最大的那个元素", "这样的话，我们新的同样这个意义的元素", "再通过在这个位置加1以后", "就可以顺利地插入在紧随其后的这个位置", "另外呢，在失败的时候", "刚才这个语义也可以等效地转义为", "返回小于这个目标元素的最大值", "因为这里头不可能有等于", "所以不大于其实就是小于", "当然这里包含一个特殊情况", "就是有可能这个返回值是哨兵", "哪个哨兵呢？", "就是在有效区间段", "最左侧的这个lo的左侧", "我们可以假想地在这里引入一个哨兵", "我们曾经讲过，它的数值可以认为是负无穷", "因此呢，充其量只能到它这儿", "而在这个时候", "我们说其实如果真是这样", "要插入这么一个元素", "而且搜索完之后停留在这儿", "返回的位置是lo-1的这个位置的话", "那只能说明这个新的元素e", "必然是全局现在已有的元素中最小", "所以如果是返回这个的话", "是再恰当不过了", "我们可以把它作为最小的那个元素插入", "而这个位置到这儿也是一个加1的过程", "在刚才版本B的基础上", "我们可以进一步地略做调整", "得到最终的一个版本，也就是版本C", "而这个版本确实可以严格地实现", "我们刚才所要求的语义"]}, {"name": "06C-2 策略", "block_id": "8ec989ec890640eda6afe2b4e3895b77", "text": ["所谓的广度优先遍历过程", "可以大致描述为如下一段自然语言", "具体来说 如果指定的起点是顶点s", "那么这种搜索将首先访问s", "在这个图中 我们通过将s染黑", "表示它已经接受了访问", "接下来我们需要访问", "S所有尚未访问的邻接顶点", "从这个图中来看", "如果s具有若干个邻居", "就需要逐一枚举", "并且访问这些邻居", "在这里由s通往它的那些", "刚被访问的邻居的边都被加粗", "这暗示着这些边都已经被我们的", "算法所采纳和保留", "这些边都是非常重要的", "它们携带了整个遍历过程中", "所发现的一些信息", "我们很快就会看到", "这些边将构成原图的一个", "极大的无环子图", "通常情况下是一棵树", "或者是一个森林", "反过来 在原图中", "还会有一些边", "我们并不采纳", "比如在此时所有这些", "刚被访问的节点之间", "有可能也有连边", "但是在经过广度优先遍历之后", "它们将不再保留 而是被舍弃掉", "接下来我们的关注点是", "刚被访问的这些新发现的节点", "我们将继续去枚举出", "它们各自的所有邻接顶点", "并且检查它们的状态", "如果这些顶点中", "仍有尚未访问者", "就轮到对它们进行访问了", "在这个图中 我们不妨", "将这些新的顶点", "画在图中的外围", "也就是说 我们接下来将通过", "刚刚被访问过的那些顶点", "通往它们的边找到它们", "同样地 在这些边中", "也有一部分被我们保留下来", "而另外一些则按照同样的原理", "不予保留", "再一次地 在新发现的这些顶点之间", "也有可能连有某些边", "比如说这些", "而且这些边也同样地不会被", "广度优先遍历所采纳", "因此它们也没有加粗", "好了 相对于这些", "新近发现的顶点", "在图中也就是这些", "居于最外围的顶点", "我们将再一次地去枚举出", "它们所对应的邻居们", "在图中 我们依然不妨", "以更外围的一些顶点来示意", "那么接下来也轮到", "这些新发现的顶点", "接受访问了", "具体来说 我们也需要保留", "若干由原先的顶点", "通往新近访问这些顶点的边", "而且同样地 尽管在这些顶点之间", "也可能连有不同的边", "我们也依然不予采纳", "好 这个算法将不断地如此迭代反复", "直到所有的顶点都接受了访问", "仍以这幅图为例 我们可以看到", "所谓广度优先搜索", "的确是一种遍历", "它会按照我们刚才", "所介绍的那种策略", "确定不同顶点接受访问的次序", "并且按照这种次序", "对各顶点逐个地访问", "而整个搜索过程的最终产物或成果", "不过是选自原图的一系列边", "也就是这里加粗的这些边", "而原图中其余的边", "也就是这里用淡色细线条表示的边", "都将被忽略", "而不予进一步考虑", "可以通过这个图看出", "这里的取舍原则", "也就是说 这里按照与起点s的距离", "将所有的顶点划分为", "若干个等价类", "在这个图中 也就是一个套一个的环路", "就像某些城市一样", "可能有一环二环三环", "以及诸如此类地 n环", "那么在同一等价类内部", "各顶点的边", "都不会被采纳", "而只有连接于相邻等价类之间的", "某些边才会被采纳", "请注意 同样是连接", "相邻等价类顶点的边", "未必都会被采纳", "比如说这条 这条 这条 这条", "以及这条 这条 这条和这条", "而反过来 我们可以注意到", "所有被保留下来", "并且采纳的这些边", "将足以把所有的顶点", "连接起来", "构成一个连通图", "同时它们之间也因为刚才的规则", "而不致于造成环路", "也就是说 它是一个", "极大的无环图", "我们讲过 这就是一棵树", "没错 它就是一棵树", "因为这棵树中涵盖了", "原图的所有的顶点", "所以我们也称之为支撑树", "Spanning Tree", "另外 既然这样一个遍历过程", "可以将所有的顶点划分为一个", "一个又一个等价类", "而且这些等价类", "按照到起点s的距离", "是逐次单调变化的", "因此它与我们此前所介绍的", "树的层次遍历", "有异曲同工之妙", "是的 对于图的特例", "也就是树而言", "这样一个遍历过程", "其实就是不折不扣的层次遍历", "所以反过来 我们也可以认为", "所谓图的广度优先遍历", "实际上就等同于", "树的层次遍历", "后者可以认为是前者的一个特例", "而反过来 前者也是后者的推广", "好了 那么这样一种", "用自然语言描述的遍历过程", "如何严格地描述为算法", "并且实现为具体的代码呢？"]}, {"name": "05E2-2 观察", "block_id": "c4c65f4f4a944c24a33c0b9f3cc01c21", "text": ["与设计算法解决很多问题的过程一样", "我们首先要做的未必是动手", "而是通过眼睛深入的观察", "进而发现其中蕴含的规律", "我们来考察这样一个具有一定的规模", "同时也具有相当一般性的实例", "首先请确认我们这里", "在下方所注明的这个序列", "确实就是这棵树的中序遍历序列", "不同节点之间相继被访问的次序", "在上面这个图中 我们用虚线来表示", "比如在e被访问之后 紧接其后的是f", "以及再随后的g以及h", "直到i和j 诸如此类", "那么我们问题的起点是", "对于这样一种中序遍历", "首先第一个接受访问的是哪一个节点呢？", "没错 就是a", "那么接下来的第二个问题是", "为什么是a呢？", "为此我们需要回到这个遍历算法的", "基本策略 也就是左中右次序", "在任何局部 比如说整个全树的根节点", "在根节点i的左子树 也就是子树d", "被完全遍历之前", "i是不会首先接受访问的", "所以我们可以理解为 当算法扫描到", "子树i的时候它将会将控制权", "转交给它的左孩子d", "同样地 当节点d被扫描到后", "它也会随即将控制权转交给它的左孩子", "再同理 c被扫描到后", "也会进而将控制权转交给它的左孩子", "也就是a", "实际上 我们可以认为a", "也试图效仿这种做法", "将控制权转交给它的左孩子", "然而 正如我们所看到的", "很遗憾 它没有左孩子", "请注意 没有左孩子其实也等效于", "左孩子以及左后代已经完全被访问过了", "换而言之 此时这个局部子树的树根", "节点a 的确是轮到该访问的时候了", "而正因为此 从全局来看", "a将首先第一个被访问", "回顾在此前各层节点逐层谦让的过程", "我们可以理解为 控制权最开始在树根i", "它进而转让给它的左孩子d", "d再继续转让给它的左孩子c", "c再转让给它的左孩子a", "而a无从转让 所以才轮到它自己接受访问", "看出什么规律来了吗？", "没错", "与先序遍历非常类似", "整个中序遍历过程的序曲总是一样的", "也就是从根节点开始", "一直沿着左侧分支逐层向下", "直到末端不能再向下的那个节点", "注意 我们这里再一次", "遇到了左侧分支 left branch", "这个规律在任何局部都是成立的", "除了刚才我们所说的全局树根i", "其实对于其它的也是如此", "我们不妨来看 当控制权", "试图转交给这个h的时候", "它也依然会类似的谦让", "将控制权转交给它的左孩子", "以及左孩子的左孩子", "如果还能左孩子下去的话", "还将一直下去", "可惜在e这个位置 这种谦让必须停止", "所以这也是为什么在节点d访问之后", "控制权进入它的右子树之后", "实质被访问的恰恰是节点e", "我们看到了什么呢？", "没错 又是一个左侧链  left branch", "站在这样一个角度 你可以很自然地解释", "为什么这也是一个左侧链", "以及这个长度为1的左侧链", "以及这个左侧链", "站在这个视角 我们可以将", "整个中序遍历分解为", "在不同尺度下的", "一系列的对左侧分支的逐步处理", "好了 到了对这种观察的规律", "做一个抽象和总结的时候了"]}, {"name": "11c6-3: \t前车之覆", "block_id": "a5e6d0bd2ae745e6bea4ffcd0989923e", "text": ["实际上 这个算法的主体流程并没有任何的问题", "而在另一个方面 我们又注意到", "控制KMP算法流程走向的", "与其说是这个算法本身", "不如说是它背后的那张查询表", "没错 next查询表", "这张next表既是算法策略的体现者", "也是每一个模式串中所蕴涵信息的具体承载者", "它简明地刻画了每一个模式串的本质特征", "而在当前 它只不过是刻画得还不完全而已", "为什么这么讲呢", "我们还是需要从next表的语义定义来说起", "比如 这个字符", "它所对应的next表项为2", "其对应的语义是说", "在它所对应的这个长度为3的前缀中", "存在一个长度为2的真前缀与同样长度为2的真后缀完全匹配", "而且这也是如此的最长匹配", "因此在经过相应的滑动之后", "这两个部分也就会自然而然地匹配", "从而无需对它们重新比对", "是的 KMP在这一方面的确显得非常聪明", "因为它充分地利用了我们在此前的比对中所业已获得的信息", "这类信息是正面的", "因为它们告诉我们 相对于当前这个失配字符", "它的前缀都是由哪些字符所构成的", "形象地说 这类信息 就相当于我们通常所说的经验", "然而 以往的经历所能告诉我们的不光有正面的经验", "还应该有负面的信息", "比如 教训", "是的 在串匹配的计算过程中", "这两方面的信息都是有的", "实际上 相对于当前这个失配的字符", "我们不仅能够知道它所对应的前缀是什么", "而且 反过来我们也应该能知道这个字符不应该是什么", "难道这不正是教训吗", "很遗憾 KMP算法目前的这个版本还不能及时地汲取这方面的教训", "以至于它会一而再 再而三地重复这个错误", "与所有问题一样", "一旦你能够定位它", "其实也就解决了它的一大半", "通过以上的分析", "既然我们已经发现KMP还不能够吸取教训", "那么改进的方法也自然就是", "使它具有这种能力", "比如 一种可行的解决方法就是", "在确定各个字符所对应的next表项时", "除了此前自相似的必要条件", "我们还需增加一个新的条件", "这个条件与刚才自相似的条件恰好相反", "大体而言 自相似条件就等价于说", "在这个前缀中存在哪些自相似的特征", "而新增补的这个条件恰恰相反", "它要指出新的这个字符必须与此前的那个字符不一样", "新的这个物体 尽管未必要比石头要更硬", "但是 它至少不应该仍然是一枚鸡蛋"]}, {"name": "01XC-6: 最长公共子序列", "block_id": "e92164a19150478681c1beaa4c8daba0", "text": ["我们再来看，动态规划策略的", "另一个应用实例", "也就是最长公共子序列", "所谓的序列sequenece", "实际上都是由", "若干个字符构成的", "像这个tsinghua", "computer", "asymptotic等等", "都是序列", "那么相对于序列", "就有子序列的概念", "Subsequence", "什么叫子序列呢？", "也就是在一个序列中", "我们随意挑选出若干个字符", "并且 这很重要", "并且按照它们原来的相对次序", "重新拼成一个序列", "这个cute、spot等等", "都是相对于原序列的子序列", "这里需要注意一点", "就是它们的相对次序", "是保持不变的", "从图形来看", "就是这些连边之间", "彼此不能交叉", "而公共子序列", "包括最长公共子序列", "都是相对于两个序列而言", "比如在这里", "相对于educational和", "advantage这两个序列", "data 同时是它们的子序列", "所以我们称它是公共子序列", "而且 如果在所有的", "这种公共子序列中", "像这个data 是其中最长的", "那么我们就称它叫", "Longest Common Subsequence", "最长公共子序列", "需要指出的是", "有可能会同时有多个", "最长的公共子序列", "比如说 就这个例子而言", "可以验证", "这个长度为4的公共子序列", "data 确实是最长的", "而与此同时 dana", "也是一个长度为4的公共子序列", "二者打了个平手", "当然我们可以验证", "这二者并不能合并起来", "得到一个长度为5的公共子序列", "因为N和T对应的这两条线", "中间出现了交叉", "这是我们刚才所说的", "应该禁止的", "所以有可能有多个", "这个时候怎么办呢？", "我们这个算法 还是比较宽松的", "只要找出其中的一个", "甚至只要找出它们那个长度", "就够了", "而后者肯定是唯一的", "另外一种可能呢", "就是说 即使结果是唯一的", "比如说这里同样是data", "但是却有可能有歧义", "其中某一个字符 比如说D", "在某一个原始的序列中", "有两个字符", "都可能对它构成贡献", "这个D可以取作是这个", "也可以取作是这边这个", "我们说 这是歧义", "当然这些复杂的情况", "目前来说 暂时都可以搁在一边", "我们把注意力集中在", "如何确定它的一个简单的版本", "也就是计算出", "最长公共子序列的长度"]}, {"name": "05E1-6 新思路", "block_id": "a50b2b64501541f484d4d50364407a1e", "text": ["我们不妨从一个规模略大", "同时也更具一般性的例子入手", "我们可以看到 对这样一个具体的例子而言", "先序遍历将首先访问全树的树根 也就是i", "接下来 我们应该转入并且访问", "它的左子树的树根 也就是d", "再接下来 应该访问d的左子树", "也就是它的树根c", "再接下来 访问它的左子树a", "因为a并没有左子树", "所以接下来 应该将控制权交给它的右子树", "也就是节点b", "好 当b被访问完之后", "左右孩子都没有", "所以我们应该回溯", "那么回溯到哪儿呢？", "回溯到a  a已经被访问完了", "回溯到c c也被访问完了", "回溯到d d也被访问完了", "但是d与c和a不同 它访问完之后", "它还留有一个尚未访问的右孩子", "所以我们说这个时候的控制权", "应该从b转交给h", "h一旦获得了这个控制权之后", "它除了访问自己以外", "接下来 又会将访问权转交给它的左孩子", "它的左孩子也将被访问", "并且继而将访问权交给它的左孩子", "同样 当它的左孩子访问完了之后", "这个孩子试图将控制权交还给f", "但是f会随即将它转让给自己的右孩子", "也就是刚才那个左孩子的兄弟", "所以我们说 从e接下来应该访问的是g", "以下也是同理 我们忽略掉下面的推导", "那么通过这样一个例子", "我们能观察出什么规律来呢？", "在此我建议你不妨稍做暂停 思考一下", "一二三 暂停", "好了 我想你大概应该能看出点道道来了", "不妨将刚才那个问题转化一下", "来问这样一个问题", "也就是对于任何一棵子树", "在起始的若干拍中", "接受访问的节点分别是谁", "你会回答首先是根 没错", "接下来呢 是根的左孩子 也没错", "再接下来呢 是左孩子的左孩子", "当然以及左孩子的左孩子的左孩子", "以及 噢 不行 没有办法下去了", "所以最终我们会在这样的一个节点处", "有一个停顿 或者说转折", "这样一个规律其实在任何一个局部", "都是成立的", "比如我们来观察一下这样一棵子树", "一旦树根节点", "接过控制权并接受访问", "接下来被访问的就是它的左孩子", "以及左孩子的左孩子", "以及同样地 不能下去的时候", "我们才会进行一次新的转移", "而每转移到一个具体的局部", "我们做的事情都是尝试着沿着这样的一个", "左孩子的分支不断地下行", "无论是在刚才这些位置 还是在这里", "我们可以看到 都具有这样一种特性", "好了 这个图虽然很清楚", "但是毕竟有些乱", "我们不妨把一些不必要的记号清除掉", "我们不妨来做一个定义", "也就是说 对于任何一棵子树", "我们都将起始于树根的", "接下来总是沿着左侧孩子分支", "不断下行的这样一条链", "称作是当前这棵子树的左侧链", "而我们的算法呢", "就是沿着这个左侧链逐渐展开"]}, {"name": "05E1-4 迭代实现（1）", "block_id": "7b85f4e22503476286d8f3cfb2fe70eb", "text": ["改写之后的第一个迭代版本", "如这段代码所示", "作为初始化 我们取一个栈s", "用以存放树节点的位置 也就是它们的引用", "首先我们将当前的树根x推入栈中", "以下进入一个主体的循环", "每一次弹出当前的节点", "并且随即对它进行访问", "此后 如果当前这个节点拥有右孩子", "我们就将右孩子推入栈中", "如果有左孩子 那么左孩子也会随后入栈", "此后整个循环又进入下一步迭代", "直到整个栈变空", "这里我们提醒大家注意", "左右孩子的入栈次序", "是先右后左 这是因为", "包括先序遍历在内的所有遍历", "都先遍历左子树 再去遍历右子树", "在这样一个算法模式中", "既然每个节点都是在", "被重新弹出栈的时刻才接受访问", "所以根据栈后进先出的特性", "自然也就应该将希望后出栈的右子树", "先入栈了"]}, {"name": "08B5-2\t旋转", "block_id": "8be984ccb0dd479c9cfa0d0f81a4f1aa", "text": ["首先 请确认 若节点v果真刚刚发生下溢", "那么它应该恰好包含m/2-1个分支 以及m/2-2个关键码", "是的 刚刚发生下溢的节点V应该恰好只包含m/2-2个关键码", "联想到在插入算法中 通过分裂来解决上溢问题", "你可能会首先想到通过合并来解决下溢问题", "是的 这只是可供选择的预案之一", "但优先级更高的 并不是它", "事实上 这个刚刚下溢的节点会首先左顾右盼", "如果有某一兄弟拥有足够多个关键码", "比如不失一般性 假设它的左兄弟存在", "而且这个兄弟所拥有的关键码数不少于m/2的上整", "那么它的这个左兄弟 就有可能向V借出一个关键码", "这里你需要核算一下 在这种情况下", "左兄弟向V借出一个关键码之后", "既可解决V的下溢问题 同时自己也不至因此而发生下溢", "这个构思非常的好 可惜有一点小小的难题需要解决", "我们知道 如果的确存在这样的两个兄弟", "那么它们的父亲也必然存在", "而且在它们的父亲中必然有一个关键码 比如说y", "会介于它们之间", "作为搜索树 B树同样应该符合中序遍历意义上的顺序性", "这就意味着 作为左子树中的一元", "L中的所有关键码 都应该小于y", "对称地 作为右子树中的一元 V中的所有关键码都应该大于y", "因此 将L中的任何一个关键码 直接移送到V中", "都将破坏这一局部 乃至全局的顺序性", "这是万万不可的", "然而 反过来 这里的技巧也恰在于此", "这样一种转借的思路 关键在于", "我们需要借助关键码y 曲线地转借", "就像所谓的三角借债一样", "实际上 V并非是直接向它的左兄弟去借入一个关键码", "而是从它的父节点中 去借出y这个关键码", "你没听错 的确是从父节点中去借出一个关键码", "不难想象到 在借出了这个关键码之后", "父节点在y这个位置上应该会出现一个空缺", "然而 这并不要紧 不要忘了 这里还有一个节点L", "它还足以向父节点借出一个关键码 以填补刚才所留出的空当", "问题是 在L中 应该借出谁呢？", "是的 应该借出的是在其中数值最大", "从图中看 位于最右侧的这个关键码 我们不妨称之为x", "这样 在经过了连续的两次借出之后", "节点V从父节点处获得了一个关键码y 使得自己不再下溢", "同时 父节点也从左侧节点中 借入了一个关键码x", "从而实现了收支的平衡", "同时 左侧的这个兄弟节点L", "也并没有因为损失一个关键码 发生下溢", "更重要的是 经过了这样一种貌似曲折的转借", "局部乃至全局的顺序性 依然得到了延续", "整个变化过程 可以化作关键码y被转移至节点V", "而关键码x则从L 转移至P", "因此 也不妨形象的将这种调整 称作旋转", "当然 只要下一节点V拥有一个满足同样条件的右兄弟R", "我们也可以通过对称的旋转来修复下溢", "然而很遗憾 这样的左兄弟和右兄弟 未必存在", "一种极端情况是 V的左右兄弟 或者不存在", "或者不足以借出任何的关键码", "对于这样的情况 我们又当如何应对和处置呢？"]}, {"name": "10xa1-5: 左倾性", "block_id": "8a8d83a8e11146358238638e57d9996f", "text": ["是的，借助NPL这个指标，我们就可以简明地定义什么叫做“左倾”，", "也就是说，对任何一个节点x，如果在NPL的意义上，它的左孩子不小于它的右孩子，", "我们就称之为“左倾”。", "如果在堆中，任何内部节点都是左倾的，", "我们就称这个堆为左倾堆，或者左式堆、左撇子堆，", "当然根据NPL的定义，既然每个节点的NPL值都是在它的孩子中间取一个小者，", "再累计上一个单位，于是很自然地在这个递推式中，", "我们只需考虑每个节点的右孩子，而忽略他的左孩子。", "不难确认，所谓的“左倾性”与我们此前的堆序性是彼此相容而不矛盾的。", "既然左倾性必须是处处满足的，因此我们自然可以推知，任何左式堆的任何一个子堆，", "必定依然是左式堆。", "不难理解，作为左式堆，它更倾向于将更多的节点分布于左侧的分支，", "正像我们最初所希望的那样。", "然而需要指出的是，这只是一个大致的倾向，事实情况未必严格如此，", "比如在课后你可以进一步来思考这样的两个问题：在左式堆中，是否左子堆的规模始终大于右子堆，", "另外左子堆的高度是否也必然总是大于右子堆？", "在这里，我们也给出了左式堆的具体实例，而刚才两个问题的答案也就藏在这个实例当中。"]}, {"name": "08B3-2\t操作实例", "block_id": "655d187bc82146699cd4e4f0d2729e28", "text": ["来看这样一个具体的实例", "首先确认这是一棵5阶的B树 也就是所谓的(3,5)树", "因此 其中每个节点至多拥有5个分支", "而除根节点之外 其他的节点也至少应该拥有3个分支", "就关键码而言 每个节点至多拥有4个", "而除根节点之外 每个节点也至少应该拥有2个", "现在我们假设需要查找75", "于是我们首先对常驻于内存的根节点进行一次顺序查找", "并且顺利的在这个位置命中", "接下来再考察一个略微复杂一些的情况", "也就是我们来试图查找69", "为此我们同样首先需要对常驻于内存的根节点进行一次顺序查找", "这次查找以失败终止于介乎53和75之间的这个引用", "于是我们顺藤摸瓜 沿着这个引用将下层的这个节点读入内存", "并且在其中进行一次顺序查找", "不出意料 最终可以成功的找到这个关键码", "再来看一个更为复杂的情况", "我们不妨来试图查找关键码49", "同样的 我们的查找依然起始于常驻于内存的根节点", "经过在根节点的一趟顺序查找 虽然以失败告终", "但是却可以确定一个引用", "这个位于53左侧的引用指向下层的另一个节点", "因此我们需要经过IO操作将这个节点载入内存", "并且依然在其中针对49做一趟顺序查找", "不出意料尽管这趟查找依然失败 但是它却会给出一个引用", "顺着这个引用 我们又可以深入到B树的下一层", "并且将对应的那个节点经过IO载入内存", "接下来我们依然需要在这个新的节点中针对目标49做一趟顺序查找", "不出意料 查找将会成功的终止于49", "作为失败查找的一个实例 我们不妨来考察针对于45的一次查找", "经过简单的目测 不难确定", "查找应该失败于这里的41和49两个关键码之间", "就整个查找所涉及的节点而言 针对于45的查找", "与刚才针对于49的查找实际上是一样的", "也就是说 我们首先要对根节点进行查找 然后再转向这个节点", "接下来再进而转向这个节点", "并且在这个节点中 经一趟顺序查找 最终失败于41和49之间", "请注意 这里的查找失败 是以介乎41和49之间的那个外部节点来指示", "尽管在这种紧凑的画法中这些指向外部节点的引用并不能看见", "但它们的确存在 而且是十分重要的", "由此我们也可以得出一个推论 对于B树的失败查找", "必然都失败于最底层叶节点所下属的某个外部节点处"]}, {"name": "07B3-3 删除：双分支", "block_id": "2177705339874236819283ffadcd11b5", "text": ["在这里我们需要再次使用", "计算机科学中的一个法宝", "也就是化繁为简", "具体来说 我们要将比较棘手的", "第二种情况", "有效地转化为第一种情况", "以这样一棵BST为例", "假设我们需要从其中删除节点36", "可以看到 这个节点", "的确是属于比较棘手的情况", "因为它的左右后代都同时存在", "此时我们不妨找到它的直接后继", "没错 直接后继", "你应该还记得我们在实现二叉树的时候", "对于BinNode类型", "曾经定义并且实现过一个名为succ()的接口", "你应该记得它的功能与语义", "没错 就是返回当前节点", "在中序遍历意义下的直接后继", "具体来说", "也就是在全树中不小于当前节点的", "最小的那个节点", "回顾当时的这个succ()算法", "在当前节点拥有右后代的情况下", "算法将首先进入到", "它所对应的右子树", "然后在右子树中", "沿着左侧分支不断地下行", "直到最终不能继续下行", "而整个过程最终所抵达的那个节点", "就应该是当前节点的直接后继", "对于这个例子而言", "36的直接后继就是40", "那么接下来 我们可以", "令当前这个节点", "与它的直接后继节点互相兑换", "比如对这个例子而言", "兑换之后的状态 就是这样", "你可能会有点担心", "因为此时的这棵树", "在这个位置违反了顺序性", "它已经不再是一棵BST了", "是的 你的担心非常有道理", "但是其实大可不必", "因为这样一种状态", "只是一个瞬态", "我们马上就会使它重新变为一棵BST", "而且能够将目标节点删除掉", "是的 此时我们已经可以着手", "对这个目标节点实施删除了", "难道不是吗？", "稍加观察", "你不难发现 此时的局部", "已经无形中转化为了", "此前的第一种情况", "也就是说 待删除的36", "至多只有一个孩子", "更确切地讲", "它至多只有右孩子", "为什么它不会有左孩子呢？", "因为作为此前那个节点的直接后继", "它必然是某条左侧分支的末端", "作为这个左侧分支的末端", "它自然不可能拥有左孩子了", "既然如此", "我们就可以直接沿用刚才", "对情况一的处理手法", "也就是直接令它唯一不空的那个孩子", "去顶替它", "于是我们就可以得到这样一个结果", "此时你不难验证", "这棵树已经恢复成为了一棵", "不折不扣的BST", "需要特别说明的是", "在此后我们还需要令", "内部的_hot变量", "指向刚刚被实际删除的这个节点的父亲", "并且从它开始", "不断地向上追溯历代的祖先", "因为这些祖先的高度有可能", "因为刚才那个后代的删除", "而发生变化", "那么同样地", "这样一个化繁为简", "并且顺利处理的过程", "如何描述并且实现为具体的代码呢？", "还是回到刚才尚未完成的removeAt算法", "我们来补充对第二种情况的处理方法", "按照刚才的分析", "我们只需要找出当前节点的直接后继", "并且令这两个节点的数据域互换", "从而等效地将待删除的节点", "转移至一个新的位置", "而且这个位置至多只有一个分支", "当然这个分支只可能是右孩子", "为了将待删除的节点", "顶替为它的这个右孩子", "我们只需在这个右孩子", "以及它此前的祖父之间", "正确地完成一次双向连接"]}, {"name": "09D2-4 M + Lemda", "block_id": "cc696e22d0834862801d6b24adfa060f", "text": ["我们采用反证法", "假设在表长为素数同时装填因子不超过50%的情况下", "居然在0与M/2的上整之间存在两个互异的整数a和b", "而它们所对应的位置彼此冲突", "那么转到数论的语言 所谓的冲突", "也就是a的平方和b的平方同属于某个关于M的同余类", "经过简单的代数变换", "我们就可以推知 b与a之和与b与a之差的乘积能够整除M", "然而我们说这是不可能的", "原因在于无论是b-a抑或b+a", "在数值上都必然是介于0和M之间", "而如此也进一步的意味着 b+a至少是2", "也就是说 b+a居然是M的一个非平凡的因子", "这与我们关于M是素数的假设是相悖的", "好了 我们现在可以得出一个结论", "只要将散列表的长度取做素数", "同时将装填因子控制在50%以下", "那么就能保证 在起始于任何位置的平方探测序列中", "前面的M/2取上整的位置 必然是彼此互异的", "而接下来的另一半位置呢 则未必能够保证", "当然包括你在内", "强调和追求效率的我们或许不会满足于这样的效率", "那么后一半的空间可否同样的利用起来呢", "好消息是 可以", "这也是我们的下一个主题"]}, {"name": "02A-2\t 向量ADT", "block_id": "6e7ae19e0309495083b0742fecfdcd63", "text": ["所谓的向量", "实际上是C++", "等高级编程语言中", "数组这种数据组织形式的", "一个推广和泛化", "我们都知道 实际上", "在这些高级程序设计语言中", "所谓的数组", "实际上就是一段", "连续的内存空间", "它被均匀地划分为若干个单元", "而每一个单元", "都与0到n之间的", "某一个整数编号", "相互彼此对应", "我们可以说", "第0号单元或者元素", "或者第1号元素、第2号元素", "以及到最后的实质", "第n-1个元素", "这里我们也同样延用", "我们此前已经约定的习惯", "虽然最后这个第n个元素", "实际上未必存在", "我们还是把它虚拟地放在这儿", "作为哨兵", "以帮助我们对很多问题的思考", "并且使得我们很多算法的实现", "能够得以简化", "既然每一个这样的元素", "都与这些编号是一一对应的", "所以反过来", "我们通过合法区间内的编号", "都可以唯一地来指代", "并且访问对应的那个元素", "确实如此", "我们一旦知道", "这个元素的下标i", "就可以从A", "也就是这段存储区域的", "首地址出发", "再向后", "以s作为间隔 去数出i步", "就可以得到某一个特定的单元", "正因为所有这些元素的物理地址", "可以按照这样一个", "线性的方程来确定", "所以我们也称之为", "linear array", "线性数组", "那么向量呢", "我们可以认为是", "数组的抽象与泛化", "它同样是由一组抽象的元素", "按照刚才的线性次序封装而成的", "具体来说 其中的每一个元素", "依然与0到n之间的", "一个合法的整数", "是一一对应的", "只不过在这里", "我们更倾向于", "把这种整数称作是", "秩rank", "所以原来通过下标i", "进行访问的方式在这里", "就可以被推广而成", "是通过秩来访问", "这种方式叫作", "call-by-rank", "也叫循秩访问", "另外在向量中", "元素的类型", "已经得到了拓展", "不限于是某一种", "特定的基本类型", "也因为如此", "它的所有操作、管理", "包括维护都更加的简化", "可以通过统一的接口来完成", "相应地 也会更加安全", "避免一些非法和歧义的操作", "同时呢 也正因为它本身", "已经做了很好的封装", "也可以便捷地", "参与更加复杂的", "一些数据结构的定制以及实现", "按照抽象数据类型的规范", "向量结构必须提供", "一系列的操作接口", "可以通过这些操作接口", "对向量做各种操作", "同时也只能通过这些操作接口", "对向量进行操作", "这里的接口功能非常的丰富", "我们在后续分别介绍", "它们的实现的时候", "自然会介绍它们的具体含义", "比如说 与其它的数据结构一样", "向量也可以看作是", "一组元素的集合", "所以这个size", "实际上返回的是", "其中元素的总数", "我们称之为", "这个数据结构的规模", "我们也可以从中取特定的元素", "也可以修改其中特定的元素", "甚至插入或者是删除某个元素", "我们也可以判定一下", "其中的元素", "是否已经有序排列", "如果没有有序排列", "可以调用相应的接口", "使之有序排列", "我们也可以在它", "尚未有序排列的时候", "按某种算法", "找到其中特定的元素", "也可以在已经有序的前提下", "按照某种方式", "来找到其中的元素", "当然为了展示一些算法的实现", "我们也附加了一些其它的功能", "比如说能够在", "无序和有序的情况下", "分别剔除", "这个数据集中的重复元素", "最后也是非常重要的一个接口", "就是如何对这个数据集中的元素", "逐一地进行枚举", "并且访问一遍", "我们称之为遍历"]}, {"name": "08b2-6: 紧凑表示", "block_id": "d553cf881d0f44a7a4dbc68dd4335544", "text": ["在这节的开始 我们曾经通过实例对B树有了一个感性的认识", "你应该记得当初我们归纳的一个特点就是", "B树会显得相对而言更加的矮 更加的宽", "因此在画法上 也需要做特别的处理", "如果需要完整的将一棵B树画出来", "那么我们都不得不为其中的每一个关键码分别针对它的左右后代", "在它的左和右画出2个引用 就像这幅图一样", "实际上关键码再稍多之后 无论是我们的讲稿还是教材", "篇幅都会很快不够用的", "一种略微紧凑的形式就是 将所有的这些引用都简化为一个点", "从而得到这样一种表示 这种表示是可行的", "依然清晰明了 不至产生任何歧义", "进一步的 既然所有的外部节点都位于同一层", "所以不妨也将它们一概省略掉", "从而得到这样一种更为紧凑的表示方法", "这也是我们在后续的讲解中将采用的方法", "那么需要提醒大家注意的是 不要被这些紧凑的表示方法误导", "尽管没有画出 在B树中的确存在很多外部节点", "而且也存在足够多个引用", "好了 接下来的一个问题自然是", "这样一种逻辑结构应该如何用代码具体表示和定义呢"]}, {"name": "12b1-2: 从中位数到众数", "block_id": "95dac183c34b4375b9ca2dcfa371f230", "text": ["众数也就是在一组元素中", "数量占绝大多数者", "因此也称作主流数", "比如在这样一个", "由5个元素所构成的集合中", "元素3总共出现了多达三次", "因此它就是这里的一个众数", "而在另一个规模为6的集合中", "尽管元素3也出现了三次", "但却没有达到4次", "因此这里并没有任何的众数", "需要强调的是作为这里的计算输入", "我们数据集中的数据", "并没有按顺序排列", "而往往是以一种", "无序的随机状态给出的", "比如构成一个无序向量", "而问题的难点也恰在此处", "因为如果所有的元素已经按顺序排列", "那么接下来", "我们只需做一趟简单的线性扫描", "就可以判断出是否有众数", "而且如果有众数", "我们也可以相应的判断是谁", "然而遗憾的是我们已经知道", "排序算法在通常的情况下", "都逃脱不了nlogn的下界", "因此我们并不能做这样的", "预处理或者假设", "在这里我们进一步追求的目标是", "对于任何一个这样的", "无序随机数据集", "我们希望能够在不超过线性的时间内", "使用最多常数的空间", "来找到其中的众数", "我们的构思首先从一条必要性出发", "实际上我们不难验证", "在一个数据集中", "如果的确存在众数", "那么这个众数", "也必然是整个数据集的中位数", "因为我们如果的确将这些数据", "从大到小排成一个有序的线性序列", "那么以中位数为界", "无论是前一半还是后一半", "都不足以容纳所有的众数", "也就是说众数所对应的那个区间", "必然会覆盖中位数", "这个必要条件非常重要", "因为它意味着", "只有中位数才是众数的", "唯一可能侯选", "实际上无论是中位数", "还是任何一个元素", "我们都可以在线性时间内", "验证它是否的确是一个众数", "你能想出具体的方法吗", "没错", "我们只需要遍历一趟整个数据集", "统计出目标元素的数目", "然后根据定义即可判断", "它是或者不是众数", "因此如果我们的确能从数据集中", "很快的找出中位数", "那么也就自然得到了", "一个众数的选取算法"]}, {"name": "09C-B DSA@THU", "block_id": "600d2232cda94029b23d3cc8e706b1fc", "text": ["作为课间轻松时刻的一个调剂", "我们不妨再来看一个实例", "Key to improving your programming skills", "编程能力及技巧 没错 据我所知", "这正是你和大多数同学来此学习的目的", "那么面对汗牛充栋的同类教材", "以及林林总总的同类课程", "为了做出一个适合于你自己的选择", "各中关键的技巧又在哪里呢", "我们不妨来看看 老天 哦不 散列所给出的建议", "看到了？", "是的 用散列的话说 这里发生了冲突", "collision 既是冲突 也是巧合", "这个方法 或许的确是你通往这个目标的最佳途径", "当然 毕竟谋事在人 在这个艰辛的过程中", "你和我都需要百倍努力 加油吧"]}, {"name": "10a2-1: \t向量 ", "block_id": "ce82591e304847ab9a50c4198ed97988", "text": ["以下我们就来看看如何基于此前业已掌握的基本数据结构来实现优先级队列。", "在这里我们既要考虑到效率，也要兼顾成本，", "而最佳的实现方式应该是这两个因素的综合与兼顾。", "我们的第一种实现方式是基于此前的向量，", "也就是说将所有的元素在底层组织为一个向量。", "这种实现方式非常简明，而且在某些方面效率还很高，", "比如对于每个新加入的元素，我们只需要简明地把它放到这个向量的末尾——", "也就是说，通过向量的insertAsLast就可以实现PQ的insert接口。", "我们知道，在向量中插入一个元素所需要的成本应该与这个元素的秩成反比。", "因此，最后一个元素作为秩最高者，所需要的成本也会最低，具体来说也就是常数。", "然而遗憾的是，为此我们却不得不在另外两个接口付出代价。", "为了找到优先级最高的元素，我们不得不遍历整个向量，", "也就是说，这一接口的实现成本将会是\\Theta(n)，", "而为了摘除优先级最高的元素，我们不仅需要遍历整个向量，", "而且需要在摘除之后将它的所有后继顺次前移，", "两项工作的成本累计也是\\Theta(n)，", "因此无论如何这都不是一个可行的解决方案。"]}, {"name": "08B4-4\t分裂到根", "block_id": "25118b7d5d4540c6ac2496575bcbdecb", "text": ["比如 仍以刚才的6阶B树为例", "假设经过若干次传播之后 最终在它的根节点处也发生了上溢", "此时 我们依然需要以这个中位数关键码为界", "将原先的节点一分为二", "同时 依然试图将这个中位数关键码向上转交给父节点", "然而 此时作为根节点 它的父节点并不存在", "在这种情况下 我们不妨就令这个", "提升之后的中位数关键码 独自成为一个节点", "也就是说 它将成为这棵B树新的根节点", "因此 整棵B树的高度 也会随之增加一层", "这也是导致B树增高的唯一情况", "请注意 在B树刚刚长高的这个时刻", "新的根节点只拥有两个分支", "无论B树的阶次是多少", "现在你应该理解了吧", "为什么在定义B树的那一整套规则中", "非要加入一条貌似不是那么完美的修正案", "是的 正因为有那么一条修正案", "才使得B树的根节点拥有少于m/2个分支 是合法的", "也就是说那条修正案是必须的 是断乎不可省略或变通的", "好了 由以上的分析我们可以看出", "在消除上溢缺陷的过程中", "我们最多只需在B树的每一层次做一次分裂", "也就是说 累计不过h次", "而每一次分裂本身 只不过是一个常数的操作", "因此  总体而言", "整个插入算法所需要的时间应该线性正比于B树的高度", "这也是我们所期望的"]}, {"name": "09C-5 M+A+D", "block_id": "e06aab54214241189c2ab81f024868fd", "text": ["我们接下来将要介绍的是MAD法", "名字听起来多少有点恐怖", "这种方法可以认为是除余法的改进或推广", "是的 如果更为严格的考察均匀性", "除余法的确还存在一定的缺陷", "体现在两个方面 问题首先出在零点", "无论表长M取值如何 0点总是会被映射到0点", "也就是说 存在不动点", "这与任何元素都拥有均等的概率", "被映射到任何位置的原则是完全相悖的", "其次 尽管其他的元素都大体拥有均等的概率被分配到各个桶中", "但不同关键码之间的这种映射", "却存在着某种简明的关联关系", "具体来说 经过散列映射之后", "相邻的关键码也必然依然的相邻", "就此意义而言 除余法所拥有的均匀性只是低阶的", "当然 我们更希望实现更高阶的均匀性", "比如至少临近的关键码", "在经过散列之后 不要继续的彼此临近", "那么如何实现这种更高阶的均匀性呢", "为此我们需要对除余法略作改进", "除了表长继续取做素数 我们还需要另外两个整数", "整个散列的计算过程包括三步", "首先做一次乘法 再做一次加法", "最后再做整除模余 这里的计算步骤增加了", "但如此却可以针对性的修复此前的两个缺陷", "你看出来了吗", "是的 新引入的整数b 可以视作是偏移量", "如此即可有效的消除不动点", "而另一个引入的整数a呢 则扮演着步长的角色", "也就是说 在经过散列变换之后 原本相邻的关键码", "将变成间隔为a 从而不再继续相邻", "当然 实际应用的需求多种多样的", "我们这里暂且只考虑最普遍的应用", "实际上在不同的场合", "散列的原则都有可能发生变换 甚至翻转", "比如 在某些特殊的场合", "未必需要高阶的乃至通常的均匀性", "比如在一些几何计算的场合", "我们需要处理的往往是来自于高维空间中的一系列点", "为了将它们压缩到更加低维的空间", "我们往往也需要借助散列", "此时我们对散列的要求可能恰恰相反", "也就是要尽可能使得临近的关键码", "被映射到临近的位置", "这也就是所谓的Locality-Sensitive Hashing", "散列技术在当今的信息处理中 之所以能够无处不在", "恰恰在于它的这些准则是灵活的", "再比如在我们这个课程中所讨论的主要技术", "多是旨在将一个相对而言更大的空间", "通过散列映射 压缩至一个相对而言更小的空间", "而实际上反过来也是大有用处的", "这也就是所谓的密码学"]}, {"name": "01b-4: \t理想模型", "block_id": "0d84c5da36f344369629c538a8a05b1d", "text": ["在解决了特定算法的评价问题之后", "我们就需要进一步的", "来回答另一个问题", "也就是说当同一个问题", "拥有多个算法的时候", "这是经常出现的情况", "我们如何来评价", "它们之间的相对好坏", "或者说优劣呢？", "一种直观的方法是", "所谓的实验统计方法", "简单的说是骡子是马拉出来溜溜", "谁所用的时间越短", "谁用的资源越少 谁就越优", "但是这种表面想当然的方法", "在实际应用中是不够用的", "因为它并不能准确的", "反应一个算法真正的全面的效率", "那么这个原因就在于", "我们的实验统计", "或者叫作实验测试", "总是不充分的", "算法和人非常的相似", "不同的算法 各有所长也各有所短", "所以如果我们的测试", "在问题实例的规模", "以及类型等等方面", "覆盖的不够全面", "不具有充分的代表性的话", "那么这种测试", "本身就是带有偏见的", "它的结论也就难以让人信服", "再退一步的 即使是同一种算法", "也可能是由不同的程序员完成的", "而且他们也有可能", "选择不同的编程语言", "而且甚至再进一步地", "可能会选择不同的编译器", "设置不同的编译选项等等", "再进一步", "即便是上述因素都是一致的", "也就是说是由同一个程序员", "用同一种语言", "并且用同一种编译器和设置", "编辑出来的执行代码", "在不同的硬件体系结构上", "在不同的操作系统上", "它体现出来的性能", "在此时和彼时", "也可能有很大的区别", "比如说 硬件的CPU速度", "内存和磁盘的速度和容量", "以及它们之间的带宽 等等", "还有包括操作系统", "在不同的时刻 对不同计算资源", "分配的当时的状况不同 等等等等", "这些因素都不可能由少数次", "有限次实验统计就足以覆盖", "综合起来我们最后", "能够可行的方法只有一条", "也就是说 我们需要抽象出", "一种理想的计算的平台或者说模型", "唯此才能抛开上述种种", "具体的 其实是次要的因素", "更加直接和准确地", "来评价和测量算法", "最后得出一个客观的结论", "这样一种做法", "就犹如物理学家伽利略", "所擅长的那样", "不是去真正的去做一个", "现实中的物理实验", "而是在头脑中去做一个", "虚拟的理想的", "但又是能够反应事物本质的实验", "而在我们这里", "确实人们已经构造出了", "很多种这样理想的平台和模型", "比如说我们接下来", "要讨论的图灵机模型"]}, {"name": "09C-A Vorldmort", "block_id": "7dbb71ff80704d328436a3e61a8097c1", "text": ["针对字符串关键码的hashcode转换", "最自然的方法莫过于此", "具体的 与多项式法一样", "这里也将每一个字符事先与某一个数值对应起来", "而所有字符所对应数值的总和", "也自然就是所对应的hashcode", "这种方法与此前所介绍的折叠法类似", "但这里的情况却有所不同", "以至于这种方法将会导致频繁的冲突", "来看这样一个字符串", "如果你熟悉Harry Potter的故事", "那么对Tom Marvolo Riddle就不会陌生", "是的 他是伏地魔的一个化身", "而这个名字也是伏地魔的一个化名", "你也应该会记得这样一句话", "是的这是Tom Marvolo在自认为", "已经掌控了Harry Potter的生死时", "颇为得意的写出的一句话", "而谜底恰好就藏在这两个字符串中", "即便你不知道这个故事 现在也不难看出", "这两个字符串实际上是由同一组字符构成", "只不过排列次序不同而已", "如果按照我们直观的想法", "将该字符串中的所有字符所对应的整数累积起来", "就会得到一个hashcode 196", "那么I am Load Voldemort", "不难理解尽管次序有所调整 但因为加法满足交换律", "所以同样应该得到196", "当然 既然这两个串都是由同一组字符构成的", "所以hashcode相同也毫不奇怪", "然而事实是即便是由不同的一组数字所构成的英文字符串", "按照这种映射方法也同样会有很高的概率发生冲突", "继续刚才的故事 你应该还记得第七集", "是的 在那集中我们终于得知", "Harry Potter居然也是Voldemort的化身死亡魂器之一", "那么在冥冥之中", "Harry Potter是否真的与伏地魔有某种因果联系呢", "我们不妨来做一次散列 如果还不是占卜的话", "来看这样一句话 哦不对是字符串", "既然Tom Marvolo与Voldemort之间的联系是源自其名字的巧合", "那么Harry Potter与Voldemort也应该是如此", "恩 必须的"]}, {"name": "08B5-1\t算法框架", "block_id": "da955b1c4ecc40c3bc8b0136b6f5acef", "text": ["接下来 我们讨论B树的第二类动态操作 也就是删除", "那么 B树的删除操作是否只是插入操作简单的逆过程呢？", "我们将会看到二者有很紧密的联系 但又不尽相同", "那么 应该如何将某个特定的关键码从其所属的节点中剔除掉", "从而完成这样的一个转换呢?", "这里我们也给出一种可能的实现方法", "首先 与插入算法一样 我们也需要经过一次查找", "并不失一般性 假设待删除的关键码的确存在", "而且就存在于返回的节点v中", "于是 我们进而通过向量的查找算法", "在v中确定 目标关键码e所对应的秩", "当然 我们希望此时的节点v是一匹叶子", "然而 这一点并非总能保证", "如果它不是一个叶节点 我们就要深入到关键码e所对应的右子树", "然后一路的沿着最左侧的分支向下", "如此最终抵达的节点u就必然是e的直接后继", "以下只要令u和v互换位置 即可等效的保证", "待删除的关键码e来自于名为v的某一个叶节点中", "而且这个关键码在v中对应的秩为r", "因此只需将这个关键码从关键码向量中剔除", "同时 删除其对应的那个分支", "与插入算法同理 如果你不太在意算法的可读性", "在这里 你要删除的未必是第r+1个分支", "而可以选择其中的任何一个 比如最后一个", "因为所有的这些孩子 此时无非都是空", "同样的 在你更新了规模记录之后 故事还并没有完结", "因为与插入过程完全对称的 在损失了这样一个关键码之后", "当前的节点v 有可能会突破B树关于分支数所设定的下限", "对称的 我们也称这种现象为下溢 underflow", "为此 我们在返回之前 还需要检查并且处理这种情况", "那么具体的 如何处置这种情况呢？"]}, {"name": "11c1-3\t: 记忆力", "block_id": "7b0e28e3f3144aae96d61b5b3dcff661", "text": ["事实上 只要我们的记忆力足够强", "自然也就可以将在前一轮比对中所获得的上述信息存储起来", "并为后续的比对所利用", "而这类信息的使用原理与方法", "则可以由这幅图来表示", "请再次确认这个图所对应的场景", "也就是在当前的对齐位置", "我们首次在T[i]和P[j]处发生了一次失配", "而反过来", "P[j]所对应的那个前缀以及T[i]所对应的那个子串是完全匹配的", "只要我们能够充分地利用这类信息", "就可以迅速地排除掉大量的对齐位置", "从而令模式串得以迅速地、大幅度地向后滑动", "而且 同样是利用这类信息", "我们甚至可以不必去重复比对在T[i]之前的任何字符", "也就是说在模式串的下一对齐位置", "新一轮的比对只需从T[i]与新的P[j]开始"]}, {"name": "08A2-5\t折叠效果", "block_id": "7cd8b1987dac4627911f57edd54d231c", "text": ["为了更好的看到树高的变化效果", "我们不妨来看一个更大的伸展树", "这是一棵由31个节点所构成的高度为30的伸展树", "我们继续试图恶意的来访问其中最深的", "也是访问成本最高的那个节点1", "请留意在访问这个节点之后", "对它进行的双层调整过程", "尤其是观察 在每一局部", "按照Tarjan所建议的方式进行调整之后", "对于这棵树的整体所产生的效果", "我们来看一下这棵调整之后伸展树的拓扑结构", "不出我们的意料 全树的高度 大致也缩减了一半", "接下来如果我们继续试图", "恶意的访问其中最深的那个节点", "那么在访问完这个节点之后", "将同样的通过一系列的双层伸展", "将这个节点推送至树根", "而且最重要的一个全局特性是", "这棵树的高度会因此继续缩减一半"]}, {"name": "05E4-2 实现", "block_id": "c33de99552d1483996f4f8daa95e5183", "text": ["好的 那我们接下来就来看看", "如何借助队列", "来实现层次遍历", "可以看到 层次遍历的接口", "与此前的其它遍历形式完全一致", "在内部 我们的确需要引入一个队列", "用以存放一系列节点的位置", "作为初始化 我们首先要将this", "也就是起始的根节点加入队中", "接下来 进入一个循环", "每次我们都首先取出队首节点", "并随即访问它", "接下来呢 同样需要向下方左顾右盼", "如果该节点有左孩子", "就令左孩子入队", "同样地 如果有右孩子", "那么也令右孩子入队", "做完这样的处理之后", "我们的循环又重新地进入", "下一步迭代", "可以看到 只有当队列重新变空时", "循环才退出", "算法也终止"]}, {"name": "01a-2: \t绳索计算机", "block_id": "102d2536030d47b4b343c3848f6f50b6", "text": ["计算在我们的周围无处不在 无时不在", "所以我们似乎对它很了解", "但实际上我们也对它非常陌生", "在相对的给出计算的明确概念之前", "我们不妨通过几个实例来看一看", "所谓的计算具有哪些特点和共性", "我们先来看这样一个问题", "这也是我们比较熟悉的一个问题", "也就是说 当我们在被给定一条直线L之后", "如果进而在上面确定一个点A", "如何经过这个点做这条线的一条垂直线", "我们来看一下在4000多年前古代的埃及人", "是如何求解这个问题的", "我们先来关注一下他们所使用的工具", "这个工具比较特别", "是由12段长度均等的绳索", "首尾连接而成这么样一个环状的工具", "绳子与绳子之间有一定的标记", "在这里我们不妨取其中一个 比如说A点", "接下来第一步就是要把", "比如说是用结来表示的这么样一个点A", "与我们给定的那个A重合起来", "接下来呢 由另一个人配合着", "从A这个绳结开始 往下数出4节", "直到第4个点 我们称之为B", "那么这第二个人将拉着B点", "当然也同时牵引着AB之间这样4条线段", "直到在L这条直线上完全的拉直", "那么接下来在剩下的8段绳索中", "我们还要找到其中3", "以及剩下的5所切分的那个点比如叫做C", "那么这时候由第三个人帮忙", "他会牵引着这个C点 沿着L这条直线的一侧", "比如说我们这里采用的是下方这样一侧", "尽可能的前行 直到他手头两侧的绳索", "也就是3和5长度的这样两个绳索", "完全的被拉直", "显而易见 在这个时候", "A和C之间所确定的这样一条直线", "就是我们所需要计算的那样一条垂线", "那么这里的计算机是什么呢", "大家可能都已经注意到了", "就是上面这个长度为12的绳索", "而这个计算是什么呢", "其实就是这样一个利用这种工具", "可以重复的机械的完成的一个过程"]}, {"name": "04C3-4\t 算法", "block_id": "a996104cda334de081b0339e11d78d3f", "text": ["关于这个问题", "knuth在他的the art of computer programming中", "已经给出了正面的解答", "他指出 其实我们所说的禁形", "不仅是个必要条件", "而且确实也是个充分条件", "if and only if是个充要条件", "具体来说 一个排列permutation", "如果确实是一个栈混洗的话", "那么充要条件就是", "其中不包含这种312的模式", "在我们教材配套的习题解析中", "第4-3题也对此作了讨论", "在这里 我们不妨把证明过程忽略掉", "当然这样一个结论", "可以直接导出一个对应的算法", "也就是说 我们去不断地枚举", "所有的i j和k的组合", "当然反过来也很遗憾", "不难看出 这样一个算法的复杂度", "将高达n的立方", "我们是不能接受的", "实际上 进一步地", "我们还可以将这样一个判别的依据", "作以简化", "具体来说 我们只要逐一地去检查", "每一对互异的i和j", "只要在排列中不会出现", "j+1、i以及j这样的一个模式", "我们同样可以把它当做一个", "判断栈混洗的充要条件", "关于这个性质的证明", "大家同样可以去参考习题4-3", "同样地 这样一个改进以后的结论", "可以直接导致一个新的甄别算法", "因为这个算法需要枚举", "所有的互异元素对", "所以它也需要高达n平方的时间", "所以它的时间复杂度也将高达n平方", "这样的效率也同样难以令我们满意", "实际上 借助栈结构", "我们完全可以实现一个", "线性时间的甄别算法", "这个算法的思想也非常的简单", "也就是完全按照栈混洗的定义", "引入三个栈", "并且通过对栈混洗过程的模拟", "以一种验证的方式来判别某一个排列", "是否的确为栈混洗", "具体地 对于输出序列中的任何一个元素", "我们都采用一种贪心的原则", "以S为中介 将其从A转移至B中", "只要这个贪心的过程能够持续进行", "并最终将所有的元素顺利地从A转入B中", "那么我们就可以判断它是一个栈混洗", "反之 每次通过pop操作", "试图从S中弹出当前的元素时", "如果S已经变空", "或者要弹出的元素 虽然在S中存在", "但却非最顶端的元素", "我们都可以立即判断这个栈混洗是非法的", "我们将这样一个算法的具体实现", "留给大家作为编程习题"]}, {"name": "05E5-2 (先序|后序)+中序", "block_id": "c971bf586d9d4051a471035ad4dc46fa", "text": ["关于二叉树的重构", "第一个结论是我们只需中序遍历序列", "再加上先序与后序遍历序列之一", "即可忠实地还原二叉树的完整拓扑结构", "为此我们需要做数学归纳", "假设对于规模小于大N的所有二叉树", "这个规律都是成立的", "接下来 考察规模恰好为N的二叉树", "不失一般性", "我们可以将这棵二叉树", "画成这样的一个模式", "于是它的先序遍历必然从根节点r开始", "因此在这棵树的先序遍历序列中", "首个节点也必然恰好就是根节点r", "而紧随其后的必然是", "左子树所对应的遍历序列", "以及右子树所对应的遍历序列", "类似地 在这棵树的中序遍历序列中", "左子数所对应的遍历序列必然是前缀", "右子树对应的遍历子序列必然是后缀", "而根节点r呢 必然镶嵌于它们之间", "因此根据先序遍历序列", "可以明确树根节点究竟是谁", "进而可以在中序遍历序列中", "对这个节点进行定位", "这个定位非常重要", "它使我们得以确认左子树", "所对应的中序遍历子序列", "以及右子树所对应的中序遍历子序列", "也就是说", "我们可以知道左子树和右子树", "分别是由哪些节点组成的", "因此只要这两个遍历序列是合法的", "反过来 我们在先序遍历序列中", "就可以很容易地将左子树和右子树", "所对应的遍历子序列切分开", "这样我们就成功地将原来全树的重构问题", "化解为两棵子树的重构问题", "不难看出 这两棵子树在规模上", "都符合归纳假设", "也就是它们都严格地小于这里的大N", "因此根据归纳假设", "无论是左子树 还是右子树", "的确都可以如此重构出来", "当然你应该不难写出一个", "递归式的重构算法", "需要特别注意的是", "无论是左子树 还是右子树", "都有可能是空树", "在这种情况下", "树的规模应该是零", "那么不借助中序遍历序列", "而只凭借先序和后序遍历序列", "是否也能保证", "完成对左右子树的正确切分呢？", "我们说这一点是不能保证的", "其中的原因正是在于我们刚刚指出的", "无论是L 还是R都有可能是空树", "比如如果有一棵树右子树是空的", "那么它对应的先序遍历序列应该是这样的", "而它的后序遍历序列呢", "应该是这样的", "反过来 如果这棵树的左子树是空的", "那么它的先序遍历序列应该是这样的", "而它的后序遍历序列应该是这样的", "可以看到 这里出现了歧义", "我们无法根据先序遍历序列", "以及后序遍历序列", "来区分在这种情况下", "除去根节点之后的部分", "究竟是左子树 还是右子树"]}, {"name": "01E-09: Max2：二分递归", "block_id": "a6b1db1302c8434f9d46489ce1d3f0af", "text": ["比如说 我们可以按照", "这样的一个图示来进行改进", "具体来说 我们总是把", "整个这个序列每次", "都化分为左侧和右侧两部分", "这里我们不妨把它们", "垂直地画出来", "这个无所谓 比如说左侧和右侧", "接下来呢", "我们递归地求解两个子问题", "分别求出左侧的", "最大元素和次大元素", "以及右侧的最大元素和次大元素", "接下来呢 全局的最大元", "必然来自于左侧的最大元", "和右侧的最大元之间的更大值", "为此我们花费一次比较", "那么当然有两种情况", "所以这里头画出了对称的情况", "可能确实是", "左侧的这个最大者胜出", "也可能是右侧的这个最大者胜出", "不失一般性 我们先考虑左侧的这个", "右侧完全对称的", "如果经过一次比较以后", "我们确认左侧的胜出", "那么我们又可以进而得出结论", "全局次大的元素", "必然是来自于", "左侧的次大元素", "和这个刚才", "如果说是败下来的", "右侧的最大的元素", "同样 我们经过一次比较", "就可以确认它们中间的胜者", "大家注意 在这里", "我们刚才失败的", "那个子问题中的次大者", "无需参与比较", "我们来看一下", "这样的一个思路呢", "可以整理为这样一段代码", "当然这里也有退化的情况", "我们把这样的退化情况的", "实现和解释这个任务", "留给同学们在课后完成", "一般而言", "我们都是取lo和hi的中点", "并且递归地求解出", "刚才我们所说的x1L x2L", "以及x1R和x2R", "接下来 我们对两个子区间的", "最大者进行一次比较", "就可以确定其中的胜者", "这就是全局的最大者", "或者是它 或者是它", "那么 刚才我们说了", "左边这个图", "对应的是if这种情况", "右边这个图", "对应的是else这种情况", "进而全局的次大元素x2", "怎么来确定呢？", "我们可以看到", "无论是if 还是else", "它都是对称的", "我们只需要再进行一次比较", "这次比较 其实对应的就是这个", "我们再回顾一下", "刚才这次比较", "其实对应的是它", "或者是说它", "后面这两次比较", "对应的是它", "或者是它", "我们可以看到", "无论如何 在每一个递归实例中", "即便是在最坏的情况", "我们也至多只需要", "进行一次和两次比较", "这也就是为什么", "可以用递推方程的方式", "可以写出来T（n）", "应该是等于两倍的", "两个T（n/2）规模的子问题", "也就是T（n/2）", "再加上刚才的两次比较", "这样一个递推式", "用前面类似的方法", "我们可以去求解", "得到5n/3－2", "当然如果你不知道", "具体地求解方法的话", "你不妨去验证一下", "我们说这种结果", "是非常好验证的", "按照这样的一个公式", "可以得出来 T的（n/2）是多少", "然后代进去", "不难验证这样一个结果", "我们这里需要指出的是", "确实我们可以看到", "如果此前的方法", "在最坏情况下", "所需要的比较次数", "就n的常系数而言", "如果是2的话", "现在 在这里降为了5/3", "我们可以看到", "它有一个确定的下降", "这种下降再强调一下", "是即便在最坏情况下", "也能够保证的", "当然在最好的情况下能够多少", "我们也把这个问题", "留给大家在课后思考", "所以概括一下", "我们这一节的主要内容是", "既教给了大家", "迭代与递归的算法", "包括两种重要的算法的策略", "减而治之和分而治之", "更重要的是", "结合这两种策略的介绍和实例", "我们给出了递归算法的", "两种典型的常用的分析方法", "也就是递归跟踪和递推式", "在后边 我们将会看到", "更多更复杂的这方面的例子"]}, {"name": "11d1-4: 以终为始", "block_id": "72d8c8759b544db0974d297d15a0f94d", "text": ["既然按照以上的分析", "模式串中越靠后的字符对算法性能的优化作用更大", "那么或许我们应该把计算的方向和次序颠倒过来", "以终为始", "此话怎讲呢", "具体来说 在每一趟扫描中", "我们都需要从末字符而不是首字符开始比对", "也就是说 扫描的方向将变成自后向前而不再是自左向右", "来看这样一个具体的例子", "这就是由12个字符所构成的一个文本串", "而待匹配的模式串", "则由这3个字符组成", "为了启动第一趟扫描", "我们首先要将它们的首字符彼此对齐", "然而这里 我们将首先从末字符开始比对", "可以看到 这是一次失败的比对", "实际上 这种失败的比对必然是更容易发生的", "因为你注意到 我们在这里所采用的字母表是由汉字构成的", "即便是只记录常用的汉字", "其规模也至少超过5000", "从多达5000个的候选中任取2个", "二者相同的概率自然是非常非常之低的", "反过来 不同的概率也就应该很高", "所以对于这次失败 我们应该有足够的心理准备", "因此接下来 或许我们应该静下心来 对这次失败好好地作一分析", "或许你能从中悟出点什么", "是的 表面上看这里是“名”与“道”之间的冲突", "而实际上我们可以将这次教训进一步地概括为", "如果需要在“道”的附近实现一次完整的匹配", "那么 至少与它对应的那个字符", "就应该也是“道”", "而非“名”", "现在 按照这一必要条件来反观我们的模式串", "就会发现其实“道”根本就没有出现在其中", "这一点非常重要", "如果能够悟到这一点", "我们就可以大胆地将这个模式串整体地移过这个位置", "从而在这样一个新的位置对齐", "接下来的这趟比对与上一趟基本类似", "依然是“名”与“道”不符", "所以再一次地", "我们同样可以将整个字符串移过这个位置", "从而在这样一个新的位置", "继续对齐", "接下来的这趟扫描", "依然起始于末字符", "可以看到 这是一次成功的比对", "你应该觉得非常幸运", "因为正如我们刚才所言", "这种成功比对出现的概率是极低的", "于是接下来 我们再去进而比对与之在左侧相邻的那一对字符", "这依然是一次大概率的失败比对", "然而 作为一次新的教训", "它同样有可能让我们悟到点什么", "是的 依然是这个失配位置处的“可”字", "它同样给出了一个能够局部完全匹配的必要条件", "然而 如果按照这个必要条件反观我们的模式串", "就会发现 其中同样没有出现这个字符", "因此接下来 我们可以将这个字符串同样整体地移过这个失配的位置", "并在这样一个新的位置", "继续对齐", "然后 依然从末字符开始", "继续比对", "同样 依然是大概率的失败", "而此后 只要我们能够静下心来对这一教训作一分析", "就同样能够针对完全匹配", "给出一个必要条件", "我想 你已经看出这个必要条件来了", "是的 如果能够在包括这个“常”字在内的局部", "实现一次完全匹配", "那么模式串中与之对齐的", "就同样也应该是一个“常”字", "这一回 我们以此反观模式串", "就会发现的确存在一个“常”字", "因此接下来 我们就不妨将整个字符串向右移动一个单位", "从而让“常”字的确与“常”字相对", "在满足了这样一个必要条件之后", "我们就可以来开始新一轮比对", "首先是末字符", "这是成功的", "而且接下来的各次比对", "也都是成功的", "这意味着我们终于发现了一次完全的匹配", "整个算法也就可以随即终止", "现在 我们来核算一下这个算法所花费的计算成本", "也就是在其间所作的比对次数", "按照我们这里标注的习惯", "深色的都是成功的比对", "灰色的则是失败的比对", "而白色的 则是没有进行 从而节省下来的比对", "可以看到 我们累计做了4次成功的比对", "以及4次失败的比对", "没错 4次", "加4次", "累计不过8次", "这一结果意义非凡", "因为我们注意到 即便忽略掉模式串", "仅文本串 也至少有12个字符", "而我们在算法过程中所执行的比对次数", "居然要小于这一长度", "换而言之 平均在每个字符上", "所消耗的比对居然不足1次"]}, {"name": "04C4−6B\t 实例B", "block_id": "6f8d535aa18e4c058c50968534d07628", "text": ["4刚刚入栈 我们的关注点就可以随即", "转向接下来的右括号运算符", "同样，当前运算符和栈顶运算符", "经过一次比较以后", "我们会发现是属于大于号的情况", "这意味着我们刚才所", "缓存起来的减法运算", "等到了能够执行的时机", "因此接下来会执行65减去4", "并且将所得的结果61", "重新纳入这个栈中", "可以看到，的确如此", "请注意，我们的关注力依然集中在", "刚才的右括号上", "接下来，将当前的这个右括号", "与栈顶的左括号进行优先级比较", "通过查阅优先级表", "我们确认这是一个相等的关系", "这依然是一种简明的情况", "我们应该还记得", "它所执行的动作有两步", "首先将栈顶的操作符弹出", "接下来跳过当前字符", "进而转向下一个字符", "从效果上看，这等价于这对括号完全不存在", "没错，如果我们回顾一下刚才的历史", "就会发现这对括号的作用", "只是阶段性的", "它们只是为了界定", "介于它们之间这个", "子表达式的运算优先级", "而我们刚才通过一系列的准确的处理", "已经将这个子表达式计算完毕", "它对应的结果已经存放在操作数栈中了", "从这个意义上讲", "这对括号的历史使命也都完成了", "所以它们可以携手退出历史舞台", "这是再自然不过的结局了", "我们来看一下这个结局", "确实这对括号消失了", "而我们的注意力转向了一个新的历史开端", "也就是接下来的乘法运算符", "我们同样通过查表确认", "乘法运算符和当前的", "栈顶\\0之间的关系", "依然是小于号", "此时如果你手头确实有那么一张", "优先级表的话", "那么我建议你关注一下\\0所对应的那一行", "你会发现其实不光是对于乘号", "只要是常规的加减乘除之类的运算", "这样一行中", "所给出来的优先级判断关系", "都是统一的小于号", "而且如果你再关注一下左括号对应的", "那一行的话", "你也会发现有类似的规律", "其实这个规律不难理解", "正像我们此前所说的", "无论是\\0，还是左括号", "它们都可以比喻为是", "一个非常谦恭而且好客的君子", "只要它遇到的是一个常规的预算符", "都会谦让地让它随即入栈", "排列在它的，从栈的方向来讲的，上方", "而为了达到这个效果", "一种简明的方法", "自然就是将对应的优先级项", "置为小于号", "所以这也就是为什么", "\\0以及左括号所对应的那一行", "几乎都是小于号的原因", "所以此后凡是\\0或者左括号", "出现在栈顶", "我们都可以下意识地认为", "接下来都应该令任何一个常规运算符", "随即入栈", "比如说在这种情况下", "正常的结果应该是", "刚才的当前运算符入栈", "同时将注意力转向下一个字符", "这是一个左括号", "请注意，我们刚才所说的关于左括号的那个规律", "是相对于它出现在栈顶而言的", "而反过来，如果它出现在当前的位置上", "在优先级表中，左括号所对应的那一列", "也大部分是小于号", "比如现在这种情况，就属于此列", "按照算法的流程", "这类情况都对应着直接令当前运算符", "也就是左括号进栈", "概括来说，左括号是个非常有意思的运算符", "如果它出现在栈顶", "它就会乐于接纳任意常规运算符", "反过来，作为回报", "一旦它出现在当前的位置上", "无论栈顶的操作符是谁", "对方也会乐于接纳它进入到栈中", "好，也就是说", "我们接下来的状态应该是", "左括号入栈", "同时将注意力转向下一个字符"]}, {"name": "02D2-3 \t语义", "block_id": "daae2e20f0b74d8a96bcc98753ac61ad", "text": ["这种在语义上进一步地细致约定", "是非常有必要的", "否则的话，我们的search接口", "将只能作为一个孤立的功能", "而不能有效地、便捷地", "为其它的算法，作为一个基本的部件而利用", "比如说，search接口至少应该", "使得有序向量自身的动态维护变得非常便利", "比如说，在有序向量不断插入元素过程中", "我们希望往往能够采用这样一种形式", "也就是说，当我们需要", "去插入某一个元素的时候", "我们首先要通过search", "来确定一个适当的位置", "比如说，就是这个查找返回的那个值再加1", "然后再将e插入于这样一个秩所对应位置", "并且同时使得这个有序向量", "继续是一个有序向量", "所以这样的话", "对我们刚才所说的几种特殊情况", "就有明确的要求", "而不是说可以简单地处理", "比如说，即便是失败", "我们也需要给出新元素插入的适当的位置", "也就是说，我即使跌倒了，我也不能白白跌倒", "我应该为后继者提供一个参考的依据", "反过来，即便是有重复的元素", "比如说像刚才所说的", "在这个地方，可能有多个元素", "构成一个区段", "它们都是某一个特定的元素", "我也需要使得新插入的元素", "总是，比如说，排在最后或者是排在最前", "这样的话呢", "能够使得每一组这样的元素", "排列的相对次序", "与它们的插入的次序是吻合的", "那么这些呢，都是属于语义方面的", "更深入的要求", "很幸运，前人已经帮我们设计出了", "这样的语义约定", "比如说，这就是其中的一种", "我们这里约定", "search接口的返回值总可以概括地", "说是不大于目标的最后那个元素", "确切地讲，是它的秩", "我们来看几种特殊的情况", "第一种情况，就是查找失败", "如果查找失败，按照这里的约定", "它会失败在", "一个不大于这个e的最大的那个元素", "所以如果随后的这个元素是存在的", "它必然是大于e的", "而这边这个呢，必然是小于等于e的", "所以如果返回值是在这", "我们将新的那个元素插入在", "它的位置再加1的这个位置上", "那么是再合适不过的了", "其实这里头也有几种特殊的情况", "比如说，这个元素确实不存在", "但是它的数值非常非常的小", "以致于这个区间内，最左侧最小的这个元素lo", "也比它大", "这个时候有效范围内的任何元素", "都是不能作为返回值返回的", "这时候我们返回什么呢？", "我们倾向于返回lo-1", "因为这样的话", "如果我们接下来确实要把这个元素插入进来", "那么也就是插入在lo这个位置上", "这个和我们的要求是吻合的", "那么怎么做到这一点呢？", "我们说，以假想地在lo的左侧", "就像现在这样，再增加一个哨兵", "而它的数值呢", "我们可以等效地认为，是等于负无穷", "反过来，如果", "待插入的这个元素e非常非常大", "以致于连实际存在的这个", "最大的这个hi-1也要比它严格地小", "那么这个时候呢", "如果要插入的话，应该插入在hi这个位置", "这个虚拟的", "有可能根本不存在的这样的一个位置上", "那么这个时候", "返回的值应该是hi-1", "再合适不过了", "因为如果是hi-1是作为返回值的话", "那么把这个数值插在hi这个位置上", "和我们的功能也是吻合的", "所以对称地", "我们不妨认为这个假想的哨兵hi", "所具有的数值也是有的", "只不过它是正无穷", "所以这种情况不仅能处理", "而且可以有一个很好的一个解释", "再来看，重复元素的情况", "如果确实像刚才所言，在这个地方", "可能有多个元素是与目标的元素是重复的", "这个时候呢", "我们说这个算法按照这里的要求", "应该返回的所谓的不大于e的最后一个元素", "当然也就是这个区段的右端点了", "所以接下来，如果我们要做一个插入", "也就是说", "把这个位置同样地加1", "指向这个位置", "新的这个元素插入于此", "我们说，也是再合适不过的", "这个所谓的合适就是说", "第一，它继续保持了整体的有序性", "第二，它以及与它雷同的那些元素", "会保持它们插入到", "这个向量中的先后的次序", "所以我们看到，这种语义定义是非常好的", "它涵盖了我们几乎所有的情况", "包括特殊情况", "所以接下来", "我们在实现这些具体的算法的时候", "必须最终落实到", "能够符合这种语义的要求"]}, {"name": "10B4-5: \t自下而上的下滤：效率", "block_id": "b6b06ece3a95497eb6757e0ebfc6131a", "text": ["纵观Floyd建堆算法，实质的计算成本来自于对每个节点的下滤。", "我们可以看到，每一个节点都会经过一系列的交换下降一定的高度，", "有的下降得少一些，有的下降得多一些。", "就最坏情况而言，每个内部节点下降的层次数最多不过它的高度，", "因此整个Floyd算法的计算成本无非就是每一个节点所对应高度的总和。", "经过推算不难得知，这个总和在渐进意义上无非是O(n)，限于时间关系我们不妨省去这个推导过程，", "如果你对此有兴趣，可以进一步地阅读我们的讲义以及习题解析。", "而利用节省下来的这一部分时间，我们不妨就Floyd算法与此前的蛮力算法做一对比：", "这一算法既有趣，也更有意义。你应该记得蛮力算法的O(nlogn)的效率是来源于对所有节点深度的求和。", "是的，这里的差异就在于究竟是对高度求和还是对深度求和。", "而饶有趣味的问题在于，对这两个貌似接近的指标进行求和，", "为什么在渐进的意义上却有如此之大的差异呢？对于这一现象，你又当如何解释呢？", "没错，造成这种实质差异的根本原因就在于，", "在完全二叉树中，越是靠近底层，节点越多；而越是靠近顶层，节点也就越少。", "因此，如果以深度作为成本的指标，那么累计的总和也自然就会更大，", "打个未必恰当的比方，每个完全二叉堆就犹如一个社会，", "如果将高度对应于收入的水平，那么高收入的人群必定是凤毛麟角，而大部分都是中低收入者。", "而如果需要对所有的人征税，再自然不过的规则就是按照收入的高低来决定税收的比例：", "低收入者少纳税，高收入者多纳税，再合理不过了。", "事实上Floyd算法所对应的正是这样一种合理的政策，从这个角度，蛮力算法恰好颠倒了标准，", "这种算法相当于，为了迎合少数的富人，竟然以收入的反比确定税赋的比例，", "因此，自然会不得人心，并最终受到惩罚。"]}, {"name": "04C2-4\t 实现", "block_id": "e0ab3bf4730b4b10977df47e2e7dda5a", "text": ["以上的整体构思，可以", "具体地兑现为这样一段代码", "为了判别low与high之间的", "这样一段表达式是否括号匹配", "需要引入一个名为S的栈", "以下的这个循环", "逐一地检查每一个字符", "如刚才所言，如果是左括号", "我们就简明地令它入栈", "否则的话，我们试图弹出栈顶", "如果它的确存在的话", "应该就是与当前这个右括号", "匹配的那个左括号", "当然，如果此时栈已经提前变空", "那么就意味着整个表达式失配", "我们甚至可以断定", "此时的失配是由于某一个右括号", "缺少与之匹配的左括号", "当处理完所有的字符", "并退出循环的时候", "我们需要检查栈在当前是否是空的", "只有当栈恰好为空时", "才说明表达式是匹配的", "否则的话，我们可以断定", "原来那个表达式是不匹配的", "我们甚至也可以断定", "此时是属于某一左括号缺失", "与之配对的右括号的情况"]}, {"name": "02B-1\t 可扩充向量", "block_id": "b2efbeccf7fb4c4cbe913e728144a644", "text": ["欢迎回到数据结构的课堂", "在上一讲中", "我们首先介绍了ADT的规范", "并且基于这种规范", "给出了向量的接口定义", "我们也实现了", "作为一个数据结构而言", "最最基本的构造与析构接口", "与所有的数据结构一样", "向量也可以认为是", "一组数据项的集合", "换而言之", "它首先必须能够", "自适应地在规模上", "适应其中所包含的", "元素个数的变化", "这也就是为什么这一节", "要集中讨论它的可扩充性能", "向量天生", "并不具有这种性能", "我们需要采取一些策略", "而且需要采取聪明的策略", "的确 就目前的设计方案而言", "我们的向量并不具备", "可扩充的性能", "究其原因在于", "它采用的 实际上是所谓的", "静态空间管理的策略", "具体来说", "它实际上在内部", "只不过是设置了一个", "私有的数组", "这个数组所占有的", "那段连续的地址空间", "会被用来存放若干个", "对外界而言可见的", "或者是有效的元素", "而这些元素的总数 或者说它们", "所占用的逻辑空间的数", "我们用_size来表示", "而整个物理空间的大小", "是由_capacity来确定的", "这里的问题是", "_capacity一旦确定", "按照目前的方案", "它就将一成不变", "而这样一种策略", "显然存在明显的不足", "这种不足", "体现在两个方面", "第一 是有可能会出现", "所谓的上溢overflow", "也就是说", "随着有效元素（个数）的增加", "总有一天有这样的可能", "使得整个这个element", "所占用的物理空间", "已经不足以存放", "需要存放的元素组", "尽管在这个时候", "在系统的其它的部分", "仍然有足够多的空间", "可以用于存放这些元素", "但是", "限于_capacity是固定的", "我们不能直接做到这一点", "另一种情况呢", "虽然不是很严重", "但是 也是会造成一定的", "空间的效率低下", "我们称之为下溢", "underflow", "具体来说 就是", "有可能我们开辟了一个", "比较大的空间", "但是在整个", "这个数据结构的生命期内", "真正存放于其中的数据", "却寥寥无几", "从而使得我们有一个指标", "叫作装填因子", "会非常非常的小", "这个装填因子", "其实就是 我们的有效元素个数", "也就是_size 去除以", "可用于存放元素的空间总数", "也就是_capacity", "我们也可以理解成是", "这个空间的利用率", "它有可能不到一半", "甚至远远地低于一半", "那么在这种时候", "空间效率非常低下", "很遗憾", "如果我们坚持采用这样一种", "固定容量的策略", "我们在实际的一般应用环境中", "很难在事先就预测到", "我们需要用多少空间", "也就是说 这种空间不足", "以及空间浪费的情况", "都有可能发生 甚至经常发生", "那么有没有什么好的办法", "可以使得向量", "可以自适应地 根据实际需要", "来动态地调整自己的容量呢？", "而且这种调整的过程", "既能保证足够", "同时又不致使得", "因为开辟的空间过多", "而导致空间效率的低下", "我们说是可以的"]}, {"name": "08xa4-9: \t归纳体味", "block_id": "3457999087eb485b9f3f8f42bc458a1c", "text": ["好 终于到了可以总结的时候了", "在介绍过红黑树在各种情况下的调整算法之后", "我们不难发现它与AVL树至少一样", "每一次删除操作 在每一高度上至多只会花费常数时间", "由此可知 红黑树的删除操作", "时间复杂度不会超过logn", "然而我们的目标还不止于此", "是的 我们还需要更为精细的来考察", "其中所涉及的拓扑结构调整的工作量", "也就是旋转操作的累计次数", "为此 我们可以将以上4种情况的处理流程", "汇总为这样一个流程图", "首先是BB-1", "你应该记得 在这种情况下我们的处理是一蹴而就的", "成本是一次重染色 以及一轮重构", "也就是说 在这种情况下 我们的确只需要常数次旋转操作", "而接下来的BB-2R 从计算的角度来看更为简明", "你应该还记得 在这里我们只需要一轮重染色", "即可完成对双黑缺陷的修复", "也就是说 这种情况所涉及的旋转次数为0", "再来看更为复杂的BB-2B", "你应该记得 在这种情况下我们会做一轮重染色", "然而遗憾的是 此时除非我们已经抵达树根", "否则我们并不能保证算法就此结束", "事实上我们往往会在一个更高的层次上回到最初的问题", "并相应的进行处理", "在最坏的情况下 这种不断的向上蔓延可能会多达logn步", "然而无论如何 我们可以看到 在这种情况下", "我们所做的操作 只涉及重染色", "而没有任何的拓扑结构的调整", "因此这种情况所实质对应的旋转操作次数也是0", "最后 自然是最为复杂的BB-3", "你应该记得 此时我们的确需要做一轮重染色", "以及一次旋转调整", "并在随后在更高的层次上 转入到问题的原点", "然而正如我们已经强调指出的", "此时的原点并非完全的原点", "什么意思呢", "你应该还记得 如果的确是从BB-3这种情况转化而来", "那么接下去必然不可能是令人生厌的BB-2B", "而只能是BB-2R甚至是BB-1", "从流程图可以看出 无论是BB-2R 还是BB-1", "接下来都不会做更多的迭代", "而反过来只需要再进行一轮调整", "即可完成整个的双黑修复", "由此可见 在这种情况下", "我们所需要执行的旋转操作 累计也不过是常数次", "凡此种种 通过以上概括我们可以发现", "红黑树的删除操作 至多只需做logn次的重染色", "以及常熟次的结构调整", "这也是红黑树优于AVL树的一个重要方面", "你应该记得 我们在介绍红黑树的一开始就曾经提到", "这一特性 对于持久性结构的实现是至关重要的"]}, {"name": "05E2-6 实例", "block_id": "602f6f316c914eb88c4ac7bc5aa2e31a", "text": ["最后我们通过这样一个实例", "来加深对刚才那个算法的认识和理解", "首先引入一个栈 初始为空", "当然 算法的入口是在这棵树的树根", "也就是节点b", "我们知道节点b并不会立即接受访问", "而是会沿着起自于它的这样一条左侧链", "不断地下行直到末端节点a", "在整个过程中 从第一个遇到的b", "到最终遇到的a 都将被依次推入栈中", "接下来 当前的栈顶a将被弹出", "轮到它接受访问了", "同样 我们这里依然以染黑", "来表示这个节点", "已经接受访问", "你应该还记得 此后", "将会试图把控制权转交给a的右孩子", "而这里是一个特殊情况", "它的右孩子根本就不存在", "尽管对于这个节点也会调用一次", "goAlongLeftBranch例程", "但实际上 它会立即返回", "而并没有任何实质的动作", "这相当于一次过门", "因此算法接下来将继续弹出新的栈顶", "也就是节点b", "并且随即对它进行访问", "此后控制权将转交给节点b的右孩子", "也就是f", "与所有的节点一样", "f一旦接过控制权", "都会试图将它转让给它的左孩子", "以及左孩子的左孩子", "这样一个谦让的过程", "又会再次终止于某一个没有左孩子的节点", "比如在这里的c", "而在这样的一个谦让过程中", "历代的节点都会依次的入栈", "接下来新的栈顶节点c将被弹出", "并接受访问", "此后对于c的这个空的右孩子", "依然会有刚才的那样一次过门", "并且没有任何的实质的动作", "所以又会继续去弹出接下来的栈顶", "也就是节点d", "并且随即访问它", "此后节点d将把控制权转交给它的右孩子e", "同样地 在e这个位置上", "也会去调用一次", "goAlongLeftBranch这个例程", "因为这里的left branch长度为0", "所以只有e孤零零的一个节点入栈", "好 在接下来的一轮迭代中", "e又将被弹出并且接受访问", "同样在这个地方也有一个过门", "我们将它忽略掉", "好 接下来又该处理栈顶节点", "也就是f", "在f重新接过控制权并被访问之后", "它将会把控制权继而转交给它的右孩子", "同样在节点g这个位置上", "依然会去执行一次", "goAlongLeftBranch这个例程", "同样它的长度也是0", "所以也只有它一个节点入栈", "而在最后的一次迭代中", "当g被弹出之后", "g也没有什么实质的后代可以回填到栈中", "因此栈终于变空 算法也随即告终"]}, {"name": "01XC-1: 动态规划", "block_id": "34f8542572074795a4cd61ed97fd2b33", "text": ["欢迎回到数据结构的课堂", "接下来的这一节", "将重点讨论动态与规划", "DSA设计与优化的", "一种重要形式和手段", "DSA的设计优化", "既是一个复杂而艰辛的过程", "同时也不乏规律可循", "Kent Beck曾经就此", "做过精辟的概括", "他说我们整个的过程", "也许应该分为三步", "首先是让你的DSA能够运转起来", "比如说 对小型的问题", "至少Make it work", "它能够工作", "其次我们要使得它的", "正确性得到保证", "也就是make it right", "那么联系上堂课所学的内容", "这两步可以通过", "递归的构思 以算法的形式", "很好的解决", "正如我们很快会看到的", "递归 从效率上讲", "并不能总是令我们满意", "有的时候 会令我们非常不满意", "所以在最后", "如果我们要讲究它的效率", "也就是要make it fast", "我们也许应该用到上堂课", "所讲的第二个方面", "也就是迭代", "从某种意义上讲", "所谓的动态规划", "也可以理解为 通过递归", "找出了算法的本质", "并且给出一个初步的解之后", "再将其等效地转化为迭代的形式", "我们的第一个例子是", "大家都非常熟悉的Fibonacci数", "具体来说 它是一个数列", "在我们这里的习惯", "从第0项开始 也就是认为", "第0项和第1项 分别是0和1", "此后的各项呢 按照这里的定义", "都等于它的前一项", "和再前一项 这两项的总和", "所以这就是为什么0+1得1", "1+1得2 1+2得3", "2+3得5 以及3+5得8 诸如此类", "那么这种形式本身", "就是一个递归的形式", "因此我们很自然地", "将它转化为这样一个算法", "来计算Fibonacci数的第n项", "具体来说 也就是", "只需判断一下这个n的大小", "如果是0或1", "我们就直接返回n", "否则的话 按照刚才的定义", "取出此前紧邻的两项", "并且做一次加法", "这个程序再直观再简明不过了", "它确实是可以work", "而且确实也正确 right", "我们现在要来实际的", "把它编译并且运行一下", "看看它是否足够的快", "这是我们这个课程", "所提供的示例代码包", "它是Visual Studio的一个Solution的形式", "根据我们讨论和学习的主题不同", "提供了50多个project", "大家可以从课程网站上", "自行下载并且解开", "打开以后 是这样的一个形式", "就目前我们这个问题而言", "可以找到其中名为Fibonacci的project", "我们可以看到其中", "比如说刚说的这个算法", "就可以描述为这样一段源程序", "现在将它运行一次 执行它", "效果还不错", "这里还做了一些其它算法的对比", "我们看到它们都非常棒", "都很好地算出了", "Fibonacci数的各项", "但问题是 我们只计算到了", "Fibonacci数的从0到第23项", "这个结果 固然还可以利用", "我们在一般的意义上的满意", "但是我们希望能够计算到更大的项", "那多大的项呢？", "我们可以对这段代码", "进行一个设置", "大家可以打开这个project的属性页", "在调试这个页面里", "找到命令行参数", "也有的叫命令参数", "我们看到这里已经指定了", "它最多计算前24项", "也就是从第0到第23项", "我们不妨把这个数调大一点", "调到多大呢？难道是240？", "待会我们看到 这个非常夸张", "我们现在这个算法会吃不消的", "诸位也会等不起的", "我们不妨弄一个", "稍微大但又不是很大的", "比如说64", "好 确定", "然后重新运行一下", "刚才那个已经编译过的程序", "也就是 要求这个程序", "按照不同的算法", "计算出Fibonacci数的前64项", "好 运行起来了", "可以看到 对于算法的其它的版本而言", "比如说迭代的版本", "已经很好的计算出了结果", "对于一些好的递归", "比如说 线性递归也很好", "但是对于有一些递归", "比如说 我们现在所采用的这个版本", "问题似乎很严重", "因为我们看到", "到目前为止", "我们并没有用这个算法", "足以完成刚才所说的任务", "实际上我们会发现", "一旦数值到40几", "比如说43、44的时候", "就已经出现了很大的延迟", "我们能感觉到的延迟", "或者精确地讲 已经能够到了十几秒", "或者几十秒的 这样的一个延迟", "这会多少令我们有些困惑", "难道是其它的方面出了问题？", "我们为了确认", "不是其它的方面出了问题", "不妨可以打开任务管理器", "我们可以来看一下", "比如说 对我这个机器而言", "它的CPU的四个核里", "已经有几乎是四分之一", "也就是一个完整的", "被这个叫Fibonacci的程序所占用", "换句话说 它确实在满负荷工作", "但是 依然计算的非常非常的慢", "比如说 我们要等到下一项", "第47项会怎么样呢？", "不知道 只有天知道", "但是 为了安全起见", "我们还是把它终止掉", "再回过头来 拿起我们的笔和纸", "运用我们此前所学过的方法", "来分析一下", "这段代码之所以这么慢", "从复杂度的角度来看", "到底如何解释"]}, {"name": "02D4-4\t 版本C", "block_id": "850701855e3a4469a9492191b5031da7", "text": ["就算法的结构而言", "这个新的这个算法和此前的版本A", "尤其是版本B", "似乎没有什么太大的区别", "解读一下", "也是这样，当这个区间还是合法之前", "我们就不断地迭代", "每一次也照样是取出它的中点作为轴点", "并且经过一次比较", "从而决定到底是向左侧还是向右侧深入", "那么直到区间宽度缩小到足够小的时候", "我们才返回最终的值", "但是我们提醒大家注意", "它和版本B，虽然在功能上是等效的", "但是在很多细节上却有着本质的区别", "我们来看一下", "第一在这里，算法中迭代退出的条件", "不再是查找的区间宽度是1", "而是又回到了版本A的情况", "要求这个区间的宽度是零", "第二呢，每做过一次判断之后", "向左和向右深入的时候", "左侧的这个区间没有变化", "还是原来的lo到mi", "可是右侧的这个区间呢", "大家注意这个地方", "已经不再是一个方括号，不再是闭区间", "换而言之，它实际上是从", "mi+1开始一直到hi-1", "所以大家会注意到", "这里我们两个分支所覆盖的情况", "中间居然有一个缝隙", "这个缝隙就是这个轴点自己", "难道说这个算法有可能会遗漏", "某一个轴点吗？", "或者说这个算法本身存在一个重大的纰漏吗？", "我们说不会的", "我们很快就会看到不会出现这种纰漏", "而且它的功能整体是正确的", "更重要的是", "它返回的那个秩", "恰好就是我们此前", "所约定的那样一个对应的语义", "我们来给出一个具体地证明"]}, {"name": "08XA2-5\t红黒树，即是B-树", "block_id": "b8995a7822464e67a4bdb815e8845b55", "text": ["尽管红黑树的规则艰深晦涩", "但是从提升变换的角度来看 就会变得异常的清晰明了", "实际上 从这个角度来看 红黑树就是4阶的B树", "实际上在经过提升变换之后 每一棵红黑树", "都会自然的对应于一棵4阶的B树 难道不是这样吗", "为此你只需将每一个黑节点", "与经过提升之后与它高度平齐的红孩子", "整体的视作为一个B树的超级节点", "于是你就会发现其实无非不过4种组合", "每一种黑父亲与红孩子的组合都对应于4阶B树的某一类内部节点", "比如某个黑父亲在此前只拥有一个右侧的红孩子", "那么这个红孩子在提升之后 就可以与他的父亲", "等同的视作为一个包含2个关键码的B树节点", "只有一个左侧红孩子的情况 完全对称", "当然 如果此前某个黑父亲并没有红孩子", "那么在变换之后", "我们也可以将其视作为只含单个关键码的超级节点", "当然 如果某个黑父亲的左右孩子同时是红色的", "那么在变换之后 我们就可以将它", "以及左右2个孩子视作为包含3个关键码的超级节点", "总体看来 无论是哪一种情况", "如此所得的每一个超级节点都至少拥有2个分支", "同时至多也拥有不过4个分支", "而凡此种种 岂不都恰好正是4阶B树的特征吗"]}, {"name": "08B1-5\t分级I O", "block_id": "a34e33bd9ea641ffba56d2292a3cbda8", "text": ["无独有偶 所谓天上方数日 人家已千年", "反映的呢 也是高达5至6个数量级的差异", "因此我们在设计与实现算法的时候 为了避免一次外存访问", "我们宁可去访问内存十次 百次 甚至千次万次也在所不惜", "这也是为什么通常的存储系统都是按层次分级组织的", "比如一个典型的存储系统可能包括CPU 当然是其中的寄存器了", "以及内存RAM 和DISK磁盘 DISK ARRAY磁盘阵列以及等等等等", "随着层次的深入 存储器的容量越来越大", "但是反过来访问的速度也越来越低", "这样一种分级的结构 之所以能够高效的运转", "在于其中采用的一种策略", "也就是将我们最常用的数据尽可能放在更高的层次", "因为尽管它的存储容量有限 它的速度能够最高", "而不常用的数据呢 会自适应的通过兑换", "转移到更大但是速度更慢的级别中去", "在这个系统中 相对于任何一个存储级别", "如果希望向更低的存储级别写入", "或者反过来 从更低的存储级别读入数据", "我们都称之为输出和输入 简称IO", "对于更上层的存储级别而言 对更底层的存储级别的访问", "都可以称作是外存访问", "当然鉴于上层存储级别与下层存储级别在访问速度上的天壤之别", "我们应该尽可能的减少它们之间的IO", "以刚才的粉笔为例 除非本地的所有粉笔都已经消耗殆尽", "否则我们是绝对不会轻易的外出 专门采购的"]}, {"name": "07B3-4 删除：复杂度", "block_id": "c046a0f0af684f899c6d890c9b251314", "text": ["好了", "那么作为remove算法的有机部分", "这个removeAt算法", "它的时间复杂度又是多少呢？", "是否会超过remove原有的", "O(h)那个复杂度呢？", "我们说 幸好不会", "原因在于removeAt本身", "并不包含任何循环", "而其中唯一可能引起复杂度的", "无非是在第二种情况下", "对succ()接口的调用", "而按照我们此前的实现方法", "以及分析结论", "这个接口所需要的时间", "也不会超过全树的高度O(h)", "至此我们可以得出一个结论", "BST的删除操作", "与插入操作一样", "在最坏情况下所需要的时间", "不会超过全树当时的高度h", "那么这个结论是好 还是不足够好呢？", "在下一节 我们将针对这个问题", "做进一步的探讨"]}, {"name": "01a-4: 算法", "block_id": "4be5b36da31d4d15bc4afdd5a5cc1658", "text": ["我们现在也许已经到了可以稍微做一个总结的时候", "什么叫做一个算法呢", "什么叫做一个计算的过程呢", "我们说计算的过程如果抽象的认为", "是一个信息处理的过程的话", "那么大致来说", "首先它必须借助某种工具", "比如说刚才的绳索计算机", "或者是尺规计算机", "然后呢 要遵照一定的规则", "比如说刚才我们讲到的绳索的使用方法", "以及尺规的使用方法", "而且必须能够以明确且机械的一系列简单基本的操作", "构成一个序列或者过程", "当然更严格的定义", "我们还需要学其他的课程才能给出来", "那么这门课里头 我们认为", "这样的一个定义已经基本上够用了", "反过来讲 这里头用的工具", "也就是我们说的计算机", "实际上也是某种用于计算的一个模型", "它也可以认为是信息处理的工具", "所以我们可以再罗列一下 作为一个计算过程", "也就是计算的方法 算法 到底是什么呢", "我们不妨从外延的角度", "刻画一下它到底应该具备哪些要素", "我们可以看到 这里有很多个点", "为什么呢 因为实际上它还具有很多要素", "鉴于我们这个课的主题的关系", "我们不必把它逐一的罗列出来并且逐一的去分析", "但主要的几个 要在这里做一个介绍", "首先都有问题本身的描述", "也就是输入以及最后得到的东西", "我们管它叫做输出", "这是必须的 很好理解", "那么正确性似乎也很好理解", "也就是说 你所给出的这个计算过程 这个方法", "应该确实能够达到你所需要的要求", "虽然在实际中 很遗憾", "这一点并不是那么容易轻易的证明", "但是我们说 至少可以假定这个是应该满足的", "另外呢 所有的动作都应该是确定的", "就是说 应该可以描述为一个或者若干个基本的操作", "这些操作都是语义明确的", "不是说 可左可右 可上可下", "或者说酌情适当等等等等", "不含糊 而是确定的", "比如说 七等分 抻直 过哪两个点做一条线", "或者说至少过一个点做一条非退化的线等等", "都属于确定性", "还有呢 我们说必须要可行", "什么叫可行呢 就是说所有这些操作", "都必须在你的这种计算的条件下能够兑现", "在这里我们不妨回忆一下 有一个很著名的小品", "是由赵本山和宋丹丹表演的 叫做《钟点工》", "宋丹丹上门陪他聊天", "为了逗赵本山高兴 她讲了一个脑筋急转弯", "她说如何把大象装到冰箱里去", "她最后呢实际上给出一个方法", "总共分三步", "第一步是把冰箱门打开", "第二步是把大象装进冰箱里", "第三步是把冰箱门关上", "表面上看 这种过程确实已经构成了一个算法", "明明它确实可以明确的描述出来", "而且你需要什么它怎么做的它都说的很清楚", "但是我们说这里有一个致命的一点", "也就是这个小品的笑点所在", "实际上它其中的动作有一条是不能兑现的", "也就是中间那一步把大象赶到冰箱里去", "所以我们说 如果你写出这样的一个算法出来", "那其实是没有任何意义的 因为它是不可行的", "好 那么接下来还有一点呢 其实也很重要", "就是 每一个计算过程 如果它真正是有意义的话", "必须是有穷的 必须能够在有限步之后终止", "并且得到一个输出", "这一点也表面上看很自然", "甚至你觉得再自然不过了", "但是我们恰恰要说的是 它其实并不自然"]}, {"name": "11d4-1: \t最好情况", "block_id": "64d137dbb4d34dd3b0e32ae4a6108e79", "text": ["以下 就让我们从最好情况的角度", "来考察坏字符策略的性能", "实际上 在最好情况下的性能之好", "要远远超过我们的想象", "具体来说 此时的时间成本", "可以度量为O(n/m)", "没错 除法", "你能构造出", "这样的一个具体实例吗", "这就是一个", "可以看到 模式串完全由0组成", "而文本串呢", "则由与模式串等长的", "若干个片段 依次拼接而成", "在每一个片段中", "末字符都不是0 比如说 取作1", "而其余的字符呢", "实质上都无所谓", "因此笼统地记作x", "我们不妨就此例来走一遍BM算法", "第一次对齐的位置", "在这里", "而首次比对就是0/1的失配", "在这里 0就是坏字符", "而且在模式串中 根本就找不到足以与1匹配的字符", "于是 BM算法将会把模式串整体地移过这个失配的位置", "并使之与文本串中的下一个片段彼此对齐", "而接下来的故事 与刚才的那个片段完全一样", "首先 末字符0无法与1匹配", "而且其余的0也不能与之匹配", "因此算法将再次整体地后移模式串", "以致再次、再再次 持续地整体移动下去", "纵观整个过程", "每经过常数次的比对", "我们就可以向后整体地移动m个字符", "既然文本串累计不过n个字符", "因此在这种情况下 算法至多会移动n/m次", "由此可见 在这种情况下", "算法的确只需要运行这么多的时间", "即便是相对于KMP而言", "这也是一个极大的提高", "更不用说蛮力算法了", "这个例子并不失一般性", "实际上 只要P中的字符", "都是坏字符", "那么每次我们都可以整体地对它进行移动", "也就是说 我们只需要常数次的比较", "就可以整体地排除掉m个对齐位置", "由此可见 如果说KMP算法是个利用经验的高手", "那么BM算法则是非常善于借鉴教训的高手", "从这个意义上讲", "BM算法更加欢迎失败比对的出现", "那么 在什么情况下 更容易出现失败的比对呢", "也就是说 对于任何一对随机出现的字符所做的比对", "失配的概率 在什么情况下 更小呢", "在这里 我们再次回到那样一个重要的指标", "也就是字母表的规模", "实际上 字母表的规模越大", "单次匹配成功的概率也就越小", "失配的概率 也就越大", "从而 BM算法的优势也就更为明显", "比如 在处理汉字甚至Unicode编码时", "BM算法就是再适合不过的了"]}]